(window.webpackJsonp=window.webpackJsonp||[]).push([[0],[]]);!function(n){function e(e){for(var i,o,a=e[0],l=e[1],u=e[2],d=0,m=[];d<a.length;d++)o=a[d],Object.prototype.hasOwnProperty.call(r,o)&&r[o]&&m.push(r[o][0]),r[o]=0;for(i in l)Object.prototype.hasOwnProperty.call(l,i)&&(n[i]=l[i]);for(c&&c(e);m.length;)m.shift()();return s.push.apply(s,u||[]),t()}function t(){for(var n,e=0;e<s.length;e++){for(var t=s[e],i=!0,a=1;a<t.length;a++){var l=t[a];0!==r[l]&&(i=!1)}i&&(s.splice(e--,1),n=o(o.s=t[0]))}return n}var i={},r={3:0},s=[];function o(e){if(i[e])return i[e].exports;var t=i[e]={i:e,l:!1,exports:{}};return n[e].call(t.exports,t,t.exports,o),t.l=!0,t.exports}o.e=function(n){var e=[],t=r[n];if(0!==t)if(t)e.push(t[2]);else{var i=new Promise((function(e,i){t=r[n]=[e,i]}));e.push(t[2]=i);var s,a=document.createElement("script");a.charset="utf-8",a.timeout=120,o.nc&&a.setAttribute("nonce",o.nc),a.src=function(n){return o.p+"assets/js/"+({}[n]||n)+"."+{1:"1f414816",2:"1488dd6a",4:"fae22af6",5:"82ac8e42",6:"965a4d53",7:"7a059cda",8:"b55339df",9:"3c634010",10:"51203a9f",11:"0f50e717",12:"adabe8b7",13:"b7cdb114",14:"b1bc1cdb",15:"b0f4c043",16:"980915c3",17:"7b1c3f6d",18:"efe8d287",19:"33245d59",20:"75aaf6ae",21:"382e8364",22:"fb04a05b",23:"b0533def",24:"a6961d98",25:"9f957f04",26:"4ea03b35",27:"23d51095",28:"96dce027",29:"fb1eaff0",30:"b662d2b2",31:"db1ea2bf",32:"4af85cb9",33:"aa3d3017",34:"c661c62d",35:"46f92092",36:"bab9f9eb",37:"8145c6a5",38:"99c8825d",39:"a6d89a87",40:"4d76e920",41:"61e74d2a",42:"10b97b13",43:"4003f927",44:"118485fd",45:"8a57d0c6",46:"a2a17e4e",47:"1681dfa8",48:"36faaa64",49:"ff5ee92a",50:"90a84a90",51:"97330a31",52:"bb8ee8fb",53:"4b61761f",54:"4743dc7a",55:"cfe516c8",56:"4e05cfe9",57:"95bbcfc1",58:"8c08df3d",59:"dea0b84b",60:"9a6e3f55",61:"d214fa48",62:"a2e37a86",63:"52dc9342",64:"148d2c5c",65:"75a22adb",66:"d451419a",67:"7579fa08",68:"2d14a921",69:"50dee4f1",70:"cfd1e48a",71:"f3ab6626",72:"6bba8caf",73:"ea85b659",74:"859d88bc",75:"c3b51c24",76:"a3c1fbc4",77:"cd3714eb",78:"435f1396",79:"448e706e",80:"a1718d35",81:"9f2898e7",82:"c7ec1e59",83:"322d09e5",84:"e27b3b8a",85:"563b300d",86:"07f07df3",87:"cb192a8b",88:"127e7dde",89:"818c2334",90:"2d2a95a1",91:"4fe4a8e9",92:"8b244fb0",93:"caf2f4c6",94:"0f14edca",95:"19960c2c",96:"c607330a",97:"408dc361",98:"6a84d457",99:"6bccc3f4",100:"23a8edae",101:"85fd0c49",102:"42ea7107",103:"d3639e86",104:"741fea30",105:"7d5908b8",106:"db670cf4",107:"7b47867b",108:"bc36fd4f",109:"9bffaadb",110:"e190fe8e",111:"7e34d7e4",112:"e62d1228",113:"c4535f53",114:"91f371ee",115:"4627e65a",116:"6a11f2c2",117:"8a307593",118:"6d91dafc",119:"416622b3",120:"1d44f03c",121:"7ee19a34",122:"713f8880",123:"f3d5b7c8",124:"96c46080",125:"2edbbbd2",126:"4c357811",127:"8d219f7c",128:"06f130f4",129:"7d2d5c45",130:"7f39c0d7",131:"26a0bb14",132:"a19e5766",133:"765240c9",134:"3b3f93b2",135:"0fe7bd96",136:"8051369a",137:"02e1bcc7",138:"7b837f85",139:"5519f277",140:"6deba5b0",141:"583c0ab3",142:"426891ec",143:"2c50ab49",144:"8002a118",145:"a8028a18",146:"61161bc3",147:"0ab83762",148:"f621a9ec",149:"4f4a520b",150:"5e3d6fac",151:"aef7ed87",152:"c79b2b31",153:"c67c8562",154:"733113ff",155:"15d296e6",156:"3d2cfc84",157:"cdf8f022",158:"0719a098",159:"0937bf93",160:"79631021",161:"5f701d20",162:"33ba3e7e",163:"c354c9ff",164:"97258f92",165:"6704ce34",166:"8f2c6cfd",167:"9b15ebbb",168:"aa67065e",169:"9c9398bd",170:"ea388564",171:"5423c11e",172:"790eb66a",173:"d2ab8cc4",174:"a2014083",175:"088f095d",176:"00fdd83f",177:"f3355ec7",178:"964c78b4",179:"fadb1cd9",180:"db4f771f",181:"3934e192",182:"bd42add7",183:"ad9143cd",184:"3f676d36",185:"c6c0188f",186:"60eea079",187:"151875be",188:"a76bb1a4",189:"43fee07a"}[n]+".js"}(n);var l=new Error;s=function(e){a.onerror=a.onload=null,clearTimeout(u);var t=r[n];if(0!==t){if(t){var i=e&&("load"===e.type?"missing":e.type),s=e&&e.target&&e.target.src;l.message="Loading chunk "+n+" failed.\n("+i+": "+s+")",l.name="ChunkLoadError",l.type=i,l.request=s,t[1](l)}r[n]=void 0}};var u=setTimeout((function(){s({type:"timeout",target:a})}),12e4);a.onerror=a.onload=s,document.head.appendChild(a)}return Promise.all(e)},o.m=n,o.c=i,o.d=function(n,e,t){o.o(n,e)||Object.defineProperty(n,e,{enumerable:!0,get:t})},o.r=function(n){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})},o.t=function(n,e){if(1&e&&(n=o(n)),8&e)return n;if(4&e&&"object"==typeof n&&n&&n.__esModule)return n;var t=Object.create(null);if(o.r(t),Object.defineProperty(t,"default",{enumerable:!0,value:n}),2&e&&"string"!=typeof n)for(var i in n)o.d(t,i,function(e){return n[e]}.bind(null,i));return t},o.n=function(n){var e=n&&n.__esModule?function(){return n.default}:function(){return n};return o.d(e,"a",e),e},o.o=function(n,e){return Object.prototype.hasOwnProperty.call(n,e)},o.p="/",o.oe=function(n){throw console.error(n),n};var a=window.webpackJsonp=window.webpackJsonp||[],l=a.push.bind(a);a.push=e,a=a.slice();for(var u=0;u<a.length;u++)e(a[u]);var c=l;s.push([109,0]),t()}([function(n,e,t){"use strict";var i=t(1),r={NotFound:()=>Promise.all([t.e(0),t.e(62)]).then(t.bind(null,1223)),Category:()=>Promise.all([t.e(0),t.e(1),t.e(2),t.e(80)]).then(t.bind(null,1224)),Layout:()=>Promise.all([t.e(0),t.e(1),t.e(9),t.e(77)]).then(t.bind(null,1221)),Tag:()=>Promise.all([t.e(0),t.e(1),t.e(2),t.e(60)]).then(t.bind(null,1227)),Tags:()=>Promise.all([t.e(0),t.e(1),t.e(15)]).then(t.bind(null,1226)),TimeLines:()=>Promise.all([t.e(0),t.e(1),t.e(35)]).then(t.bind(null,1225))},s={"v-50a4e6f6":()=>t.e(108).then(t.bind(null,1273)),"v-872b1f36":()=>t.e(93).then(t.bind(null,1393)),"v-51a0a422":()=>t.e(109).then(t.bind(null,1275)),"v-7541876e":()=>t.e(81).then(t.bind(null,1276)),"v-082f848c":()=>t.e(22).then(t.bind(null,1277)),"v-4779f67f":()=>t.e(42).then(t.bind(null,1278)),"v-69743892":()=>t.e(63).then(t.bind(null,1279)),"v-40896626":()=>t.e(70).then(t.bind(null,1280)),"v-2b081e4c":()=>t.e(48).then(t.bind(null,1281)),"v-29c9103a":()=>t.e(110).then(t.bind(null,1283)),"v-1efc4839":()=>t.e(71).then(t.bind(null,1284)),"v-4ed2f72c":()=>t.e(23).then(t.bind(null,1285)),"v-46d8099a":()=>t.e(49).then(t.bind(null,1286)),"v-27f937b5":()=>t.e(69).then(t.bind(null,1287)),"v-662329a2":()=>t.e(112).then(t.bind(null,1288)),"v-37e48825":()=>t.e(82).then(t.bind(null,1289)),"v-4b70cbd6":()=>t.e(17).then(t.bind(null,1290)),"v-92619eec":()=>t.e(19).then(t.bind(null,1291)),"v-0e1774ab":()=>t.e(10).then(t.bind(null,1292)),"v-7c92bd0a":()=>t.e(113).then(t.bind(null,1293)),"v-4ec67454":()=>t.e(26).then(t.bind(null,1294)),"v-67f0bc42":()=>t.e(27).then(t.bind(null,1295)),"v-69c9e716":()=>t.e(114).then(t.bind(null,1296)),"v-09fa2471":()=>t.e(54).then(t.bind(null,1297)),"v-a45a98cc":()=>t.e(111).then(t.bind(null,1298)),"v-636b4c6e":()=>t.e(83).then(t.bind(null,1299)),"v-4cbecd9d":()=>t.e(115).then(t.bind(null,1300)),"v-3bb3d58a":()=>t.e(94).then(t.bind(null,1301)),"v-70fe855a":()=>t.e(36).then(t.bind(null,1302)),"v-7dcfc1d7":()=>t.e(13).then(t.bind(null,1303)),"v-78c30bf4":()=>t.e(43).then(t.bind(null,1304)),"v-08021f6f":()=>t.e(18).then(t.bind(null,1305)),"v-4fb1a763":()=>t.e(117).then(t.bind(null,1306)),"v-b7e2d1be":()=>t.e(116).then(t.bind(null,1307)),"v-4aeac5ec":()=>t.e(118).then(t.bind(null,1404)),"v-94273df0":()=>t.e(119).then(t.bind(null,1308)),"v-6fab22e5":()=>t.e(120).then(t.bind(null,1309)),"v-6ba46688":()=>t.e(24).then(t.bind(null,1310)),"v-2a6bb239":()=>t.e(39).then(t.bind(null,1311)),"v-78dbd082":()=>t.e(121).then(t.bind(null,1312)),"v-172d1308":()=>t.e(64).then(t.bind(null,1313)),"v-f54f2200":()=>t.e(95).then(t.bind(null,1315)),"v-7d3d3b3c":()=>t.e(44).then(t.bind(null,1228)),"v-5cfb85d7":()=>t.e(31).then(t.bind(null,1317)),"v-3e57534e":()=>t.e(96).then(t.bind(null,1318)),"v-0c1dc4cd":()=>t.e(122).then(t.bind(null,1319)),"v-239b7bef":()=>t.e(72).then(t.bind(null,1320)),"v-a8cd2084":()=>t.e(84).then(t.bind(null,1321)),"v-39824ad2":()=>t.e(28).then(t.bind(null,1322)),"v-49ca1f81":()=>t.e(6).then(t.bind(null,1323)),"v-4f2683df":()=>t.e(14).then(t.bind(null,1324)),"v-59e03967":()=>t.e(123).then(t.bind(null,1325)),"v-36ec1cda":()=>t.e(85).then(t.bind(null,1326)),"v-0d191fb0":()=>t.e(124).then(t.bind(null,1327)),"v-4772a9c6":()=>t.e(125).then(t.bind(null,1328)),"v-a45ead70":()=>t.e(25).then(t.bind(null,1329)),"v-fedf490e":()=>t.e(86).then(t.bind(null,1330)),"v-b2977cb0":()=>t.e(97).then(t.bind(null,1331)),"v-4b6669ef":()=>t.e(4).then(t.bind(null,1332)),"v-64e21c1e":()=>t.e(55).then(t.bind(null,1333)),"v-2f5ba20c":()=>t.e(61).then(t.bind(null,1334)),"v-4f4e8ede":()=>t.e(126).then(t.bind(null,1335)),"v-9b996c72":()=>t.e(127).then(t.bind(null,1336)),"v-237c778e":()=>t.e(50).then(t.bind(null,1337)),"v-25ece19a":()=>t.e(98).then(t.bind(null,1338)),"v-0677f7bb":()=>t.e(5).then(t.bind(null,1339)),"v-b27509c4":()=>t.e(99).then(t.bind(null,1340)),"v-7016069a":()=>t.e(65).then(t.bind(null,1341)),"v-0a7ef002":()=>t.e(128).then(t.bind(null,1342)),"v-f20421d4":()=>t.e(129).then(t.bind(null,1343)),"v-1146fde9":()=>t.e(130).then(t.bind(null,1344)),"v-d999d50a":()=>t.e(66).then(t.bind(null,1345)),"v-72c7019a":()=>t.e(100).then(t.bind(null,1346)),"v-0aae0649":()=>t.e(7).then(t.bind(null,1347)),"v-78f01504":()=>t.e(131).then(t.bind(null,1348)),"v-7cecf4db":()=>t.e(51).then(t.bind(null,1349)),"v-dd4bf7e4":()=>t.e(56).then(t.bind(null,1350)),"v-3caa00fc":()=>t.e(132).then(t.bind(null,1351)),"v-22fe62f0":()=>t.e(11).then(t.bind(null,1352)),"v-964e1e2e":()=>t.e(74).then(t.bind(null,1353)),"v-eab508ce":()=>t.e(52).then(t.bind(null,1354)),"v-86ef19d0":()=>t.e(73).then(t.bind(null,1355)),"v-08aa0349":()=>t.e(133).then(t.bind(null,1356)),"v-f3ca02fe":()=>t.e(135).then(t.bind(null,1357)),"v-31ede314":()=>t.e(87).then(t.bind(null,1358)),"v-49990e49":()=>t.e(134).then(t.bind(null,1359)),"v-0e59c80c":()=>t.e(57).then(t.bind(null,1360)),"v-ccf835da":()=>t.e(45).then(t.bind(null,1361)),"v-cb8dcbd0":()=>t.e(88).then(t.bind(null,1362)),"v-1f930831":()=>t.e(136).then(t.bind(null,1363)),"v-8f131bfc":()=>t.e(138).then(t.bind(null,1364)),"v-9e31a4c2":()=>t.e(37).then(t.bind(null,1365)),"v-41f9c21d":()=>t.e(137).then(t.bind(null,1366)),"v-7727e773":()=>t.e(46).then(t.bind(null,1367)),"v-9c035a4c":()=>t.e(32).then(t.bind(null,1368)),"v-c37cfd5c":()=>t.e(139).then(t.bind(null,1369)),"v-3d43ded6":()=>t.e(101).then(t.bind(null,1370)),"v-a3978ed0":()=>t.e(141).then(t.bind(null,1371)),"v-0bb21a4d":()=>t.e(140).then(t.bind(null,1372)),"v-0cf96847":()=>t.e(142).then(t.bind(null,1373)),"v-1676ace0":()=>t.e(144).then(t.bind(null,1374)),"v-fa980d7a":()=>t.e(145).then(t.bind(null,1375)),"v-35262026":()=>t.e(102).then(t.bind(null,1376)),"v-17a4fc23":()=>t.e(143).then(t.bind(null,1377)),"v-6f1770fa":()=>t.e(103).then(t.bind(null,1378)),"v-58dab6f5":()=>t.e(67).then(t.bind(null,1379)),"v-896f1fde":()=>t.e(33).then(t.bind(null,1380)),"v-683b2412":()=>t.e(104).then(t.bind(null,1381)),"v-0d83ecdc":()=>t.e(147).then(t.bind(null,1382)),"v-a44527a2":()=>t.e(148).then(t.bind(null,1383)),"v-1b66e8d5":()=>t.e(75).then(t.bind(null,1384)),"v-1b5e2caa":()=>t.e(89).then(t.bind(null,1385)),"v-f3fd332e":()=>t.e(150).then(t.bind(null,1386)),"v-c12cd844":()=>t.e(149).then(t.bind(null,1387)),"v-695ff01c":()=>t.e(146).then(t.bind(null,1388)),"v-386f1cf4":()=>t.e(152).then(t.bind(null,1389)),"v-6a1a8aca":()=>t.e(153).then(t.bind(null,1390)),"v-3febb966":()=>t.e(151).then(t.bind(null,1391)),"v-eacea4c0":()=>t.e(90).then(t.bind(null,1392)),"v-0e89010e":()=>t.e(154).then(t.bind(null,1399)),"v-371682cc":()=>t.e(68).then(t.bind(null,1269)),"v-812258f8":()=>t.e(53).then(t.bind(null,1268)),"v-35ed2a6a":()=>t.e(155).then(t.bind(null,1267)),"v-b9ae42f8":()=>t.e(156).then(t.bind(null,1266)),"v-2f53649e":()=>t.e(91).then(t.bind(null,1265)),"v-3f69c3c2":()=>t.e(157).then(t.bind(null,1264)),"v-b8b51226":()=>t.e(158).then(t.bind(null,1263)),"v-72faf49f":()=>t.e(159).then(t.bind(null,1262)),"v-f36f62ca":()=>t.e(160).then(t.bind(null,1261)),"v-24aef886":()=>t.e(58).then(t.bind(null,1260)),"v-33b19a42":()=>t.e(161).then(t.bind(null,1258)),"v-57525a9a":()=>t.e(20).then(t.bind(null,1257)),"v-861ad970":()=>t.e(164).then(t.bind(null,1256)),"v-9549f80c":()=>t.e(163).then(t.bind(null,1255)),"v-c89f9d26":()=>t.e(162).then(t.bind(null,1254)),"v-4a51aa00":()=>t.e(165).then(t.bind(null,1253)),"v-0d795ffd":()=>t.e(167).then(t.bind(null,1252)),"v-16b46357":()=>t.e(169).then(t.bind(null,1251)),"v-fa0e71a0":()=>t.e(166).then(t.bind(null,1250)),"v-487d573a":()=>t.e(170).then(t.bind(null,1249)),"v-55c55936":()=>t.e(171).then(t.bind(null,1248)),"v-25479726":()=>t.e(34).then(t.bind(null,1247)),"v-3529fb88":()=>t.e(172).then(t.bind(null,1246)),"v-17bb9e2d":()=>t.e(8).then(t.bind(null,1245)),"v-9df561a4":()=>t.e(59).then(t.bind(null,1244)),"v-54968448":()=>t.e(47).then(t.bind(null,1243)),"v-78bc8af7":()=>t.e(168).then(t.bind(null,1242)),"v-6384368a":()=>t.e(12).then(t.bind(null,1241)),"v-21d82b43":()=>t.e(174).then(t.bind(null,1240)),"v-2fc6e32b":()=>t.e(175).then(t.bind(null,1239)),"v-22e5cd39":()=>t.e(76).then(t.bind(null,1238)),"v-4f4bf9f6":()=>t.e(176).then(t.bind(null,1237)),"v-c9f395f0":()=>t.e(40).then(t.bind(null,1236)),"v-6a8c0a12":()=>t.e(178).then(t.bind(null,1235)),"v-2d78303e":()=>t.e(177).then(t.bind(null,1234)),"v-e1b467a8":()=>t.e(173).then(t.bind(null,1233)),"v-0b39ac5e":()=>t.e(179).then(t.bind(null,1232)),"v-536bbb82":()=>t.e(180).then(t.bind(null,1231)),"v-75e2436c":()=>t.e(181).then(t.bind(null,1230)),"v-6d5a9f28":()=>t.e(182).then(t.bind(null,1229)),"v-638027b4":()=>t.e(92).then(t.bind(null,1316)),"v-d3e8a800":()=>t.e(105).then(t.bind(null,1400)),"v-5bdc57ee":()=>t.e(38).then(t.bind(null,1259)),"v-493516c6":()=>t.e(184).then(t.bind(null,1270)),"v-2bbe7c80":()=>t.e(183).then(t.bind(null,1271)),"v-71aae79a":()=>t.e(185).then(t.bind(null,1272)),"v-a8e7c0ea":()=>t.e(186).then(t.bind(null,1401)),"v-0aece9fa":()=>t.e(106).then(t.bind(null,1402)),"v-c077fb86":()=>t.e(187).then(t.bind(null,1403)),"v-3f33cfdc":()=>t.e(188).then(t.bind(null,1314)),"v-622c1825":()=>t.e(107).then(t.bind(null,1282)),"v-1bff81f9":()=>t.e(21).then(t.bind(null,1274)),"v-1f24f964":()=>t.e(16).then(t.bind(null,1394)),"v-0e65eec4":()=>t.e(41).then(t.bind(null,1395)),"v-559cfd35":()=>t.e(29).then(t.bind(null,1396)),"v-64944eae":()=>t.e(30).then(t.bind(null,1397))};function o(n){const e=Object.create(null);return function(t){return e[t]||(e[t]=n(t))}}t.d(e,"e",(function(){return b})),t.d(e,"d",(function(){return x})),t.d(e,"c",(function(){return w})),t.d(e,"f",(function(){return E})),t.d(e,"a",(function(){return y})),t.d(e,"g",(function(){return k})),t.d(e,"b",(function(){return A})),t.d(e,"h",(function(){return j})),t.d(e,"i",(function(){return _}));const a=/-(\w)/g,l=o(n=>n.replace(a,(n,e)=>e?e.toUpperCase():"")),u=/\B([A-Z])/g,c=o(n=>n.replace(u,"-$1").toLowerCase()),d=o(n=>n.charAt(0).toUpperCase()+n.slice(1));function m(n,e){if(!e)return;if(n(e))return n(e);return e.includes("-")?n(d(l(e))):n(d(e))||n(c(e))}const p=Object.assign({},r,s),h=n=>p[n],f=n=>s[n],g=n=>r[n],v=n=>i.a.component(n);function b(n){return m(f,n)}function x(n){return m(g,n)}function w(n){return m(h,n)}function E(n){return m(v,n)}function y(...n){return Promise.all(n.filter(n=>n).map(async n=>{if(!E(n)&&w(n)){const e=await w(n)();i.a.component(n,e.default)}}))}function k(n,e,t){switch(e){case"components":n[e]||(n[e]={}),Object.assign(n[e],t);break;case"mixins":n[e]||(n[e]=[]),n[e].push(...t);break;default:throw new Error("Unknown option name.")}}function A(n,e){for(let t=0;t<n.length;t++){const i=n[t];if(i.key===e)return i}return{path:"",frontmatter:{}}}function j(n,e){const{$localePath:t}=n;return"object"==typeof e&&e[t]?e[t]:e}function _(n,e){"undefined"!=typeof window&&window.__VUEPRESS__&&(window.__VUEPRESS__[n]=e)}},function(n,e,t){"use strict";
/*!
 * Vue.js v2.6.10
 * (c) 2014-2019 Evan You
 * Released under the MIT License.
 */var i=Object.freeze({});function r(n){return null==n}function s(n){return null!=n}function o(n){return!0===n}function a(n){return"string"==typeof n||"number"==typeof n||"symbol"==typeof n||"boolean"==typeof n}function l(n){return null!==n&&"object"==typeof n}var u=Object.prototype.toString;function c(n){return"[object Object]"===u.call(n)}function d(n){return"[object RegExp]"===u.call(n)}function m(n){var e=parseFloat(String(n));return e>=0&&Math.floor(e)===e&&isFinite(n)}function p(n){return s(n)&&"function"==typeof n.then&&"function"==typeof n.catch}function h(n){return null==n?"":Array.isArray(n)||c(n)&&n.toString===u?JSON.stringify(n,null,2):String(n)}function f(n){var e=parseFloat(n);return isNaN(e)?n:e}function g(n,e){for(var t=Object.create(null),i=n.split(","),r=0;r<i.length;r++)t[i[r]]=!0;return e?function(n){return t[n.toLowerCase()]}:function(n){return t[n]}}g("slot,component",!0);var v=g("key,ref,slot,slot-scope,is");function b(n,e){if(n.length){var t=n.indexOf(e);if(t>-1)return n.splice(t,1)}}var x=Object.prototype.hasOwnProperty;function w(n,e){return x.call(n,e)}function E(n){var e=Object.create(null);return function(t){return e[t]||(e[t]=n(t))}}var y=/-(\w)/g,k=E((function(n){return n.replace(y,(function(n,e){return e?e.toUpperCase():""}))})),A=E((function(n){return n.charAt(0).toUpperCase()+n.slice(1)})),j=/\B([A-Z])/g,_=E((function(n){return n.replace(j,"-$1").toLowerCase()}));var N=Function.prototype.bind?function(n,e){return n.bind(e)}:function(n,e){function t(t){var i=arguments.length;return i?i>1?n.apply(e,arguments):n.call(e,t):n.call(e)}return t._length=n.length,t};function O(n,e){e=e||0;for(var t=n.length-e,i=new Array(t);t--;)i[t]=n[t+e];return i}function B(n,e){for(var t in e)n[t]=e[t];return n}function S(n){for(var e={},t=0;t<n.length;t++)n[t]&&B(e,n[t]);return e}function I(n,e,t){}var L=function(n,e,t){return!1},C=function(n){return n};function T(n,e){if(n===e)return!0;var t=l(n),i=l(e);if(!t||!i)return!t&&!i&&String(n)===String(e);try{var r=Array.isArray(n),s=Array.isArray(e);if(r&&s)return n.length===e.length&&n.every((function(n,t){return T(n,e[t])}));if(n instanceof Date&&e instanceof Date)return n.getTime()===e.getTime();if(r||s)return!1;var o=Object.keys(n),a=Object.keys(e);return o.length===a.length&&o.every((function(t){return T(n[t],e[t])}))}catch(n){return!1}}function D(n,e){for(var t=0;t<n.length;t++)if(T(n[t],e))return t;return-1}function q(n){var e=!1;return function(){e||(e=!0,n.apply(this,arguments))}}var P=["component","directive","filter"],M=["beforeCreate","created","beforeMount","mounted","beforeUpdate","updated","beforeDestroy","destroyed","activated","deactivated","errorCaptured","serverPrefetch"],F={optionMergeStrategies:Object.create(null),silent:!1,productionTip:!1,devtools:!1,performance:!1,errorHandler:null,warnHandler:null,ignoredElements:[],keyCodes:Object.create(null),isReservedTag:L,isReservedAttr:L,isUnknownElement:L,getTagNamespace:I,parsePlatformTagName:C,mustUseProp:L,async:!0,_lifecycleHooks:M},z=/a-zA-Z\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u037D\u037F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD/;function R(n,e,t,i){Object.defineProperty(n,e,{value:t,enumerable:!!i,writable:!0,configurable:!0})}var $=new RegExp("[^"+z.source+".$_\\d]");var U,H="__proto__"in{},V="undefined"!=typeof window,W="undefined"!=typeof WXEnvironment&&!!WXEnvironment.platform,K=W&&WXEnvironment.platform.toLowerCase(),Q=V&&window.navigator.userAgent.toLowerCase(),G=Q&&/msie|trident/.test(Q),Z=Q&&Q.indexOf("msie 9.0")>0,J=Q&&Q.indexOf("edge/")>0,X=(Q&&Q.indexOf("android"),Q&&/iphone|ipad|ipod|ios/.test(Q)||"ios"===K),Y=(Q&&/chrome\/\d+/.test(Q),Q&&/phantomjs/.test(Q),Q&&Q.match(/firefox\/(\d+)/)),nn={}.watch,en=!1;if(V)try{var tn={};Object.defineProperty(tn,"passive",{get:function(){en=!0}}),window.addEventListener("test-passive",null,tn)}catch(n){}var rn=function(){return void 0===U&&(U=!V&&!W&&"undefined"!=typeof global&&(global.process&&"server"===global.process.env.VUE_ENV)),U},sn=V&&window.__VUE_DEVTOOLS_GLOBAL_HOOK__;function on(n){return"function"==typeof n&&/native code/.test(n.toString())}var an,ln="undefined"!=typeof Symbol&&on(Symbol)&&"undefined"!=typeof Reflect&&on(Reflect.ownKeys);an="undefined"!=typeof Set&&on(Set)?Set:function(){function n(){this.set=Object.create(null)}return n.prototype.has=function(n){return!0===this.set[n]},n.prototype.add=function(n){this.set[n]=!0},n.prototype.clear=function(){this.set=Object.create(null)},n}();var un=I,cn=0,dn=function(){this.id=cn++,this.subs=[]};dn.prototype.addSub=function(n){this.subs.push(n)},dn.prototype.removeSub=function(n){b(this.subs,n)},dn.prototype.depend=function(){dn.target&&dn.target.addDep(this)},dn.prototype.notify=function(){var n=this.subs.slice();for(var e=0,t=n.length;e<t;e++)n[e].update()},dn.target=null;var mn=[];function pn(n){mn.push(n),dn.target=n}function hn(){mn.pop(),dn.target=mn[mn.length-1]}var fn=function(n,e,t,i,r,s,o,a){this.tag=n,this.data=e,this.children=t,this.text=i,this.elm=r,this.ns=void 0,this.context=s,this.fnContext=void 0,this.fnOptions=void 0,this.fnScopeId=void 0,this.key=e&&e.key,this.componentOptions=o,this.componentInstance=void 0,this.parent=void 0,this.raw=!1,this.isStatic=!1,this.isRootInsert=!0,this.isComment=!1,this.isCloned=!1,this.isOnce=!1,this.asyncFactory=a,this.asyncMeta=void 0,this.isAsyncPlaceholder=!1},gn={child:{configurable:!0}};gn.child.get=function(){return this.componentInstance},Object.defineProperties(fn.prototype,gn);var vn=function(n){void 0===n&&(n="");var e=new fn;return e.text=n,e.isComment=!0,e};function bn(n){return new fn(void 0,void 0,void 0,String(n))}function xn(n){var e=new fn(n.tag,n.data,n.children&&n.children.slice(),n.text,n.elm,n.context,n.componentOptions,n.asyncFactory);return e.ns=n.ns,e.isStatic=n.isStatic,e.key=n.key,e.isComment=n.isComment,e.fnContext=n.fnContext,e.fnOptions=n.fnOptions,e.fnScopeId=n.fnScopeId,e.asyncMeta=n.asyncMeta,e.isCloned=!0,e}var wn=Array.prototype,En=Object.create(wn);["push","pop","shift","unshift","splice","sort","reverse"].forEach((function(n){var e=wn[n];R(En,n,(function(){for(var t=[],i=arguments.length;i--;)t[i]=arguments[i];var r,s=e.apply(this,t),o=this.__ob__;switch(n){case"push":case"unshift":r=t;break;case"splice":r=t.slice(2)}return r&&o.observeArray(r),o.dep.notify(),s}))}));var yn=Object.getOwnPropertyNames(En),kn=!0;function An(n){kn=n}var jn=function(n){this.value=n,this.dep=new dn,this.vmCount=0,R(n,"__ob__",this),Array.isArray(n)?(H?function(n,e){n.__proto__=e}(n,En):function(n,e,t){for(var i=0,r=t.length;i<r;i++){var s=t[i];R(n,s,e[s])}}(n,En,yn),this.observeArray(n)):this.walk(n)};function _n(n,e){var t;if(l(n)&&!(n instanceof fn))return w(n,"__ob__")&&n.__ob__ instanceof jn?t=n.__ob__:kn&&!rn()&&(Array.isArray(n)||c(n))&&Object.isExtensible(n)&&!n._isVue&&(t=new jn(n)),e&&t&&t.vmCount++,t}function Nn(n,e,t,i,r){var s=new dn,o=Object.getOwnPropertyDescriptor(n,e);if(!o||!1!==o.configurable){var a=o&&o.get,l=o&&o.set;a&&!l||2!==arguments.length||(t=n[e]);var u=!r&&_n(t);Object.defineProperty(n,e,{enumerable:!0,configurable:!0,get:function(){var e=a?a.call(n):t;return dn.target&&(s.depend(),u&&(u.dep.depend(),Array.isArray(e)&&Sn(e))),e},set:function(e){var i=a?a.call(n):t;e===i||e!=e&&i!=i||a&&!l||(l?l.call(n,e):t=e,u=!r&&_n(e),s.notify())}})}}function On(n,e,t){if(Array.isArray(n)&&m(e))return n.length=Math.max(n.length,e),n.splice(e,1,t),t;if(e in n&&!(e in Object.prototype))return n[e]=t,t;var i=n.__ob__;return n._isVue||i&&i.vmCount?t:i?(Nn(i.value,e,t),i.dep.notify(),t):(n[e]=t,t)}function Bn(n,e){if(Array.isArray(n)&&m(e))n.splice(e,1);else{var t=n.__ob__;n._isVue||t&&t.vmCount||w(n,e)&&(delete n[e],t&&t.dep.notify())}}function Sn(n){for(var e=void 0,t=0,i=n.length;t<i;t++)(e=n[t])&&e.__ob__&&e.__ob__.dep.depend(),Array.isArray(e)&&Sn(e)}jn.prototype.walk=function(n){for(var e=Object.keys(n),t=0;t<e.length;t++)Nn(n,e[t])},jn.prototype.observeArray=function(n){for(var e=0,t=n.length;e<t;e++)_n(n[e])};var In=F.optionMergeStrategies;function Ln(n,e){if(!e)return n;for(var t,i,r,s=ln?Reflect.ownKeys(e):Object.keys(e),o=0;o<s.length;o++)"__ob__"!==(t=s[o])&&(i=n[t],r=e[t],w(n,t)?i!==r&&c(i)&&c(r)&&Ln(i,r):On(n,t,r));return n}function Cn(n,e,t){return t?function(){var i="function"==typeof e?e.call(t,t):e,r="function"==typeof n?n.call(t,t):n;return i?Ln(i,r):r}:e?n?function(){return Ln("function"==typeof e?e.call(this,this):e,"function"==typeof n?n.call(this,this):n)}:e:n}function Tn(n,e){var t=e?n?n.concat(e):Array.isArray(e)?e:[e]:n;return t?function(n){for(var e=[],t=0;t<n.length;t++)-1===e.indexOf(n[t])&&e.push(n[t]);return e}(t):t}function Dn(n,e,t,i){var r=Object.create(n||null);return e?B(r,e):r}In.data=function(n,e,t){return t?Cn(n,e,t):e&&"function"!=typeof e?n:Cn(n,e)},M.forEach((function(n){In[n]=Tn})),P.forEach((function(n){In[n+"s"]=Dn})),In.watch=function(n,e,t,i){if(n===nn&&(n=void 0),e===nn&&(e=void 0),!e)return Object.create(n||null);if(!n)return e;var r={};for(var s in B(r,n),e){var o=r[s],a=e[s];o&&!Array.isArray(o)&&(o=[o]),r[s]=o?o.concat(a):Array.isArray(a)?a:[a]}return r},In.props=In.methods=In.inject=In.computed=function(n,e,t,i){if(!n)return e;var r=Object.create(null);return B(r,n),e&&B(r,e),r},In.provide=Cn;var qn=function(n,e){return void 0===e?n:e};function Pn(n,e,t){if("function"==typeof e&&(e=e.options),function(n,e){var t=n.props;if(t){var i,r,s={};if(Array.isArray(t))for(i=t.length;i--;)"string"==typeof(r=t[i])&&(s[k(r)]={type:null});else if(c(t))for(var o in t)r=t[o],s[k(o)]=c(r)?r:{type:r};else 0;n.props=s}}(e),function(n,e){var t=n.inject;if(t){var i=n.inject={};if(Array.isArray(t))for(var r=0;r<t.length;r++)i[t[r]]={from:t[r]};else if(c(t))for(var s in t){var o=t[s];i[s]=c(o)?B({from:s},o):{from:o}}else 0}}(e),function(n){var e=n.directives;if(e)for(var t in e){var i=e[t];"function"==typeof i&&(e[t]={bind:i,update:i})}}(e),!e._base&&(e.extends&&(n=Pn(n,e.extends,t)),e.mixins))for(var i=0,r=e.mixins.length;i<r;i++)n=Pn(n,e.mixins[i],t);var s,o={};for(s in n)a(s);for(s in e)w(n,s)||a(s);function a(i){var r=In[i]||qn;o[i]=r(n[i],e[i],t,i)}return o}function Mn(n,e,t,i){if("string"==typeof t){var r=n[e];if(w(r,t))return r[t];var s=k(t);if(w(r,s))return r[s];var o=A(s);return w(r,o)?r[o]:r[t]||r[s]||r[o]}}function Fn(n,e,t,i){var r=e[n],s=!w(t,n),o=t[n],a=$n(Boolean,r.type);if(a>-1)if(s&&!w(r,"default"))o=!1;else if(""===o||o===_(n)){var l=$n(String,r.type);(l<0||a<l)&&(o=!0)}if(void 0===o){o=function(n,e,t){if(!w(e,"default"))return;var i=e.default;0;if(n&&n.$options.propsData&&void 0===n.$options.propsData[t]&&void 0!==n._props[t])return n._props[t];return"function"==typeof i&&"Function"!==zn(e.type)?i.call(n):i}(i,r,n);var u=kn;An(!0),_n(o),An(u)}return o}function zn(n){var e=n&&n.toString().match(/^\s*function (\w+)/);return e?e[1]:""}function Rn(n,e){return zn(n)===zn(e)}function $n(n,e){if(!Array.isArray(e))return Rn(e,n)?0:-1;for(var t=0,i=e.length;t<i;t++)if(Rn(e[t],n))return t;return-1}function Un(n,e,t){pn();try{if(e)for(var i=e;i=i.$parent;){var r=i.$options.errorCaptured;if(r)for(var s=0;s<r.length;s++)try{if(!1===r[s].call(i,n,e,t))return}catch(n){Vn(n,i,"errorCaptured hook")}}Vn(n,e,t)}finally{hn()}}function Hn(n,e,t,i,r){var s;try{(s=t?n.apply(e,t):n.call(e))&&!s._isVue&&p(s)&&!s._handled&&(s.catch((function(n){return Un(n,i,r+" (Promise/async)")})),s._handled=!0)}catch(n){Un(n,i,r)}return s}function Vn(n,e,t){if(F.errorHandler)try{return F.errorHandler.call(null,n,e,t)}catch(e){e!==n&&Wn(e,null,"config.errorHandler")}Wn(n,e,t)}function Wn(n,e,t){if(!V&&!W||"undefined"==typeof console)throw n;console.error(n)}var Kn,Qn=!1,Gn=[],Zn=!1;function Jn(){Zn=!1;var n=Gn.slice(0);Gn.length=0;for(var e=0;e<n.length;e++)n[e]()}if("undefined"!=typeof Promise&&on(Promise)){var Xn=Promise.resolve();Kn=function(){Xn.then(Jn),X&&setTimeout(I)},Qn=!0}else if(G||"undefined"==typeof MutationObserver||!on(MutationObserver)&&"[object MutationObserverConstructor]"!==MutationObserver.toString())Kn="undefined"!=typeof setImmediate&&on(setImmediate)?function(){setImmediate(Jn)}:function(){setTimeout(Jn,0)};else{var Yn=1,ne=new MutationObserver(Jn),ee=document.createTextNode(String(Yn));ne.observe(ee,{characterData:!0}),Kn=function(){Yn=(Yn+1)%2,ee.data=String(Yn)},Qn=!0}function te(n,e){var t;if(Gn.push((function(){if(n)try{n.call(e)}catch(n){Un(n,e,"nextTick")}else t&&t(e)})),Zn||(Zn=!0,Kn()),!n&&"undefined"!=typeof Promise)return new Promise((function(n){t=n}))}var ie=new an;function re(n){!function n(e,t){var i,r,s=Array.isArray(e);if(!s&&!l(e)||Object.isFrozen(e)||e instanceof fn)return;if(e.__ob__){var o=e.__ob__.dep.id;if(t.has(o))return;t.add(o)}if(s)for(i=e.length;i--;)n(e[i],t);else for(r=Object.keys(e),i=r.length;i--;)n(e[r[i]],t)}(n,ie),ie.clear()}var se=E((function(n){var e="&"===n.charAt(0),t="~"===(n=e?n.slice(1):n).charAt(0),i="!"===(n=t?n.slice(1):n).charAt(0);return{name:n=i?n.slice(1):n,once:t,capture:i,passive:e}}));function oe(n,e){function t(){var n=arguments,i=t.fns;if(!Array.isArray(i))return Hn(i,null,arguments,e,"v-on handler");for(var r=i.slice(),s=0;s<r.length;s++)Hn(r[s],null,n,e,"v-on handler")}return t.fns=n,t}function ae(n,e,t,i,s,a){var l,u,c,d;for(l in n)u=n[l],c=e[l],d=se(l),r(u)||(r(c)?(r(u.fns)&&(u=n[l]=oe(u,a)),o(d.once)&&(u=n[l]=s(d.name,u,d.capture)),t(d.name,u,d.capture,d.passive,d.params)):u!==c&&(c.fns=u,n[l]=c));for(l in e)r(n[l])&&i((d=se(l)).name,e[l],d.capture)}function le(n,e,t){var i;n instanceof fn&&(n=n.data.hook||(n.data.hook={}));var a=n[e];function l(){t.apply(this,arguments),b(i.fns,l)}r(a)?i=oe([l]):s(a.fns)&&o(a.merged)?(i=a).fns.push(l):i=oe([a,l]),i.merged=!0,n[e]=i}function ue(n,e,t,i,r){if(s(e)){if(w(e,t))return n[t]=e[t],r||delete e[t],!0;if(w(e,i))return n[t]=e[i],r||delete e[i],!0}return!1}function ce(n){return a(n)?[bn(n)]:Array.isArray(n)?function n(e,t){var i,l,u,c,d=[];for(i=0;i<e.length;i++)r(l=e[i])||"boolean"==typeof l||(u=d.length-1,c=d[u],Array.isArray(l)?l.length>0&&(de((l=n(l,(t||"")+"_"+i))[0])&&de(c)&&(d[u]=bn(c.text+l[0].text),l.shift()),d.push.apply(d,l)):a(l)?de(c)?d[u]=bn(c.text+l):""!==l&&d.push(bn(l)):de(l)&&de(c)?d[u]=bn(c.text+l.text):(o(e._isVList)&&s(l.tag)&&r(l.key)&&s(t)&&(l.key="__vlist"+t+"_"+i+"__"),d.push(l)));return d}(n):void 0}function de(n){return s(n)&&s(n.text)&&!1===n.isComment}function me(n,e){if(n){for(var t=Object.create(null),i=ln?Reflect.ownKeys(n):Object.keys(n),r=0;r<i.length;r++){var s=i[r];if("__ob__"!==s){for(var o=n[s].from,a=e;a;){if(a._provided&&w(a._provided,o)){t[s]=a._provided[o];break}a=a.$parent}if(!a)if("default"in n[s]){var l=n[s].default;t[s]="function"==typeof l?l.call(e):l}else 0}}return t}}function pe(n,e){if(!n||!n.length)return{};for(var t={},i=0,r=n.length;i<r;i++){var s=n[i],o=s.data;if(o&&o.attrs&&o.attrs.slot&&delete o.attrs.slot,s.context!==e&&s.fnContext!==e||!o||null==o.slot)(t.default||(t.default=[])).push(s);else{var a=o.slot,l=t[a]||(t[a]=[]);"template"===s.tag?l.push.apply(l,s.children||[]):l.push(s)}}for(var u in t)t[u].every(he)&&delete t[u];return t}function he(n){return n.isComment&&!n.asyncFactory||" "===n.text}function fe(n,e,t){var r,s=Object.keys(e).length>0,o=n?!!n.$stable:!s,a=n&&n.$key;if(n){if(n._normalized)return n._normalized;if(o&&t&&t!==i&&a===t.$key&&!s&&!t.$hasNormal)return t;for(var l in r={},n)n[l]&&"$"!==l[0]&&(r[l]=ge(e,l,n[l]))}else r={};for(var u in e)u in r||(r[u]=ve(e,u));return n&&Object.isExtensible(n)&&(n._normalized=r),R(r,"$stable",o),R(r,"$key",a),R(r,"$hasNormal",s),r}function ge(n,e,t){var i=function(){var n=arguments.length?t.apply(null,arguments):t({});return(n=n&&"object"==typeof n&&!Array.isArray(n)?[n]:ce(n))&&(0===n.length||1===n.length&&n[0].isComment)?void 0:n};return t.proxy&&Object.defineProperty(n,e,{get:i,enumerable:!0,configurable:!0}),i}function ve(n,e){return function(){return n[e]}}function be(n,e){var t,i,r,o,a;if(Array.isArray(n)||"string"==typeof n)for(t=new Array(n.length),i=0,r=n.length;i<r;i++)t[i]=e(n[i],i);else if("number"==typeof n)for(t=new Array(n),i=0;i<n;i++)t[i]=e(i+1,i);else if(l(n))if(ln&&n[Symbol.iterator]){t=[];for(var u=n[Symbol.iterator](),c=u.next();!c.done;)t.push(e(c.value,t.length)),c=u.next()}else for(o=Object.keys(n),t=new Array(o.length),i=0,r=o.length;i<r;i++)a=o[i],t[i]=e(n[a],a,i);return s(t)||(t=[]),t._isVList=!0,t}function xe(n,e,t,i){var r,s=this.$scopedSlots[n];s?(t=t||{},i&&(t=B(B({},i),t)),r=s(t)||e):r=this.$slots[n]||e;var o=t&&t.slot;return o?this.$createElement("template",{slot:o},r):r}function we(n){return Mn(this.$options,"filters",n)||C}function Ee(n,e){return Array.isArray(n)?-1===n.indexOf(e):n!==e}function ye(n,e,t,i,r){var s=F.keyCodes[e]||t;return r&&i&&!F.keyCodes[e]?Ee(r,i):s?Ee(s,n):i?_(i)!==e:void 0}function ke(n,e,t,i,r){if(t)if(l(t)){var s;Array.isArray(t)&&(t=S(t));var o=function(o){if("class"===o||"style"===o||v(o))s=n;else{var a=n.attrs&&n.attrs.type;s=i||F.mustUseProp(e,a,o)?n.domProps||(n.domProps={}):n.attrs||(n.attrs={})}var l=k(o),u=_(o);l in s||u in s||(s[o]=t[o],r&&((n.on||(n.on={}))["update:"+o]=function(n){t[o]=n}))};for(var a in t)o(a)}else;return n}function Ae(n,e){var t=this._staticTrees||(this._staticTrees=[]),i=t[n];return i&&!e?i:(_e(i=t[n]=this.$options.staticRenderFns[n].call(this._renderProxy,null,this),"__static__"+n,!1),i)}function je(n,e,t){return _e(n,"__once__"+e+(t?"_"+t:""),!0),n}function _e(n,e,t){if(Array.isArray(n))for(var i=0;i<n.length;i++)n[i]&&"string"!=typeof n[i]&&Ne(n[i],e+"_"+i,t);else Ne(n,e,t)}function Ne(n,e,t){n.isStatic=!0,n.key=e,n.isOnce=t}function Oe(n,e){if(e)if(c(e)){var t=n.on=n.on?B({},n.on):{};for(var i in e){var r=t[i],s=e[i];t[i]=r?[].concat(r,s):s}}else;return n}function Be(n,e,t,i){e=e||{$stable:!t};for(var r=0;r<n.length;r++){var s=n[r];Array.isArray(s)?Be(s,e,t):s&&(s.proxy&&(s.fn.proxy=!0),e[s.key]=s.fn)}return i&&(e.$key=i),e}function Se(n,e){for(var t=0;t<e.length;t+=2){var i=e[t];"string"==typeof i&&i&&(n[e[t]]=e[t+1])}return n}function Ie(n,e){return"string"==typeof n?e+n:n}function Le(n){n._o=je,n._n=f,n._s=h,n._l=be,n._t=xe,n._q=T,n._i=D,n._m=Ae,n._f=we,n._k=ye,n._b=ke,n._v=bn,n._e=vn,n._u=Be,n._g=Oe,n._d=Se,n._p=Ie}function Ce(n,e,t,r,s){var a,l=this,u=s.options;w(r,"_uid")?(a=Object.create(r))._original=r:(a=r,r=r._original);var c=o(u._compiled),d=!c;this.data=n,this.props=e,this.children=t,this.parent=r,this.listeners=n.on||i,this.injections=me(u.inject,r),this.slots=function(){return l.$slots||fe(n.scopedSlots,l.$slots=pe(t,r)),l.$slots},Object.defineProperty(this,"scopedSlots",{enumerable:!0,get:function(){return fe(n.scopedSlots,this.slots())}}),c&&(this.$options=u,this.$slots=this.slots(),this.$scopedSlots=fe(n.scopedSlots,this.$slots)),u._scopeId?this._c=function(n,e,t,i){var s=ze(a,n,e,t,i,d);return s&&!Array.isArray(s)&&(s.fnScopeId=u._scopeId,s.fnContext=r),s}:this._c=function(n,e,t,i){return ze(a,n,e,t,i,d)}}function Te(n,e,t,i,r){var s=xn(n);return s.fnContext=t,s.fnOptions=i,e.slot&&((s.data||(s.data={})).slot=e.slot),s}function De(n,e){for(var t in e)n[k(t)]=e[t]}Le(Ce.prototype);var qe={init:function(n,e){if(n.componentInstance&&!n.componentInstance._isDestroyed&&n.data.keepAlive){var t=n;qe.prepatch(t,t)}else{(n.componentInstance=function(n,e){var t={_isComponent:!0,_parentVnode:n,parent:e},i=n.data.inlineTemplate;s(i)&&(t.render=i.render,t.staticRenderFns=i.staticRenderFns);return new n.componentOptions.Ctor(t)}(n,Ze)).$mount(e?n.elm:void 0,e)}},prepatch:function(n,e){var t=e.componentOptions;!function(n,e,t,r,s){0;var o=r.data.scopedSlots,a=n.$scopedSlots,l=!!(o&&!o.$stable||a!==i&&!a.$stable||o&&n.$scopedSlots.$key!==o.$key),u=!!(s||n.$options._renderChildren||l);n.$options._parentVnode=r,n.$vnode=r,n._vnode&&(n._vnode.parent=r);if(n.$options._renderChildren=s,n.$attrs=r.data.attrs||i,n.$listeners=t||i,e&&n.$options.props){An(!1);for(var c=n._props,d=n.$options._propKeys||[],m=0;m<d.length;m++){var p=d[m],h=n.$options.props;c[p]=Fn(p,h,e,n)}An(!0),n.$options.propsData=e}t=t||i;var f=n.$options._parentListeners;n.$options._parentListeners=t,Ge(n,t,f),u&&(n.$slots=pe(s,r.context),n.$forceUpdate());0}(e.componentInstance=n.componentInstance,t.propsData,t.listeners,e,t.children)},insert:function(n){var e,t=n.context,i=n.componentInstance;i._isMounted||(i._isMounted=!0,nt(i,"mounted")),n.data.keepAlive&&(t._isMounted?((e=i)._inactive=!1,tt.push(e)):Ye(i,!0))},destroy:function(n){var e=n.componentInstance;e._isDestroyed||(n.data.keepAlive?function n(e,t){if(t&&(e._directInactive=!0,Xe(e)))return;if(!e._inactive){e._inactive=!0;for(var i=0;i<e.$children.length;i++)n(e.$children[i]);nt(e,"deactivated")}}(e,!0):e.$destroy())}},Pe=Object.keys(qe);function Me(n,e,t,a,u){if(!r(n)){var c=t.$options._base;if(l(n)&&(n=c.extend(n)),"function"==typeof n){var d;if(r(n.cid)&&void 0===(n=function(n,e){if(o(n.error)&&s(n.errorComp))return n.errorComp;if(s(n.resolved))return n.resolved;var t=$e;t&&s(n.owners)&&-1===n.owners.indexOf(t)&&n.owners.push(t);if(o(n.loading)&&s(n.loadingComp))return n.loadingComp;if(t&&!s(n.owners)){var i=n.owners=[t],a=!0,u=null,c=null;t.$on("hook:destroyed",(function(){return b(i,t)}));var d=function(n){for(var e=0,t=i.length;e<t;e++)i[e].$forceUpdate();n&&(i.length=0,null!==u&&(clearTimeout(u),u=null),null!==c&&(clearTimeout(c),c=null))},m=q((function(t){n.resolved=Ue(t,e),a?i.length=0:d(!0)})),h=q((function(e){s(n.errorComp)&&(n.error=!0,d(!0))})),f=n(m,h);return l(f)&&(p(f)?r(n.resolved)&&f.then(m,h):p(f.component)&&(f.component.then(m,h),s(f.error)&&(n.errorComp=Ue(f.error,e)),s(f.loading)&&(n.loadingComp=Ue(f.loading,e),0===f.delay?n.loading=!0:u=setTimeout((function(){u=null,r(n.resolved)&&r(n.error)&&(n.loading=!0,d(!1))}),f.delay||200)),s(f.timeout)&&(c=setTimeout((function(){c=null,r(n.resolved)&&h(null)}),f.timeout)))),a=!1,n.loading?n.loadingComp:n.resolved}}(d=n,c)))return function(n,e,t,i,r){var s=vn();return s.asyncFactory=n,s.asyncMeta={data:e,context:t,children:i,tag:r},s}(d,e,t,a,u);e=e||{},yt(n),s(e.model)&&function(n,e){var t=n.model&&n.model.prop||"value",i=n.model&&n.model.event||"input";(e.attrs||(e.attrs={}))[t]=e.model.value;var r=e.on||(e.on={}),o=r[i],a=e.model.callback;s(o)?(Array.isArray(o)?-1===o.indexOf(a):o!==a)&&(r[i]=[a].concat(o)):r[i]=a}(n.options,e);var m=function(n,e,t){var i=e.options.props;if(!r(i)){var o={},a=n.attrs,l=n.props;if(s(a)||s(l))for(var u in i){var c=_(u);ue(o,l,u,c,!0)||ue(o,a,u,c,!1)}return o}}(e,n);if(o(n.options.functional))return function(n,e,t,r,o){var a=n.options,l={},u=a.props;if(s(u))for(var c in u)l[c]=Fn(c,u,e||i);else s(t.attrs)&&De(l,t.attrs),s(t.props)&&De(l,t.props);var d=new Ce(t,l,o,r,n),m=a.render.call(null,d._c,d);if(m instanceof fn)return Te(m,t,d.parent,a,d);if(Array.isArray(m)){for(var p=ce(m)||[],h=new Array(p.length),f=0;f<p.length;f++)h[f]=Te(p[f],t,d.parent,a,d);return h}}(n,m,e,t,a);var h=e.on;if(e.on=e.nativeOn,o(n.options.abstract)){var f=e.slot;e={},f&&(e.slot=f)}!function(n){for(var e=n.hook||(n.hook={}),t=0;t<Pe.length;t++){var i=Pe[t],r=e[i],s=qe[i];r===s||r&&r._merged||(e[i]=r?Fe(s,r):s)}}(e);var g=n.options.name||u;return new fn("vue-component-"+n.cid+(g?"-"+g:""),e,void 0,void 0,void 0,t,{Ctor:n,propsData:m,listeners:h,tag:u,children:a},d)}}}function Fe(n,e){var t=function(t,i){n(t,i),e(t,i)};return t._merged=!0,t}function ze(n,e,t,i,u,c){return(Array.isArray(t)||a(t))&&(u=i,i=t,t=void 0),o(c)&&(u=2),function(n,e,t,i,a){if(s(t)&&s(t.__ob__))return vn();s(t)&&s(t.is)&&(e=t.is);if(!e)return vn();0;Array.isArray(i)&&"function"==typeof i[0]&&((t=t||{}).scopedSlots={default:i[0]},i.length=0);2===a?i=ce(i):1===a&&(i=function(n){for(var e=0;e<n.length;e++)if(Array.isArray(n[e]))return Array.prototype.concat.apply([],n);return n}(i));var u,c;if("string"==typeof e){var d;c=n.$vnode&&n.$vnode.ns||F.getTagNamespace(e),u=F.isReservedTag(e)?new fn(F.parsePlatformTagName(e),t,i,void 0,void 0,n):t&&t.pre||!s(d=Mn(n.$options,"components",e))?new fn(e,t,i,void 0,void 0,n):Me(d,t,n,i,e)}else u=Me(e,t,n,i);return Array.isArray(u)?u:s(u)?(s(c)&&function n(e,t,i){e.ns=t,"foreignObject"===e.tag&&(t=void 0,i=!0);if(s(e.children))for(var a=0,l=e.children.length;a<l;a++){var u=e.children[a];s(u.tag)&&(r(u.ns)||o(i)&&"svg"!==u.tag)&&n(u,t,i)}}(u,c),s(t)&&function(n){l(n.style)&&re(n.style);l(n.class)&&re(n.class)}(t),u):vn()}(n,e,t,i,u)}var Re,$e=null;function Ue(n,e){return(n.__esModule||ln&&"Module"===n[Symbol.toStringTag])&&(n=n.default),l(n)?e.extend(n):n}function He(n){return n.isComment&&n.asyncFactory}function Ve(n){if(Array.isArray(n))for(var e=0;e<n.length;e++){var t=n[e];if(s(t)&&(s(t.componentOptions)||He(t)))return t}}function We(n,e){Re.$on(n,e)}function Ke(n,e){Re.$off(n,e)}function Qe(n,e){var t=Re;return function i(){var r=e.apply(null,arguments);null!==r&&t.$off(n,i)}}function Ge(n,e,t){Re=n,ae(e,t||{},We,Ke,Qe,n),Re=void 0}var Ze=null;function Je(n){var e=Ze;return Ze=n,function(){Ze=e}}function Xe(n){for(;n&&(n=n.$parent);)if(n._inactive)return!0;return!1}function Ye(n,e){if(e){if(n._directInactive=!1,Xe(n))return}else if(n._directInactive)return;if(n._inactive||null===n._inactive){n._inactive=!1;for(var t=0;t<n.$children.length;t++)Ye(n.$children[t]);nt(n,"activated")}}function nt(n,e){pn();var t=n.$options[e],i=e+" hook";if(t)for(var r=0,s=t.length;r<s;r++)Hn(t[r],n,null,n,i);n._hasHookEvent&&n.$emit("hook:"+e),hn()}var et=[],tt=[],it={},rt=!1,st=!1,ot=0;var at=0,lt=Date.now;if(V&&!G){var ut=window.performance;ut&&"function"==typeof ut.now&&lt()>document.createEvent("Event").timeStamp&&(lt=function(){return ut.now()})}function ct(){var n,e;for(at=lt(),st=!0,et.sort((function(n,e){return n.id-e.id})),ot=0;ot<et.length;ot++)(n=et[ot]).before&&n.before(),e=n.id,it[e]=null,n.run();var t=tt.slice(),i=et.slice();ot=et.length=tt.length=0,it={},rt=st=!1,function(n){for(var e=0;e<n.length;e++)n[e]._inactive=!0,Ye(n[e],!0)}(t),function(n){var e=n.length;for(;e--;){var t=n[e],i=t.vm;i._watcher===t&&i._isMounted&&!i._isDestroyed&&nt(i,"updated")}}(i),sn&&F.devtools&&sn.emit("flush")}var dt=0,mt=function(n,e,t,i,r){this.vm=n,r&&(n._watcher=this),n._watchers.push(this),i?(this.deep=!!i.deep,this.user=!!i.user,this.lazy=!!i.lazy,this.sync=!!i.sync,this.before=i.before):this.deep=this.user=this.lazy=this.sync=!1,this.cb=t,this.id=++dt,this.active=!0,this.dirty=this.lazy,this.deps=[],this.newDeps=[],this.depIds=new an,this.newDepIds=new an,this.expression="","function"==typeof e?this.getter=e:(this.getter=function(n){if(!$.test(n)){var e=n.split(".");return function(n){for(var t=0;t<e.length;t++){if(!n)return;n=n[e[t]]}return n}}}(e),this.getter||(this.getter=I)),this.value=this.lazy?void 0:this.get()};mt.prototype.get=function(){var n;pn(this);var e=this.vm;try{n=this.getter.call(e,e)}catch(n){if(!this.user)throw n;Un(n,e,'getter for watcher "'+this.expression+'"')}finally{this.deep&&re(n),hn(),this.cleanupDeps()}return n},mt.prototype.addDep=function(n){var e=n.id;this.newDepIds.has(e)||(this.newDepIds.add(e),this.newDeps.push(n),this.depIds.has(e)||n.addSub(this))},mt.prototype.cleanupDeps=function(){for(var n=this.deps.length;n--;){var e=this.deps[n];this.newDepIds.has(e.id)||e.removeSub(this)}var t=this.depIds;this.depIds=this.newDepIds,this.newDepIds=t,this.newDepIds.clear(),t=this.deps,this.deps=this.newDeps,this.newDeps=t,this.newDeps.length=0},mt.prototype.update=function(){this.lazy?this.dirty=!0:this.sync?this.run():function(n){var e=n.id;if(null==it[e]){if(it[e]=!0,st){for(var t=et.length-1;t>ot&&et[t].id>n.id;)t--;et.splice(t+1,0,n)}else et.push(n);rt||(rt=!0,te(ct))}}(this)},mt.prototype.run=function(){if(this.active){var n=this.get();if(n!==this.value||l(n)||this.deep){var e=this.value;if(this.value=n,this.user)try{this.cb.call(this.vm,n,e)}catch(n){Un(n,this.vm,'callback for watcher "'+this.expression+'"')}else this.cb.call(this.vm,n,e)}}},mt.prototype.evaluate=function(){this.value=this.get(),this.dirty=!1},mt.prototype.depend=function(){for(var n=this.deps.length;n--;)this.deps[n].depend()},mt.prototype.teardown=function(){if(this.active){this.vm._isBeingDestroyed||b(this.vm._watchers,this);for(var n=this.deps.length;n--;)this.deps[n].removeSub(this);this.active=!1}};var pt={enumerable:!0,configurable:!0,get:I,set:I};function ht(n,e,t){pt.get=function(){return this[e][t]},pt.set=function(n){this[e][t]=n},Object.defineProperty(n,t,pt)}function ft(n){n._watchers=[];var e=n.$options;e.props&&function(n,e){var t=n.$options.propsData||{},i=n._props={},r=n.$options._propKeys=[];n.$parent&&An(!1);var s=function(s){r.push(s);var o=Fn(s,e,t,n);Nn(i,s,o),s in n||ht(n,"_props",s)};for(var o in e)s(o);An(!0)}(n,e.props),e.methods&&function(n,e){n.$options.props;for(var t in e)n[t]="function"!=typeof e[t]?I:N(e[t],n)}(n,e.methods),e.data?function(n){var e=n.$options.data;c(e=n._data="function"==typeof e?function(n,e){pn();try{return n.call(e,e)}catch(n){return Un(n,e,"data()"),{}}finally{hn()}}(e,n):e||{})||(e={});var t=Object.keys(e),i=n.$options.props,r=(n.$options.methods,t.length);for(;r--;){var s=t[r];0,i&&w(i,s)||(o=void 0,36!==(o=(s+"").charCodeAt(0))&&95!==o&&ht(n,"_data",s))}var o;_n(e,!0)}(n):_n(n._data={},!0),e.computed&&function(n,e){var t=n._computedWatchers=Object.create(null),i=rn();for(var r in e){var s=e[r],o="function"==typeof s?s:s.get;0,i||(t[r]=new mt(n,o||I,I,gt)),r in n||vt(n,r,s)}}(n,e.computed),e.watch&&e.watch!==nn&&function(n,e){for(var t in e){var i=e[t];if(Array.isArray(i))for(var r=0;r<i.length;r++)wt(n,t,i[r]);else wt(n,t,i)}}(n,e.watch)}var gt={lazy:!0};function vt(n,e,t){var i=!rn();"function"==typeof t?(pt.get=i?bt(e):xt(t),pt.set=I):(pt.get=t.get?i&&!1!==t.cache?bt(e):xt(t.get):I,pt.set=t.set||I),Object.defineProperty(n,e,pt)}function bt(n){return function(){var e=this._computedWatchers&&this._computedWatchers[n];if(e)return e.dirty&&e.evaluate(),dn.target&&e.depend(),e.value}}function xt(n){return function(){return n.call(this,this)}}function wt(n,e,t,i){return c(t)&&(i=t,t=t.handler),"string"==typeof t&&(t=n[t]),n.$watch(e,t,i)}var Et=0;function yt(n){var e=n.options;if(n.super){var t=yt(n.super);if(t!==n.superOptions){n.superOptions=t;var i=function(n){var e,t=n.options,i=n.sealedOptions;for(var r in t)t[r]!==i[r]&&(e||(e={}),e[r]=t[r]);return e}(n);i&&B(n.extendOptions,i),(e=n.options=Pn(t,n.extendOptions)).name&&(e.components[e.name]=n)}}return e}function kt(n){this._init(n)}function At(n){n.cid=0;var e=1;n.extend=function(n){n=n||{};var t=this,i=t.cid,r=n._Ctor||(n._Ctor={});if(r[i])return r[i];var s=n.name||t.options.name;var o=function(n){this._init(n)};return(o.prototype=Object.create(t.prototype)).constructor=o,o.cid=e++,o.options=Pn(t.options,n),o.super=t,o.options.props&&function(n){var e=n.options.props;for(var t in e)ht(n.prototype,"_props",t)}(o),o.options.computed&&function(n){var e=n.options.computed;for(var t in e)vt(n.prototype,t,e[t])}(o),o.extend=t.extend,o.mixin=t.mixin,o.use=t.use,P.forEach((function(n){o[n]=t[n]})),s&&(o.options.components[s]=o),o.superOptions=t.options,o.extendOptions=n,o.sealedOptions=B({},o.options),r[i]=o,o}}function jt(n){return n&&(n.Ctor.options.name||n.tag)}function _t(n,e){return Array.isArray(n)?n.indexOf(e)>-1:"string"==typeof n?n.split(",").indexOf(e)>-1:!!d(n)&&n.test(e)}function Nt(n,e){var t=n.cache,i=n.keys,r=n._vnode;for(var s in t){var o=t[s];if(o){var a=jt(o.componentOptions);a&&!e(a)&&Ot(t,s,i,r)}}}function Ot(n,e,t,i){var r=n[e];!r||i&&r.tag===i.tag||r.componentInstance.$destroy(),n[e]=null,b(t,e)}!function(n){n.prototype._init=function(n){var e=this;e._uid=Et++,e._isVue=!0,n&&n._isComponent?function(n,e){var t=n.$options=Object.create(n.constructor.options),i=e._parentVnode;t.parent=e.parent,t._parentVnode=i;var r=i.componentOptions;t.propsData=r.propsData,t._parentListeners=r.listeners,t._renderChildren=r.children,t._componentTag=r.tag,e.render&&(t.render=e.render,t.staticRenderFns=e.staticRenderFns)}(e,n):e.$options=Pn(yt(e.constructor),n||{},e),e._renderProxy=e,e._self=e,function(n){var e=n.$options,t=e.parent;if(t&&!e.abstract){for(;t.$options.abstract&&t.$parent;)t=t.$parent;t.$children.push(n)}n.$parent=t,n.$root=t?t.$root:n,n.$children=[],n.$refs={},n._watcher=null,n._inactive=null,n._directInactive=!1,n._isMounted=!1,n._isDestroyed=!1,n._isBeingDestroyed=!1}(e),function(n){n._events=Object.create(null),n._hasHookEvent=!1;var e=n.$options._parentListeners;e&&Ge(n,e)}(e),function(n){n._vnode=null,n._staticTrees=null;var e=n.$options,t=n.$vnode=e._parentVnode,r=t&&t.context;n.$slots=pe(e._renderChildren,r),n.$scopedSlots=i,n._c=function(e,t,i,r){return ze(n,e,t,i,r,!1)},n.$createElement=function(e,t,i,r){return ze(n,e,t,i,r,!0)};var s=t&&t.data;Nn(n,"$attrs",s&&s.attrs||i,null,!0),Nn(n,"$listeners",e._parentListeners||i,null,!0)}(e),nt(e,"beforeCreate"),function(n){var e=me(n.$options.inject,n);e&&(An(!1),Object.keys(e).forEach((function(t){Nn(n,t,e[t])})),An(!0))}(e),ft(e),function(n){var e=n.$options.provide;e&&(n._provided="function"==typeof e?e.call(n):e)}(e),nt(e,"created"),e.$options.el&&e.$mount(e.$options.el)}}(kt),function(n){var e={get:function(){return this._data}},t={get:function(){return this._props}};Object.defineProperty(n.prototype,"$data",e),Object.defineProperty(n.prototype,"$props",t),n.prototype.$set=On,n.prototype.$delete=Bn,n.prototype.$watch=function(n,e,t){if(c(e))return wt(this,n,e,t);(t=t||{}).user=!0;var i=new mt(this,n,e,t);if(t.immediate)try{e.call(this,i.value)}catch(n){Un(n,this,'callback for immediate watcher "'+i.expression+'"')}return function(){i.teardown()}}}(kt),function(n){var e=/^hook:/;n.prototype.$on=function(n,t){var i=this;if(Array.isArray(n))for(var r=0,s=n.length;r<s;r++)i.$on(n[r],t);else(i._events[n]||(i._events[n]=[])).push(t),e.test(n)&&(i._hasHookEvent=!0);return i},n.prototype.$once=function(n,e){var t=this;function i(){t.$off(n,i),e.apply(t,arguments)}return i.fn=e,t.$on(n,i),t},n.prototype.$off=function(n,e){var t=this;if(!arguments.length)return t._events=Object.create(null),t;if(Array.isArray(n)){for(var i=0,r=n.length;i<r;i++)t.$off(n[i],e);return t}var s,o=t._events[n];if(!o)return t;if(!e)return t._events[n]=null,t;for(var a=o.length;a--;)if((s=o[a])===e||s.fn===e){o.splice(a,1);break}return t},n.prototype.$emit=function(n){var e=this,t=e._events[n];if(t){t=t.length>1?O(t):t;for(var i=O(arguments,1),r='event handler for "'+n+'"',s=0,o=t.length;s<o;s++)Hn(t[s],e,i,e,r)}return e}}(kt),function(n){n.prototype._update=function(n,e){var t=this,i=t.$el,r=t._vnode,s=Je(t);t._vnode=n,t.$el=r?t.__patch__(r,n):t.__patch__(t.$el,n,e,!1),s(),i&&(i.__vue__=null),t.$el&&(t.$el.__vue__=t),t.$vnode&&t.$parent&&t.$vnode===t.$parent._vnode&&(t.$parent.$el=t.$el)},n.prototype.$forceUpdate=function(){this._watcher&&this._watcher.update()},n.prototype.$destroy=function(){var n=this;if(!n._isBeingDestroyed){nt(n,"beforeDestroy"),n._isBeingDestroyed=!0;var e=n.$parent;!e||e._isBeingDestroyed||n.$options.abstract||b(e.$children,n),n._watcher&&n._watcher.teardown();for(var t=n._watchers.length;t--;)n._watchers[t].teardown();n._data.__ob__&&n._data.__ob__.vmCount--,n._isDestroyed=!0,n.__patch__(n._vnode,null),nt(n,"destroyed"),n.$off(),n.$el&&(n.$el.__vue__=null),n.$vnode&&(n.$vnode.parent=null)}}}(kt),function(n){Le(n.prototype),n.prototype.$nextTick=function(n){return te(n,this)},n.prototype._render=function(){var n,e=this,t=e.$options,i=t.render,r=t._parentVnode;r&&(e.$scopedSlots=fe(r.data.scopedSlots,e.$slots,e.$scopedSlots)),e.$vnode=r;try{$e=e,n=i.call(e._renderProxy,e.$createElement)}catch(t){Un(t,e,"render"),n=e._vnode}finally{$e=null}return Array.isArray(n)&&1===n.length&&(n=n[0]),n instanceof fn||(n=vn()),n.parent=r,n}}(kt);var Bt=[String,RegExp,Array],St={KeepAlive:{name:"keep-alive",abstract:!0,props:{include:Bt,exclude:Bt,max:[String,Number]},created:function(){this.cache=Object.create(null),this.keys=[]},destroyed:function(){for(var n in this.cache)Ot(this.cache,n,this.keys)},mounted:function(){var n=this;this.$watch("include",(function(e){Nt(n,(function(n){return _t(e,n)}))})),this.$watch("exclude",(function(e){Nt(n,(function(n){return!_t(e,n)}))}))},render:function(){var n=this.$slots.default,e=Ve(n),t=e&&e.componentOptions;if(t){var i=jt(t),r=this.include,s=this.exclude;if(r&&(!i||!_t(r,i))||s&&i&&_t(s,i))return e;var o=this.cache,a=this.keys,l=null==e.key?t.Ctor.cid+(t.tag?"::"+t.tag:""):e.key;o[l]?(e.componentInstance=o[l].componentInstance,b(a,l),a.push(l)):(o[l]=e,a.push(l),this.max&&a.length>parseInt(this.max)&&Ot(o,a[0],a,this._vnode)),e.data.keepAlive=!0}return e||n&&n[0]}}};!function(n){var e={get:function(){return F}};Object.defineProperty(n,"config",e),n.util={warn:un,extend:B,mergeOptions:Pn,defineReactive:Nn},n.set=On,n.delete=Bn,n.nextTick=te,n.observable=function(n){return _n(n),n},n.options=Object.create(null),P.forEach((function(e){n.options[e+"s"]=Object.create(null)})),n.options._base=n,B(n.options.components,St),function(n){n.use=function(n){var e=this._installedPlugins||(this._installedPlugins=[]);if(e.indexOf(n)>-1)return this;var t=O(arguments,1);return t.unshift(this),"function"==typeof n.install?n.install.apply(n,t):"function"==typeof n&&n.apply(null,t),e.push(n),this}}(n),function(n){n.mixin=function(n){return this.options=Pn(this.options,n),this}}(n),At(n),function(n){P.forEach((function(e){n[e]=function(n,t){return t?("component"===e&&c(t)&&(t.name=t.name||n,t=this.options._base.extend(t)),"directive"===e&&"function"==typeof t&&(t={bind:t,update:t}),this.options[e+"s"][n]=t,t):this.options[e+"s"][n]}}))}(n)}(kt),Object.defineProperty(kt.prototype,"$isServer",{get:rn}),Object.defineProperty(kt.prototype,"$ssrContext",{get:function(){return this.$vnode&&this.$vnode.ssrContext}}),Object.defineProperty(kt,"FunctionalRenderContext",{value:Ce}),kt.version="2.6.10";var It=g("style,class"),Lt=g("input,textarea,option,select,progress"),Ct=g("contenteditable,draggable,spellcheck"),Tt=g("events,caret,typing,plaintext-only"),Dt=g("allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,default,defaultchecked,defaultmuted,defaultselected,defer,disabled,enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,required,reversed,scoped,seamless,selected,sortable,translate,truespeed,typemustmatch,visible"),qt="http://www.w3.org/1999/xlink",Pt=function(n){return":"===n.charAt(5)&&"xlink"===n.slice(0,5)},Mt=function(n){return Pt(n)?n.slice(6,n.length):""},Ft=function(n){return null==n||!1===n};function zt(n){for(var e=n.data,t=n,i=n;s(i.componentInstance);)(i=i.componentInstance._vnode)&&i.data&&(e=Rt(i.data,e));for(;s(t=t.parent);)t&&t.data&&(e=Rt(e,t.data));return function(n,e){if(s(n)||s(e))return $t(n,Ut(e));return""}(e.staticClass,e.class)}function Rt(n,e){return{staticClass:$t(n.staticClass,e.staticClass),class:s(n.class)?[n.class,e.class]:e.class}}function $t(n,e){return n?e?n+" "+e:n:e||""}function Ut(n){return Array.isArray(n)?function(n){for(var e,t="",i=0,r=n.length;i<r;i++)s(e=Ut(n[i]))&&""!==e&&(t&&(t+=" "),t+=e);return t}(n):l(n)?function(n){var e="";for(var t in n)n[t]&&(e&&(e+=" "),e+=t);return e}(n):"string"==typeof n?n:""}var Ht={svg:"http://www.w3.org/2000/svg",math:"http://www.w3.org/1998/Math/MathML"},Vt=g("html,body,base,head,link,meta,style,title,address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,menuitem,summary,content,element,shadow,template,blockquote,iframe,tfoot"),Wt=g("svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,foreignObject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view",!0),Kt=function(n){return Vt(n)||Wt(n)};var Qt=Object.create(null);var Gt=g("text,number,password,search,email,tel,url");var Zt=Object.freeze({createElement:function(n,e){var t=document.createElement(n);return"select"!==n?t:(e.data&&e.data.attrs&&void 0!==e.data.attrs.multiple&&t.setAttribute("multiple","multiple"),t)},createElementNS:function(n,e){return document.createElementNS(Ht[n],e)},createTextNode:function(n){return document.createTextNode(n)},createComment:function(n){return document.createComment(n)},insertBefore:function(n,e,t){n.insertBefore(e,t)},removeChild:function(n,e){n.removeChild(e)},appendChild:function(n,e){n.appendChild(e)},parentNode:function(n){return n.parentNode},nextSibling:function(n){return n.nextSibling},tagName:function(n){return n.tagName},setTextContent:function(n,e){n.textContent=e},setStyleScope:function(n,e){n.setAttribute(e,"")}}),Jt={create:function(n,e){Xt(e)},update:function(n,e){n.data.ref!==e.data.ref&&(Xt(n,!0),Xt(e))},destroy:function(n){Xt(n,!0)}};function Xt(n,e){var t=n.data.ref;if(s(t)){var i=n.context,r=n.componentInstance||n.elm,o=i.$refs;e?Array.isArray(o[t])?b(o[t],r):o[t]===r&&(o[t]=void 0):n.data.refInFor?Array.isArray(o[t])?o[t].indexOf(r)<0&&o[t].push(r):o[t]=[r]:o[t]=r}}var Yt=new fn("",{},[]),ni=["create","activate","update","remove","destroy"];function ei(n,e){return n.key===e.key&&(n.tag===e.tag&&n.isComment===e.isComment&&s(n.data)===s(e.data)&&function(n,e){if("input"!==n.tag)return!0;var t,i=s(t=n.data)&&s(t=t.attrs)&&t.type,r=s(t=e.data)&&s(t=t.attrs)&&t.type;return i===r||Gt(i)&&Gt(r)}(n,e)||o(n.isAsyncPlaceholder)&&n.asyncFactory===e.asyncFactory&&r(e.asyncFactory.error))}function ti(n,e,t){var i,r,o={};for(i=e;i<=t;++i)s(r=n[i].key)&&(o[r]=i);return o}var ii={create:ri,update:ri,destroy:function(n){ri(n,Yt)}};function ri(n,e){(n.data.directives||e.data.directives)&&function(n,e){var t,i,r,s=n===Yt,o=e===Yt,a=oi(n.data.directives,n.context),l=oi(e.data.directives,e.context),u=[],c=[];for(t in l)i=a[t],r=l[t],i?(r.oldValue=i.value,r.oldArg=i.arg,li(r,"update",e,n),r.def&&r.def.componentUpdated&&c.push(r)):(li(r,"bind",e,n),r.def&&r.def.inserted&&u.push(r));if(u.length){var d=function(){for(var t=0;t<u.length;t++)li(u[t],"inserted",e,n)};s?le(e,"insert",d):d()}c.length&&le(e,"postpatch",(function(){for(var t=0;t<c.length;t++)li(c[t],"componentUpdated",e,n)}));if(!s)for(t in a)l[t]||li(a[t],"unbind",n,n,o)}(n,e)}var si=Object.create(null);function oi(n,e){var t,i,r=Object.create(null);if(!n)return r;for(t=0;t<n.length;t++)(i=n[t]).modifiers||(i.modifiers=si),r[ai(i)]=i,i.def=Mn(e.$options,"directives",i.name);return r}function ai(n){return n.rawName||n.name+"."+Object.keys(n.modifiers||{}).join(".")}function li(n,e,t,i,r){var s=n.def&&n.def[e];if(s)try{s(t.elm,n,t,i,r)}catch(i){Un(i,t.context,"directive "+n.name+" "+e+" hook")}}var ui=[Jt,ii];function ci(n,e){var t=e.componentOptions;if(!(s(t)&&!1===t.Ctor.options.inheritAttrs||r(n.data.attrs)&&r(e.data.attrs))){var i,o,a=e.elm,l=n.data.attrs||{},u=e.data.attrs||{};for(i in s(u.__ob__)&&(u=e.data.attrs=B({},u)),u)o=u[i],l[i]!==o&&di(a,i,o);for(i in(G||J)&&u.value!==l.value&&di(a,"value",u.value),l)r(u[i])&&(Pt(i)?a.removeAttributeNS(qt,Mt(i)):Ct(i)||a.removeAttribute(i))}}function di(n,e,t){n.tagName.indexOf("-")>-1?mi(n,e,t):Dt(e)?Ft(t)?n.removeAttribute(e):(t="allowfullscreen"===e&&"EMBED"===n.tagName?"true":e,n.setAttribute(e,t)):Ct(e)?n.setAttribute(e,function(n,e){return Ft(e)||"false"===e?"false":"contenteditable"===n&&Tt(e)?e:"true"}(e,t)):Pt(e)?Ft(t)?n.removeAttributeNS(qt,Mt(e)):n.setAttributeNS(qt,e,t):mi(n,e,t)}function mi(n,e,t){if(Ft(t))n.removeAttribute(e);else{if(G&&!Z&&"TEXTAREA"===n.tagName&&"placeholder"===e&&""!==t&&!n.__ieph){var i=function(e){e.stopImmediatePropagation(),n.removeEventListener("input",i)};n.addEventListener("input",i),n.__ieph=!0}n.setAttribute(e,t)}}var pi={create:ci,update:ci};function hi(n,e){var t=e.elm,i=e.data,o=n.data;if(!(r(i.staticClass)&&r(i.class)&&(r(o)||r(o.staticClass)&&r(o.class)))){var a=zt(e),l=t._transitionClasses;s(l)&&(a=$t(a,Ut(l))),a!==t._prevClass&&(t.setAttribute("class",a),t._prevClass=a)}}var fi,gi={create:hi,update:hi};function vi(n,e,t){var i=fi;return function r(){var s=e.apply(null,arguments);null!==s&&wi(n,r,t,i)}}var bi=Qn&&!(Y&&Number(Y[1])<=53);function xi(n,e,t,i){if(bi){var r=at,s=e;e=s._wrapper=function(n){if(n.target===n.currentTarget||n.timeStamp>=r||n.timeStamp<=0||n.target.ownerDocument!==document)return s.apply(this,arguments)}}fi.addEventListener(n,e,en?{capture:t,passive:i}:t)}function wi(n,e,t,i){(i||fi).removeEventListener(n,e._wrapper||e,t)}function Ei(n,e){if(!r(n.data.on)||!r(e.data.on)){var t=e.data.on||{},i=n.data.on||{};fi=e.elm,function(n){if(s(n.__r)){var e=G?"change":"input";n[e]=[].concat(n.__r,n[e]||[]),delete n.__r}s(n.__c)&&(n.change=[].concat(n.__c,n.change||[]),delete n.__c)}(t),ae(t,i,xi,wi,vi,e.context),fi=void 0}}var yi,ki={create:Ei,update:Ei};function Ai(n,e){if(!r(n.data.domProps)||!r(e.data.domProps)){var t,i,o=e.elm,a=n.data.domProps||{},l=e.data.domProps||{};for(t in s(l.__ob__)&&(l=e.data.domProps=B({},l)),a)t in l||(o[t]="");for(t in l){if(i=l[t],"textContent"===t||"innerHTML"===t){if(e.children&&(e.children.length=0),i===a[t])continue;1===o.childNodes.length&&o.removeChild(o.childNodes[0])}if("value"===t&&"PROGRESS"!==o.tagName){o._value=i;var u=r(i)?"":String(i);ji(o,u)&&(o.value=u)}else if("innerHTML"===t&&Wt(o.tagName)&&r(o.innerHTML)){(yi=yi||document.createElement("div")).innerHTML="<svg>"+i+"</svg>";for(var c=yi.firstChild;o.firstChild;)o.removeChild(o.firstChild);for(;c.firstChild;)o.appendChild(c.firstChild)}else if(i!==a[t])try{o[t]=i}catch(n){}}}}function ji(n,e){return!n.composing&&("OPTION"===n.tagName||function(n,e){var t=!0;try{t=document.activeElement!==n}catch(n){}return t&&n.value!==e}(n,e)||function(n,e){var t=n.value,i=n._vModifiers;if(s(i)){if(i.number)return f(t)!==f(e);if(i.trim)return t.trim()!==e.trim()}return t!==e}(n,e))}var _i={create:Ai,update:Ai},Ni=E((function(n){var e={},t=/:(.+)/;return n.split(/;(?![^(]*\))/g).forEach((function(n){if(n){var i=n.split(t);i.length>1&&(e[i[0].trim()]=i[1].trim())}})),e}));function Oi(n){var e=Bi(n.style);return n.staticStyle?B(n.staticStyle,e):e}function Bi(n){return Array.isArray(n)?S(n):"string"==typeof n?Ni(n):n}var Si,Ii=/^--/,Li=/\s*!important$/,Ci=function(n,e,t){if(Ii.test(e))n.style.setProperty(e,t);else if(Li.test(t))n.style.setProperty(_(e),t.replace(Li,""),"important");else{var i=Di(e);if(Array.isArray(t))for(var r=0,s=t.length;r<s;r++)n.style[i]=t[r];else n.style[i]=t}},Ti=["Webkit","Moz","ms"],Di=E((function(n){if(Si=Si||document.createElement("div").style,"filter"!==(n=k(n))&&n in Si)return n;for(var e=n.charAt(0).toUpperCase()+n.slice(1),t=0;t<Ti.length;t++){var i=Ti[t]+e;if(i in Si)return i}}));function qi(n,e){var t=e.data,i=n.data;if(!(r(t.staticStyle)&&r(t.style)&&r(i.staticStyle)&&r(i.style))){var o,a,l=e.elm,u=i.staticStyle,c=i.normalizedStyle||i.style||{},d=u||c,m=Bi(e.data.style)||{};e.data.normalizedStyle=s(m.__ob__)?B({},m):m;var p=function(n,e){var t,i={};if(e)for(var r=n;r.componentInstance;)(r=r.componentInstance._vnode)&&r.data&&(t=Oi(r.data))&&B(i,t);(t=Oi(n.data))&&B(i,t);for(var s=n;s=s.parent;)s.data&&(t=Oi(s.data))&&B(i,t);return i}(e,!0);for(a in d)r(p[a])&&Ci(l,a,"");for(a in p)(o=p[a])!==d[a]&&Ci(l,a,null==o?"":o)}}var Pi={create:qi,update:qi},Mi=/\s+/;function Fi(n,e){if(e&&(e=e.trim()))if(n.classList)e.indexOf(" ")>-1?e.split(Mi).forEach((function(e){return n.classList.add(e)})):n.classList.add(e);else{var t=" "+(n.getAttribute("class")||"")+" ";t.indexOf(" "+e+" ")<0&&n.setAttribute("class",(t+e).trim())}}function zi(n,e){if(e&&(e=e.trim()))if(n.classList)e.indexOf(" ")>-1?e.split(Mi).forEach((function(e){return n.classList.remove(e)})):n.classList.remove(e),n.classList.length||n.removeAttribute("class");else{for(var t=" "+(n.getAttribute("class")||"")+" ",i=" "+e+" ";t.indexOf(i)>=0;)t=t.replace(i," ");(t=t.trim())?n.setAttribute("class",t):n.removeAttribute("class")}}function Ri(n){if(n){if("object"==typeof n){var e={};return!1!==n.css&&B(e,$i(n.name||"v")),B(e,n),e}return"string"==typeof n?$i(n):void 0}}var $i=E((function(n){return{enterClass:n+"-enter",enterToClass:n+"-enter-to",enterActiveClass:n+"-enter-active",leaveClass:n+"-leave",leaveToClass:n+"-leave-to",leaveActiveClass:n+"-leave-active"}})),Ui=V&&!Z,Hi="transition",Vi="transitionend",Wi="animation",Ki="animationend";Ui&&(void 0===window.ontransitionend&&void 0!==window.onwebkittransitionend&&(Hi="WebkitTransition",Vi="webkitTransitionEnd"),void 0===window.onanimationend&&void 0!==window.onwebkitanimationend&&(Wi="WebkitAnimation",Ki="webkitAnimationEnd"));var Qi=V?window.requestAnimationFrame?window.requestAnimationFrame.bind(window):setTimeout:function(n){return n()};function Gi(n){Qi((function(){Qi(n)}))}function Zi(n,e){var t=n._transitionClasses||(n._transitionClasses=[]);t.indexOf(e)<0&&(t.push(e),Fi(n,e))}function Ji(n,e){n._transitionClasses&&b(n._transitionClasses,e),zi(n,e)}function Xi(n,e,t){var i=nr(n,e),r=i.type,s=i.timeout,o=i.propCount;if(!r)return t();var a="transition"===r?Vi:Ki,l=0,u=function(){n.removeEventListener(a,c),t()},c=function(e){e.target===n&&++l>=o&&u()};setTimeout((function(){l<o&&u()}),s+1),n.addEventListener(a,c)}var Yi=/\b(transform|all)(,|$)/;function nr(n,e){var t,i=window.getComputedStyle(n),r=(i[Hi+"Delay"]||"").split(", "),s=(i[Hi+"Duration"]||"").split(", "),o=er(r,s),a=(i[Wi+"Delay"]||"").split(", "),l=(i[Wi+"Duration"]||"").split(", "),u=er(a,l),c=0,d=0;return"transition"===e?o>0&&(t="transition",c=o,d=s.length):"animation"===e?u>0&&(t="animation",c=u,d=l.length):d=(t=(c=Math.max(o,u))>0?o>u?"transition":"animation":null)?"transition"===t?s.length:l.length:0,{type:t,timeout:c,propCount:d,hasTransform:"transition"===t&&Yi.test(i[Hi+"Property"])}}function er(n,e){for(;n.length<e.length;)n=n.concat(n);return Math.max.apply(null,e.map((function(e,t){return tr(e)+tr(n[t])})))}function tr(n){return 1e3*Number(n.slice(0,-1).replace(",","."))}function ir(n,e){var t=n.elm;s(t._leaveCb)&&(t._leaveCb.cancelled=!0,t._leaveCb());var i=Ri(n.data.transition);if(!r(i)&&!s(t._enterCb)&&1===t.nodeType){for(var o=i.css,a=i.type,u=i.enterClass,c=i.enterToClass,d=i.enterActiveClass,m=i.appearClass,p=i.appearToClass,h=i.appearActiveClass,g=i.beforeEnter,v=i.enter,b=i.afterEnter,x=i.enterCancelled,w=i.beforeAppear,E=i.appear,y=i.afterAppear,k=i.appearCancelled,A=i.duration,j=Ze,_=Ze.$vnode;_&&_.parent;)j=_.context,_=_.parent;var N=!j._isMounted||!n.isRootInsert;if(!N||E||""===E){var O=N&&m?m:u,B=N&&h?h:d,S=N&&p?p:c,I=N&&w||g,L=N&&"function"==typeof E?E:v,C=N&&y||b,T=N&&k||x,D=f(l(A)?A.enter:A);0;var P=!1!==o&&!Z,M=or(L),F=t._enterCb=q((function(){P&&(Ji(t,S),Ji(t,B)),F.cancelled?(P&&Ji(t,O),T&&T(t)):C&&C(t),t._enterCb=null}));n.data.show||le(n,"insert",(function(){var e=t.parentNode,i=e&&e._pending&&e._pending[n.key];i&&i.tag===n.tag&&i.elm._leaveCb&&i.elm._leaveCb(),L&&L(t,F)})),I&&I(t),P&&(Zi(t,O),Zi(t,B),Gi((function(){Ji(t,O),F.cancelled||(Zi(t,S),M||(sr(D)?setTimeout(F,D):Xi(t,a,F)))}))),n.data.show&&(e&&e(),L&&L(t,F)),P||M||F()}}}function rr(n,e){var t=n.elm;s(t._enterCb)&&(t._enterCb.cancelled=!0,t._enterCb());var i=Ri(n.data.transition);if(r(i)||1!==t.nodeType)return e();if(!s(t._leaveCb)){var o=i.css,a=i.type,u=i.leaveClass,c=i.leaveToClass,d=i.leaveActiveClass,m=i.beforeLeave,p=i.leave,h=i.afterLeave,g=i.leaveCancelled,v=i.delayLeave,b=i.duration,x=!1!==o&&!Z,w=or(p),E=f(l(b)?b.leave:b);0;var y=t._leaveCb=q((function(){t.parentNode&&t.parentNode._pending&&(t.parentNode._pending[n.key]=null),x&&(Ji(t,c),Ji(t,d)),y.cancelled?(x&&Ji(t,u),g&&g(t)):(e(),h&&h(t)),t._leaveCb=null}));v?v(k):k()}function k(){y.cancelled||(!n.data.show&&t.parentNode&&((t.parentNode._pending||(t.parentNode._pending={}))[n.key]=n),m&&m(t),x&&(Zi(t,u),Zi(t,d),Gi((function(){Ji(t,u),y.cancelled||(Zi(t,c),w||(sr(E)?setTimeout(y,E):Xi(t,a,y)))}))),p&&p(t,y),x||w||y())}}function sr(n){return"number"==typeof n&&!isNaN(n)}function or(n){if(r(n))return!1;var e=n.fns;return s(e)?or(Array.isArray(e)?e[0]:e):(n._length||n.length)>1}function ar(n,e){!0!==e.data.show&&ir(e)}var lr=function(n){var e,t,i={},l=n.modules,u=n.nodeOps;for(e=0;e<ni.length;++e)for(i[ni[e]]=[],t=0;t<l.length;++t)s(l[t][ni[e]])&&i[ni[e]].push(l[t][ni[e]]);function c(n){var e=u.parentNode(n);s(e)&&u.removeChild(e,n)}function d(n,e,t,r,a,l,c){if(s(n.elm)&&s(l)&&(n=l[c]=xn(n)),n.isRootInsert=!a,!function(n,e,t,r){var a=n.data;if(s(a)){var l=s(n.componentInstance)&&a.keepAlive;if(s(a=a.hook)&&s(a=a.init)&&a(n,!1),s(n.componentInstance))return m(n,e),p(t,n.elm,r),o(l)&&function(n,e,t,r){var o,a=n;for(;a.componentInstance;)if(a=a.componentInstance._vnode,s(o=a.data)&&s(o=o.transition)){for(o=0;o<i.activate.length;++o)i.activate[o](Yt,a);e.push(a);break}p(t,n.elm,r)}(n,e,t,r),!0}}(n,e,t,r)){var d=n.data,f=n.children,g=n.tag;s(g)?(n.elm=n.ns?u.createElementNS(n.ns,g):u.createElement(g,n),b(n),h(n,f,e),s(d)&&v(n,e),p(t,n.elm,r)):o(n.isComment)?(n.elm=u.createComment(n.text),p(t,n.elm,r)):(n.elm=u.createTextNode(n.text),p(t,n.elm,r))}}function m(n,e){s(n.data.pendingInsert)&&(e.push.apply(e,n.data.pendingInsert),n.data.pendingInsert=null),n.elm=n.componentInstance.$el,f(n)?(v(n,e),b(n)):(Xt(n),e.push(n))}function p(n,e,t){s(n)&&(s(t)?u.parentNode(t)===n&&u.insertBefore(n,e,t):u.appendChild(n,e))}function h(n,e,t){if(Array.isArray(e)){0;for(var i=0;i<e.length;++i)d(e[i],t,n.elm,null,!0,e,i)}else a(n.text)&&u.appendChild(n.elm,u.createTextNode(String(n.text)))}function f(n){for(;n.componentInstance;)n=n.componentInstance._vnode;return s(n.tag)}function v(n,t){for(var r=0;r<i.create.length;++r)i.create[r](Yt,n);s(e=n.data.hook)&&(s(e.create)&&e.create(Yt,n),s(e.insert)&&t.push(n))}function b(n){var e;if(s(e=n.fnScopeId))u.setStyleScope(n.elm,e);else for(var t=n;t;)s(e=t.context)&&s(e=e.$options._scopeId)&&u.setStyleScope(n.elm,e),t=t.parent;s(e=Ze)&&e!==n.context&&e!==n.fnContext&&s(e=e.$options._scopeId)&&u.setStyleScope(n.elm,e)}function x(n,e,t,i,r,s){for(;i<=r;++i)d(t[i],s,n,e,!1,t,i)}function w(n){var e,t,r=n.data;if(s(r))for(s(e=r.hook)&&s(e=e.destroy)&&e(n),e=0;e<i.destroy.length;++e)i.destroy[e](n);if(s(e=n.children))for(t=0;t<n.children.length;++t)w(n.children[t])}function E(n,e,t,i){for(;t<=i;++t){var r=e[t];s(r)&&(s(r.tag)?(y(r),w(r)):c(r.elm))}}function y(n,e){if(s(e)||s(n.data)){var t,r=i.remove.length+1;for(s(e)?e.listeners+=r:e=function(n,e){function t(){0==--t.listeners&&c(n)}return t.listeners=e,t}(n.elm,r),s(t=n.componentInstance)&&s(t=t._vnode)&&s(t.data)&&y(t,e),t=0;t<i.remove.length;++t)i.remove[t](n,e);s(t=n.data.hook)&&s(t=t.remove)?t(n,e):e()}else c(n.elm)}function k(n,e,t,i){for(var r=t;r<i;r++){var o=e[r];if(s(o)&&ei(n,o))return r}}function A(n,e,t,a,l,c){if(n!==e){s(e.elm)&&s(a)&&(e=a[l]=xn(e));var m=e.elm=n.elm;if(o(n.isAsyncPlaceholder))s(e.asyncFactory.resolved)?N(n.elm,e,t):e.isAsyncPlaceholder=!0;else if(o(e.isStatic)&&o(n.isStatic)&&e.key===n.key&&(o(e.isCloned)||o(e.isOnce)))e.componentInstance=n.componentInstance;else{var p,h=e.data;s(h)&&s(p=h.hook)&&s(p=p.prepatch)&&p(n,e);var g=n.children,v=e.children;if(s(h)&&f(e)){for(p=0;p<i.update.length;++p)i.update[p](n,e);s(p=h.hook)&&s(p=p.update)&&p(n,e)}r(e.text)?s(g)&&s(v)?g!==v&&function(n,e,t,i,o){var a,l,c,m=0,p=0,h=e.length-1,f=e[0],g=e[h],v=t.length-1,b=t[0],w=t[v],y=!o;for(0;m<=h&&p<=v;)r(f)?f=e[++m]:r(g)?g=e[--h]:ei(f,b)?(A(f,b,i,t,p),f=e[++m],b=t[++p]):ei(g,w)?(A(g,w,i,t,v),g=e[--h],w=t[--v]):ei(f,w)?(A(f,w,i,t,v),y&&u.insertBefore(n,f.elm,u.nextSibling(g.elm)),f=e[++m],w=t[--v]):ei(g,b)?(A(g,b,i,t,p),y&&u.insertBefore(n,g.elm,f.elm),g=e[--h],b=t[++p]):(r(a)&&(a=ti(e,m,h)),r(l=s(b.key)?a[b.key]:k(b,e,m,h))?d(b,i,n,f.elm,!1,t,p):ei(c=e[l],b)?(A(c,b,i,t,p),e[l]=void 0,y&&u.insertBefore(n,c.elm,f.elm)):d(b,i,n,f.elm,!1,t,p),b=t[++p]);m>h?x(n,r(t[v+1])?null:t[v+1].elm,t,p,v,i):p>v&&E(0,e,m,h)}(m,g,v,t,c):s(v)?(s(n.text)&&u.setTextContent(m,""),x(m,null,v,0,v.length-1,t)):s(g)?E(0,g,0,g.length-1):s(n.text)&&u.setTextContent(m,""):n.text!==e.text&&u.setTextContent(m,e.text),s(h)&&s(p=h.hook)&&s(p=p.postpatch)&&p(n,e)}}}function j(n,e,t){if(o(t)&&s(n.parent))n.parent.data.pendingInsert=e;else for(var i=0;i<e.length;++i)e[i].data.hook.insert(e[i])}var _=g("attrs,class,staticClass,staticStyle,key");function N(n,e,t,i){var r,a=e.tag,l=e.data,u=e.children;if(i=i||l&&l.pre,e.elm=n,o(e.isComment)&&s(e.asyncFactory))return e.isAsyncPlaceholder=!0,!0;if(s(l)&&(s(r=l.hook)&&s(r=r.init)&&r(e,!0),s(r=e.componentInstance)))return m(e,t),!0;if(s(a)){if(s(u))if(n.hasChildNodes())if(s(r=l)&&s(r=r.domProps)&&s(r=r.innerHTML)){if(r!==n.innerHTML)return!1}else{for(var c=!0,d=n.firstChild,p=0;p<u.length;p++){if(!d||!N(d,u[p],t,i)){c=!1;break}d=d.nextSibling}if(!c||d)return!1}else h(e,u,t);if(s(l)){var f=!1;for(var g in l)if(!_(g)){f=!0,v(e,t);break}!f&&l.class&&re(l.class)}}else n.data!==e.text&&(n.data=e.text);return!0}return function(n,e,t,a){if(!r(e)){var l,c=!1,m=[];if(r(n))c=!0,d(e,m);else{var p=s(n.nodeType);if(!p&&ei(n,e))A(n,e,m,null,null,a);else{if(p){if(1===n.nodeType&&n.hasAttribute("data-server-rendered")&&(n.removeAttribute("data-server-rendered"),t=!0),o(t)&&N(n,e,m))return j(e,m,!0),n;l=n,n=new fn(u.tagName(l).toLowerCase(),{},[],void 0,l)}var h=n.elm,g=u.parentNode(h);if(d(e,m,h._leaveCb?null:g,u.nextSibling(h)),s(e.parent))for(var v=e.parent,b=f(e);v;){for(var x=0;x<i.destroy.length;++x)i.destroy[x](v);if(v.elm=e.elm,b){for(var y=0;y<i.create.length;++y)i.create[y](Yt,v);var k=v.data.hook.insert;if(k.merged)for(var _=1;_<k.fns.length;_++)k.fns[_]()}else Xt(v);v=v.parent}s(g)?E(0,[n],0,0):s(n.tag)&&w(n)}}return j(e,m,c),e.elm}s(n)&&w(n)}}({nodeOps:Zt,modules:[pi,gi,ki,_i,Pi,V?{create:ar,activate:ar,remove:function(n,e){!0!==n.data.show?rr(n,e):e()}}:{}].concat(ui)});Z&&document.addEventListener("selectionchange",(function(){var n=document.activeElement;n&&n.vmodel&&gr(n,"input")}));var ur={inserted:function(n,e,t,i){"select"===t.tag?(i.elm&&!i.elm._vOptions?le(t,"postpatch",(function(){ur.componentUpdated(n,e,t)})):cr(n,e,t.context),n._vOptions=[].map.call(n.options,pr)):("textarea"===t.tag||Gt(n.type))&&(n._vModifiers=e.modifiers,e.modifiers.lazy||(n.addEventListener("compositionstart",hr),n.addEventListener("compositionend",fr),n.addEventListener("change",fr),Z&&(n.vmodel=!0)))},componentUpdated:function(n,e,t){if("select"===t.tag){cr(n,e,t.context);var i=n._vOptions,r=n._vOptions=[].map.call(n.options,pr);if(r.some((function(n,e){return!T(n,i[e])})))(n.multiple?e.value.some((function(n){return mr(n,r)})):e.value!==e.oldValue&&mr(e.value,r))&&gr(n,"change")}}};function cr(n,e,t){dr(n,e,t),(G||J)&&setTimeout((function(){dr(n,e,t)}),0)}function dr(n,e,t){var i=e.value,r=n.multiple;if(!r||Array.isArray(i)){for(var s,o,a=0,l=n.options.length;a<l;a++)if(o=n.options[a],r)s=D(i,pr(o))>-1,o.selected!==s&&(o.selected=s);else if(T(pr(o),i))return void(n.selectedIndex!==a&&(n.selectedIndex=a));r||(n.selectedIndex=-1)}}function mr(n,e){return e.every((function(e){return!T(e,n)}))}function pr(n){return"_value"in n?n._value:n.value}function hr(n){n.target.composing=!0}function fr(n){n.target.composing&&(n.target.composing=!1,gr(n.target,"input"))}function gr(n,e){var t=document.createEvent("HTMLEvents");t.initEvent(e,!0,!0),n.dispatchEvent(t)}function vr(n){return!n.componentInstance||n.data&&n.data.transition?n:vr(n.componentInstance._vnode)}var br={model:ur,show:{bind:function(n,e,t){var i=e.value,r=(t=vr(t)).data&&t.data.transition,s=n.__vOriginalDisplay="none"===n.style.display?"":n.style.display;i&&r?(t.data.show=!0,ir(t,(function(){n.style.display=s}))):n.style.display=i?s:"none"},update:function(n,e,t){var i=e.value;!i!=!e.oldValue&&((t=vr(t)).data&&t.data.transition?(t.data.show=!0,i?ir(t,(function(){n.style.display=n.__vOriginalDisplay})):rr(t,(function(){n.style.display="none"}))):n.style.display=i?n.__vOriginalDisplay:"none")},unbind:function(n,e,t,i,r){r||(n.style.display=n.__vOriginalDisplay)}}},xr={name:String,appear:Boolean,css:Boolean,mode:String,type:String,enterClass:String,leaveClass:String,enterToClass:String,leaveToClass:String,enterActiveClass:String,leaveActiveClass:String,appearClass:String,appearActiveClass:String,appearToClass:String,duration:[Number,String,Object]};function wr(n){var e=n&&n.componentOptions;return e&&e.Ctor.options.abstract?wr(Ve(e.children)):n}function Er(n){var e={},t=n.$options;for(var i in t.propsData)e[i]=n[i];var r=t._parentListeners;for(var s in r)e[k(s)]=r[s];return e}function yr(n,e){if(/\d-keep-alive$/.test(e.tag))return n("keep-alive",{props:e.componentOptions.propsData})}var kr=function(n){return n.tag||He(n)},Ar=function(n){return"show"===n.name},jr={name:"transition",props:xr,abstract:!0,render:function(n){var e=this,t=this.$slots.default;if(t&&(t=t.filter(kr)).length){0;var i=this.mode;0;var r=t[0];if(function(n){for(;n=n.parent;)if(n.data.transition)return!0}(this.$vnode))return r;var s=wr(r);if(!s)return r;if(this._leaving)return yr(n,r);var o="__transition-"+this._uid+"-";s.key=null==s.key?s.isComment?o+"comment":o+s.tag:a(s.key)?0===String(s.key).indexOf(o)?s.key:o+s.key:s.key;var l=(s.data||(s.data={})).transition=Er(this),u=this._vnode,c=wr(u);if(s.data.directives&&s.data.directives.some(Ar)&&(s.data.show=!0),c&&c.data&&!function(n,e){return e.key===n.key&&e.tag===n.tag}(s,c)&&!He(c)&&(!c.componentInstance||!c.componentInstance._vnode.isComment)){var d=c.data.transition=B({},l);if("out-in"===i)return this._leaving=!0,le(d,"afterLeave",(function(){e._leaving=!1,e.$forceUpdate()})),yr(n,r);if("in-out"===i){if(He(s))return u;var m,p=function(){m()};le(l,"afterEnter",p),le(l,"enterCancelled",p),le(d,"delayLeave",(function(n){m=n}))}}return r}}},_r=B({tag:String,moveClass:String},xr);function Nr(n){n.elm._moveCb&&n.elm._moveCb(),n.elm._enterCb&&n.elm._enterCb()}function Or(n){n.data.newPos=n.elm.getBoundingClientRect()}function Br(n){var e=n.data.pos,t=n.data.newPos,i=e.left-t.left,r=e.top-t.top;if(i||r){n.data.moved=!0;var s=n.elm.style;s.transform=s.WebkitTransform="translate("+i+"px,"+r+"px)",s.transitionDuration="0s"}}delete _r.mode;var Sr={Transition:jr,TransitionGroup:{props:_r,beforeMount:function(){var n=this,e=this._update;this._update=function(t,i){var r=Je(n);n.__patch__(n._vnode,n.kept,!1,!0),n._vnode=n.kept,r(),e.call(n,t,i)}},render:function(n){for(var e=this.tag||this.$vnode.data.tag||"span",t=Object.create(null),i=this.prevChildren=this.children,r=this.$slots.default||[],s=this.children=[],o=Er(this),a=0;a<r.length;a++){var l=r[a];if(l.tag)if(null!=l.key&&0!==String(l.key).indexOf("__vlist"))s.push(l),t[l.key]=l,(l.data||(l.data={})).transition=o;else;}if(i){for(var u=[],c=[],d=0;d<i.length;d++){var m=i[d];m.data.transition=o,m.data.pos=m.elm.getBoundingClientRect(),t[m.key]?u.push(m):c.push(m)}this.kept=n(e,null,u),this.removed=c}return n(e,null,s)},updated:function(){var n=this.prevChildren,e=this.moveClass||(this.name||"v")+"-move";n.length&&this.hasMove(n[0].elm,e)&&(n.forEach(Nr),n.forEach(Or),n.forEach(Br),this._reflow=document.body.offsetHeight,n.forEach((function(n){if(n.data.moved){var t=n.elm,i=t.style;Zi(t,e),i.transform=i.WebkitTransform=i.transitionDuration="",t.addEventListener(Vi,t._moveCb=function n(i){i&&i.target!==t||i&&!/transform$/.test(i.propertyName)||(t.removeEventListener(Vi,n),t._moveCb=null,Ji(t,e))})}})))},methods:{hasMove:function(n,e){if(!Ui)return!1;if(this._hasMove)return this._hasMove;var t=n.cloneNode();n._transitionClasses&&n._transitionClasses.forEach((function(n){zi(t,n)})),Fi(t,e),t.style.display="none",this.$el.appendChild(t);var i=nr(t);return this.$el.removeChild(t),this._hasMove=i.hasTransform}}}};kt.config.mustUseProp=function(n,e,t){return"value"===t&&Lt(n)&&"button"!==e||"selected"===t&&"option"===n||"checked"===t&&"input"===n||"muted"===t&&"video"===n},kt.config.isReservedTag=Kt,kt.config.isReservedAttr=It,kt.config.getTagNamespace=function(n){return Wt(n)?"svg":"math"===n?"math":void 0},kt.config.isUnknownElement=function(n){if(!V)return!0;if(Kt(n))return!1;if(n=n.toLowerCase(),null!=Qt[n])return Qt[n];var e=document.createElement(n);return n.indexOf("-")>-1?Qt[n]=e.constructor===window.HTMLUnknownElement||e.constructor===window.HTMLElement:Qt[n]=/HTMLUnknownElement/.test(e.toString())},B(kt.options.directives,br),B(kt.options.components,Sr),kt.prototype.__patch__=V?lr:I,kt.prototype.$mount=function(n,e){return function(n,e,t){var i;return n.$el=e,n.$options.render||(n.$options.render=vn),nt(n,"beforeMount"),i=function(){n._update(n._render(),t)},new mt(n,i,I,{before:function(){n._isMounted&&!n._isDestroyed&&nt(n,"beforeUpdate")}},!0),t=!1,null==n.$vnode&&(n._isMounted=!0,nt(n,"mounted")),n}(this,n=n&&V?function(n){if("string"==typeof n){var e=document.querySelector(n);return e||document.createElement("div")}return n}(n):void 0,e)},V&&setTimeout((function(){F.devtools&&sn&&sn.emit("init",kt)}),0),e.a=kt},function(n,e,t){"use strict";function i(n,e,t,i,r,s,o,a){var l,u="function"==typeof n?n.options:n;if(e&&(u.render=e,u.staticRenderFns=t,u._compiled=!0),i&&(u.functional=!0),s&&(u._scopeId="data-v-"+s),o?(l=function(n){(n=n||this.$vnode&&this.$vnode.ssrContext||this.parent&&this.parent.$vnode&&this.parent.$vnode.ssrContext)||"undefined"==typeof __VUE_SSR_CONTEXT__||(n=__VUE_SSR_CONTEXT__),r&&r.call(this,n),n&&n._registeredComponents&&n._registeredComponents.add(o)},u._ssrRegister=l):r&&(l=a?function(){r.call(this,this.$root.$options.shadowRoot)}:r),l)if(u.functional){u._injectStyles=l;var c=u.render;u.render=function(n,e){return l.call(e),c(n,e)}}else{var d=u.beforeCreate;u.beforeCreate=d?[].concat(d,l):[l]}return{exports:n,options:u}}t.d(e,"a",(function(){return i}))},function(n,e,t){"use strict";var i=t(79),r=t(107),s=Object.prototype.toString;function o(n){return"[object Array]"===s.call(n)}function a(n){return null!==n&&"object"==typeof n}function l(n){return"[object Function]"===s.call(n)}function u(n,e){if(null!=n)if("object"!=typeof n&&(n=[n]),o(n))for(var t=0,i=n.length;t<i;t++)e.call(null,n[t],t,n);else for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&e.call(null,n[r],r,n)}n.exports={isArray:o,isArrayBuffer:function(n){return"[object ArrayBuffer]"===s.call(n)},isBuffer:r,isFormData:function(n){return"undefined"!=typeof FormData&&n instanceof FormData},isArrayBufferView:function(n){return"undefined"!=typeof ArrayBuffer&&ArrayBuffer.isView?ArrayBuffer.isView(n):n&&n.buffer&&n.buffer instanceof ArrayBuffer},isString:function(n){return"string"==typeof n},isNumber:function(n){return"number"==typeof n},isObject:a,isUndefined:function(n){return void 0===n},isDate:function(n){return"[object Date]"===s.call(n)},isFile:function(n){return"[object File]"===s.call(n)},isBlob:function(n){return"[object Blob]"===s.call(n)},isFunction:l,isStream:function(n){return a(n)&&l(n.pipe)},isURLSearchParams:function(n){return"undefined"!=typeof URLSearchParams&&n instanceof URLSearchParams},isStandardBrowserEnv:function(){return("undefined"==typeof navigator||"ReactNative"!==navigator.product)&&("undefined"!=typeof window&&"undefined"!=typeof document)},forEach:u,merge:function n(){var e={};function t(t,i){"object"==typeof e[i]&&"object"==typeof t?e[i]=n(e[i],t):e[i]=t}for(var i=0,r=arguments.length;i<r;i++)u(arguments[i],t);return e},extend:function(n,e,t){return u(e,(function(e,r){n[r]=t&&"function"==typeof e?i(e,t):e})),n},trim:function(n){return n.replace(/^\s*/,"").replace(/\s*$/,"")}}},function(n,e,t){var i=t(6),r=t(28),s=t(11),o=t(19),a=t(42),l=function(n,e,t){var u,c,d,m,p=n&l.F,h=n&l.G,f=n&l.S,g=n&l.P,v=n&l.B,b=h?i:f?i[e]||(i[e]={}):(i[e]||{}).prototype,x=h?r:r[e]||(r[e]={}),w=x.prototype||(x.prototype={});for(u in h&&(t=e),t)d=((c=!p&&b&&void 0!==b[u])?b:t)[u],m=v&&c?a(d,i):g&&"function"==typeof d?a(Function.call,d):d,b&&o(b,u,d,n&l.U),x[u]!=d&&s(x,u,m),g&&w[u]!=d&&(w[u]=d)};i.core=r,l.F=1,l.G=2,l.S=4,l.P=8,l.B=16,l.W=32,l.U=64,l.R=128,n.exports=l},function(n,e,t){n.exports=t(155)},function(n,e){var t=n.exports="undefined"!=typeof window&&window.Math==Math?window:"undefined"!=typeof self&&self.Math==Math?self:Function("return this")();"number"==typeof __g&&(__g=t)},function(n,e,t){var i=t(45)("wks"),r=t(46),s=t(6).Symbol,o="function"==typeof s;(n.exports=function(n){return i[n]||(i[n]=o&&s[n]||(o?s:r)("Symbol."+n))}).store=i},function(n,e,t){n.exports=!t(9)((function(){return 7!=Object.defineProperty({},"a",{get:function(){return 7}}).a}))},function(n,e){n.exports=function(n){try{return!!n()}catch(n){return!0}}},function(n,e,t){var i=t(14);n.exports=function(n){if(!i(n))throw TypeError(n+" is not an object!");return n}},function(n,e,t){var i=t(13),r=t(27);n.exports=t(8)?function(n,e,t){return i.f(n,e,r(1,t))}:function(n,e,t){return n[e]=t,n}},function(n,e,t){var i=t(141),r=t(75),s=/[T ]/,o=/:/,a=/^(\d{2})$/,l=[/^([+-]\d{2})$/,/^([+-]\d{3})$/,/^([+-]\d{4})$/],u=/^(\d{4})/,c=[/^([+-]\d{4})/,/^([+-]\d{5})/,/^([+-]\d{6})/],d=/^-(\d{2})$/,m=/^-?(\d{3})$/,p=/^-?(\d{2})-?(\d{2})$/,h=/^-?W(\d{2})$/,f=/^-?W(\d{2})-?(\d{1})$/,g=/^(\d{2}([.,]\d*)?)$/,v=/^(\d{2}):?(\d{2}([.,]\d*)?)$/,b=/^(\d{2}):?(\d{2}):?(\d{2}([.,]\d*)?)$/,x=/([Z+-].*)$/,w=/^(Z)$/,E=/^([+-])(\d{2})$/,y=/^([+-])(\d{2}):?(\d{2})$/;function k(n,e,t){e=e||0,t=t||0;var i=new Date(0);i.setUTCFullYear(n,0,4);var r=7*e+t+1-(i.getUTCDay()||7);return i.setUTCDate(i.getUTCDate()+r),i}n.exports=function(n,e){if(r(n))return new Date(n.getTime());if("string"!=typeof n)return new Date(n);var t=(e||{}).additionalDigits;t=null==t?2:Number(t);var A=function(n){var e,t={},i=n.split(s);o.test(i[0])?(t.date=null,e=i[0]):(t.date=i[0],e=i[1]);if(e){var r=x.exec(e);r?(t.time=e.replace(r[1],""),t.timezone=r[1]):t.time=e}return t}(n),j=function(n,e){var t,i=l[e],r=c[e];if(t=u.exec(n)||r.exec(n)){var s=t[1];return{year:parseInt(s,10),restDateString:n.slice(s.length)}}if(t=a.exec(n)||i.exec(n)){var o=t[1];return{year:100*parseInt(o,10),restDateString:n.slice(o.length)}}return{year:null}}(A.date,t),_=j.year,N=function(n,e){if(null===e)return null;var t,i,r,s;if(0===n.length)return(i=new Date(0)).setUTCFullYear(e),i;if(t=d.exec(n))return i=new Date(0),r=parseInt(t[1],10)-1,i.setUTCFullYear(e,r),i;if(t=m.exec(n)){i=new Date(0);var o=parseInt(t[1],10);return i.setUTCFullYear(e,0,o),i}if(t=p.exec(n)){i=new Date(0),r=parseInt(t[1],10)-1;var a=parseInt(t[2],10);return i.setUTCFullYear(e,r,a),i}if(t=h.exec(n))return s=parseInt(t[1],10)-1,k(e,s);if(t=f.exec(n)){s=parseInt(t[1],10)-1;var l=parseInt(t[2],10)-1;return k(e,s,l)}return null}(j.restDateString,_);if(N){var O,B=N.getTime(),S=0;if(A.time&&(S=function(n){var e,t,i;if(e=g.exec(n))return(t=parseFloat(e[1].replace(",",".")))%24*36e5;if(e=v.exec(n))return t=parseInt(e[1],10),i=parseFloat(e[2].replace(",",".")),t%24*36e5+6e4*i;if(e=b.exec(n)){t=parseInt(e[1],10),i=parseInt(e[2],10);var r=parseFloat(e[3].replace(",","."));return t%24*36e5+6e4*i+1e3*r}return null}(A.time)),A.timezone)O=6e4*function(n){var e,t;if(e=w.exec(n))return 0;if(e=E.exec(n))return t=60*parseInt(e[2],10),"+"===e[1]?-t:t;if(e=y.exec(n))return t=60*parseInt(e[2],10)+parseInt(e[3],10),"+"===e[1]?-t:t;return 0}(A.timezone);else{var I=B+S,L=new Date(I);O=i(L);var C=new Date(I);C.setDate(L.getDate()+1);var T=i(C)-i(L);T>0&&(O+=T)}return new Date(B+S+O)}return new Date(n)}},function(n,e,t){var i=t(10),r=t(67),s=t(41),o=Object.defineProperty;e.f=t(8)?Object.defineProperty:function(n,e,t){if(i(n),e=s(e,!0),i(t),r)try{return o(n,e,t)}catch(n){}if("get"in t||"set"in t)throw TypeError("Accessors not supported!");return"value"in t&&(n[e]=t.value),n}},function(n,e){n.exports=function(n){return"object"==typeof n?null!==n:"function"==typeof n}},function(n,e){var t={}.hasOwnProperty;n.exports=function(n,e){return t.call(n,e)}},function(n,e,t){"use strict";var i=t(1);e.a=new i.a},function(n,e){n.exports=function(n){if(null==n)throw TypeError("Can't call method on  "+n);return n}},function(n,e,t){var i=t(66),r=t(17);n.exports=function(n){return i(r(n))}},function(n,e,t){var i=t(6),r=t(11),s=t(15),o=t(46)("src"),a=t(118),l=(""+a).split("toString");t(28).inspectSource=function(n){return a.call(n)},(n.exports=function(n,e,t,a){var u="function"==typeof t;u&&(s(t,"name")||r(t,"name",e)),n[e]!==t&&(u&&(s(t,o)||r(t,o,n[e]?""+n[e]:l.join(String(e)))),n===i?n[e]=t:a?n[e]?n[e]=t:r(n,e,t):(delete n[e],r(n,e,t)))})(Function.prototype,"toString",(function(){return"function"==typeof this&&this[o]||a.call(this)}))},function(n,e,t){"use strict";t.d(e,"a",(function(){return r})),t.d(e,"c",(function(){return s})),t.d(e,"b",(function(){return o}));var i=t(21);function r(n,e){return n=n.filter(n=>{const{title:t,frontmatter:{home:i,date:r,publish:s}}=n;return!0===e?!(1==i||null==t||void 0===r||!1===s):!(1==i||null==t||!1===s)})}function s(n){n.sort((n,e)=>{const t=n.frontmatter.sticky,r=e.frontmatter.sticky;return t&&r?t==r?Object(i.a)(n,e):t-r:t&&!r?-1:!t&&r?1:Object(i.a)(n,e)})}function o(n){n.sort((n,e)=>Object(i.a)(n,e))}},function(n,e,t){"use strict";t.d(e,"f",(function(){return i})),t.d(e,"b",(function(){return s})),t.d(e,"k",(function(){return o})),t.d(e,"h",(function(){return l})),t.d(e,"i",(function(){return u})),t.d(e,"j",(function(){return c})),t.d(e,"c",(function(){return d})),t.d(e,"g",(function(){return m})),t.d(e,"m",(function(){return p})),t.d(e,"n",(function(){return h})),t.d(e,"e",(function(){return f})),t.d(e,"l",(function(){return g})),t.d(e,"d",(function(){return v})),t.d(e,"a",(function(){return x}));const i=/#.*$/,r=/\.(md|html)$/,s=/\/$/,o=/^(https?:|mailto:|tel:)/;function a(n){return decodeURI(n).replace(i,"").replace(r,"")}function l(n){return o.test(n)}function u(n){return/^mailto:/.test(n)}function c(n){return/^tel:/.test(n)}function d(n){if(l(n))return n;const e=n.match(i),t=e?e[0]:"",r=a(n);return s.test(r)?n:r+".html"+t}function m(n,e){const t=n.hash,r=function(n){const e=n.match(i);if(e)return e[0]}(e);return(!r||t===r)&&a(n.path)===a(e)}function p(n,e,t){t&&(e=function(n,e,t){const i=n.charAt(0);if("/"===i)return n;if("?"===i||"#"===i)return e+n;const r=e.split("/");t&&r[r.length-1]||r.pop();const s=n.replace(/^\//,"").split("/");for(let n=0;n<s.length;n++){const e=s[n];".."===e?r.pop():"."!==e&&r.push(e)}""!==r[0]&&r.unshift("");return r.join("/")}(e,t));const i=a(e);for(let e=0;e<n.length;e++)if(a(n[e].regularPath)===i)return Object.assign({},n[e],{type:"page",path:d(n[e].path)});return console.error(`[vuepress] No matching page found for sidebar item "${e}"`),{}}function h(n,e,t,i){const{pages:r,themeConfig:s}=t,o=i&&s.locales&&s.locales[i]||s;if("auto"===(n.frontmatter.sidebar||o.sidebar||s.sidebar))return function(n){const e=f(n.headers||[]);return[{type:"group",collapsable:!1,title:n.title,path:null,children:e.map(e=>({type:"auto",title:e.title,basePath:n.path,path:n.path+"#"+e.slug,children:e.children||[]}))}]}(n);const a=o.sidebar||s.sidebar;if(a){const{base:n,config:t}=function(n,e){if(Array.isArray(e))return{base:"/",config:e};for(const i in e)if(0===(t=n,/(\.html|\/)$/.test(t)?t:t+"/").indexOf(encodeURI(i)))return{base:i,config:e[i]};var t;return{}}(e,a);return t?t.map(e=>function n(e,t,i,r=1){if("string"==typeof e)return p(t,e,i);if(Array.isArray(e))return Object.assign(p(t,e[0],i),{title:e[1]});{r>3&&console.error("[vuepress] detected a too deep nested sidebar group.");const s=e.children||[];return 0===s.length&&e.path?Object.assign(p(t,e.path,i),{title:e.title}):{type:"group",path:e.path,title:e.title,sidebarDepth:e.sidebarDepth,children:s.map(e=>n(e,t,i,r+1)),collapsable:!1!==e.collapsable}}}(e,r,n)):[]}return[]}function f(n){let e;return(n=n.map(n=>Object.assign({},n))).forEach(n=>{2===n.level?e=n:e&&(e.children||(e.children=[])).push(n)}),n.filter(n=>2===n.level)}function g(n){return Object.assign(n,{type:n.items&&n.items.length?"links":"link"})}function v(n,e="yyyy-MM-dd hh:mm:ss"){n=n.replace(/-/g,"/");const t=new Date(n);/(y+)/.test(e)&&(e=e.replace(RegExp.$1,t.getFullYear()+"").substr(4-RegExp.$1.length));const i={"M+":t.getMonth()+1,"d+":t.getDate(),"h+":t.getHours(),"m+":t.getMinutes(),"s+":t.getSeconds()};for(const n in i)if(RegExp(`(${n})`).test(e)){const t=i[n]+"";e=e.replace(RegExp.$1,2===t.length?t:"0"+t)}return e}function b(n){return new Date(n.frontmatter.date).getTime()}function x(n,e){return b(e)-b(n)}},function(n,e,t){"use strict";t.d(e,"a",(function(){return s}));var i=t(85),r=t.n(i);function s(n,e,t){return e in n?r()(n,e,{value:t,enumerable:!0,configurable:!0,writable:!0}):n[e]=t,n}},function(n,e,t){n.exports=!t(74)((function(){return 7!=Object.defineProperty({},"a",{get:function(){return 7}}).a}))},function(n,e){var t={}.toString;n.exports=function(n){return t.call(n).slice(8,-1)}},function(n,e){var t=Math.ceil,i=Math.floor;n.exports=function(n){return isNaN(n=+n)?0:(n>0?i:t)(n)}},function(n,e,t){var i=t(17);n.exports=function(n){return Object(i(n))}},function(n,e){n.exports=function(n,e){return{enumerable:!(1&n),configurable:!(2&n),writable:!(4&n),value:e}}},function(n,e){var t=n.exports={version:"2.6.10"};"number"==typeof __e&&(__e=t)},function(n,e,t){},function(n,e,t){},function(n,e,t){},function(n,e,t){},function(n,e,t){},function(n,e,t){},function(n,e,t){},function(n,e,t){var i,r;
/* NProgress, (c) 2013, 2014 Rico Sta. Cruz - http://ricostacruz.com/nprogress
 * @license MIT */void 0===(r="function"==typeof(i=function(){var n,e,t={version:"0.2.0"},i=t.settings={minimum:.08,easing:"ease",positionUsing:"",speed:200,trickle:!0,trickleRate:.02,trickleSpeed:800,showSpinner:!0,barSelector:'[role="bar"]',spinnerSelector:'[role="spinner"]',parent:"body",template:'<div class="bar" role="bar"><div class="peg"></div></div><div class="spinner" role="spinner"><div class="spinner-icon"></div></div>'};function r(n,e,t){return n<e?e:n>t?t:n}function s(n){return 100*(-1+n)}t.configure=function(n){var e,t;for(e in n)void 0!==(t=n[e])&&n.hasOwnProperty(e)&&(i[e]=t);return this},t.status=null,t.set=function(n){var e=t.isStarted();n=r(n,i.minimum,1),t.status=1===n?null:n;var l=t.render(!e),u=l.querySelector(i.barSelector),c=i.speed,d=i.easing;return l.offsetWidth,o((function(e){""===i.positionUsing&&(i.positionUsing=t.getPositioningCSS()),a(u,function(n,e,t){var r;return(r="translate3d"===i.positionUsing?{transform:"translate3d("+s(n)+"%,0,0)"}:"translate"===i.positionUsing?{transform:"translate("+s(n)+"%,0)"}:{"margin-left":s(n)+"%"}).transition="all "+e+"ms "+t,r}(n,c,d)),1===n?(a(l,{transition:"none",opacity:1}),l.offsetWidth,setTimeout((function(){a(l,{transition:"all "+c+"ms linear",opacity:0}),setTimeout((function(){t.remove(),e()}),c)}),c)):setTimeout(e,c)})),this},t.isStarted=function(){return"number"==typeof t.status},t.start=function(){t.status||t.set(0);var n=function(){setTimeout((function(){t.status&&(t.trickle(),n())}),i.trickleSpeed)};return i.trickle&&n(),this},t.done=function(n){return n||t.status?t.inc(.3+.5*Math.random()).set(1):this},t.inc=function(n){var e=t.status;return e?("number"!=typeof n&&(n=(1-e)*r(Math.random()*e,.1,.95)),e=r(e+n,0,.994),t.set(e)):t.start()},t.trickle=function(){return t.inc(Math.random()*i.trickleRate)},n=0,e=0,t.promise=function(i){return i&&"resolved"!==i.state()?(0===e&&t.start(),n++,e++,i.always((function(){0==--e?(n=0,t.done()):t.set((n-e)/n)})),this):this},t.render=function(n){if(t.isRendered())return document.getElementById("nprogress");u(document.documentElement,"nprogress-busy");var e=document.createElement("div");e.id="nprogress",e.innerHTML=i.template;var r,o=e.querySelector(i.barSelector),l=n?"-100":s(t.status||0),c=document.querySelector(i.parent);return a(o,{transition:"all 0 linear",transform:"translate3d("+l+"%,0,0)"}),i.showSpinner||(r=e.querySelector(i.spinnerSelector))&&m(r),c!=document.body&&u(c,"nprogress-custom-parent"),c.appendChild(e),e},t.remove=function(){c(document.documentElement,"nprogress-busy"),c(document.querySelector(i.parent),"nprogress-custom-parent");var n=document.getElementById("nprogress");n&&m(n)},t.isRendered=function(){return!!document.getElementById("nprogress")},t.getPositioningCSS=function(){var n=document.body.style,e="WebkitTransform"in n?"Webkit":"MozTransform"in n?"Moz":"msTransform"in n?"ms":"OTransform"in n?"O":"";return e+"Perspective"in n?"translate3d":e+"Transform"in n?"translate":"margin"};var o=function(){var n=[];function e(){var t=n.shift();t&&t(e)}return function(t){n.push(t),1==n.length&&e()}}(),a=function(){var n=["Webkit","O","Moz","ms"],e={};function t(t){return t=t.replace(/^-ms-/,"ms-").replace(/-([\da-z])/gi,(function(n,e){return e.toUpperCase()})),e[t]||(e[t]=function(e){var t=document.body.style;if(e in t)return e;for(var i,r=n.length,s=e.charAt(0).toUpperCase()+e.slice(1);r--;)if((i=n[r]+s)in t)return i;return e}(t))}function i(n,e,i){e=t(e),n.style[e]=i}return function(n,e){var t,r,s=arguments;if(2==s.length)for(t in e)void 0!==(r=e[t])&&e.hasOwnProperty(t)&&i(n,t,r);else i(n,s[1],s[2])}}();function l(n,e){return("string"==typeof n?n:d(n)).indexOf(" "+e+" ")>=0}function u(n,e){var t=d(n),i=t+e;l(t,e)||(n.className=i.substring(1))}function c(n,e){var t,i=d(n);l(n,e)&&(t=i.replace(" "+e+" "," "),n.className=t.substring(1,t.length-1))}function d(n){return(" "+(n.className||"")+" ").replace(/\s+/gi," ")}function m(n){n&&n.parentNode&&n.parentNode.removeChild(n)}return t})?i.call(e,t,e,n):i)||(n.exports=r)},function(n,e,t){"use strict";var i=t(153),r=t(154),s=t(78);n.exports={formats:s,parse:r,stringify:i}},function(n,e,t){var i=t(25),r=Math.min;n.exports=function(n){return n>0?r(i(n),9007199254740991):0}},function(n,e,t){"use strict";var i=t(9);n.exports=function(n,e){return!!n&&i((function(){e?n.call(null,(function(){}),1):n.call(null)}))}},function(n,e){n.exports=function(n){return"object"==typeof n?null!==n:"function"==typeof n}},function(n,e,t){var i=t(14);n.exports=function(n,e){if(!i(n))return n;var t,r;if(e&&"function"==typeof(t=n.toString)&&!i(r=t.call(n)))return r;if("function"==typeof(t=n.valueOf)&&!i(r=t.call(n)))return r;if(!e&&"function"==typeof(t=n.toString)&&!i(r=t.call(n)))return r;throw TypeError("Can't convert object to primitive value")}},function(n,e,t){var i=t(104);n.exports=function(n,e,t){if(i(n),void 0===e)return n;switch(t){case 1:return function(t){return n.call(e,t)};case 2:return function(t,i){return n.call(e,t,i)};case 3:return function(t,i,r){return n.call(e,t,i,r)}}return function(){return n.apply(e,arguments)}}},function(n,e,t){var i=t(116),r=t(27),s=t(18),o=t(41),a=t(15),l=t(67),u=Object.getOwnPropertyDescriptor;e.f=t(8)?u:function(n,e){if(n=s(n),e=o(e,!0),l)try{return u(n,e)}catch(n){}if(a(n,e))return r(!i.f.call(n,e),n[e])}},function(n,e,t){var i=t(45)("keys"),r=t(46);n.exports=function(n){return i[n]||(i[n]=r(n))}},function(n,e,t){var i=t(28),r=t(6),s=r["__core-js_shared__"]||(r["__core-js_shared__"]={});(n.exports=function(n,e){return s[n]||(s[n]=void 0!==e?e:{})})("versions",[]).push({version:i.version,mode:t(70)?"pure":"global",copyright:"© 2019 Denis Pushkarev (zloirock.ru)"})},function(n,e){var t=0,i=Math.random();n.exports=function(n){return"Symbol(".concat(void 0===n?"":n,")_",(++t+i).toString(36))}},function(n,e){n.exports="constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf".split(",")},function(n,e,t){var i=t(69),r=t(47);n.exports=Object.keys||function(n){return i(n,r)}},function(n,e){n.exports={}},function(n,e,t){var i=t(146);n.exports=function(n){return i(n,{weekStartsOn:1})}},function(n,e,t){"use strict";var i=t(3),r=t(157),s={"Content-Type":"application/x-www-form-urlencoded"};function o(n,e){!i.isUndefined(n)&&i.isUndefined(n["Content-Type"])&&(n["Content-Type"]=e)}var a,l={adapter:("undefined"!=typeof XMLHttpRequest?a=t(80):"undefined"!=typeof process&&(a=t(80)),a),transformRequest:[function(n,e){return r(e,"Content-Type"),i.isFormData(n)||i.isArrayBuffer(n)||i.isBuffer(n)||i.isStream(n)||i.isFile(n)||i.isBlob(n)?n:i.isArrayBufferView(n)?n.buffer:i.isURLSearchParams(n)?(o(e,"application/x-www-form-urlencoded;charset=utf-8"),n.toString()):i.isObject(n)?(o(e,"application/json;charset=utf-8"),JSON.stringify(n)):n}],transformResponse:[function(n){if("string"==typeof n)try{n=JSON.parse(n)}catch(n){}return n}],timeout:0,xsrfCookieName:"XSRF-TOKEN",xsrfHeaderName:"X-XSRF-TOKEN",maxContentLength:-1,validateStatus:function(n){return n>=200&&n<300}};l.headers={common:{Accept:"application/json, text/plain, */*"}},i.forEach(["delete","get","head"],(function(n){l.headers[n]={}})),i.forEach(["post","put","patch"],(function(n){l.headers[n]=i.merge(s)})),n.exports=l},function(n,e,t){"use strict";var i=t(4),r=t(62)(2);i(i.P+i.F*!t(39)([].filter,!0),"Array",{filter:function(n){return r(this,n,arguments[1])}})},function(n,e,t){for(var i=t(127),r=t(48),s=t(19),o=t(6),a=t(11),l=t(49),u=t(7),c=u("iterator"),d=u("toStringTag"),m=l.Array,p={CSSRuleList:!0,CSSStyleDeclaration:!1,CSSValueList:!1,ClientRectList:!1,DOMRectList:!1,DOMStringList:!1,DOMTokenList:!0,DataTransferItemList:!1,FileList:!1,HTMLAllCollection:!1,HTMLCollection:!1,HTMLFormElement:!1,HTMLSelectElement:!1,MediaList:!0,MimeTypeArray:!1,NamedNodeMap:!1,NodeList:!0,PaintRequestList:!1,Plugin:!1,PluginArray:!1,SVGLengthList:!1,SVGNumberList:!1,SVGPathSegList:!1,SVGPointList:!1,SVGStringList:!1,SVGTransformList:!1,SourceBufferList:!1,StyleSheetList:!0,TextTrackCueList:!1,TextTrackList:!1,TouchList:!1},h=r(p),f=0;f<h.length;f++){var g,v=h[f],b=p[v],x=o[v],w=x&&x.prototype;if(w&&(w[c]||a(w,c,m),w[d]||a(w,d,v),l[v]=m,b))for(g in i)w[g]||s(w,g,i[g],!0)}},function(n,e){var t=n.exports="undefined"!=typeof window&&window.Math==Math?window:"undefined"!=typeof self&&self.Math==Math?self:Function("return this")();"number"==typeof __g&&(__g=t)},function(n,e){var t=n.exports={version:"2.6.10"};"number"==typeof __e&&(__e=t)},function(n,e,t){var i=t(26),r=t(48);t(132)("keys",(function(){return function(n){return r(i(n))}}))},function(n,e,t){var i=t(4);i(i.S+i.F*!t(8),"Object",{defineProperty:t(13).f})},function(n,e,t){var i=t(4);i(i.S+i.F*!t(8),"Object",{defineProperties:t(72)})},function(n,e,t){var i=t(4),r=t(122),s=t(18),o=t(43),a=t(124);i(i.S,"Object",{getOwnPropertyDescriptors:function(n){for(var e,t,i=s(n),l=o.f,u=r(i),c={},d=0;u.length>d;)void 0!==(t=l(i,e=u[d++]))&&a(c,e,t);return c}})},function(n,e,t){"use strict";var i=t(4),r=t(62)(0),s=t(39)([].forEach,!0);i(i.P+i.F*!s,"Array",{forEach:function(n){return r(this,n,arguments[1])}})},function(n,e,t){var i=t(90),r=t(135),s=t(136),o=Object.defineProperty;e.f=t(23)?Object.defineProperty:function(n,e,t){if(i(n),e=s(e,!0),i(t),r)try{return o(n,e,t)}catch(n){}if("get"in t||"set"in t)throw TypeError("Accessors not supported!");return"value"in t&&(n[e]=t.value),n}},function(n,e,t){var i=t(42),r=t(66),s=t(26),o=t(38),a=t(125);n.exports=function(n,e){var t=1==n,l=2==n,u=3==n,c=4==n,d=6==n,m=5==n||d,p=e||a;return function(e,a,h){for(var f,g,v=s(e),b=r(v),x=i(a,h,3),w=o(b.length),E=0,y=t?p(e,w):l?p(e,0):void 0;w>E;E++)if((m||E in b)&&(g=x(f=b[E],E,v),n))if(t)y[E]=g;else if(g)switch(n){case 3:return!0;case 5:return f;case 6:return E;case 2:y.push(f)}else if(c)return!1;return d?-1:u||c?c:y}}},function(n,e,t){var i=t(69),r=t(47).concat("length","prototype");e.f=Object.getOwnPropertyNames||function(n){return i(n,r)}},function(n,e,t){var i=t(18),r=t(38),s=t(117);n.exports=function(n){return function(e,t,o){var a,l=i(e),u=r(l.length),c=s(o,u);if(n&&t!=t){for(;u>c;)if((a=l[c++])!=a)return!0}else for(;u>c;c++)if((n||c in l)&&l[c]===t)return n||c||0;return!n&&-1}}},function(n,e,t){"use strict";var i,r,s=t(108),o=RegExp.prototype.exec,a=String.prototype.replace,l=o,u=(i=/a/,r=/b*/g,o.call(i,"a"),o.call(r,"a"),0!==i.lastIndex||0!==r.lastIndex),c=void 0!==/()??/.exec("")[1];(u||c)&&(l=function(n){var e,t,i,r,l=this;return c&&(t=new RegExp("^"+l.source+"$(?!\\s)",s.call(l))),u&&(e=l.lastIndex),i=o.call(l,n),u&&i&&(l.lastIndex=l.global?i.index+i[0].length:e),c&&i&&i.length>1&&a.call(i[0],t,(function(){for(r=1;r<arguments.length-2;r++)void 0===arguments[r]&&(i[r]=void 0)})),i}),n.exports=l},function(n,e,t){var i=t(24);n.exports=Object("z").propertyIsEnumerable(0)?Object:function(n){return"String"==i(n)?n.split(""):Object(n)}},function(n,e,t){n.exports=!t(8)&&!t(9)((function(){return 7!=Object.defineProperty(t(68)("div"),"a",{get:function(){return 7}}).a}))},function(n,e,t){var i=t(14),r=t(6).document,s=i(r)&&i(r.createElement);n.exports=function(n){return s?r.createElement(n):{}}},function(n,e,t){var i=t(15),r=t(18),s=t(64)(!1),o=t(44)("IE_PROTO");n.exports=function(n,e){var t,a=r(n),l=0,u=[];for(t in a)t!=o&&i(a,t)&&u.push(t);for(;e.length>l;)i(a,t=e[l++])&&(~s(u,t)||u.push(t));return u}},function(n,e){n.exports=!1},function(n,e,t){var i=t(10),r=t(72),s=t(47),o=t(44)("IE_PROTO"),a=function(){},l=function(){var n,e=t(68)("iframe"),i=s.length;for(e.style.display="none",t(120).appendChild(e),e.src="javascript:",(n=e.contentWindow.document).open(),n.write("<script>document.F=Object<\/script>"),n.close(),l=n.F;i--;)delete l.prototype[s[i]];return l()};n.exports=Object.create||function(n,e){var t;return null!==n?(a.prototype=i(n),t=new a,a.prototype=null,t[o]=n):t=l(),void 0===e?t:r(t,e)}},function(n,e,t){var i=t(13),r=t(10),s=t(48);n.exports=t(8)?Object.defineProperties:function(n,e){r(n);for(var t,o=s(e),a=o.length,l=0;a>l;)i.f(n,t=o[l++],e[t]);return n}},function(n,e,t){var i=t(13).f,r=t(15),s=t(7)("toStringTag");n.exports=function(n,e,t){n&&!r(n=t?n:n.prototype,s)&&i(n,s,{configurable:!0,value:e})}},function(n,e){n.exports=function(n){try{return!!n()}catch(n){return!0}}},function(n,e){n.exports=function(n){return n instanceof Date}},function(n,e,t){var i=t(12),r=t(50);n.exports=function(n){var e=i(n),t=e.getFullYear(),s=new Date(0);s.setFullYear(t+1,0,4),s.setHours(0,0,0,0);var o=r(s),a=new Date(0);a.setFullYear(t,0,4),a.setHours(0,0,0,0);var l=r(a);return e.getTime()>=o.getTime()?t+1:e.getTime()>=l.getTime()?t:t-1}},function(n,e,t){"use strict";var i=Object.prototype.hasOwnProperty,r=Array.isArray,s=function(){for(var n=[],e=0;e<256;++e)n.push("%"+((e<16?"0":"")+e.toString(16)).toUpperCase());return n}(),o=function(n,e){for(var t=e&&e.plainObjects?Object.create(null):{},i=0;i<n.length;++i)void 0!==n[i]&&(t[i]=n[i]);return t};n.exports={arrayToObject:o,assign:function(n,e){return Object.keys(e).reduce((function(n,t){return n[t]=e[t],n}),n)},combine:function(n,e){return[].concat(n,e)},compact:function(n){for(var e=[{obj:{o:n},prop:"o"}],t=[],i=0;i<e.length;++i)for(var s=e[i],o=s.obj[s.prop],a=Object.keys(o),l=0;l<a.length;++l){var u=a[l],c=o[u];"object"==typeof c&&null!==c&&-1===t.indexOf(c)&&(e.push({obj:o,prop:u}),t.push(c))}return function(n){for(;n.length>1;){var e=n.pop(),t=e.obj[e.prop];if(r(t)){for(var i=[],s=0;s<t.length;++s)void 0!==t[s]&&i.push(t[s]);e.obj[e.prop]=i}}}(e),n},decode:function(n,e,t){var i=n.replace(/\+/g," ");if("iso-8859-1"===t)return i.replace(/%[0-9a-f]{2}/gi,unescape);try{return decodeURIComponent(i)}catch(n){return i}},encode:function(n,e,t){if(0===n.length)return n;var i="string"==typeof n?n:String(n);if("iso-8859-1"===t)return escape(i).replace(/%u[0-9a-f]{4}/gi,(function(n){return"%26%23"+parseInt(n.slice(2),16)+"%3B"}));for(var r="",o=0;o<i.length;++o){var a=i.charCodeAt(o);45===a||46===a||95===a||126===a||a>=48&&a<=57||a>=65&&a<=90||a>=97&&a<=122?r+=i.charAt(o):a<128?r+=s[a]:a<2048?r+=s[192|a>>6]+s[128|63&a]:a<55296||a>=57344?r+=s[224|a>>12]+s[128|a>>6&63]+s[128|63&a]:(o+=1,a=65536+((1023&a)<<10|1023&i.charCodeAt(o)),r+=s[240|a>>18]+s[128|a>>12&63]+s[128|a>>6&63]+s[128|63&a])}return r},isBuffer:function(n){return!(!n||"object"!=typeof n)&&!!(n.constructor&&n.constructor.isBuffer&&n.constructor.isBuffer(n))},isRegExp:function(n){return"[object RegExp]"===Object.prototype.toString.call(n)},merge:function n(e,t,s){if(!t)return e;if("object"!=typeof t){if(r(e))e.push(t);else{if(!e||"object"!=typeof e)return[e,t];(s&&(s.plainObjects||s.allowPrototypes)||!i.call(Object.prototype,t))&&(e[t]=!0)}return e}if(!e||"object"!=typeof e)return[e].concat(t);var a=e;return r(e)&&!r(t)&&(a=o(e,s)),r(e)&&r(t)?(t.forEach((function(t,r){if(i.call(e,r)){var o=e[r];o&&"object"==typeof o&&t&&"object"==typeof t?e[r]=n(o,t,s):e.push(t)}else e[r]=t})),e):Object.keys(t).reduce((function(e,r){var o=t[r];return i.call(e,r)?e[r]=n(e[r],o,s):e[r]=o,e}),a)}}},function(n,e,t){"use strict";var i=String.prototype.replace,r=/%20/g;n.exports={default:"RFC3986",formatters:{RFC1738:function(n){return i.call(n,r,"+")},RFC3986:function(n){return n}},RFC1738:"RFC1738",RFC3986:"RFC3986"}},function(n,e,t){"use strict";n.exports=function(n,e){return function(){for(var t=new Array(arguments.length),i=0;i<t.length;i++)t[i]=arguments[i];return n.apply(e,t)}}},function(n,e,t){"use strict";var i=t(3),r=t(158),s=t(160),o=t(161),a=t(162),l=t(81);n.exports=function(n){return new Promise((function(e,u){var c=n.data,d=n.headers;i.isFormData(c)&&delete d["Content-Type"];var m=new XMLHttpRequest;if(n.auth){var p=n.auth.username||"",h=n.auth.password||"";d.Authorization="Basic "+btoa(p+":"+h)}if(m.open(n.method.toUpperCase(),s(n.url,n.params,n.paramsSerializer),!0),m.timeout=n.timeout,m.onreadystatechange=function(){if(m&&4===m.readyState&&(0!==m.status||m.responseURL&&0===m.responseURL.indexOf("file:"))){var t="getAllResponseHeaders"in m?o(m.getAllResponseHeaders()):null,i={data:n.responseType&&"text"!==n.responseType?m.response:m.responseText,status:m.status,statusText:m.statusText,headers:t,config:n,request:m};r(e,u,i),m=null}},m.onerror=function(){u(l("Network Error",n,null,m)),m=null},m.ontimeout=function(){u(l("timeout of "+n.timeout+"ms exceeded",n,"ECONNABORTED",m)),m=null},i.isStandardBrowserEnv()){var f=t(163),g=(n.withCredentials||a(n.url))&&n.xsrfCookieName?f.read(n.xsrfCookieName):void 0;g&&(d[n.xsrfHeaderName]=g)}if("setRequestHeader"in m&&i.forEach(d,(function(n,e){void 0===c&&"content-type"===e.toLowerCase()?delete d[e]:m.setRequestHeader(e,n)})),n.withCredentials&&(m.withCredentials=!0),n.responseType)try{m.responseType=n.responseType}catch(e){if("json"!==n.responseType)throw e}"function"==typeof n.onDownloadProgress&&m.addEventListener("progress",n.onDownloadProgress),"function"==typeof n.onUploadProgress&&m.upload&&m.upload.addEventListener("progress",n.onUploadProgress),n.cancelToken&&n.cancelToken.promise.then((function(n){m&&(m.abort(),u(n),m=null)})),void 0===c&&(c=null),m.send(c)}))}},function(n,e,t){"use strict";var i=t(159);n.exports=function(n,e,t,r,s){var o=new Error(n);return i(o,e,t,r,s)}},function(n,e,t){"use strict";n.exports=function(n){return!(!n||!n.__CANCEL__)}},function(n,e,t){"use strict";function i(n){this.message=n}i.prototype.toString=function(){return"Cancel"+(this.message?": "+this.message:"")},i.prototype.__CANCEL__=!0,n.exports=i},function(n,e){var t=/^\s+|\s+$/g,i=/^[-+]0x[0-9a-f]+$/i,r=/^0b[01]+$/i,s=/^0o[0-7]+$/i,o=parseInt,a="object"==typeof global&&global&&global.Object===Object&&global,l="object"==typeof self&&self&&self.Object===Object&&self,u=a||l||Function("return this")(),c=Object.prototype.toString,d=Math.max,m=Math.min,p=function(){return u.Date.now()};function h(n){var e=typeof n;return!!n&&("object"==e||"function"==e)}function f(n){if("number"==typeof n)return n;if(function(n){return"symbol"==typeof n||function(n){return!!n&&"object"==typeof n}(n)&&"[object Symbol]"==c.call(n)}(n))return NaN;if(h(n)){var e="function"==typeof n.valueOf?n.valueOf():n;n=h(e)?e+"":e}if("string"!=typeof n)return 0===n?n:+n;n=n.replace(t,"");var a=r.test(n);return a||s.test(n)?o(n.slice(2),a?2:8):i.test(n)?NaN:+n}n.exports=function(n,e,t){var i,r,s,o,a,l,u=0,c=!1,g=!1,v=!0;if("function"!=typeof n)throw new TypeError("Expected a function");function b(e){var t=i,s=r;return i=r=void 0,u=e,o=n.apply(s,t)}function x(n){return u=n,a=setTimeout(E,e),c?b(n):o}function w(n){var t=n-l;return void 0===l||t>=e||t<0||g&&n-u>=s}function E(){var n=p();if(w(n))return y(n);a=setTimeout(E,function(n){var t=e-(n-l);return g?m(t,s-(n-u)):t}(n))}function y(n){return a=void 0,v&&i?b(n):(i=r=void 0,o)}function k(){var n=p(),t=w(n);if(i=arguments,r=this,l=n,t){if(void 0===a)return x(l);if(g)return a=setTimeout(E,e),b(l)}return void 0===a&&(a=setTimeout(E,e)),o}return e=f(e)||0,h(t)&&(c=!!t.leading,s=(g="maxWait"in t)?d(f(t.maxWait)||0,e):s,v="trailing"in t?!!t.trailing:v),k.cancel=function(){void 0!==a&&clearTimeout(a),u=0,i=l=r=a=void 0},k.flush=function(){return void 0===a?o:y(p())},k}},function(n,e,t){n.exports=t(133)},function(n,e,t){var i=t(140),r=t(145),s=t(76),o=t(12),a=t(148),l=t(149);var u={M:function(n){return n.getMonth()+1},MM:function(n){return m(n.getMonth()+1,2)},Q:function(n){return Math.ceil((n.getMonth()+1)/3)},D:function(n){return n.getDate()},DD:function(n){return m(n.getDate(),2)},DDD:function(n){return i(n)},DDDD:function(n){return m(i(n),3)},d:function(n){return n.getDay()},E:function(n){return n.getDay()||7},W:function(n){return r(n)},WW:function(n){return m(r(n),2)},YY:function(n){return m(n.getFullYear(),4).substr(2)},YYYY:function(n){return m(n.getFullYear(),4)},GG:function(n){return String(s(n)).substr(2)},GGGG:function(n){return s(n)},H:function(n){return n.getHours()},HH:function(n){return m(n.getHours(),2)},h:function(n){var e=n.getHours();return 0===e?12:e>12?e%12:e},hh:function(n){return m(u.h(n),2)},m:function(n){return n.getMinutes()},mm:function(n){return m(n.getMinutes(),2)},s:function(n){return n.getSeconds()},ss:function(n){return m(n.getSeconds(),2)},S:function(n){return Math.floor(n.getMilliseconds()/100)},SS:function(n){return m(Math.floor(n.getMilliseconds()/10),2)},SSS:function(n){return m(n.getMilliseconds(),3)},Z:function(n){return d(n.getTimezoneOffset(),":")},ZZ:function(n){return d(n.getTimezoneOffset())},X:function(n){return Math.floor(n.getTime()/1e3)},x:function(n){return n.getTime()}};function c(n){return n.match(/\[[\s\S]/)?n.replace(/^\[|]$/g,""):n.replace(/\\/g,"")}function d(n,e){e=e||"";var t=n>0?"-":"+",i=Math.abs(n),r=i%60;return t+m(Math.floor(i/60),2)+e+m(r,2)}function m(n,e){for(var t=Math.abs(n).toString();t.length<e;)t="0"+t;return t}n.exports=function(n,e,t){var i=e?String(e):"YYYY-MM-DDTHH:mm:ss.SSSZ",r=(t||{}).locale,s=l.format.formatters,d=l.format.formattingTokensRegExp;r&&r.format&&r.format.formatters&&(s=r.format.formatters,r.format.formattingTokensRegExp&&(d=r.format.formattingTokensRegExp));var m=o(n);return a(m)?function(n,e,t){var i,r,s=n.match(t),o=s.length;for(i=0;i<o;i++)r=e[s[i]]||u[s[i]],s[i]=r||c(s[i]);return function(n){for(var e="",t=0;t<o;t++)s[t]instanceof Function?e+=s[t](n,u):e+=s[t];return e}}(i,s,d)(m):"Invalid Date"}},function(n,e,t){function i(){var n;try{n=e.storage.debug}catch(n){}return!n&&"undefined"!=typeof process&&"env"in process&&(n=process.env.DEBUG),n}(e=n.exports=t(174)).log=function(){return"object"==typeof console&&console.log&&Function.prototype.apply.call(console.log,console,arguments)},e.formatArgs=function(n){var t=this.useColors;if(n[0]=(t?"%c":"")+this.namespace+(t?" %c":" ")+n[0]+(t?"%c ":" ")+"+"+e.humanize(this.diff),!t)return;var i="color: "+this.color;n.splice(1,0,i,"color: inherit");var r=0,s=0;n[0].replace(/%[a-zA-Z%]/g,(function(n){"%%"!==n&&(r++,"%c"===n&&(s=r))})),n.splice(s,0,i)},e.save=function(n){try{null==n?e.storage.removeItem("debug"):e.storage.debug=n}catch(n){}},e.load=i,e.useColors=function(){if("undefined"!=typeof window&&window.process&&"renderer"===window.process.type)return!0;return"undefined"!=typeof document&&document.documentElement&&document.documentElement.style&&document.documentElement.style.WebkitAppearance||"undefined"!=typeof window&&window.console&&(window.console.firebug||window.console.exception&&window.console.table)||"undefined"!=typeof navigator&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)&&parseInt(RegExp.$1,10)>=31||"undefined"!=typeof navigator&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/)},e.storage="undefined"!=typeof chrome&&void 0!==chrome.storage?chrome.storage.local:function(){try{return window.localStorage}catch(n){}}(),e.colors=["lightseagreen","forestgreen","goldenrod","dodgerblue","darkorchid","crimson"],e.formatters.j=function(n){try{return JSON.stringify(n)}catch(n){return"[UnexpectedJSONParseError]: "+n.message}},e.enable(i())},function(n,e,t){"use strict";var i=t(4),r=t(64)(!1),s=[].indexOf,o=!!s&&1/[1].indexOf(1,-0)<0;i(i.P+i.F*(o||!t(39)(s)),"Array",{indexOf:function(n){return o?s.apply(this,arguments)||0:r(this,n,arguments[1])}})},function(n,e,t){var i=t(54),r=t(55),s=t(93),o=t(92),a=t(96),l=function(n,e,t){var u,c,d,m=n&l.F,p=n&l.G,h=n&l.S,f=n&l.P,g=n&l.B,v=n&l.W,b=p?r:r[e]||(r[e]={}),x=b.prototype,w=p?i:h?i[e]:(i[e]||{}).prototype;for(u in p&&(t=e),t)(c=!m&&w&&void 0!==w[u])&&a(b,u)||(d=c?w[u]:t[u],b[u]=p&&"function"!=typeof w[u]?t[u]:g&&c?s(d,i):v&&w[u]==d?function(n){var e=function(e,t,i){if(this instanceof n){switch(arguments.length){case 0:return new n;case 1:return new n(e);case 2:return new n(e,t)}return new n(e,t,i)}return n.apply(this,arguments)};return e.prototype=n.prototype,e}(d):f&&"function"==typeof d?s(Function.call,d):d,f&&((b.virtual||(b.virtual={}))[u]=d,n&l.R&&x&&!x[u]&&o(x,u,d)))};l.F=1,l.G=2,l.S=4,l.P=8,l.B=16,l.W=32,l.U=64,l.R=128,n.exports=l},function(n,e,t){var i=t(40);n.exports=function(n){if(!i(n))throw TypeError(n+" is not an object!");return n}},function(n,e,t){"use strict";var i=t(10),r=t(26),s=t(38),o=t(25),a=t(102),l=t(97),u=Math.max,c=Math.min,d=Math.floor,m=/\$([$&`']|\d\d?|<[^>]*>)/g,p=/\$([$&`']|\d\d?)/g;t(98)("replace",2,(function(n,e,t,h){return[function(i,r){var s=n(this),o=null==i?void 0:i[e];return void 0!==o?o.call(i,s,r):t.call(String(s),i,r)},function(n,e){var r=h(t,n,this,e);if(r.done)return r.value;var d=i(n),m=String(this),p="function"==typeof e;p||(e=String(e));var g=d.global;if(g){var v=d.unicode;d.lastIndex=0}for(var b=[];;){var x=l(d,m);if(null===x)break;if(b.push(x),!g)break;""===String(x[0])&&(d.lastIndex=a(m,s(d.lastIndex),v))}for(var w,E="",y=0,k=0;k<b.length;k++){x=b[k];for(var A=String(x[0]),j=u(c(o(x.index),m.length),0),_=[],N=1;N<x.length;N++)_.push(void 0===(w=x[N])?w:String(w));var O=x.groups;if(p){var B=[A].concat(_,j,m);void 0!==O&&B.push(O);var S=String(e.apply(void 0,B))}else S=f(A,m,j,_,O,e);j>=y&&(E+=m.slice(y,j)+S,y=j+A.length)}return E+m.slice(y)}];function f(n,e,i,s,o,a){var l=i+n.length,u=s.length,c=p;return void 0!==o&&(o=r(o),c=m),t.call(a,c,(function(t,r){var a;switch(r.charAt(0)){case"$":return"$";case"&":return n;case"`":return e.slice(0,i);case"'":return e.slice(l);case"<":a=o[r.slice(1,-1)];break;default:var c=+r;if(0===c)return t;if(c>u){var m=d(c/10);return 0===m?t:m<=u?void 0===s[m-1]?r.charAt(1):s[m-1]+r.charAt(1):t}a=s[c-1]}return void 0===a?"":a}))}}))},function(n,e,t){var i=t(61),r=t(101);n.exports=t(23)?function(n,e,t){return i.f(n,e,r(1,t))}:function(n,e,t){return n[e]=t,n}},function(n,e,t){var i=t(95);n.exports=function(n,e,t){if(i(n),void 0===e)return n;switch(t){case 1:return function(t){return n.call(e,t)};case 2:return function(t,i){return n.call(e,t,i)};case 3:return function(t,i,r){return n.call(e,t,i,r)}}return function(){return n.apply(e,arguments)}}},function(n,e,t){"use strict";var i=t(6),r=t(15),s=t(24),o=t(103),a=t(41),l=t(9),u=t(63).f,c=t(43).f,d=t(13).f,m=t(105).trim,p=i.Number,h=p,f=p.prototype,g="Number"==s(t(71)(f)),v="trim"in String.prototype,b=function(n){var e=a(n,!1);if("string"==typeof e&&e.length>2){var t,i,r,s=(e=v?e.trim():m(e,3)).charCodeAt(0);if(43===s||45===s){if(88===(t=e.charCodeAt(2))||120===t)return NaN}else if(48===s){switch(e.charCodeAt(1)){case 66:case 98:i=2,r=49;break;case 79:case 111:i=8,r=55;break;default:return+e}for(var o,l=e.slice(2),u=0,c=l.length;u<c;u++)if((o=l.charCodeAt(u))<48||o>r)return NaN;return parseInt(l,i)}}return+e};if(!p(" 0o1")||!p("0b1")||p("+0x1")){p=function(n){var e=arguments.length<1?0:n,t=this;return t instanceof p&&(g?l((function(){f.valueOf.call(t)})):"Number"!=s(t))?o(new h(b(e)),t,p):b(e)};for(var x,w=t(8)?u(h):"MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger".split(","),E=0;w.length>E;E++)r(h,x=w[E])&&!r(p,x)&&d(p,x,c(h,x));p.prototype=f,f.constructor=p,t(19)(i,"Number",p)}},function(n,e){n.exports=function(n){if("function"!=typeof n)throw TypeError(n+" is not a function!");return n}},function(n,e){var t={}.hasOwnProperty;n.exports=function(n,e){return t.call(n,e)}},function(n,e,t){"use strict";var i=t(179),r=RegExp.prototype.exec;n.exports=function(n,e){var t=n.exec;if("function"==typeof t){var s=t.call(n,e);if("object"!=typeof s)throw new TypeError("RegExp exec method returned something other than an Object or null");return s}if("RegExp"!==i(n))throw new TypeError("RegExp#exec called on incompatible receiver");return r.call(n,e)}},function(n,e,t){"use strict";t(180);var i=t(19),r=t(11),s=t(9),o=t(17),a=t(7),l=t(65),u=a("species"),c=!s((function(){var n=/./;return n.exec=function(){var n=[];return n.groups={a:"7"},n},"7"!=="".replace(n,"$<a>")})),d=function(){var n=/(?:)/,e=n.exec;n.exec=function(){return e.apply(this,arguments)};var t="ab".split(n);return 2===t.length&&"a"===t[0]&&"b"===t[1]}();n.exports=function(n,e,t){var m=a(n),p=!s((function(){var e={};return e[m]=function(){return 7},7!=""[n](e)})),h=p?!s((function(){var e=!1,t=/a/;return t.exec=function(){return e=!0,null},"split"===n&&(t.constructor={},t.constructor[u]=function(){return t}),t[m](""),!e})):void 0;if(!p||!h||"replace"===n&&!c||"split"===n&&!d){var f=/./[m],g=t(o,m,""[n],(function(n,e,t,i,r){return e.exec===l?p&&!r?{done:!0,value:f.call(e,t,i)}:{done:!0,value:n.call(t,e,i)}:{done:!1}})),v=g[0],b=g[1];i(String.prototype,n,v),r(RegExp.prototype,m,2==e?function(n,e){return b.call(n,this,e)}:function(n){return b.call(n,this)})}}},function(n,e,t){var i=t(7)("unscopables"),r=Array.prototype;null==r[i]&&t(11)(r,i,{}),n.exports=function(n){r[i][n]=!0}},function(n,e,t){var i=t(40),r=t(54).document,s=i(r)&&i(r.createElement);n.exports=function(n){return s?r.createElement(n):{}}},function(n,e){n.exports=function(n,e){return{enumerable:!(1&n),configurable:!(2&n),writable:!(4&n),value:e}}},function(n,e,t){"use strict";var i=t(178)(!0);n.exports=function(n,e,t){return e+(t?i(n,e).length:1)}},function(n,e,t){var i=t(14),r=t(115).set;n.exports=function(n,e,t){var s,o=e.constructor;return o!==t&&"function"==typeof o&&(s=o.prototype)!==t.prototype&&i(s)&&r&&r(n,s),n}},function(n,e){n.exports=function(n){if("function"!=typeof n)throw TypeError(n+" is not a function!");return n}},function(n,e,t){var i=t(4),r=t(17),s=t(9),o=t(119),a="["+o+"]",l=RegExp("^"+a+a+"*"),u=RegExp(a+a+"*$"),c=function(n,e,t){var r={},a=s((function(){return!!o[n]()||"​"!="​"[n]()})),l=r[n]=a?e(d):o[n];t&&(r[t]=l),i(i.P+i.F*a,"String",r)},d=c.trim=function(n,e){return n=String(r(n)),1&e&&(n=n.replace(l,"")),2&e&&(n=n.replace(u,"")),n};n.exports=c},function(n,e,t){var i=t(24);n.exports=Array.isArray||function(n){return"Array"==i(n)}},function(n,e){function t(n){return!!n.constructor&&"function"==typeof n.constructor.isBuffer&&n.constructor.isBuffer(n)}
/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
n.exports=function(n){return null!=n&&(t(n)||function(n){return"function"==typeof n.readFloatLE&&"function"==typeof n.slice&&t(n.slice(0,0))}(n)||!!n._isBuffer)}},function(n,e,t){"use strict";var i=t(10);n.exports=function(){var n=i(this),e="";return n.global&&(e+="g"),n.ignoreCase&&(e+="i"),n.multiline&&(e+="m"),n.unicode&&(e+="u"),n.sticky&&(e+="y"),e}},function(n,e,t){n.exports=t(183)},function(n,e,t){},function(n,e,t){},function(n,e,t){Promise.all([t.e(0),t.e(189)]).then(t.t.bind(null,184,7))},function(n,e,t){"use strict";var i=t(29);t.n(i).a},function(n,e,t){"use strict";var i=t(30);t.n(i).a},function(n,e,t){var i=t(14),r=t(10),s=function(n,e){if(r(n),!i(e)&&null!==e)throw TypeError(e+": can't set as prototype!")};n.exports={set:Object.setPrototypeOf||("__proto__"in{}?function(n,e,i){try{(i=t(42)(Function.call,t(43).f(Object.prototype,"__proto__").set,2))(n,[]),e=!(n instanceof Array)}catch(n){e=!0}return function(n,t){return s(n,t),e?n.__proto__=t:i(n,t),n}}({},!1):void 0),check:s}},function(n,e){e.f={}.propertyIsEnumerable},function(n,e,t){var i=t(25),r=Math.max,s=Math.min;n.exports=function(n,e){return(n=i(n))<0?r(n+e,0):s(n,e)}},function(n,e,t){n.exports=t(45)("native-function-to-string",Function.toString)},function(n,e){n.exports="\t\n\v\f\r   ᠎             　\u2028\u2029\ufeff"},function(n,e,t){var i=t(6).document;n.exports=i&&i.documentElement},function(n,e,t){"use strict";var i=t(31);t.n(i).a},function(n,e,t){var i=t(63),r=t(123),s=t(10),o=t(6).Reflect;n.exports=o&&o.ownKeys||function(n){var e=i.f(s(n)),t=r.f;return t?e.concat(t(n)):e}},function(n,e){e.f=Object.getOwnPropertySymbols},function(n,e,t){"use strict";var i=t(13),r=t(27);n.exports=function(n,e,t){e in n?i.f(n,e,r(0,t)):n[e]=t}},function(n,e,t){var i=t(126);n.exports=function(n,e){return new(i(n))(e)}},function(n,e,t){var i=t(14),r=t(106),s=t(7)("species");n.exports=function(n){var e;return r(n)&&("function"!=typeof(e=n.constructor)||e!==Array&&!r(e.prototype)||(e=void 0),i(e)&&null===(e=e[s])&&(e=void 0)),void 0===e?Array:e}},function(n,e,t){"use strict";var i=t(99),r=t(128),s=t(49),o=t(18);n.exports=t(129)(Array,"Array",(function(n,e){this._t=o(n),this._i=0,this._k=e}),(function(){var n=this._t,e=this._k,t=this._i++;return!n||t>=n.length?(this._t=void 0,r(1)):r(0,"keys"==e?t:"values"==e?n[t]:[t,n[t]])}),"values"),s.Arguments=s.Array,i("keys"),i("values"),i("entries")},function(n,e){n.exports=function(n,e){return{value:e,done:!!n}}},function(n,e,t){"use strict";var i=t(70),r=t(4),s=t(19),o=t(11),a=t(49),l=t(130),u=t(73),c=t(131),d=t(7)("iterator"),m=!([].keys&&"next"in[].keys()),p=function(){return this};n.exports=function(n,e,t,h,f,g,v){l(t,e,h);var b,x,w,E=function(n){if(!m&&n in j)return j[n];switch(n){case"keys":case"values":return function(){return new t(this,n)}}return function(){return new t(this,n)}},y=e+" Iterator",k="values"==f,A=!1,j=n.prototype,_=j[d]||j["@@iterator"]||f&&j[f],N=_||E(f),O=f?k?E("entries"):N:void 0,B="Array"==e&&j.entries||_;if(B&&(w=c(B.call(new n)))!==Object.prototype&&w.next&&(u(w,y,!0),i||"function"==typeof w[d]||o(w,d,p)),k&&_&&"values"!==_.name&&(A=!0,N=function(){return _.call(this)}),i&&!v||!m&&!A&&j[d]||o(j,d,N),a[e]=N,a[y]=p,f)if(b={values:k?N:E("values"),keys:g?N:E("keys"),entries:O},v)for(x in b)x in j||s(j,x,b[x]);else r(r.P+r.F*(m||A),e,b);return b}},function(n,e,t){"use strict";var i=t(71),r=t(27),s=t(73),o={};t(11)(o,t(7)("iterator"),(function(){return this})),n.exports=function(n,e,t){n.prototype=i(o,{next:r(1,t)}),s(n,e+" Iterator")}},function(n,e,t){var i=t(15),r=t(26),s=t(44)("IE_PROTO"),o=Object.prototype;n.exports=Object.getPrototypeOf||function(n){return n=r(n),i(n,s)?n[s]:"function"==typeof n.constructor&&n instanceof n.constructor?n.constructor.prototype:n instanceof Object?o:null}},function(n,e,t){var i=t(4),r=t(28),s=t(9);n.exports=function(n,e){var t=(r.Object||{})[n]||Object[n],o={};o[n]=e(t),i(i.S+i.F*s((function(){t(1)})),"Object",o)}},function(n,e,t){t(134);var i=t(55).Object;n.exports=function(n,e,t){return i.defineProperty(n,e,t)}},function(n,e,t){var i=t(89);i(i.S+i.F*!t(23),"Object",{defineProperty:t(61).f})},function(n,e,t){n.exports=!t(23)&&!t(74)((function(){return 7!=Object.defineProperty(t(100)("div"),"a",{get:function(){return 7}}).a}))},function(n,e,t){var i=t(40);n.exports=function(n,e){if(!i(n))return n;var t,r;if(e&&"function"==typeof(t=n.toString)&&!i(r=t.call(n)))return r;if("function"==typeof(t=n.valueOf)&&!i(r=t.call(n)))return r;if(!e&&"function"==typeof(t=n.toString)&&!i(r=t.call(n)))return r;throw TypeError("Can't convert object to primitive value")}},function(n,e,t){
/*!
 * Valine v1.3.6
 * (c) 2017-2019 xCss
 * Released under the GPL-2.0 License.
 * Last Update: 2019-04-01 14:26:14
 */
n.exports=function(n){function e(i){if(t[i])return t[i].exports;var r=t[i]={i:i,l:!1,exports:{}};return n[i].call(r.exports,r,r.exports,e),r.l=!0,r.exports}var t={};return e.m=n,e.c=t,e.i=function(n){return n},e.d=function(n,t,i){e.o(n,t)||Object.defineProperty(n,t,{configurable:!1,enumerable:!0,get:i})},e.n=function(n){var t=n&&n.__esModule?function(){return n.default}:function(){return n};return e.d(t,"a",t),t},e.o=function(n,e){return Object.prototype.hasOwnProperty.call(n,e)},e.p="",e(e.s=17)}([function(n,e,t){var i,r,s;
/*!
	autosize 4.0.2
	license: MIT
	http://www.jacklmoore.com/autosize
*/r=[n,e],i=function(n,e){"use strict";function t(n){function e(e){var t=n.style.width;n.style.width="0px",n.offsetWidth,n.style.width=t,n.style.overflowY=e}function t(){if(0!==n.scrollHeight){var e=function(n){for(var e=[];n&&n.parentNode&&n.parentNode instanceof Element;)n.parentNode.scrollTop&&e.push({node:n.parentNode,scrollTop:n.parentNode.scrollTop}),n=n.parentNode;return e}(n),t=document.documentElement&&document.documentElement.scrollTop;n.style.height="",n.style.height=n.scrollHeight+r+"px",a=n.clientWidth,e.forEach((function(n){n.node.scrollTop=n.scrollTop})),t&&(document.documentElement.scrollTop=t)}}function i(){t();var i=Math.round(parseFloat(n.style.height)),r=window.getComputedStyle(n,null),s="content-box"===r.boxSizing?Math.round(parseFloat(r.height)):n.offsetHeight;if(s<i?"hidden"===r.overflowY&&(e("scroll"),t(),s="content-box"===r.boxSizing?Math.round(parseFloat(window.getComputedStyle(n,null).height)):n.offsetHeight):"hidden"!==r.overflowY&&(e("hidden"),t(),s="content-box"===r.boxSizing?Math.round(parseFloat(window.getComputedStyle(n,null).height)):n.offsetHeight),l!==s){l=s;var a=o("autosize:resized");try{n.dispatchEvent(a)}catch(n){}}}if(n&&n.nodeName&&"TEXTAREA"===n.nodeName&&!s.has(n)){var r=null,a=null,l=null,u=function(){n.clientWidth!==a&&i()},c=function(e){window.removeEventListener("resize",u,!1),n.removeEventListener("input",i,!1),n.removeEventListener("keyup",i,!1),n.removeEventListener("autosize:destroy",c,!1),n.removeEventListener("autosize:update",i,!1),Object.keys(e).forEach((function(t){n.style[t]=e[t]})),s.delete(n)}.bind(n,{height:n.style.height,resize:n.style.resize,overflowY:n.style.overflowY,overflowX:n.style.overflowX,wordWrap:n.style.wordWrap});n.addEventListener("autosize:destroy",c,!1),"onpropertychange"in n&&"oninput"in n&&n.addEventListener("keyup",i,!1),window.addEventListener("resize",u,!1),n.addEventListener("input",i,!1),n.addEventListener("autosize:update",i,!1),n.style.overflowX="hidden",n.style.wordWrap="break-word",s.set(n,{destroy:c,update:i}),function(){var e=window.getComputedStyle(n,null);"vertical"===e.resize?n.style.resize="none":"both"===e.resize&&(n.style.resize="horizontal"),r="content-box"===e.boxSizing?-(parseFloat(e.paddingTop)+parseFloat(e.paddingBottom)):parseFloat(e.borderTopWidth)+parseFloat(e.borderBottomWidth),isNaN(r)&&(r=0),i()}()}}function i(n){var e=s.get(n);e&&e.destroy()}function r(n){var e=s.get(n);e&&e.update()}var s="function"==typeof Map?new Map:function(){var n=[],e=[];return{has:function(e){return n.indexOf(e)>-1},get:function(t){return e[n.indexOf(t)]},set:function(t,i){-1===n.indexOf(t)&&(n.push(t),e.push(i))},delete:function(t){var i=n.indexOf(t);i>-1&&(n.splice(i,1),e.splice(i,1))}}}(),o=function(n){return new Event(n,{bubbles:!0})};try{new Event("test")}catch(n){o=function(n){var e=document.createEvent("Event");return e.initEvent(n,!0,!1),e}}var a=null;"undefined"==typeof window||"function"!=typeof window.getComputedStyle?((a=function(n){return n}).destroy=function(n){return n},a.update=function(n){return n}):((a=function(n,e){return n&&Array.prototype.forEach.call(n.length?n:[n],(function(n){return t(n)})),n}).destroy=function(n){return n&&Array.prototype.forEach.call(n.length?n:[n],i),n},a.update=function(n){return n&&Array.prototype.forEach.call(n.length?n:[n],r),n}),e.default=a,n.exports=e.default},void 0!==(s="function"==typeof i?i.apply(e,r):i)&&(n.exports=s)},function(n,e,t){"use strict";function i(n){return!!n&&this.init(n),this}function r(n){return new i(n)}var s=t(9).version,o=t(6),a=t(8),l=t(0),u=t(5),c=t(3),d=t(4),m=t(2),p=t(7),h=/^https?\:\/\//,f={comment:"",nick:"Anonymous",mail:"",link:"",ua:navigator.userAgent,url:""},g={"zh-cn":{head:{nick:"昵称",mail:"邮箱",link:"网址(http://)"},tips:{comments:"评论",sofa:"快来做第一个评论的人吧~",busy:"还在提交中，请稍候...",again:"这么简单也能错，也是没谁了."},ctrl:{reply:"回复",ok:"好的",sure:"确认",cancel:"取消",confirm:"确认",continue:"继续",more:"查看更多...",try:"再试试?",preview:"预览",emoji:"表情"},error:{99:"初始化失败，请检查init中的`el`元素.",100:"初始化失败，请检查你的AppId和AppKey.",401:"未经授权的操作，请检查你的AppId和AppKey.",403:"访问被api域名白名单拒绝，请检查你的安全域名设置."},timeago:{seconds:"秒前",minutes:"分钟前",hours:"小时前",days:"天前",now:"刚刚"}},en:{head:{nick:"NickName",mail:"E-Mail",link:"Website(http://)"},tips:{comments:"Comments",sofa:"No comments yet.",busy:"Submit is busy, please wait...",again:"Sorry, this is a wrong calculation."},ctrl:{reply:"Reply",ok:"Ok",sure:"Sure",cancel:"Cancel",confirm:"Confirm",continue:"Continue",more:"Load More...",try:"Once More?",preview:"Preview",emoji:"Emoji"},error:{99:"Initialization failed, Please check the `el` element in the init method.",100:"Initialization failed, Please check your appId and appKey.",401:"Unauthorized operation, Please check your appId and appKey.",403:"Access denied by api domain white list, Please check your security domain."},timeago:{seconds:"seconds ago",minutes:"minutes ago",hours:"hours ago",days:"days ago",now:"just now"}}},v={cdn:"https://gravatar.loli.net/avatar/",ds:["mp","identicon","monsterid","wavatar","robohash","retro",""],params:"",hide:!1},b=["nick","mail","link"],x=Storage&&localStorage&&localStorage instanceof Storage&&localStorage,w=location.pathname.replace(/index\.html?$/,"");i.prototype.init=function(n){if("undefined"!=typeof document){var e=this;try{var t=n.lang,i=n.langMode,r=n.avatar,o=n.avatarForce,l=n.avatar_cdn,u=n.notify,c=n.verify,m=n.visitor,x=n.pageSize,E=n.recordIP,k=v.ds,A=o?"&q="+Math.random().toString(32).substring(2):"";if(t&&i&&e.installLocale(t,i),e.locale=e.locale||g[t||"zh-cn"],e.notify=u||!1,e.verify=c||!1,E){var j=d.create("script","src","//api.ip.sb/jsonip?callback=getIP"),_=document.getElementsByTagName("script")[0];_.parentNode.insertBefore(j,_),window.getIP=function(n){f.ip=n.ip}}v.params="?d="+(k.indexOf(r)>-1?r:"mp")+"&v="+s+A,v.hide="hide"===r,v.cdn=h.test(l)?l:v.cdn,w=n.path||w;var N=Number(x||10);if(n.pageSize=isNaN(N)?10:N<1?10:N,a.setOptions({renderer:new a.Renderer,highlight:!1===n.highlight?null:p,gfm:!0,tables:!0,breaks:!0,pedantic:!1,sanitize:!1,smartLists:!0,smartypants:!0}),!AV)return void setTimeout((function(){e.init(n)}),20);var O=n.app_id||n.appId,B=n.app_key||n.appKey;if(!O||!B)throw 99;AV.applicationId&&delete AV._config.applicationId||(AV.applicationId=null),AV.applicationKey&&delete AV._config.applicationKey||(AV.applicationKey=null),AV.init({appId:O,appKey:B});for(var S=d.findAll(document,".valine-comment-count"),I=0,L=S.length;I<L;I++)!function(n,t){var i=S[n];if(i){var r=d.attr(i,"data-xid");r&&e.Q(r).count().then((function(n){i.innerText=n})).catch((function(n){i.innerText=0}))}}(I);m&&y.add(AV.Object.extend("Counter"));var C=n.el||null,T=d.findAll(document,C);if(!(C=C instanceof HTMLElement?C:T[T.length-1]||null))return;e.el=C,e.el.classList.add("v"),v.hide&&e.el.classList.add("hide-avatar"),n.meta=(n.guest_info||n.meta||b).filter((function(n){return b.indexOf(n)>-1}));var D=(0==n.meta.length?b:n.meta).map((function(n){var t="mail"==n?"email":"text";return b.indexOf(n)>-1?'<input name="'+n+'" placeholder="'+e.locale.head[n]+'" class="v'+n+' vinput" type="'+t+'">':""}));e.placeholder=n.placeholder||"Just Go Go",e.el.innerHTML='<div class="vwrap"><div class="vheader item'+D.length+'">'+D.join("")+'</div><div class="vedit"><textarea id="veditor" class="veditor vinput" placeholder="'+e.placeholder+'"></textarea><div class="vctrl"><span class="vemoji-btn">'+e.locale.ctrl.emoji+'</span> | <span class="vpreview-btn">'+e.locale.ctrl.preview+'</span></div><div class="vemojis" style="display:none;"></div><div class="vinput vpreview" style="display:none;"></div></div><div class="vcontrol"><div class="col col-20" title="Markdown is supported"><a href="https://segmentfault.com/markdown" target="_blank"><svg class="markdown" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M14.85 3H1.15C.52 3 0 3.52 0 4.15v7.69C0 12.48.52 13 1.15 13h13.69c.64 0 1.15-.52 1.15-1.15v-7.7C16 3.52 15.48 3 14.85 3zM9 11H7V8L5.5 9.92 4 8v3H2V5h2l1.5 2L7 5h2v6zm2.99.5L9.5 8H11V5h2v3h1.5l-2.51 3.5z"></path></svg></a></div><div class="col col-80 text-right"><button type="button" title="Cmd|Ctrl+Enter" class="vsubmit vbtn">'+e.locale.ctrl.reply+'</button></div></div><div style="display:none;" class="vmark"></div></div><div class="vinfo" style="display:none;"><div class="vcount col"></div></div><div class="vlist"></div><div class="vempty" style="display:none;"></div><div class="vpage txt-center"></div><div class="info"><div class="power txt-right">Powered By <a href="https://valine.js.org" target="_blank">Valine</a><br>v'+s+"</div></div>";var q=d.find(e.el,".vempty");e.nodata={show:function(n){return q.innerHTML=n||e.locale.tips.sofa,d.attr(q,"style","display:block;"),e},hide:function(){return d.attr(q,"style","display:none;"),e}};var P=d.create("div","class","vloading"),M=d.find(e.el,".vlist");e.loading={show:function(n){var t=d.findAll(M,".vcard");return n?M.insertBefore(P,t[0]):M.appendChild(P),e.nodata.hide(),e},hide:function(){var n=d.find(M,".vloading");return n&&d.remove(n),0===d.findAll(M,".vcard").length&&e.nodata.show(),e}};var F=d.find(e.el,".vmark");e.alert={show:function(n){F.innerHTML='<div class="valert txt-center"><div class="vtext">'+(n&&n.text||1)+'</div><div class="vbtns"></div></div>';var t=d.find(F,".vbtns"),i='<button class="vcancel vbtn">'+(n&&n.ctxt||e.locale.ctrl.cancel)+"</button>",r='<button class="vsure vbtn">'+(n&&n.otxt||e.locale.ctrl.sure)+"</button>";if(t.innerHTML=""+i+(n&&n.type&&r),d.on("click",d.find(F,".vcancel"),(function(n){e.alert.hide()})),d.attr(F,"style","display:block;"),n&&n.type){var s=d.find(F,".vsure");d.on("click",s,(function(t){e.alert.hide(),n.cb&&n.cb()}))}return e},hide:function(){return d.attr(F,"style","display:none;"),e}},e.bind(n)}catch(n){e.ErrorHandler(n)}return e}console};var E=function(n,e){var t=new n,i=new AV.ACL;i.setPublicReadAccess(!0),i.setPublicWriteAccess(!0),t.setACL(i),t.set("url",e.url),t.set("xid",e.xid),t.set("title",e.title),t.set("time",1),t.save().then((function(n){d.find(e.el,".leancloud-visitors-count").innerText=1})).catch((function(n){}))},y={add:function(n){var e=d.findAll(document,".leancloud_visitors,.leancloud-visitors");if(e.length){var t=e[0],i=d.attr(t,"id"),r=d.attr(t,"data-flag-title"),s=encodeURI(i),o={el:t,url:i,xid:s,title:r};if(decodeURI(i)===decodeURI(w)){var a=new AV.Query(n);a.equalTo("url",i),a.find().then((function(e){if(e.length>0){var i=e[0];i.increment("time"),i.save().then((function(n){d.find(t,".leancloud-visitors-count").innerText=n.get("time")})).catch((function(n){}))}else E(n,o)})).catch((function(e){101==e.code&&E(n,o)}))}else y.show(n,e)}},show:function(n,e){d.each(e,(function(n,e){var t=d.find(e,".leancloud-visitors-count");t&&(t.innerText=0)}));var t=[];for(var i in e)e.hasOwnProperty(i)&&t.push(d.attr(e[i],"id"));if(t.length){var r=new AV.Query(n);r.containedIn("url",t),r.find().then((function(n){n.length>0&&d.each(n,(function(n,e){var t=e.get("url"),i=e.get("time"),r=d.find(document,'.leancloud_visitors[id="'+t+'"]')||d.find(document,'.leancloud-visitors[id="'+t+'"]'),s=d.find(r,".leancloud-visitors-count");s&&(s.innerText=i)}))})).catch((function(n){}))}}};i.prototype.Q=function(n){if(1==arguments.length){var e=new AV.Query("Comment");e.doesNotExist("rid");var t=new AV.Query("Comment");t.equalTo("rid","");var i=AV.Query.or(e,t);return i.equalTo("url",decodeURI(n)),i.addDescending("createdAt"),i.addDescending("insertedAt"),i}var r=JSON.stringify(arguments[1]).replace(/(\[|\])/g,""),s="select * from Comment where rid in ("+r+") order by -createdAt,-createdAt";return AV.Query.doCloudQuery(s)},i.prototype.ErrorHandler=function(n){var e=this;if(e.el&&e.loading.hide().nodata.hide(),"[object Error]"==={}.toString.call(n)){var t=n.code||"",i=e.locale.error[t]||n.message||n.error||"";101==t?e.nodata.show():e.el&&e.nodata.show('<pre style="text-align:left;">Code '+t+": "+i+"</pre>")||console}else e.el&&e.nodata.show('<pre style="text-align:left;">'+JSON.stringify(n)+"</pre>")||console},i.prototype.installLocale=function(n,e){return e=e||{},n&&(g[n]=e,this.locale=g[n]||g["zh-cn"]),this},i.prototype.setPath=function(n){return w=n||w,this},i.prototype.bind=function(n){var e=this,t=d.find(e.el,".vemojis"),i=d.find(e.el,".vpreview"),r=d.find(e.el,".vemoji-btn"),s=d.find(e.el,".vpreview-btn"),p=m.data;for(var h in p)p.hasOwnProperty(h)&&function(n,i){var r=d.create("i",{name:n,title:n});r.innerHTML=i,t.appendChild(r),d.on("click",r,(function(n){var t=d.find(e.el,".veditor");N(t,i),b(t)}))}(h,p[h]);e.emoji={show:function(){return e.preview.hide(),d.attr(r,"v",1),d.removeAttr(s,"v"),d.attr(t,"style","display:block"),e.emoji},hide:function(){return d.removeAttr(r,"v"),d.attr(t,"style","display:hide"),e.emoji}},e.preview={show:function(){return f.comment&&(e.emoji.hide(),d.attr(s,"v",1),d.removeAttr(r,"v"),i.innerHTML=f.comment,d.attr(i,"style","display:block"),I()),e.preview},hide:function(){return d.removeAttr(s,"v"),d.attr(i,"style","display:none"),e.preview},empty:function(){return i.innerHtml="",e.preview}};var g=function(n){var e=d.create("div");e.insertAdjacentHTML("afterbegin",n);var t=d.findAll(e,"*"),i=["INPUT","STYLE","SCRIPT","IFRAME","FRAME","AUDIO","VIDEO","EMBED","META","TITLE","LINK"];return d.each(t,(function(n,e){1===e.nodeType&&(i.indexOf(e.nodeName)>-1&&("INPUT"===e.nodeName&&"checkbox"===d.attr(e,"type")?d.attr(e,"disabled","disabled"):d.remove(e)),"A"===e.nodeName&&function(n,e){var t=d.attr(n,e);t&&d.attr(n,e,t.replace(/(javascript|eval)/gi,""))}(e,"href"),d.clearAttr(e))})),e.innerHTML},b=function(n){var e=n.value||"";e=m.parse(e),n.value=e;var t=g(a(e));f.comment=t,i.innerHTML=t,e?l(n):l.destroy(n)};d.on("click",r,(function(n){d.attr(r,"v")?e.emoji.hide():e.emoji.show()})),d.on("click",s,(function(n){d.attr(s,"v")?e.preview.hide():e.preview.show()}));for(var E=n.meta,y={},k={veditor:"comment"},A=0,j=E.length;A<j;A++)k["v"+E[A]]=E[A];for(var _ in k)k.hasOwnProperty(_)&&function(){var n=k[_],t=d.find(e.el,"."+_);y[n]=t,t&&d.on("input change blur",t,(function(e){"comment"===n?b(t):f[n]=d.escape(t.value.replace(/(^\s*)|(\s*$)/g,""))}))}();var N=function(n,e){if(document.selection)n.focus(),document.selection.createRange().text=e,n.focus();else if(n.selectionStart||"0"==n.selectionStart){var t=n.selectionStart,i=n.selectionEnd,r=n.scrollTop;n.value=n.value.substring(0,t)+e+n.value.substring(i,n.value.length),n.focus(),n.selectionStart=t+e.length,n.selectionEnd=t+e.length,n.scrollTop=r}else n.focus(),n.value+=e},O=function(n){var t=d.find(e.el,".vh[rootid='"+n+"']"),i=d.find(t,".vquote");return i||(i=d.create("div","class","vquote"),t.appendChild(i)),i},B=function t(){var i=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1,r=n.pageSize,s=Number(d.find(e.el,".vnum").innerText);e.loading.show();var o=e.Q(w);o.limit(r),o.skip((i-1)*r),o.find().then((function(n){for(var o=n.length,a=[],l=0;l<o;l++){var u=n[l];a.push(u.id),S(u,d.find(e.el,".vlist"),!0)}e.Q(w,a).then((function(n){for(var e=n&&n.results||[],t=0;t<e.length;t++){var i=e[t];S(i,O(i.get("rid")))}}));var c=d.find(e.el,".vpage");c.innerHTML=r*i<s?'<button type="button" class="vmore vbtn">'+e.locale.ctrl.more+"</button>":"";var m=d.find(c,".vmore");m&&d.on("click",m,(function(n){c.innerHTML="",t(++i)})),e.loading.hide()})).catch((function(n){e.loading.hide().ErrorHandler(n)}))};e.Q(w).count().then((function(n){n>0?(d.attr(d.find(e.el,".vinfo"),"style","display:block;"),d.find(e.el,".vcount").innerHTML='<span class="vnum">'+n+"</span> "+e.locale.tips.comments,B()):e.loading.hide()})).catch((function(n){e.ErrorHandler(n)}));var S=function(n,t,i){var r=d.create("div",{class:"vcard",id:n.id}),s=v.hide?"":'<img class="vimg" src="'+(v.cdn+o(n.get("mail"))+v.params)+'">',a=n.get("ua")||"",l="";a&&(l='<span class="vsys">'+(a=c(a)).browser+" "+a.version+'</span> <span class="vsys">'+a.os+" "+a.osVersion+"</span>");var m,p=n.get("link")||"";m=p?'<a class="vnick" rel="nofollow" href="'+p+'" target="_blank" >'+n.get("nick")+"</a>":'<span class="vnick">'+n.get("nick")+"</span>",r.innerHTML=s+'\n            <div class="vh" rootid='+(n.get("rid")||n.id)+'>\n                <div class="vhead">'+m+" "+l+'</div>\n                <div class="vmeta">\n                    <span class="vtime">'+u(n.get("insertedAt")||n.createdAt,e.locale)+'</span>\n                    <span class="vat">'+e.locale.ctrl.reply+'</span>\n                </div>\n                <div class="vcontent">\n                    '+g(n.get("comment"))+"\n                </div>\n            </div>";for(var h=d.find(r,".vat"),f=d.findAll(r,"a"),b=0,x=f.length;b<x;b++){var w=f[b];w&&-1==(d.attr(w,"class")||"").indexOf("at")&&d.attr(w,{target:"_blank",rel:"nofollow"})}var E=d.findAll(t,".vcard");i?t.appendChild(r):t.insertBefore(r,E[0]);var y=d.find(r,".vcontent");y&&L(y),h&&T(h,n),I()},I=function(){setTimeout((function(){try{var n=n||"";n&&n.Hub.Queue(["Typeset",n.Hub]),$("pre code").each((function(n,e){hljs.highlightBlock(e)})),$("code.hljs").each((function(n,e){hljs.lineNumbersBlock(e)}))}catch(n){}}),20)},L=function(n){setTimeout((function(){n.offsetHeight>180&&(n.classList.add("expand"),d.on("click",n,(function(e){d.attr(n,"class","vcontent")})))}))},C={},T=function(n,e){d.on("click",n,(function(n){var t="@"+d.escape(e.get("nick"));C={at:d.escape(t)+" ",rid:e.get("rid")||e.id,pid:e.id,rmail:e.get("mail")},d.attr(y.comment,"placeholder",t),y.comment.focus()}))};!function(){var n=x&&x.ValineCache;if(n){n=JSON.parse(n);var t=E;for(var i in t){var r=t[i];d.find(e.el,".v"+r).value=d.unescape(n[r]),f[r]=n[r]}}}();var D=d.find(e.el,".vsubmit"),q=function(n){return d.attr(D,"disabled")?void e.alert.show({type:0,text:e.locale.tips.busy+'ヾ(๑╹◡╹)ﾉ"',ctxt:e.locale.ctrl.ok}):""==f.comment?void y.comment.focus():(f.nick=f.nick||"Anonymous",void(e.notify||e.verify?F(M):M()))},P=function(){var n=new AV.ACL;return n.setPublicReadAccess(!0),n.setPublicWriteAccess(!1),n},M=function(){d.attr(D,"disabled",!0),e.loading.show(!0);var n=new(AV.Object.extend("Comment"));if(f.url=decodeURI(w),f.insertedAt=new Date,C.rid){var t=C.pid||C.rid;n.set("rid",C.rid),n.set("pid",t),f.comment=f.comment.replace("<p>",'<p><a class="at" href="#'+t+'">'+C.at+"</a> , ")}for(var i in f)if(f.hasOwnProperty(i)){var r=f[i];n.set(i,r)}n.setACL(P()),n.save().then((function(n){"Anonymous"!=f.nick&&x&&x.setItem("ValineCache",JSON.stringify({nick:f.nick,link:f.link,mail:f.mail}));var t=d.find(e.el,".vnum"),i=1;try{if(C.rid){var r=d.find(e.el,'.vquote[rid="'+C.rid+'"]')||O(C.rid);S(n,r,!0)}else t?(i=Number(t.innerText)+1,t.innerText=i):d.find(e.el,".vcount").innerHTML='<span class="num">1</span> '+e.locale.tips.comments,S(n,d.find(e.el,".vlist"));f.mail&&z({username:f.nick,mail:f.mail}),C.at&&C.rmail&&e.notify&&R({username:C.at.replace("@",""),mail:C.rmail}),d.removeAttr(D,"disabled"),e.loading.hide(),f.comment="",y.comment.value="",b(y.comment),d.attr(y.comment,"placeholder",e.placeholder),C={},e.preview.empty().hide()}catch(n){e.ErrorHandler(n)}})).catch((function(n){e.ErrorHandler(n)}))},F=function n(t){var i=Math.floor(10*Math.random()+1),r=Math.floor(10*Math.random()+1),s=Math.floor(10*Math.random()+1),o=["+","-","x"],a=""+i+o[Math.floor(3*Math.random())]+r+o[Math.floor(3*Math.random())]+s,l=a+" = <input class='vcode vinput' >";e.alert.show({type:1,text:l,ctxt:e.locale.ctrl.cancel,otxt:e.locale.ctrl.ok,cb:function(){var i=+d.find(e.el,".vcode").value;new Function("return "+a.replace(/x/g,"*"))()===i?t&&t():e.alert.show({type:1,text:"(T＿T)"+e.locale.tips.again,ctxt:e.locale.ctrl.cancel,otxt:e.locale.ctrl.try,cb:function(){n(t)}})}})},z=function(n){var e=new AV.User;return e.setUsername(n.username),e.setPassword(n.mail),e.setEmail(n.mail),e.setACL(P()),e.signUp()},R=function n(t){AV.User.requestPasswordReset(t.mail).then((function(n){})).catch((function(i){1==i.code?e.alert.show({type:0,text:"ヾ(ｏ･ω･)ﾉ At太频繁啦，提醒功能暂时宕机。<br>"+i.error,ctxt:e.locale.ctrl.ok}):z(t).then((function(e){n(t)})).catch((function(n){}))}))};d.on("click",D,q),d.on("keydown",document,(function(n){var t=(n=event||n).keyCode||n.which||n.charCode;if((n.ctrlKey||n.metaKey)&&13===t&&q(),9===t&&"veditor"==(document.activeElement.id||"")){n.preventDefault();var i=d.find(e.el,".veditor");N(i,"    ")}}))},n.exports=r,n.exports.default=r},function(n,e,t){"use strict";var i={data:t(11),parse:function(n){return String(n).replace(/:(.+?):/g,(function(n,e){return i.data[e]||n}))}};n.exports=i},function(n,e,t){"use strict";function i(n){var e=this,t={Trident:n.indexOf("Trident")>-1||n.indexOf("NET CLR")>-1,Presto:n.indexOf("Presto")>-1,WebKit:n.indexOf("AppleWebKit")>-1,Gecko:n.indexOf("Gecko/")>-1,Safari:n.indexOf("Safari")>-1,Chrome:n.indexOf("Chrome")>-1||n.indexOf("CriOS")>-1,IE:n.indexOf("MSIE")>-1||n.indexOf("Trident")>-1,Edge:n.indexOf("Edge")>-1,Firefox:n.indexOf("Firefox")>-1||n.indexOf("FxiOS")>-1,"Firefox Focus":n.indexOf("Focus")>-1,Chromium:n.indexOf("Chromium")>-1,Opera:n.indexOf("Opera")>-1||n.indexOf("OPR")>-1,Vivaldi:n.indexOf("Vivaldi")>-1,Yandex:n.indexOf("YaBrowser")>-1,Kindle:n.indexOf("Kindle")>-1||n.indexOf("Silk/")>-1,360:n.indexOf("360EE")>-1||n.indexOf("360SE")>-1,UC:n.indexOf("UC")>-1||n.indexOf(" UBrowser")>-1,QQBrowser:n.indexOf("QQBrowser")>-1,QQ:n.indexOf("QQ/")>-1,Baidu:n.indexOf("Baidu")>-1||n.indexOf("BIDUBrowser")>-1,Maxthon:n.indexOf("Maxthon")>-1,Sogou:n.indexOf("MetaSr")>-1||n.indexOf("Sogou")>-1,LBBROWSER:n.indexOf("LBBROWSER")>-1,"2345Explorer":n.indexOf("2345Explorer")>-1,TheWorld:n.indexOf("TheWorld")>-1,XiaoMi:n.indexOf("MiuiBrowser")>-1,Quark:n.indexOf("Quark")>-1,Qiyu:n.indexOf("Qiyu")>-1,Wechat:n.indexOf("MicroMessenger")>-1,Taobao:n.indexOf("AliApp(TB")>-1,Alipay:n.indexOf("AliApp(AP")>-1,Weibo:n.indexOf("Weibo")>-1,Douban:n.indexOf("com.douban.frodo")>-1,Suning:n.indexOf("SNEBUY-APP")>-1,iQiYi:n.indexOf("IqiyiApp")>-1,Windows:n.indexOf("Windows")>-1,Linux:n.indexOf("Linux")>-1||n.indexOf("X11")>-1,"Mac OS":n.indexOf("Macintosh")>-1,Android:n.indexOf("Android")>-1||n.indexOf("Adr")>-1,Ubuntu:n.indexOf("Ubuntu")>-1,FreeBSD:n.indexOf("FreeBSD")>-1,Debian:n.indexOf("Debian")>-1,"Windows Phone":n.indexOf("IEMobile")>-1||n.indexOf("Windows Phone")>-1,BlackBerry:n.indexOf("BlackBerry")>-1||n.indexOf("RIM")>-1,MeeGo:n.indexOf("MeeGo")>-1,Symbian:n.indexOf("Symbian")>-1,iOS:n.indexOf("like Mac OS X")>-1,"Chrome OS":n.indexOf("CrOS")>-1,WebOS:n.indexOf("hpwOS")>-1,Mobile:n.indexOf("Mobi")>-1||n.indexOf("iPh")>-1||n.indexOf("480")>-1,Tablet:n.indexOf("Tablet")>-1||n.indexOf("Pad")>-1||n.indexOf("Nexus 7")>-1};t.Mobile&&(t.Mobile=!(n.indexOf("iPad")>-1));var i={engine:["WebKit","Trident","Gecko","Presto"],browser:["Safari","Chrome","Edge","IE","Firefox","Firefox Focus","Chromium","Opera","Vivaldi","Yandex","Kindle","360","UC","QQBrowser","QQ","Baidu","Maxthon","Sogou","LBBROWSER","2345Explorer","TheWorld","XiaoMi","Quark","Qiyu","Wechat","Taobao","Alipay","Weibo","Douban","Suning","iQiYi"],os:["Windows","Linux","Mac OS","Android","Ubuntu","FreeBSD","Debian","iOS","Windows Phone","BlackBerry","MeeGo","Symbian","Chrome OS","WebOS"],device:["Mobile","Tablet"]};for(var r in e.device="PC",i)for(var s=0;s<i[r].length;s++){var o=i[r][s];t[o]&&(e[r]=o)}var a={Windows:function(){var e=n.replace(/^.*Windows NT ([\d.]+);.*$/,"$1");return{6.4:"10",6.3:"8.1",6.2:"8",6.1:"7","6.0":"Vista",5.2:"XP",5.1:"XP","5.0":"2000"}[e]||e},Android:function(){return n.replace(/^.*Android ([\d.]+);.*$/,"$1")},iOS:function(){return n.replace(/^.*OS ([\d_]+) like.*$/,"$1").replace(/_/g,".")},Debian:function(){return n.replace(/^.*Debian\/([\d.]+).*$/,"$1")},"Windows Phone":function(){return n.replace(/^.*Windows Phone( OS)? ([\d.]+);.*$/,"$2")},"Mac OS":function(){return n.replace(/^.*Mac OS X ([\d_]+).*$/,"$1").replace(/_/g,".")},WebOS:function(){return n.replace(/^.*hpwOS\/([\d.]+);.*$/,"$1")}};e.osVersion="",a[e.os]&&(e.osVersion=a[e.os](),e.osVersion==n&&(e.osVersion=""));var l={Safari:function(){return n.replace(/^.*Version\/([\d.]+).*$/,"$1")},Chrome:function(){return n.replace(/^.*Chrome\/([\d.]+).*$/,"$1").replace(/^.*CriOS\/([\d.]+).*$/,"$1")},IE:function(){return n.replace(/^.*MSIE ([\d.]+).*$/,"$1").replace(/^.*rv:([\d.]+).*$/,"$1")},Edge:function(){return n.replace(/^.*Edge\/([\d.]+).*$/,"$1")},Firefox:function(){return n.replace(/^.*Firefox\/([\d.]+).*$/,"$1").replace(/^.*FxiOS\/([\d.]+).*$/,"$1")},"Firefox Focus":function(){return n.replace(/^.*Focus\/([\d.]+).*$/,"$1")},Chromium:function(){return n.replace(/^.*Chromium\/([\d.]+).*$/,"$1")},Opera:function(){return n.replace(/^.*Opera\/([\d.]+).*$/,"$1").replace(/^.*OPR\/([\d.]+).*$/,"$1")},Vivaldi:function(){return n.replace(/^.*Vivaldi\/([\d.]+).*$/,"$1")},Yandex:function(){return n.replace(/^.*YaBrowser\/([\d.]+).*$/,"$1")},Kindle:function(){return n.replace(/^.*Version\/([\d.]+).*$/,"$1")},Maxthon:function(){return n.replace(/^.*Maxthon\/([\d.]+).*$/,"$1")},QQBrowser:function(){return n.replace(/^.*QQBrowser\/([\d.]+).*$/,"$1")},QQ:function(){return n.replace(/^.*QQ\/([\d.]+).*$/,"$1")},Baidu:function(){return n.replace(/^.*BIDUBrowser[\s\/]([\d.]+).*$/,"$1")},UC:function(){return n.replace(/^.*UC?Browser\/([\d.]+).*$/,"$1")},Sogou:function(){return n.replace(/^.*SE ([\d.X]+).*$/,"$1").replace(/^.*SogouMobileBrowser\/([\d.]+).*$/,"$1")},"2345Explorer":function(){return n.replace(/^.*2345Explorer\/([\d.]+).*$/,"$1")},TheWorld:function(){return n.replace(/^.*TheWorld ([\d.]+).*$/,"$1")},XiaoMi:function(){return n.replace(/^.*MiuiBrowser\/([\d.]+).*$/,"$1")},Quark:function(){return n.replace(/^.*Quark\/([\d.]+).*$/,"$1")},Qiyu:function(){return n.replace(/^.*Qiyu\/([\d.]+).*$/,"$1")},Wechat:function(){return n.replace(/^.*MicroMessenger\/([\d.]+).*$/,"$1")},Taobao:function(){return n.replace(/^.*AliApp\(TB\/([\d.]+).*$/,"$1")},Alipay:function(){return n.replace(/^.*AliApp\(AP\/([\d.]+).*$/,"$1")},Weibo:function(){return n.replace(/^.*weibo__([\d.]+).*$/,"$1")},Douban:function(){return n.replace(/^.*com.douban.frodo\/([\d.]+).*$/,"$1")},Suning:function(){return n.replace(/^.*SNEBUY-APP([\d.]+).*$/,"$1")},iQiYi:function(){return n.replace(/^.*IqiyiVersion\/([\d.]+).*$/,"$1")}};e.version="",l[e.browser]&&(e.version=l[e.browser](),e.version==n&&(e.version="")),"Edge"==e.browser?e.engine="EdgeHTML":"Chrome"==e.browser&&parseInt(e.version)>27?e.engine="Blink":"Opera"==e.browser&&parseInt(e.version)>12?e.engine="Blink":"Yandex"==e.browser?e.engine="Blink":null==e.browser&&(e.browser="Unknow App")}n.exports=function(n){return new i(n)}},function(n,e,t){"use strict";var i={},r={"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;","`":"&#x60;","\\":"&#x5c;"};for(var s in r)i[r[s]]=s;var o=/[&<>"'`\\]/g,a=RegExp(o.source),l=/&(?:amp|lt|gt|quot|#39|#x60|#x5c);/g,u=RegExp(l.source),c={on:function(n,e,t,i){for(var r=0,s=(n=n.split(" ")).length;r<s;r++)c.off(n[r],e,t,i),e.addEventListener?e.addEventListener(n[r],t,i||!1):e.attachEvent?e.attachEvent("on"+n[r],t):e["on"+n[r]]=t},off:function(n,e,t,i){e.removeEventListener?e.removeEventListener(n,t,i||!1):e.detachEvent?e.detachEvent("on"+n,t):e["on"+n]=null},escape:function(n){return n&&a.test(n)?n.replace(o,(function(n){return r[n]})):n},unescape:function(n){return n&&u.test(n)?n.replace(l,(function(n){return i[n]})):n},create:function(n,e,t){var i=document.createElement(n);return c.attr(i,e,t),i},find:function(n,e){return n.querySelector(e)},findAll:function(n,e){return n.querySelectorAll(e)},attr:function(n,e,t){if(void 0===n.getAttribute)return c.prop(n,e,t);if(void 0!==t)null===t?c.removeAttr(n,e):n.setAttribute(e,t);else{if("[object Object]"!=={}.toString.call(e))return n.getAttribute(e);c.each(e,(function(e,t){n.setAttribute(e,t)}))}},prop:function(n,e,t){return void 0!==t?n[e]=t:"[object Object]"!=={}.toString.call(e)?n[e]:void c.each(e,(function(e,t){n[e]=t}))},removeAttr:function(n,e){var t=void 0,i=0,r=e&&e.match(/[^\x20\t\r\n\f\*\/\\]+/g);if(r&&1===n.nodeType)for(;t=r[i++];)n.removeAttribute(t);return n},clearAttr:function(n){var e=n.attributes,t=["align","alt","disabled","href","id","target","title","type","src","class","style"];return c.each(e,(function(e,i){var r=i.name;switch(i.name.toLowerCase()){case"style":var s=i.value;c.each(s.split(";"),(function(e,t){if(t.indexOf("color")>-1)return c.attr(n,"style",t),!1;c.removeAttr(n,"style")}));break;case"class":if("CODE"==n.nodeName)return!1;if(i.value.indexOf("at")>-1)return c.attr(n,"class","at"),!1}t.indexOf(r)>-1||c.removeAttr(n,r)})),n},remove:function(n){try{n.parentNode&&n.parentNode.removeChild(n)}catch(n){}},each:function(n,e){var t=0,i=n.length,r={}.toString.call(n);if(["[object Array]","[object NodeList]"].indexOf(r)>-1)for(;t<i&&!1!==(e&&e.call(n[t],t,n[t]));t++);else for(t in n)if(n.hasOwnProperty(t)&&!1===(e&&e.call(n[t],t,n[t])))break;return n}};n.exports=c},function(n,e,t){"use strict";var i=function(n){var e=r(n.getDate(),2),t=r(n.getMonth()+1,2);return r(n.getFullYear(),2)+"-"+t+"-"+e},r=function(n,e){for(var t=n.toString();t.length<e;)t="0"+t;return t};n.exports=function(n,e){if(n)try{var t=n.getTime(),r=(new Date).getTime()-t,s=Math.floor(r/864e5);if(0===s){var o=r%864e5,a=Math.floor(o/36e5);if(0===a){var l=o%36e5,u=Math.floor(l/6e4);if(0===u){var c=l%6e4;return Math.round(c/1e3)+" "+e.timeago.seconds}return u+" "+e.timeago.minutes}return a+" "+e.timeago.hours}return s<0?e.timeago.now:s<8?s+" "+e.timeago.days:i(n)}catch(n){}}},function(n,e,t){var i;!function(r){"use strict";function s(n,e){var t=(65535&n)+(65535&e);return(n>>16)+(e>>16)+(t>>16)<<16|65535&t}function o(n,e,t,i,r,o){return s(function(n,e){return n<<e|n>>>32-e}(s(s(e,n),s(i,o)),r),t)}function a(n,e,t,i,r,s,a){return o(e&t|~e&i,n,e,r,s,a)}function l(n,e,t,i,r,s,a){return o(e&i|t&~i,n,e,r,s,a)}function u(n,e,t,i,r,s,a){return o(e^t^i,n,e,r,s,a)}function c(n,e,t,i,r,s,a){return o(t^(e|~i),n,e,r,s,a)}function d(n,e){n[e>>5]|=128<<e%32,n[14+(e+64>>>9<<4)]=e;var t,i,r,o,d,m=1732584193,p=-271733879,h=-1732584194,f=271733878;for(t=0;t<n.length;t+=16)i=m,r=p,o=h,d=f,m=a(m,p,h,f,n[t],7,-680876936),f=a(f,m,p,h,n[t+1],12,-389564586),h=a(h,f,m,p,n[t+2],17,606105819),p=a(p,h,f,m,n[t+3],22,-1044525330),m=a(m,p,h,f,n[t+4],7,-176418897),f=a(f,m,p,h,n[t+5],12,1200080426),h=a(h,f,m,p,n[t+6],17,-1473231341),p=a(p,h,f,m,n[t+7],22,-45705983),m=a(m,p,h,f,n[t+8],7,1770035416),f=a(f,m,p,h,n[t+9],12,-1958414417),h=a(h,f,m,p,n[t+10],17,-42063),p=a(p,h,f,m,n[t+11],22,-1990404162),m=a(m,p,h,f,n[t+12],7,1804603682),f=a(f,m,p,h,n[t+13],12,-40341101),h=a(h,f,m,p,n[t+14],17,-1502002290),m=l(m,p=a(p,h,f,m,n[t+15],22,1236535329),h,f,n[t+1],5,-165796510),f=l(f,m,p,h,n[t+6],9,-1069501632),h=l(h,f,m,p,n[t+11],14,643717713),p=l(p,h,f,m,n[t],20,-373897302),m=l(m,p,h,f,n[t+5],5,-701558691),f=l(f,m,p,h,n[t+10],9,38016083),h=l(h,f,m,p,n[t+15],14,-660478335),p=l(p,h,f,m,n[t+4],20,-405537848),m=l(m,p,h,f,n[t+9],5,568446438),f=l(f,m,p,h,n[t+14],9,-1019803690),h=l(h,f,m,p,n[t+3],14,-187363961),p=l(p,h,f,m,n[t+8],20,1163531501),m=l(m,p,h,f,n[t+13],5,-1444681467),f=l(f,m,p,h,n[t+2],9,-51403784),h=l(h,f,m,p,n[t+7],14,1735328473),m=u(m,p=l(p,h,f,m,n[t+12],20,-1926607734),h,f,n[t+5],4,-378558),f=u(f,m,p,h,n[t+8],11,-2022574463),h=u(h,f,m,p,n[t+11],16,1839030562),p=u(p,h,f,m,n[t+14],23,-35309556),m=u(m,p,h,f,n[t+1],4,-1530992060),f=u(f,m,p,h,n[t+4],11,1272893353),h=u(h,f,m,p,n[t+7],16,-155497632),p=u(p,h,f,m,n[t+10],23,-1094730640),m=u(m,p,h,f,n[t+13],4,681279174),f=u(f,m,p,h,n[t],11,-358537222),h=u(h,f,m,p,n[t+3],16,-722521979),p=u(p,h,f,m,n[t+6],23,76029189),m=u(m,p,h,f,n[t+9],4,-640364487),f=u(f,m,p,h,n[t+12],11,-421815835),h=u(h,f,m,p,n[t+15],16,530742520),m=c(m,p=u(p,h,f,m,n[t+2],23,-995338651),h,f,n[t],6,-198630844),f=c(f,m,p,h,n[t+7],10,1126891415),h=c(h,f,m,p,n[t+14],15,-1416354905),p=c(p,h,f,m,n[t+5],21,-57434055),m=c(m,p,h,f,n[t+12],6,1700485571),f=c(f,m,p,h,n[t+3],10,-1894986606),h=c(h,f,m,p,n[t+10],15,-1051523),p=c(p,h,f,m,n[t+1],21,-2054922799),m=c(m,p,h,f,n[t+8],6,1873313359),f=c(f,m,p,h,n[t+15],10,-30611744),h=c(h,f,m,p,n[t+6],15,-1560198380),p=c(p,h,f,m,n[t+13],21,1309151649),m=c(m,p,h,f,n[t+4],6,-145523070),f=c(f,m,p,h,n[t+11],10,-1120210379),h=c(h,f,m,p,n[t+2],15,718787259),p=c(p,h,f,m,n[t+9],21,-343485551),m=s(m,i),p=s(p,r),h=s(h,o),f=s(f,d);return[m,p,h,f]}function m(n){var e,t="",i=32*n.length;for(e=0;e<i;e+=8)t+=String.fromCharCode(n[e>>5]>>>e%32&255);return t}function p(n){var e,t=[];for(t[(n.length>>2)-1]=void 0,e=0;e<t.length;e+=1)t[e]=0;var i=8*n.length;for(e=0;e<i;e+=8)t[e>>5]|=(255&n.charCodeAt(e/8))<<e%32;return t}function h(n){var e,t,i="0123456789abcdef",r="";for(t=0;t<n.length;t+=1)e=n.charCodeAt(t),r+=i.charAt(e>>>4&15)+i.charAt(15&e);return r}function f(n){return unescape(encodeURIComponent(n))}function g(n){return function(n){return m(d(p(n),8*n.length))}(f(n))}function v(n,e){return function(n,e){var t,i,r=p(n),s=[],o=[];for(s[15]=o[15]=void 0,r.length>16&&(r=d(r,8*n.length)),t=0;t<16;t+=1)s[t]=909522486^r[t],o[t]=1549556828^r[t];return i=d(s.concat(p(e)),512+8*e.length),m(d(o.concat(i),640))}(f(n),f(e))}function b(n,e,t){return e?t?v(e,n):function(n,e){return h(v(n,e))}(e,n):t?g(n):function(n){return h(g(n))}(n)}void 0!==(i=function(){return b}.call(e,t,e,n))&&(n.exports=i)}()},function(n,e,t){n.exports=function(){"use strict";var n=function(n,e){return function(n){var e=n.exports=function(){return new RegExp("(?:"+e.line().source+")|(?:"+e.block().source+")","gm")};e.line=function(){return/(?:^|\s)\/\/(.+?)$/gm},e.block=function(){return/\/\*([\S\s]*?)\*\//gm}}(e={exports:{}}),e.exports}(),e=["23AC69","91C132","F19726","E8552D","1AAB8E","E1147F","2980C1","1BA1E6","9FA0A0","F19726","E30B20","E30B20","A3338B"];return function(t,i){void 0===i&&(i={});var r=i.colors;void 0===r&&(r=e);var s=0,o={},a=new RegExp("("+/[\u4E00-\u9FFF\u3400-\u4dbf\uf900-\ufaff\u3040-\u309f\uac00-\ud7af\u0400-\u04FF]+|\w+/.source+"|"+/</.source+")|("+n().source+")","gmi");return t.replace(a,(function(n,e,t){if(t)return function(n){return'<span style="color: slategray">'+n+"</span>"}(t);if("<"===e)return"&lt;";var i;o[e]?i=o[e]:(i=r[s],o[e]=i);var a='<span style="color: #'+i+'">'+e+"</span>";return s=++s%r.length,a}))}}()},function(n,e,t){(function(e){!function(e){"use strict";function t(n){this.tokens=[],this.tokens.links={},this.options=n||h.defaults,this.rules=f.normal,this.options.pedantic?this.rules=f.pedantic:this.options.gfm&&(this.options.tables?this.rules=f.tables:this.rules=f.gfm)}function i(n,e){if(this.options=e||h.defaults,this.links=n,this.rules=g.normal,this.renderer=this.options.renderer||new r,this.renderer.options=this.options,!this.links)throw new Error("Tokens array requires a `links` property.");this.options.pedantic?this.rules=g.pedantic:this.options.gfm&&(this.options.breaks?this.rules=g.breaks:this.rules=g.gfm)}function r(n){this.options=n||h.defaults}function s(){}function o(n){this.tokens=[],this.token=null,this.options=n||h.defaults,this.options.renderer=this.options.renderer||new r,this.renderer=this.options.renderer,this.renderer.options=this.options}function a(n,e){return n.replace(e?/&/g:/&(?!#?\w+;)/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;").replace(/"/g,"&quot;").replace(/'/g,"&#39;")}function l(n){return n.replace(/&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/gi,(function(n,e){return"colon"===(e=e.toLowerCase())?":":"#"===e.charAt(0)?"x"===e.charAt(1)?String.fromCharCode(parseInt(e.substring(2),16)):String.fromCharCode(+e.substring(1)):""}))}function u(n,e){return n=n.source||n,e=e||"",{replace:function(e,t){return t=(t=t.source||t).replace(/(^|[^\[])\^/g,"$1"),n=n.replace(e,t),this},getRegex:function(){return new RegExp(n,e)}}}function c(n,e){return v[" "+n]||(/^[^:]+:\/*[^\/]*$/.test(n)?v[" "+n]=n+"/":v[" "+n]=n.replace(/[^\/]*$/,"")),n=v[" "+n],"//"===e.slice(0,2)?n.replace(/:[\s\S]*/,":")+e:"/"===e.charAt(0)?n.replace(/(:\/*[^\/]*)[\s\S]*/,"$1")+e:n+e}function d(){}function m(n){for(var e,t,i=1;i<arguments.length;i++)for(t in e=arguments[i])Object.prototype.hasOwnProperty.call(e,t)&&(n[t]=e[t]);return n}function p(n,e){var t=n.replace(/([^\\])\|/g,"$1 |").split(/ +\| */),i=0;if(t.length>e)t.splice(e);else for(;t.length<e;)t.push("");for(;i<t.length;i++)t[i]=t[i].replace(/\\\|/g,"|");return t}function h(n,e,i){if(null==n)throw new Error("marked(): input parameter is undefined or null");if("string"!=typeof n)throw new Error("marked(): input parameter is of type "+Object.prototype.toString.call(n)+", string expected");if(i||"function"==typeof e){i||(i=e,e=null);var r,s,l=(e=m({},h.defaults,e||{})).highlight,u=0;try{r=t.lex(n,e)}catch(n){return i(n)}s=r.length;var c=function(n){if(n)return e.highlight=l,i(n);var t;try{t=o.parse(r,e)}catch(e){n=e}return e.highlight=l,n?i(n):i(null,t)};if(!l||l.length<3)return c();if(delete e.highlight,!s)return c();for(;u<r.length;u++)!function(n){"code"!==n.type?--s||c():l(n.text,n.lang,(function(e,t){return e?c(e):null==t||t===n.text?--s||c():(n.text=t,n.escaped=!0,void(--s||c()))}))}(r[u])}else try{return e&&(e=m({},h.defaults,e)),o.parse(t.lex(n,e),e)}catch(n){if(n.message+="\nPlease report this to https://github.com/markedjs/marked.",(e||h.defaults).silent)return"<p>An error occurred:</p><pre>"+a(n.message+"",!0)+"</pre>";throw n}}var f={newline:/^\n+/,code:/^( {4}[^\n]+\n*)+/,fences:d,hr:/^ {0,3}((?:- *){3,}|(?:_ *){3,}|(?:\* *){3,})(?:\n+|$)/,heading:/^ *(#{1,6}) *([^\n]+?) *(?:#+ *)?(?:\n+|$)/,nptable:d,blockquote:/^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/,list:/^( *)(bull) [\s\S]+?(?:hr|def|\n{2,}(?! )(?!\1bull )\n*|\s*$)/,html:"^ {0,3}(?:<(script|pre|style)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)|comment[^\\n]*(\\n+|$)|<\\?[\\s\\S]*?\\?>\\n*|<![A-Z][\\s\\S]*?>\\n*|<!\\[CDATA\\[[\\s\\S]*?\\]\\]>\\n*|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:\\n{2,}|$)|<(?!script|pre|style)([a-z][\\w-]*)(?:attribute)*? */?>(?=\\h*\\n)[\\s\\S]*?(?:\\n{2,}|$)|</(?!script|pre|style)[a-z][\\w-]*\\s*>(?=\\h*\\n)[\\s\\S]*?(?:\\n{2,}|$))",def:/^ {0,3}\[(label)\]: *\n? *<?([^\s>]+)>?(?:(?: +\n? *| *\n *)(title))? *(?:\n+|$)/,table:d,lheading:/^([^\n]+)\n *(=|-){2,} *(?:\n+|$)/,paragraph:/^([^\n]+(?:\n(?!hr|heading|lheading| {0,3}>|<\/?(?:tag)(?: +|\n|\/?>)|<(?:script|pre|style|!--))[^\n]+)*)/,text:/^[^\n]+/,_label:/(?!\s*\])(?:\\[\[\]]|[^\[\]])+/,_title:/(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/};f.def=u(f.def).replace("label",f._label).replace("title",f._title).getRegex(),f.bullet=/(?:[*+-]|\d+\.)/,f.item=/^( *)(bull) [^\n]*(?:\n(?!\1bull )[^\n]*)*/,f.item=u(f.item,"gm").replace(/bull/g,f.bullet).getRegex(),f.list=u(f.list).replace(/bull/g,f.bullet).replace("hr","\\n+(?=\\1?(?:(?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$))").replace("def","\\n+(?="+f.def.source+")").getRegex(),f._tag="address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul",f._comment=/<!--(?!-?>)[\s\S]*?-->/,f.html=u(f.html,"i").replace("comment",f._comment).replace("tag",f._tag).replace("attribute",/ +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/).getRegex(),f.paragraph=u(f.paragraph).replace("hr",f.hr).replace("heading",f.heading).replace("lheading",f.lheading).replace("tag",f._tag).getRegex(),f.blockquote=u(f.blockquote).replace("paragraph",f.paragraph).getRegex(),f.normal=m({},f),f.gfm=m({},f.normal,{fences:/^ *(`{3,}|~{3,})[ \.]*(\S+)? *\n([\s\S]*?)\n? *\1 *(?:\n+|$)/,paragraph:/^/,heading:/^ *(#{1,6}) +([^\n]+?) *#* *(?:\n+|$)/}),f.gfm.paragraph=u(f.paragraph).replace("(?!","(?!"+f.gfm.fences.source.replace("\\1","\\2")+"|"+f.list.source.replace("\\1","\\3")+"|").getRegex(),f.tables=m({},f.gfm,{nptable:/^ *([^|\n ].*\|.*)\n *([-:]+ *\|[-| :]*)(?:\n((?:.*[^>\n ].*(?:\n|$))*)\n*|$)/,table:/^ *\|(.+)\n *\|?( *[-:]+[-| :]*)(?:\n((?: *[^>\n ].*(?:\n|$))*)\n*|$)/}),f.pedantic=m({},f.normal,{html:u("^ *(?:comment *(?:\\n|\\s*$)|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)|<tag(?:\"[^\"]*\"|'[^']*'|\\s[^'\"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))").replace("comment",f._comment).replace(/tag/g,"(?!(?:a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\\b)\\w+(?!:|[^\\w\\s@]*@)\\b").getRegex(),def:/^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/}),t.rules=f,t.lex=function(n,e){return new t(e).lex(n)},t.prototype.lex=function(n){return n=n.replace(/\r\n|\r/g,"\n").replace(/\t/g,"    ").replace(/\u00a0/g," ").replace(/\u2424/g,"\n"),this.token(n,!0)},t.prototype.token=function(n,e){n=n.replace(/^ +$/gm,"");for(var t,i,r,s,o,a,l,u,c,d,m,h,g;n;)if((r=this.rules.newline.exec(n))&&(n=n.substring(r[0].length),r[0].length>1&&this.tokens.push({type:"space"})),r=this.rules.code.exec(n))n=n.substring(r[0].length),r=r[0].replace(/^ {4}/gm,""),this.tokens.push({type:"code",text:this.options.pedantic?r:r.replace(/\n+$/,"")});else if(r=this.rules.fences.exec(n))n=n.substring(r[0].length),this.tokens.push({type:"code",lang:r[2],text:r[3]||""});else if(r=this.rules.heading.exec(n))n=n.substring(r[0].length),this.tokens.push({type:"heading",depth:r[1].length,text:r[2]});else if(e&&(r=this.rules.nptable.exec(n))&&(a={type:"table",header:p(r[1].replace(/^ *| *\| *$/g,"")),align:r[2].replace(/^ *|\| *$/g,"").split(/ *\| */),cells:r[3]?r[3].replace(/\n$/,"").split("\n"):[]}).header.length===a.align.length){for(n=n.substring(r[0].length),u=0;u<a.align.length;u++)/^ *-+: *$/.test(a.align[u])?a.align[u]="right":/^ *:-+: *$/.test(a.align[u])?a.align[u]="center":/^ *:-+ *$/.test(a.align[u])?a.align[u]="left":a.align[u]=null;for(u=0;u<a.cells.length;u++)a.cells[u]=p(a.cells[u],a.header.length);this.tokens.push(a)}else if(r=this.rules.hr.exec(n))n=n.substring(r[0].length),this.tokens.push({type:"hr"});else if(r=this.rules.blockquote.exec(n))n=n.substring(r[0].length),this.tokens.push({type:"blockquote_start"}),r=r[0].replace(/^ *> ?/gm,""),this.token(r,e),this.tokens.push({type:"blockquote_end"});else if(r=this.rules.list.exec(n)){for(n=n.substring(r[0].length),m=(s=r[2]).length>1,this.tokens.push({type:"list_start",ordered:m,start:m?+s:""}),t=!1,d=(r=r[0].match(this.rules.item)).length,u=0;u<d;u++)l=(a=r[u]).length,~(a=a.replace(/^ *([*+-]|\d+\.) +/,"")).indexOf("\n ")&&(l-=a.length,a=this.options.pedantic?a.replace(/^ {1,4}/gm,""):a.replace(new RegExp("^ {1,"+l+"}","gm"),"")),this.options.smartLists&&u!==d-1&&(s===(o=f.bullet.exec(r[u+1])[0])||s.length>1&&o.length>1||(n=r.slice(u+1).join("\n")+n,u=d-1)),i=t||/\n\n(?!\s*$)/.test(a),u!==d-1&&(t="\n"===a.charAt(a.length-1),i||(i=t)),g=void 0,(h=/^\[[ xX]\] /.test(a))&&(g=" "!==a[1],a=a.replace(/^\[[ xX]\] +/,"")),this.tokens.push({type:i?"loose_item_start":"list_item_start",task:h,checked:g}),this.token(a,!1),this.tokens.push({type:"list_item_end"});this.tokens.push({type:"list_end"})}else if(r=this.rules.html.exec(n))n=n.substring(r[0].length),this.tokens.push({type:this.options.sanitize?"paragraph":"html",pre:!this.options.sanitizer&&("pre"===r[1]||"script"===r[1]||"style"===r[1]),text:r[0]});else if(e&&(r=this.rules.def.exec(n)))n=n.substring(r[0].length),r[3]&&(r[3]=r[3].substring(1,r[3].length-1)),c=r[1].toLowerCase().replace(/\s+/g," "),this.tokens.links[c]||(this.tokens.links[c]={href:r[2],title:r[3]});else if(e&&(r=this.rules.table.exec(n))&&(a={type:"table",header:p(r[1].replace(/^ *| *\| *$/g,"")),align:r[2].replace(/^ *|\| *$/g,"").split(/ *\| */),cells:r[3]?r[3].replace(/(?: *\| *)?\n$/,"").split("\n"):[]}).header.length===a.align.length){for(n=n.substring(r[0].length),u=0;u<a.align.length;u++)/^ *-+: *$/.test(a.align[u])?a.align[u]="right":/^ *:-+: *$/.test(a.align[u])?a.align[u]="center":/^ *:-+ *$/.test(a.align[u])?a.align[u]="left":a.align[u]=null;for(u=0;u<a.cells.length;u++)a.cells[u]=p(a.cells[u].replace(/^ *\| *| *\| *$/g,""),a.header.length);this.tokens.push(a)}else if(r=this.rules.lheading.exec(n))n=n.substring(r[0].length),this.tokens.push({type:"heading",depth:"="===r[2]?1:2,text:r[1]});else if(e&&(r=this.rules.paragraph.exec(n)))n=n.substring(r[0].length),this.tokens.push({type:"paragraph",text:"\n"===r[1].charAt(r[1].length-1)?r[1].slice(0,-1):r[1]});else if(r=this.rules.text.exec(n))n=n.substring(r[0].length),this.tokens.push({type:"text",text:r[0]});else if(n)throw new Error("Infinite loop on byte: "+n.charCodeAt(0));return this.tokens};var g={escape:/^\\([!"#$%&'()*+,\-.\/:;<=>?@\[\]\\^_`{|}~])/,autolink:/^<(scheme:[^\s\x00-\x1f<>]*|email)>/,url:d,tag:"^comment|^</[a-zA-Z][\\w:-]*\\s*>|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>|^<\\?[\\s\\S]*?\\?>|^<![a-zA-Z]+\\s[\\s\\S]*?>|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>",link:/^!?\[(label)\]\(href(?:\s+(title))?\s*\)/,reflink:/^!?\[(label)\]\[(?!\s*\])((?:\\[\[\]]?|[^\[\]\\])+)\]/,nolink:/^!?\[(?!\s*\])((?:\[[^\[\]]*\]|\\[\[\]]|[^\[\]])*)\](?:\[\])?/,strong:/^__([^\s][\s\S]*?[^\s])__(?!_)|^\*\*([^\s][\s\S]*?[^\s])\*\*(?!\*)|^__([^\s])__(?!_)|^\*\*([^\s])\*\*(?!\*)/,em:/^_([^\s][\s\S]*?[^\s_])_(?!_)|^_([^\s_][\s\S]*?[^\s])_(?!_)|^\*([^\s][\s\S]*?[^\s*])\*(?!\*)|^\*([^\s*][\s\S]*?[^\s])\*(?!\*)|^_([^\s_])_(?!_)|^\*([^\s*])\*(?!\*)/,code:/^(`+)\s*([\s\S]*?[^`]?)\s*\1(?!`)/,br:/^ {2,}\n(?!\s*$)/,del:d,text:/^[\s\S]+?(?=[\\<!\[`*]|\b_| {2,}\n|$)/,_escapes:/\\([!"#$%&'()*+,\-.\/:;<=>?@\[\]\\^_`{|}~])/g,_scheme:/[a-zA-Z][a-zA-Z0-9+.-]{1,31}/,_email:/[a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/};g.autolink=u(g.autolink).replace("scheme",g._scheme).replace("email",g._email).getRegex(),g._attribute=/\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/,g.tag=u(g.tag).replace("comment",f._comment).replace("attribute",g._attribute).getRegex(),g._label=/(?:\[[^\[\]]*\]|\\[\[\]]?|`[^`]*`|[^\[\]\\])*?/,g._href=/\s*(<(?:\\[<>]?|[^\s<>\\])*>|(?:\\[()]?|\([^\s\x00-\x1f()\\]*\)|[^\s\x00-\x1f()\\])*?)/,g._title=/"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/,g.link=u(g.link).replace("label",g._label).replace("href",g._href).replace("title",g._title).getRegex(),g.reflink=u(g.reflink).replace("label",g._label).getRegex(),g.normal=m({},g),g.pedantic=m({},g.normal,{strong:/^__(?=\S)([\s\S]*?\S)__(?!_)|^\*\*(?=\S)([\s\S]*?\S)\*\*(?!\*)/,em:/^_(?=\S)([\s\S]*?\S)_(?!_)|^\*(?=\S)([\s\S]*?\S)\*(?!\*)/,link:u(/^!?\[(label)\]\((.*?)\)/).replace("label",g._label).getRegex(),reflink:u(/^!?\[(label)\]\s*\[([^\]]*)\]/).replace("label",g._label).getRegex()}),g.gfm=m({},g.normal,{escape:u(g.escape).replace("])","~|])").getRegex(),url:u(/^((?:ftp|https?):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/).replace("email",g._email).getRegex(),_backpedal:/(?:[^?!.,:;*_~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_~)]+(?!$))+/,del:/^~~(?=\S)([\s\S]*?\S)~~/,text:u(g.text).replace("]|","~]|").replace("|","|https?://|ftp://|www\\.|[a-zA-Z0-9.!#$%&'*+/=?^_`{\\|}~-]+@|").getRegex()}),g.breaks=m({},g.gfm,{br:u(g.br).replace("{2,}","*").getRegex(),text:u(g.gfm.text).replace("{2,}","*").getRegex()}),i.rules=g,i.output=function(n,e,t){return new i(e,t).output(n)},i.prototype.output=function(n){for(var e,t,r,s,o,l="";n;)if(o=this.rules.escape.exec(n))n=n.substring(o[0].length),l+=o[1];else if(o=this.rules.autolink.exec(n))n=n.substring(o[0].length),r="@"===o[2]?"mailto:"+(t=a(this.mangle(o[1]))):t=a(o[1]),l+=this.renderer.link(r,null,t);else if(this.inLink||!(o=this.rules.url.exec(n))){if(o=this.rules.tag.exec(n))!this.inLink&&/^<a /i.test(o[0])?this.inLink=!0:this.inLink&&/^<\/a>/i.test(o[0])&&(this.inLink=!1),n=n.substring(o[0].length),l+=this.options.sanitize?this.options.sanitizer?this.options.sanitizer(o[0]):a(o[0]):o[0];else if(o=this.rules.link.exec(n))n=n.substring(o[0].length),this.inLink=!0,r=o[2],this.options.pedantic?(e=/^([^'"]*[^\s])\s+(['"])(.*)\2/.exec(r))?(r=e[1],s=e[3]):s="":s=o[3]?o[3].slice(1,-1):"",r=r.trim().replace(/^<([\s\S]*)>$/,"$1"),l+=this.outputLink(o,{href:i.escapes(r),title:i.escapes(s)}),this.inLink=!1;else if((o=this.rules.reflink.exec(n))||(o=this.rules.nolink.exec(n))){if(n=n.substring(o[0].length),e=(o[2]||o[1]).replace(/\s+/g," "),!(e=this.links[e.toLowerCase()])||!e.href){l+=o[0].charAt(0),n=o[0].substring(1)+n;continue}this.inLink=!0,l+=this.outputLink(o,e),this.inLink=!1}else if(o=this.rules.strong.exec(n))n=n.substring(o[0].length),l+=this.renderer.strong(this.output(o[4]||o[3]||o[2]||o[1]));else if(o=this.rules.em.exec(n))n=n.substring(o[0].length),l+=this.renderer.em(this.output(o[6]||o[5]||o[4]||o[3]||o[2]||o[1]));else if(o=this.rules.code.exec(n))n=n.substring(o[0].length),l+=this.renderer.codespan(a(o[2].trim(),!0));else if(o=this.rules.br.exec(n))n=n.substring(o[0].length),l+=this.renderer.br();else if(o=this.rules.del.exec(n))n=n.substring(o[0].length),l+=this.renderer.del(this.output(o[1]));else if(o=this.rules.text.exec(n))n=n.substring(o[0].length),l+=this.renderer.text(a(this.smartypants(o[0])));else if(n)throw new Error("Infinite loop on byte: "+n.charCodeAt(0))}else o[0]=this.rules._backpedal.exec(o[0])[0],n=n.substring(o[0].length),"@"===o[2]?r="mailto:"+(t=a(o[0])):(t=a(o[0]),r="www."===o[1]?"http://"+t:t),l+=this.renderer.link(r,null,t);return l},i.escapes=function(n){return n?n.replace(i.rules._escapes,"$1"):n},i.prototype.outputLink=function(n,e){var t=e.href,i=e.title?a(e.title):null;return"!"!==n[0].charAt(0)?this.renderer.link(t,i,this.output(n[1])):this.renderer.image(t,i,a(n[1]))},i.prototype.smartypants=function(n){return this.options.smartypants?n.replace(/---/g,"—").replace(/--/g,"–").replace(/(^|[-\u2014\/(\[{"\s])'/g,"$1‘").replace(/'/g,"’").replace(/(^|[-\u2014\/(\[{\u2018\s])"/g,"$1“").replace(/"/g,"”").replace(/\.{3}/g,"…"):n},i.prototype.mangle=function(n){if(!this.options.mangle)return n;for(var e,t="",i=n.length,r=0;r<i;r++)e=n.charCodeAt(r),Math.random()>.5&&(e="x"+e.toString(16)),t+="&#"+e+";";return t},r.prototype.code=function(n,e,t){if(this.options.highlight){var i=this.options.highlight(n,e);null!=i&&i!==n&&(t=!0,n=i)}return e?'<pre><code class="'+this.options.langPrefix+a(e,!0)+'">'+(t?n:a(n,!0))+"</code></pre>\n":"<pre><code>"+(t?n:a(n,!0))+"</code></pre>"},r.prototype.blockquote=function(n){return"<blockquote>\n"+n+"</blockquote>\n"},r.prototype.html=function(n){return n},r.prototype.heading=function(n,e,t){return this.options.headerIds?"<h"+e+' id="'+this.options.headerPrefix+t.toLowerCase().replace(/[^\w]+/g,"-")+'">'+n+"</h"+e+">\n":"<h"+e+">"+n+"</h"+e+">\n"},r.prototype.hr=function(){return this.options.xhtml?"<hr/>\n":"<hr>\n"},r.prototype.list=function(n,e,t){var i=e?"ol":"ul";return"<"+i+(e&&1!==t?' start="'+t+'"':"")+">\n"+n+"</"+i+">\n"},r.prototype.listitem=function(n){return"<li>"+n+"</li>\n"},r.prototype.checkbox=function(n){return"<input "+(n?'checked="" ':"")+'disabled="" type="checkbox"'+(this.options.xhtml?" /":"")+"> "},r.prototype.paragraph=function(n){return"<p>"+n+"</p>\n"},r.prototype.table=function(n,e){return e&&(e="<tbody>"+e+"</tbody>"),"<table>\n<thead>\n"+n+"</thead>\n"+e+"</table>\n"},r.prototype.tablerow=function(n){return"<tr>\n"+n+"</tr>\n"},r.prototype.tablecell=function(n,e){var t=e.header?"th":"td";return(e.align?"<"+t+' align="'+e.align+'">':"<"+t+">")+n+"</"+t+">\n"},r.prototype.strong=function(n){return"<strong>"+n+"</strong>"},r.prototype.em=function(n){return"<em>"+n+"</em>"},r.prototype.codespan=function(n){return"<code>"+n+"</code>"},r.prototype.br=function(){return this.options.xhtml?"<br/>":"<br>"},r.prototype.del=function(n){return"<del>"+n+"</del>"},r.prototype.link=function(n,e,t){if(this.options.sanitize){try{var i=decodeURIComponent(l(n)).replace(/[^\w:]/g,"").toLowerCase()}catch(n){return t}if(0===i.indexOf("javascript:")||0===i.indexOf("vbscript:")||0===i.indexOf("data:"))return t}this.options.baseUrl&&!b.test(n)&&(n=c(this.options.baseUrl,n));try{n=encodeURI(n).replace(/%25/g,"%")}catch(n){return t}var r='<a href="'+a(n)+'"';return e&&(r+=' title="'+e+'"'),r+">"+t+"</a>"},r.prototype.image=function(n,e,t){this.options.baseUrl&&!b.test(n)&&(n=c(this.options.baseUrl,n));var i='<img src="'+n+'" alt="'+t+'"';return e&&(i+=' title="'+e+'"'),i+(this.options.xhtml?"/>":">")},r.prototype.text=function(n){return n},s.prototype.strong=s.prototype.em=s.prototype.codespan=s.prototype.del=s.prototype.text=function(n){return n},s.prototype.link=s.prototype.image=function(n,e,t){return""+t},s.prototype.br=function(){return""},o.parse=function(n,e){return new o(e).parse(n)},o.prototype.parse=function(n){this.inline=new i(n.links,this.options),this.inlineText=new i(n.links,m({},this.options,{renderer:new s})),this.tokens=n.reverse();for(var e="";this.next();)e+=this.tok();return e},o.prototype.next=function(){return this.token=this.tokens.pop()},o.prototype.peek=function(){return this.tokens[this.tokens.length-1]||0},o.prototype.parseText=function(){for(var n=this.token.text;"text"===this.peek().type;)n+="\n"+this.next().text;return this.inline.output(n)},o.prototype.tok=function(){switch(this.token.type){case"space":return"";case"hr":return this.renderer.hr();case"heading":return this.renderer.heading(this.inline.output(this.token.text),this.token.depth,l(this.inlineText.output(this.token.text)));case"code":return this.renderer.code(this.token.text,this.token.lang,this.token.escaped);case"table":var n,e,t,i,r="",s="";for(t="",n=0;n<this.token.header.length;n++)t+=this.renderer.tablecell(this.inline.output(this.token.header[n]),{header:!0,align:this.token.align[n]});for(r+=this.renderer.tablerow(t),n=0;n<this.token.cells.length;n++){for(e=this.token.cells[n],t="",i=0;i<e.length;i++)t+=this.renderer.tablecell(this.inline.output(e[i]),{header:!1,align:this.token.align[i]});s+=this.renderer.tablerow(t)}return this.renderer.table(r,s);case"blockquote_start":for(s="";"blockquote_end"!==this.next().type;)s+=this.tok();return this.renderer.blockquote(s);case"list_start":s="";for(var o=this.token.ordered,a=this.token.start;"list_end"!==this.next().type;)s+=this.tok();return this.renderer.list(s,o,a);case"list_item_start":for(s="",this.token.task&&(s+=this.renderer.checkbox(this.token.checked));"list_item_end"!==this.next().type;)s+="text"===this.token.type?this.parseText():this.tok();return this.renderer.listitem(s);case"loose_item_start":for(s="";"list_item_end"!==this.next().type;)s+=this.tok();return this.renderer.listitem(s);case"html":return this.renderer.html(this.token.text);case"paragraph":return this.renderer.paragraph(this.inline.output(this.token.text));case"text":return this.renderer.paragraph(this.parseText())}};var v={},b=/^$|^[a-z][a-z0-9+.-]*:|^[?#]/i;d.exec=d,h.options=h.setOptions=function(n){return m(h.defaults,n),h},h.getDefaults=function(){return{baseUrl:null,breaks:!1,gfm:!0,headerIds:!0,headerPrefix:"",highlight:null,langPrefix:"language-",mangle:!0,pedantic:!1,renderer:new r,sanitize:!1,sanitizer:null,silent:!1,smartLists:!1,smartypants:!1,tables:!0,xhtml:!1}},h.defaults=h.getDefaults(),h.Parser=o,h.parser=o.parse,h.Renderer=r,h.TextRenderer=s,h.Lexer=t,h.lexer=t.lex,h.InlineLexer=i,h.inlineLexer=i.output,h.parse=h,n.exports=h}(this||"undefined"!=typeof window&&window)}).call(e,t(10))},function(n,e){n.exports={name:"valine",version:"1.3.6",description:"A simple comment system based on Leancloud.",main:"/dist/Valine.min.js",author:"xCss <xioveliu@gmail.com> (https://github.com/xCss)",scripts:{test:"webpack",build:"webpack",dev:"webpack-dev-server --env.dev",clean:"rm -rf dist/* "},keywords:["simple","easy-to-use","fast-and-safe","comment-system"],license:"GPL-2.0",repository:{type:"git",url:"git+https://github.com/xcss/Valine.git"},homepage:"https://github.com/xcss/Valine#readme",devDependencies:{autoprefixer:"^7.1.1",autosize:"^4.0.2","babel-core":"^6.25.0","babel-loader":"^7.1.1","babel-polyfill":"^6.23.0","babel-preset-es2015":"^6.24.1","babel-preset-stage-0":"^6.24.1","blueimp-md5":"^2.8.0","css-loader":"^0.28.4","exports-loader":"^0.6.3","file-loader":"^0.11.2",hanabi:"^0.4.0",marked:"^0.4.0","node-sass":"^4.9.2","postcss-loader":"^2.0.5","sass-loader":"^6.0.3","style-loader":"^0.18.2","url-loader":"^0.6.2",webpack:"^2.6.1","webpack-cli":"^3.3.0","webpack-dev-server":"^2.9.1"}}},function(n,e){var t;t=function(){return this}();try{t=t||Function("return this")()||(0,eval)("this")}catch(n){"object"==typeof window&&(t=window)}n.exports=t},function(n,e){n.exports={grinning:"😀",smiley:"😃",smile:"😄",grin:"😁",laughing:"😆",sweat_smile:"😅",joy:"😂",blush:"😊",innocent:"😇",wink:"😉",relieved:"😌",heart_eyes:"😍",kissing_heart:"😘",kissing:"😗",kissing_smiling_eyes:"😙",kissing_closed_eyes:"😚",yum:"😋",stuck_out_tongue_winking_eye:"😜",stuck_out_tongue_closed_eyes:"😝",stuck_out_tongue:"😛",sunglasses:"😎",smirk:"😏",unamused:"😒",disappointed:"😞",pensive:"😔",worried:"😟",confused:"😕",persevere:"😣",confounded:"😖",tired_face:"😫",weary:"😩",angry:"😠",rage:"😡",no_mouth:"😶",neutral_face:"😐",expressionless:"😑",hushed:"😯",frowning:"😦",anguished:"😧",open_mouth:"😮",astonished:"😲",dizzy_face:"😵",flushed:"😳",scream:"😱",fearful:"😨",cold_sweat:"😰",cry:"😢",disappointed_relieved:"😥",sob:"😭",sweat:"😓",sleepy:"😪",sleeping:"😴",mask:"😷",smiling_imp:"😈",smiley_cat:"😺",smile_cat:"😸",joy_cat:"😹",heart_eyes_cat:"😻",smirk_cat:"😼",kissing_cat:"😽",scream_cat:"🙀",crying_cat_face:"😿",pouting_cat:"😾",cat:"🐱",mouse:"🐭",cow:"🐮",monkey_face:"🐵",hand:"✋",fist:"✊",v:"✌️",point_up:"👆",point_down:"👇",point_left:"👈",point_right:"👉",facepunch:"👊",wave:"👋",clap:"👏",open_hands:"👐","+1":"👍","-1":"👎",ok_hand:"👌",pray:"🙏",ear:"👂",eyes:"👀",nose:"👃",lips:"👄",tongue:"👅",heart:"❤️",cupid:"💘",sparkling_heart:"💖",star:"⭐️",sparkles:"✨",zap:"⚡️",sunny:"☀️",cloud:"☁️",snowflake:"❄️",umbrella:"☔️",coffee:"☕️",airplane:"✈️",anchor:"⚓️",watch:"⌚️",phone:"☎️",hourglass:"⌛️",email:"✉️",scissors:"✂️",black_nib:"✒️",pencil2:"✏️",x:"❌",recycle:"♻️",white_check_mark:"✅",negative_squared_cross_mark:"❎",m:"Ⓜ️",i:"ℹ️",tm:"™️",copyright:"©️",registered:"®️"}},function(n,e,t){var i=t(13);"string"==typeof i&&(i=[[n.i,i,""]]);var r={transform:void 0};t(15)(i,r),i.locals&&(n.exports=i.locals)},function(n,e,t){(n.exports=t(14)(!1)).push([n.i,'.v *{-webkit-box-sizing:border-box;box-sizing:border-box;line-height:2;color:#555;-webkit-transition:all .3s ease;transition:all .3s ease}.v hr{margin:.825rem 0;border-color:#f6f6f6;border-style:dashed}.v.hide-avatar .vimg{display:none}.v a{position:relative;cursor:pointer;color:#1abc9c;display:inline-block}.v a:before{content:"";position:absolute;width:0;right:0;bottom:0;height:1px;background:#1abc9c;-webkit-transition:width .3s ease;transition:width .3s ease}.v a:hover{color:#d7191a}.v a:hover:before{width:100%;left:0;right:auto}.v code,.v pre{background-color:#f6f6f6;color:#555;padding:.2em .4em;border-radius:3px;font-size:85%;margin:0;font-family:Source Code Pro,courier new,Input Mono,PT Mono,SFMono-Regular,Consolas,Monaco,Menlo,PingFang SC,Liberation Mono,Microsoft YaHei,Courier，monospace}.v pre{padding:10px;overflow:auto;line-height:1.45}.v pre code{padding:0;background:transparent;white-space:pre-wrap;word-break:keep-all}.v blockquote{color:#666;margin:.5rem 0;padding:0 0 0 1rem;border-left:8px solid hsla(0,0%,93%,.5)}.v .vinput{border:none;resize:none;outline:none;padding:10px 5px;max-width:100%;font-size:.775rem}.v input[type=checkbox],.v input[type=radio]{display:inline-block;vertical-align:middle;margin-top:-2px}.v .vwrap{border:1px solid #f0f0f0;border-radius:4px;margin-bottom:10px;overflow:hidden;position:relative;padding:10px}.v .vwrap input{background:transparent}.v .vwrap .vedit{position:relative;padding-top:10px}.v .vwrap .vedit .vctrl{text-align:right;font-size:12px}.v .vwrap .vedit .vctrl span{padding:10px;display:inline-block;vertical-align:middle;cursor:pointer}.v .vwrap .vedit .vemojis{display:none;font-size:18px;text-align:justify;max-height:145px;overflow:auto;margin-bottom:10px;-webkit-box-shadow:0 0 1px #f0f0f0;box-shadow:0 0 1px #f0f0f0}.v .vwrap .vedit .vemojis i{font-style:normal;padding:7px 0;width:38px;cursor:pointer;text-align:center;display:inline-block;vertical-align:middle}.v .vwrap .vedit .vpreview{padding:7px;-webkit-box-shadow:0 0 1px #f0f0f0;box-shadow:0 0 1px #f0f0f0}.v .vwrap .vedit .vpreview frame,.v .vwrap .vedit .vpreview iframe,.v .vwrap .vedit .vpreview img{max-width:100%;border:none}.v .vwrap .vheader .vinput{width:33.33%;border-bottom:1px dashed #dedede}.v .vwrap .vheader.item2 .vinput{width:50%}.v .vwrap .vheader.item1 .vinput{width:100%}.v .vwrap .vheader .vinput:focus{border-bottom-color:#eb5055}@media screen and (max-width:520px){.v .vwrap .vheader.item2 .vinput,.v .vwrap .vheader .vinput{width:100%}}.v .vwrap .vcontrol{font-size:0;padding-top:15px}.v .vwrap .vcontrol .col{display:inline-block;font-size:.725rem;vertical-align:middle;color:#ccc}.v .vwrap .vcontrol .col.text-right{text-align:right}.v .vwrap .vcontrol .col svg{margin-right:2px;overflow:hidden;fill:currentColor;vertical-align:middle}.v .vwrap .vcontrol .col.col-20{width:20%}.v .vwrap .vcontrol .col.col-40{width:40%}.v .vwrap .vcontrol .col.col-60{width:60%}.v .vwrap .vcontrol .col.col-80{width:80%}.v .vwrap .vcontrol .col.split{width:50%}.v .vwrap .vmark{position:absolute;background:rgba(0,0,0,.65);width:100%;height:100%;left:0;top:0}.v .vwrap .vmark .valert{padding-top:3rem}.v .vwrap .vmark .valert .vtext{color:#fff;padding:1rem 0}.v .vwrap .vmark .valert .vcode{width:4.6875rem;border-radius:.3125rem;padding:.5rem;background:#dedede}.v .vwrap .vmark .valert .vcode:focus{border-color:#3090e4;background-color:#fff}@media screen and (max-width:720px){.v .vwrap .vmark .valert{padding-top:5.5rem}.v .vwrap .vmark .valert .vtext{color:#fff;padding:1rem 0}}.v .power{color:#999;padding:.5rem 0}.v .power,.v .power a{font-size:.75rem}.v .vinfo{font-size:0;padding:5px}.v .vinfo .col{font-size:.875rem;display:inline-block;width:50%;vertical-align:middle}.v .vinfo .vcount .vnum{font-weight:600;font-size:1.25rem}.v a{text-decoration:none;color:#555}.v a:hover{color:#222}.v ol,.v ul{padding:0;margin-left:1.25rem}.v .txt-center{text-align:center}.v .txt-right{text-align:right}.v .pd5{padding:5px}.v .pd10{padding:10px}.v .veditor{width:100%;min-height:8.75rem;font-size:.875rem;background:transparent;resize:vertical;-webkit-transition:all .25s ease;transition:all .25s ease}.v .vbtn{-webkit-transition-duration:.4s;transition-duration:.4s;text-align:center;color:#313131;border:1px solid #ededed;border-radius:.3rem;display:inline-block;background:#ededed;margin-bottom:0;font-weight:400;vertical-align:middle;-ms-touch-action:manipulation;touch-action:manipulation;cursor:pointer;white-space:nowrap;padding:.5rem 1.25rem;font-size:.875rem;line-height:1.42857143;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;outline:none}.v .vbtn+.vbtn{margin-left:1.25rem}.v .vbtn:active,.v .vbtn:hover{color:#3090e4;border-color:#3090e4;background-color:#fff}.v .vempty{padding:1.25rem;text-align:center;color:#999}.v .vlist{width:100%}.v .vlist .vcard{padding-top:1.5rem;position:relative;display:block}.v .vlist .vcard:after{content:"";clear:both;display:block}.v .vlist .vcard .vimg{width:3.125rem;height:3.125rem;float:left;border-radius:50%;margin-right:.7525rem;border:1px solid #f5f5f5;padding:.125rem}@media screen and (max-width:720px){.v .vlist .vcard .vimg{width:2.5rem;height:2.5rem}}.v .vlist .vcard .vhead{line-height:1.5;margin-top:0}.v .vlist .vcard .vhead .vnick{position:relative;font-size:.875rem;font-weight:500;margin-right:.875rem;cursor:pointer;color:#1abc9c;text-decoration:none;display:inline-block}.v .vlist .vcard .vhead .vnick:before{content:"";position:absolute;width:0;right:0;bottom:0;height:1px;background:#1abc9c;-webkit-transition:width .3s ease;transition:width .3s ease}.v .vlist .vcard .vhead .vnick:hover{color:#d7191a}.v .vlist .vcard .vhead .vnick:hover:before{width:100%;left:0;right:auto}.v .vlist .vcard .vhead .vsys{display:inline-block;padding:.2rem .5rem;background:#ededed;color:#b3b1b1;font-size:.75rem;border-radius:.2rem;margin-right:.3rem}@media screen and (max-width:520px){.v .vlist .vcard .vhead .vsys{display:none}}.v .vlist .vcard .vh{overflow:hidden;padding-bottom:.5rem;border-bottom:1px dashed #f5f5f5}.v .vlist .vcard .vh .vtime{color:#b3b3b3;font-size:.75rem;margin-right:.875rem}.v .vlist .vcard .vh .vmeta{line-height:1;position:relative}.v .vlist .vcard .vh .vmeta .vat{font-size:.8125rem;color:#ef2f11;cursor:pointer;float:right}.v .vlist .vcard:last-child .vh{border-bottom:none}.v .vlist .vcard .vcontent{word-wrap:break-word;word-break:break-all;text-align:justify;color:#4a4a4a;font-size:.875rem;line-height:2;position:relative;margin-bottom:.75rem;padding-top:.625rem}.v .vlist .vcard .vcontent frame,.v .vlist .vcard .vcontent iframe,.v .vlist .vcard .vcontent img{max-width:100%;border:none}.v .vlist .vcard .vcontent.expand{cursor:pointer;max-height:11.25rem;overflow:hidden}.v .vlist .vcard .vcontent.expand:before{display:block;content:"";position:absolute;width:100%;left:0;top:0;bottom:3.15rem;pointer-events:none;background:-webkit-gradient(linear,left top,left bottom,from(hsla(0,0%,100%,0)),to(hsla(0,0%,100%,.9)));background:linear-gradient(180deg,hsla(0,0%,100%,0),hsla(0,0%,100%,.9))}.v .vlist .vcard .vcontent.expand:after{display:block;content:"Click on expand";text-align:center;color:#828586;position:absolute;width:100%;height:3.15rem;line-height:3.15rem;left:0;bottom:0;pointer-events:none;background:hsla(0,0%,100%,.9)}.v .vlist .vcard .vquote{color:#666;margin-top:1rem;padding-left:1rem;border-left:1px dashed hsla(0,0%,93%,.5)}.v .vlist .vcard .vquote .vimg{width:2.225rem;height:2.225rem}.v .vpage .vmore{margin:1rem 0}.v .clear{content:"";display:block;clear:both}@-webkit-keyframes spin{0%{-webkit-transform:rotate(0deg);transform:rotate(0deg)}to{-webkit-transform:rotate(1turn);transform:rotate(1turn)}}@keyframes spin{0%{-webkit-transform:rotate(0deg);transform:rotate(0deg)}to{-webkit-transform:rotate(1turn);transform:rotate(1turn)}}@-webkit-keyframes pulse{50%{background:#dcdcdc}}@keyframes pulse{50%{background:#dcdcdc}}.v .vloading{position:relative;padding:20px;display:block;height:80px}.v .vloading:before{-webkit-box-sizing:border-box;box-sizing:border-box;content:"";position:absolute;display:inline-block;top:20px;left:50%;margin-left:-20px;width:40px;height:40px;border:6px double #a0a0a0;border-top-color:transparent;border-bottom-color:transparent;border-radius:50%;-webkit-animation:spin 1s infinite linear;animation:spin 1s infinite linear}',""])},function(n,e){function t(n,e){var t=n[1]||"",i=n[3];if(!i)return t;if(e&&"function"==typeof btoa){var r=function(n){return"/*# sourceMappingURL=data:application/json;charset=utf-8;base64,"+btoa(unescape(encodeURIComponent(JSON.stringify(n))))+" */"}(i);return[t].concat(i.sources.map((function(n){return"/*# sourceURL="+i.sourceRoot+n+" */"}))).concat([r]).join("\n")}return[t].join("\n")}n.exports=function(n){var e=[];return e.toString=function(){return this.map((function(e){var i=t(e,n);return e[2]?"@media "+e[2]+"{"+i+"}":i})).join("")},e.i=function(n,t){"string"==typeof n&&(n=[[null,n,""]]);for(var i={},r=0;r<this.length;r++){var s=this[r][0];"number"==typeof s&&(i[s]=!0)}for(r=0;r<n.length;r++){var o=n[r];"number"==typeof o[0]&&i[o[0]]||(t&&!o[2]?o[2]=t:t&&(o[2]="("+o[2]+") and ("+t+")"),e.push(o))}},e}},function(n,e,t){function i(n,e){for(var t=0;t<n.length;t++){var i=n[t],r=h[i.id];if(r){r.refs++;for(var s=0;s<r.parts.length;s++)r.parts[s](i.parts[s]);for(;s<i.parts.length;s++)r.parts.push(c(i.parts[s],e))}else{var o=[];for(s=0;s<i.parts.length;s++)o.push(c(i.parts[s],e));h[i.id]={id:i.id,refs:1,parts:o}}}}function r(n,e){for(var t=[],i={},r=0;r<n.length;r++){var s=n[r],o=e.base?s[0]+e.base:s[0],a={css:s[1],media:s[2],sourceMap:s[3]};i[o]?i[o].parts.push(a):t.push(i[o]={id:o,parts:[a]})}return t}function s(n,e){var t=g(n.insertInto);if(!t)throw new Error("Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.");var i=x[x.length-1];if("top"===n.insertAt)i?i.nextSibling?t.insertBefore(e,i.nextSibling):t.appendChild(e):t.insertBefore(e,t.firstChild),x.push(e);else{if("bottom"!==n.insertAt)throw new Error("Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.");t.appendChild(e)}}function o(n){if(null===n.parentNode)return!1;n.parentNode.removeChild(n);var e=x.indexOf(n);e>=0&&x.splice(e,1)}function a(n){var e=document.createElement("style");return n.attrs.type="text/css",u(e,n.attrs),s(n,e),e}function l(n){var e=document.createElement("link");return n.attrs.type="text/css",n.attrs.rel="stylesheet",u(e,n.attrs),s(n,e),e}function u(n,e){Object.keys(e).forEach((function(t){n.setAttribute(t,e[t])}))}function c(n,e){var t,i,r,s;if(e.transform&&n.css){if(!(s=e.transform(n.css)))return function(){};n.css=s}if(e.singleton){var u=b++;t=v||(v=a(e)),i=d.bind(null,t,u,!1),r=d.bind(null,t,u,!0)}else n.sourceMap&&"function"==typeof URL&&"function"==typeof URL.createObjectURL&&"function"==typeof URL.revokeObjectURL&&"function"==typeof Blob&&"function"==typeof btoa?(t=l(e),i=p.bind(null,t,e),r=function(){o(t),t.href&&URL.revokeObjectURL(t.href)}):(t=a(e),i=m.bind(null,t),r=function(){o(t)});return i(n),function(e){if(e){if(e.css===n.css&&e.media===n.media&&e.sourceMap===n.sourceMap)return;i(n=e)}else r()}}function d(n,e,t,i){var r=t?"":i.css;if(n.styleSheet)n.styleSheet.cssText=E(e,r);else{var s=document.createTextNode(r),o=n.childNodes;o[e]&&n.removeChild(o[e]),o.length?n.insertBefore(s,o[e]):n.appendChild(s)}}function m(n,e){var t=e.css,i=e.media;if(i&&n.setAttribute("media",i),n.styleSheet)n.styleSheet.cssText=t;else{for(;n.firstChild;)n.removeChild(n.firstChild);n.appendChild(document.createTextNode(t))}}function p(n,e,t){var i=t.css,r=t.sourceMap,s=void 0===e.convertToAbsoluteUrls&&r;(e.convertToAbsoluteUrls||s)&&(i=w(i)),r&&(i+="\n/*# sourceMappingURL=data:application/json;base64,"+btoa(unescape(encodeURIComponent(JSON.stringify(r))))+" */");var o=new Blob([i],{type:"text/css"}),a=n.href;n.href=URL.createObjectURL(o),a&&URL.revokeObjectURL(a)}var h={},f=function(n){var e;return function(){return void 0===e&&(e=n.apply(this,arguments)),e}}((function(){return window&&document&&document.all&&!window.atob})),g=function(n){var e={};return function(t){return void 0===e[t]&&(e[t]=n.call(this,t)),e[t]}}((function(n){return document.querySelector(n)})),v=null,b=0,x=[],w=t(16);n.exports=function(n,e){if("undefined"!=typeof DEBUG&&DEBUG&&"object"!=typeof document)throw new Error("The style-loader cannot be used in a non-browser environment");(e=e||{}).attrs="object"==typeof e.attrs?e.attrs:{},e.singleton||(e.singleton=f()),e.insertInto||(e.insertInto="head"),e.insertAt||(e.insertAt="bottom");var t=r(n,e);return i(t,e),function(n){for(var s=[],o=0;o<t.length;o++){var a=t[o];(l=h[a.id]).refs--,s.push(l)}for(n&&i(r(n,e),e),o=0;o<s.length;o++){var l;if(0===(l=s[o]).refs){for(var u=0;u<l.parts.length;u++)l.parts[u]();delete h[l.id]}}}};var E=function(){var n=[];return function(e,t){return n[e]=t,n.filter(Boolean).join("\n")}}()},function(n,e){n.exports=function(n){var e="undefined"!=typeof window&&window.location;if(!e)throw new Error("fixUrls requires window.location");if(!n||"string"!=typeof n)return n;var t=e.protocol+"//"+e.host,i=t+e.pathname.replace(/\/[^\/]*$/,"/");return n.replace(/url\s*\(((?:[^)(]|\((?:[^)(]+|\([^)(]*\))*\))*)\)/gi,(function(n,e){var r,s=e.trim().replace(/^"(.*)"$/,(function(n,e){return e})).replace(/^'(.*)'$/,(function(n,e){return e}));return/^(#|data:|http:\/\/|https:\/\/|file:\/\/\/)/i.test(s)?n:(r=0===s.indexOf("//")?s:0===s.indexOf("/")?t+s:i+s.replace(/^\.\//,""),"url("+JSON.stringify(r)+")")}))}},function(n,e,t){t(12),n.exports=t(1)}])},function(n,e,t){"undefined"!=typeof self&&self,n.exports=function(n){function e(i){if(t[i])return t[i].exports;var r=t[i]={i:i,l:!1,exports:{}};return n[i].call(r.exports,r,r.exports,e),r.l=!0,r.exports}var t={};return e.m=n,e.c=t,e.d=function(n,t,i){e.o(n,t)||Object.defineProperty(n,t,{configurable:!1,enumerable:!0,get:i})},e.n=function(n){var t=n&&n.__esModule?function(){return n.default}:function(){return n};return e.d(t,"a",t),t},e.o=function(n,e){return Object.prototype.hasOwnProperty.call(n,e)},e.p="",e(e.s=15)}([function(n,e,t){(function(n,t){var i;!function(){var r="object"==typeof self&&self.self===self&&self||"object"==typeof n&&n.global===n&&n||this||{},s=r._,o=Array.prototype,a=Object.prototype,l="undefined"!=typeof Symbol?Symbol.prototype:null,u=o.push,c=o.slice,d=a.toString,m=a.hasOwnProperty,p=Array.isArray,h=Object.keys,f=Object.create,g=function(){},v=function(n){return n instanceof v?n:this instanceof v?void(this._wrapped=n):new v(n)};void 0===e||e.nodeType?r._=v:(void 0!==t&&!t.nodeType&&t.exports&&(e=t.exports=v),e._=v),v.VERSION="1.9.1";var b,x=function(n,e,t){if(void 0===e)return n;switch(null==t?3:t){case 1:return function(t){return n.call(e,t)};case 3:return function(t,i,r){return n.call(e,t,i,r)};case 4:return function(t,i,r,s){return n.call(e,t,i,r,s)}}return function(){return n.apply(e,arguments)}},w=function(n,e,t){return v.iteratee!==b?v.iteratee(n,e):null==n?v.identity:v.isFunction(n)?x(n,e,t):v.isObject(n)&&!v.isArray(n)?v.matcher(n):v.property(n)};v.iteratee=b=function(n,e){return w(n,e,1/0)};var E=function(n,e){return e=null==e?n.length-1:+e,function(){for(var t=Math.max(arguments.length-e,0),i=Array(t),r=0;r<t;r++)i[r]=arguments[r+e];switch(e){case 0:return n.call(this,i);case 1:return n.call(this,arguments[0],i);case 2:return n.call(this,arguments[0],arguments[1],i)}var s=Array(e+1);for(r=0;r<e;r++)s[r]=arguments[r];return s[e]=i,n.apply(this,s)}},y=function(n){if(!v.isObject(n))return{};if(f)return f(n);g.prototype=n;var e=new g;return g.prototype=null,e},k=function(n){return function(e){return null==e?void 0:e[n]}},A=function(n,e){return null!=n&&m.call(n,e)},j=function(n,e){for(var t=e.length,i=0;i<t;i++){if(null==n)return;n=n[e[i]]}return t?n:void 0},_=Math.pow(2,53)-1,N=k("length"),O=function(n){var e=N(n);return"number"==typeof e&&e>=0&&e<=_};v.each=v.forEach=function(n,e,t){var i,r;if(e=x(e,t),O(n))for(i=0,r=n.length;i<r;i++)e(n[i],i,n);else{var s=v.keys(n);for(i=0,r=s.length;i<r;i++)e(n[s[i]],s[i],n)}return n},v.map=v.collect=function(n,e,t){e=w(e,t);for(var i=!O(n)&&v.keys(n),r=(i||n).length,s=Array(r),o=0;o<r;o++){var a=i?i[o]:o;s[o]=e(n[a],a,n)}return s};var B=function(n){var e=function(e,t,i,r){var s=!O(e)&&v.keys(e),o=(s||e).length,a=n>0?0:o-1;for(r||(i=e[s?s[a]:a],a+=n);a>=0&&a<o;a+=n){var l=s?s[a]:a;i=t(i,e[l],l,e)}return i};return function(n,t,i,r){var s=arguments.length>=3;return e(n,x(t,r,4),i,s)}};v.reduce=v.foldl=v.inject=B(1),v.reduceRight=v.foldr=B(-1),v.find=v.detect=function(n,e,t){var i=(O(n)?v.findIndex:v.findKey)(n,e,t);if(void 0!==i&&-1!==i)return n[i]},v.filter=v.select=function(n,e,t){var i=[];return e=w(e,t),v.each(n,(function(n,t,r){e(n,t,r)&&i.push(n)})),i},v.reject=function(n,e,t){return v.filter(n,v.negate(w(e)),t)},v.every=v.all=function(n,e,t){e=w(e,t);for(var i=!O(n)&&v.keys(n),r=(i||n).length,s=0;s<r;s++){var o=i?i[s]:s;if(!e(n[o],o,n))return!1}return!0},v.some=v.any=function(n,e,t){e=w(e,t);for(var i=!O(n)&&v.keys(n),r=(i||n).length,s=0;s<r;s++){var o=i?i[s]:s;if(e(n[o],o,n))return!0}return!1},v.contains=v.includes=v.include=function(n,e,t,i){return O(n)||(n=v.values(n)),("number"!=typeof t||i)&&(t=0),v.indexOf(n,e,t)>=0},v.invoke=E((function(n,e,t){var i,r;return v.isFunction(e)?r=e:v.isArray(e)&&(i=e.slice(0,-1),e=e[e.length-1]),v.map(n,(function(n){var s=r;if(!s){if(i&&i.length&&(n=j(n,i)),null==n)return;s=n[e]}return null==s?s:s.apply(n,t)}))})),v.pluck=function(n,e){return v.map(n,v.property(e))},v.where=function(n,e){return v.filter(n,v.matcher(e))},v.findWhere=function(n,e){return v.find(n,v.matcher(e))},v.max=function(n,e,t){var i,r,s=-1/0,o=-1/0;if(null==e||"number"==typeof e&&"object"!=typeof n[0]&&null!=n)for(var a=0,l=(n=O(n)?n:v.values(n)).length;a<l;a++)null!=(i=n[a])&&i>s&&(s=i);else e=w(e,t),v.each(n,(function(n,t,i){((r=e(n,t,i))>o||r===-1/0&&s===-1/0)&&(s=n,o=r)}));return s},v.min=function(n,e,t){var i,r,s=1/0,o=1/0;if(null==e||"number"==typeof e&&"object"!=typeof n[0]&&null!=n)for(var a=0,l=(n=O(n)?n:v.values(n)).length;a<l;a++)null!=(i=n[a])&&i<s&&(s=i);else e=w(e,t),v.each(n,(function(n,t,i){((r=e(n,t,i))<o||r===1/0&&s===1/0)&&(s=n,o=r)}));return s},v.shuffle=function(n){return v.sample(n,1/0)},v.sample=function(n,e,t){if(null==e||t)return O(n)||(n=v.values(n)),n[v.random(n.length-1)];var i=O(n)?v.clone(n):v.values(n),r=N(i);e=Math.max(Math.min(e,r),0);for(var s=r-1,o=0;o<e;o++){var a=v.random(o,s),l=i[o];i[o]=i[a],i[a]=l}return i.slice(0,e)},v.sortBy=function(n,e,t){var i=0;return e=w(e,t),v.pluck(v.map(n,(function(n,t,r){return{value:n,index:i++,criteria:e(n,t,r)}})).sort((function(n,e){var t=n.criteria,i=e.criteria;if(t!==i){if(t>i||void 0===t)return 1;if(t<i||void 0===i)return-1}return n.index-e.index})),"value")};var S=function(n,e){return function(t,i,r){var s=e?[[],[]]:{};return i=w(i,r),v.each(t,(function(e,r){var o=i(e,r,t);n(s,e,o)})),s}};v.groupBy=S((function(n,e,t){A(n,t)?n[t].push(e):n[t]=[e]})),v.indexBy=S((function(n,e,t){n[t]=e})),v.countBy=S((function(n,e,t){A(n,t)?n[t]++:n[t]=1}));var I=/[^\ud800-\udfff]|[\ud800-\udbff][\udc00-\udfff]|[\ud800-\udfff]/g;v.toArray=function(n){return n?v.isArray(n)?c.call(n):v.isString(n)?n.match(I):O(n)?v.map(n,v.identity):v.values(n):[]},v.size=function(n){return null==n?0:O(n)?n.length:v.keys(n).length},v.partition=S((function(n,e,t){n[t?0:1].push(e)}),!0),v.first=v.head=v.take=function(n,e,t){return null==n||n.length<1?null==e?void 0:[]:null==e||t?n[0]:v.initial(n,n.length-e)},v.initial=function(n,e,t){return c.call(n,0,Math.max(0,n.length-(null==e||t?1:e)))},v.last=function(n,e,t){return null==n||n.length<1?null==e?void 0:[]:null==e||t?n[n.length-1]:v.rest(n,Math.max(0,n.length-e))},v.rest=v.tail=v.drop=function(n,e,t){return c.call(n,null==e||t?1:e)},v.compact=function(n){return v.filter(n,Boolean)};var L=function(n,e,t,i){for(var r=(i=i||[]).length,s=0,o=N(n);s<o;s++){var a=n[s];if(O(a)&&(v.isArray(a)||v.isArguments(a)))if(e)for(var l=0,u=a.length;l<u;)i[r++]=a[l++];else L(a,e,t,i),r=i.length;else t||(i[r++]=a)}return i};v.flatten=function(n,e){return L(n,e,!1)},v.without=E((function(n,e){return v.difference(n,e)})),v.uniq=v.unique=function(n,e,t,i){v.isBoolean(e)||(i=t,t=e,e=!1),null!=t&&(t=w(t,i));for(var r=[],s=[],o=0,a=N(n);o<a;o++){var l=n[o],u=t?t(l,o,n):l;e&&!t?(o&&s===u||r.push(l),s=u):t?v.contains(s,u)||(s.push(u),r.push(l)):v.contains(r,l)||r.push(l)}return r},v.union=E((function(n){return v.uniq(L(n,!0,!0))})),v.intersection=function(n){for(var e=[],t=arguments.length,i=0,r=N(n);i<r;i++){var s=n[i];if(!v.contains(e,s)){var o;for(o=1;o<t&&v.contains(arguments[o],s);o++);o===t&&e.push(s)}}return e},v.difference=E((function(n,e){return e=L(e,!0,!0),v.filter(n,(function(n){return!v.contains(e,n)}))})),v.unzip=function(n){for(var e=n&&v.max(n,N).length||0,t=Array(e),i=0;i<e;i++)t[i]=v.pluck(n,i);return t},v.zip=E(v.unzip),v.object=function(n,e){for(var t={},i=0,r=N(n);i<r;i++)e?t[n[i]]=e[i]:t[n[i][0]]=n[i][1];return t};var C=function(n){return function(e,t,i){t=w(t,i);for(var r=N(e),s=n>0?0:r-1;s>=0&&s<r;s+=n)if(t(e[s],s,e))return s;return-1}};v.findIndex=C(1),v.findLastIndex=C(-1),v.sortedIndex=function(n,e,t,i){for(var r=(t=w(t,i,1))(e),s=0,o=N(n);s<o;){var a=Math.floor((s+o)/2);t(n[a])<r?s=a+1:o=a}return s};var T=function(n,e,t){return function(i,r,s){var o=0,a=N(i);if("number"==typeof s)n>0?o=s>=0?s:Math.max(s+a,o):a=s>=0?Math.min(s+1,a):s+a+1;else if(t&&s&&a)return i[s=t(i,r)]===r?s:-1;if(r!=r)return(s=e(c.call(i,o,a),v.isNaN))>=0?s+o:-1;for(s=n>0?o:a-1;s>=0&&s<a;s+=n)if(i[s]===r)return s;return-1}};v.indexOf=T(1,v.findIndex,v.sortedIndex),v.lastIndexOf=T(-1,v.findLastIndex),v.range=function(n,e,t){null==e&&(e=n||0,n=0),t||(t=e<n?-1:1);for(var i=Math.max(Math.ceil((e-n)/t),0),r=Array(i),s=0;s<i;s++,n+=t)r[s]=n;return r},v.chunk=function(n,e){if(null==e||e<1)return[];for(var t=[],i=0,r=n.length;i<r;)t.push(c.call(n,i,i+=e));return t};var D=function(n,e,t,i,r){if(!(i instanceof e))return n.apply(t,r);var s=y(n.prototype),o=n.apply(s,r);return v.isObject(o)?o:s};v.bind=E((function(n,e,t){if(!v.isFunction(n))throw new TypeError("Bind must be called on a function");var i=E((function(r){return D(n,i,e,this,t.concat(r))}));return i})),v.partial=E((function(n,e){var t=v.partial.placeholder,i=function(){for(var r=0,s=e.length,o=Array(s),a=0;a<s;a++)o[a]=e[a]===t?arguments[r++]:e[a];for(;r<arguments.length;)o.push(arguments[r++]);return D(n,i,this,this,o)};return i})),v.partial.placeholder=v,v.bindAll=E((function(n,e){var t=(e=L(e,!1,!1)).length;if(t<1)throw new Error("bindAll must be passed function names");for(;t--;){var i=e[t];n[i]=v.bind(n[i],n)}})),v.memoize=function(n,e){var t=function(i){var r=t.cache,s=""+(e?e.apply(this,arguments):i);return A(r,s)||(r[s]=n.apply(this,arguments)),r[s]};return t.cache={},t},v.delay=E((function(n,e,t){return setTimeout((function(){return n.apply(null,t)}),e)})),v.defer=v.partial(v.delay,v,1),v.throttle=function(n,e,t){var i,r,s,o,a=0;t||(t={});var l=function(){a=!1===t.leading?0:v.now(),i=null,o=n.apply(r,s),i||(r=s=null)},u=function(){var u=v.now();a||!1!==t.leading||(a=u);var c=e-(u-a);return r=this,s=arguments,c<=0||c>e?(i&&(clearTimeout(i),i=null),a=u,o=n.apply(r,s),i||(r=s=null)):i||!1===t.trailing||(i=setTimeout(l,c)),o};return u.cancel=function(){clearTimeout(i),a=0,i=r=s=null},u},v.debounce=function(n,e,t){var i,r,s=function(e,t){i=null,t&&(r=n.apply(e,t))},o=E((function(o){if(i&&clearTimeout(i),t){var a=!i;i=setTimeout(s,e),a&&(r=n.apply(this,o))}else i=v.delay(s,e,this,o);return r}));return o.cancel=function(){clearTimeout(i),i=null},o},v.wrap=function(n,e){return v.partial(e,n)},v.negate=function(n){return function(){return!n.apply(this,arguments)}},v.compose=function(){var n=arguments,e=n.length-1;return function(){for(var t=e,i=n[e].apply(this,arguments);t--;)i=n[t].call(this,i);return i}},v.after=function(n,e){return function(){if(--n<1)return e.apply(this,arguments)}},v.before=function(n,e){var t;return function(){return--n>0&&(t=e.apply(this,arguments)),n<=1&&(e=null),t}},v.once=v.partial(v.before,2),v.restArguments=E;var q=!{toString:null}.propertyIsEnumerable("toString"),P=["valueOf","isPrototypeOf","toString","propertyIsEnumerable","hasOwnProperty","toLocaleString"],M=function(n,e){var t=P.length,i=n.constructor,r=v.isFunction(i)&&i.prototype||a,s="constructor";for(A(n,s)&&!v.contains(e,s)&&e.push(s);t--;)(s=P[t])in n&&n[s]!==r[s]&&!v.contains(e,s)&&e.push(s)};v.keys=function(n){if(!v.isObject(n))return[];if(h)return h(n);var e=[];for(var t in n)A(n,t)&&e.push(t);return q&&M(n,e),e},v.allKeys=function(n){if(!v.isObject(n))return[];var e=[];for(var t in n)e.push(t);return q&&M(n,e),e},v.values=function(n){for(var e=v.keys(n),t=e.length,i=Array(t),r=0;r<t;r++)i[r]=n[e[r]];return i},v.mapObject=function(n,e,t){e=w(e,t);for(var i=v.keys(n),r=i.length,s={},o=0;o<r;o++){var a=i[o];s[a]=e(n[a],a,n)}return s},v.pairs=function(n){for(var e=v.keys(n),t=e.length,i=Array(t),r=0;r<t;r++)i[r]=[e[r],n[e[r]]];return i},v.invert=function(n){for(var e={},t=v.keys(n),i=0,r=t.length;i<r;i++)e[n[t[i]]]=t[i];return e},v.functions=v.methods=function(n){var e=[];for(var t in n)v.isFunction(n[t])&&e.push(t);return e.sort()};var F=function(n,e){return function(t){var i=arguments.length;if(e&&(t=Object(t)),i<2||null==t)return t;for(var r=1;r<i;r++)for(var s=arguments[r],o=n(s),a=o.length,l=0;l<a;l++){var u=o[l];e&&void 0!==t[u]||(t[u]=s[u])}return t}};v.extend=F(v.allKeys),v.extendOwn=v.assign=F(v.keys),v.findKey=function(n,e,t){e=w(e,t);for(var i,r=v.keys(n),s=0,o=r.length;s<o;s++)if(e(n[i=r[s]],i,n))return i};var z,R,$=function(n,e,t){return e in t};v.pick=E((function(n,e){var t={},i=e[0];if(null==n)return t;v.isFunction(i)?(e.length>1&&(i=x(i,e[1])),e=v.allKeys(n)):(i=$,e=L(e,!1,!1),n=Object(n));for(var r=0,s=e.length;r<s;r++){var o=e[r],a=n[o];i(a,o,n)&&(t[o]=a)}return t})),v.omit=E((function(n,e){var t,i=e[0];return v.isFunction(i)?(i=v.negate(i),e.length>1&&(t=e[1])):(e=v.map(L(e,!1,!1),String),i=function(n,t){return!v.contains(e,t)}),v.pick(n,i,t)})),v.defaults=F(v.allKeys,!0),v.create=function(n,e){var t=y(n);return e&&v.extendOwn(t,e),t},v.clone=function(n){return v.isObject(n)?v.isArray(n)?n.slice():v.extend({},n):n},v.tap=function(n,e){return e(n),n},v.isMatch=function(n,e){var t=v.keys(e),i=t.length;if(null==n)return!i;for(var r=Object(n),s=0;s<i;s++){var o=t[s];if(e[o]!==r[o]||!(o in r))return!1}return!0},z=function(n,e,t,i){if(n===e)return 0!==n||1/n==1/e;if(null==n||null==e)return!1;if(n!=n)return e!=e;var r=typeof n;return("function"===r||"object"===r||"object"==typeof e)&&R(n,e,t,i)},R=function(n,e,t,i){n instanceof v&&(n=n._wrapped),e instanceof v&&(e=e._wrapped);var r=d.call(n);if(r!==d.call(e))return!1;switch(r){case"[object RegExp]":case"[object String]":return""+n==""+e;case"[object Number]":return+n!=+n?+e!=+e:0==+n?1/+n==1/e:+n==+e;case"[object Date]":case"[object Boolean]":return+n==+e;case"[object Symbol]":return l.valueOf.call(n)===l.valueOf.call(e)}var s="[object Array]"===r;if(!s){if("object"!=typeof n||"object"!=typeof e)return!1;var o=n.constructor,a=e.constructor;if(o!==a&&!(v.isFunction(o)&&o instanceof o&&v.isFunction(a)&&a instanceof a)&&"constructor"in n&&"constructor"in e)return!1}i=i||[];for(var u=(t=t||[]).length;u--;)if(t[u]===n)return i[u]===e;if(t.push(n),i.push(e),s){if((u=n.length)!==e.length)return!1;for(;u--;)if(!z(n[u],e[u],t,i))return!1}else{var c,m=v.keys(n);if(u=m.length,v.keys(e).length!==u)return!1;for(;u--;)if(c=m[u],!A(e,c)||!z(n[c],e[c],t,i))return!1}return t.pop(),i.pop(),!0},v.isEqual=function(n,e){return z(n,e)},v.isEmpty=function(n){return null==n||(O(n)&&(v.isArray(n)||v.isString(n)||v.isArguments(n))?0===n.length:0===v.keys(n).length)},v.isElement=function(n){return!(!n||1!==n.nodeType)},v.isArray=p||function(n){return"[object Array]"===d.call(n)},v.isObject=function(n){var e=typeof n;return"function"===e||"object"===e&&!!n},v.each(["Arguments","Function","String","Number","Date","RegExp","Error","Symbol","Map","WeakMap","Set","WeakSet"],(function(n){v["is"+n]=function(e){return d.call(e)==="[object "+n+"]"}})),v.isArguments(arguments)||(v.isArguments=function(n){return A(n,"callee")});var U=r.document&&r.document.childNodes;"object"!=typeof Int8Array&&"function"!=typeof U&&(v.isFunction=function(n){return"function"==typeof n||!1}),v.isFinite=function(n){return!v.isSymbol(n)&&isFinite(n)&&!isNaN(parseFloat(n))},v.isNaN=function(n){return v.isNumber(n)&&isNaN(n)},v.isBoolean=function(n){return!0===n||!1===n||"[object Boolean]"===d.call(n)},v.isNull=function(n){return null===n},v.isUndefined=function(n){return void 0===n},v.has=function(n,e){if(!v.isArray(e))return A(n,e);for(var t=e.length,i=0;i<t;i++){var r=e[i];if(null==n||!m.call(n,r))return!1;n=n[r]}return!!t},v.noConflict=function(){return r._=s,this},v.identity=function(n){return n},v.constant=function(n){return function(){return n}},v.noop=function(){},v.property=function(n){return v.isArray(n)?function(e){return j(e,n)}:k(n)},v.propertyOf=function(n){return null==n?function(){}:function(e){return v.isArray(e)?j(n,e):n[e]}},v.matcher=v.matches=function(n){return n=v.extendOwn({},n),function(e){return v.isMatch(e,n)}},v.times=function(n,e,t){var i=Array(Math.max(0,n));e=x(e,t,1);for(var r=0;r<n;r++)i[r]=e(r);return i},v.random=function(n,e){return null==e&&(e=n,n=0),n+Math.floor(Math.random()*(e-n+1))},v.now=Date.now||function(){return(new Date).getTime()};var H={"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#x27;","`":"&#x60;"},V=v.invert(H),W=function(n){var e=function(e){return n[e]},t="(?:"+v.keys(n).join("|")+")",i=RegExp(t),r=RegExp(t,"g");return function(n){return n=null==n?"":""+n,i.test(n)?n.replace(r,e):n}};v.escape=W(H),v.unescape=W(V),v.result=function(n,e,t){v.isArray(e)||(e=[e]);var i=e.length;if(!i)return v.isFunction(t)?t.call(n):t;for(var r=0;r<i;r++){var s=null==n?void 0:n[e[r]];void 0===s&&(s=t,r=i),n=v.isFunction(s)?s.call(n):s}return n};var K=0;v.uniqueId=function(n){var e=++K+"";return n?n+e:e},v.templateSettings={evaluate:/<%([\s\S]+?)%>/g,interpolate:/<%=([\s\S]+?)%>/g,escape:/<%-([\s\S]+?)%>/g};var Q=/(.)^/,G={"'":"'","\\":"\\","\r":"r","\n":"n","\u2028":"u2028","\u2029":"u2029"},Z=/\\|'|\r|\n|\u2028|\u2029/g,J=function(n){return"\\"+G[n]};v.template=function(n,e,t){!e&&t&&(e=t),e=v.defaults({},e,v.templateSettings);var i,r=RegExp([(e.escape||Q).source,(e.interpolate||Q).source,(e.evaluate||Q).source].join("|")+"|$","g"),s=0,o="__p+='";n.replace(r,(function(e,t,i,r,a){return o+=n.slice(s,a).replace(Z,J),s=a+e.length,t?o+="'+\n((__t=("+t+"))==null?'':_.escape(__t))+\n'":i?o+="'+\n((__t=("+i+"))==null?'':__t)+\n'":r&&(o+="';\n"+r+"\n__p+='"),e})),o+="';\n",e.variable||(o="with(obj||{}){\n"+o+"}\n"),o="var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};\n"+o+"return __p;\n";try{i=new Function(e.variable||"obj","_",o)}catch(n){throw n.source=o,n}var a=function(n){return i.call(this,n,v)};return a.source="function("+(e.variable||"obj")+"){\n"+o+"}",a},v.chain=function(n){var e=v(n);return e._chain=!0,e};var X=function(n,e){return n._chain?v(e).chain():e};v.mixin=function(n){return v.each(v.functions(n),(function(e){var t=v[e]=n[e];v.prototype[e]=function(){var n=[this._wrapped];return u.apply(n,arguments),X(this,t.apply(v,n))}})),v},v.mixin(v),v.each(["pop","push","reverse","shift","sort","splice","unshift"],(function(n){var e=o[n];v.prototype[n]=function(){var t=this._wrapped;return e.apply(t,arguments),"shift"!==n&&"splice"!==n||0!==t.length||delete t[0],X(this,t)}})),v.each(["concat","join","slice"],(function(n){var e=o[n];v.prototype[n]=function(){return X(this,e.apply(this._wrapped,arguments))}})),v.prototype.value=function(){return this._wrapped},v.prototype.valueOf=v.prototype.toJSON=v.prototype.value,v.prototype.toString=function(){return String(this._wrapped)},void 0!==(i=function(){return v}.apply(e,[]))&&(t.exports=i)}()}).call(e,t(7),t(17)(n))},function(n,e,t){"use strict";var i=t(29).Promise;i._continueWhile=function(n,e){return n()?e().then((function(){return i._continueWhile(n,e)})):i.resolve()},n.exports=i},function(n,e,t){"use strict";var i=t(0),r=t(44),s=t(0).extend,o=t(1),a=t(5),l=t(3),u=l.getSessionToken,c=l.ajax,d=function(n,e){var t=(new Date).getTime(),i=r(t+n);return e?i+","+t+",master":i+","+t},m=function(n,e){e?n["X-LC-Sign"]=d(a.applicationKey):n["X-LC-Key"]=a.applicationKey},p=function(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},e=arguments[1],t={"X-LC-Id":a.applicationId,"Content-Type":"application/json;charset=UTF-8"},i=!1;return"boolean"==typeof n.useMasterKey?i=n.useMasterKey:"boolean"==typeof a._config.useMasterKey&&(i=a._config.useMasterKey),i?a.masterKey?e?t["X-LC-Sign"]=d(a.masterKey,!0):t["X-LC-Key"]=a.masterKey+",master":(console.warn("masterKey is not set, fall back to use appKey"),m(t,e)):m(t,e),a.hookKey&&(t["X-LC-Hook-Key"]=a.hookKey),null!==a._config.production&&(t["X-LC-Prod"]=String(a._config.production)),t["X-LC-UA"]=a._sharedConfig.userAgent,o.resolve().then((function(){var e=u(n);if(e)t["X-LC-Session"]=e;else if(!a._config.disableCurrentUser)return a.User.currentAsync().then((function(n){return n&&n._sessionToken&&(t["X-LC-Session"]=n._sessionToken),t}));return t}))},h=function(n){var e=n.service,t=n.version,r=n.method,s=n.path,o=n.query,l=n.data,u=n.authOptions,d=n.signKey,m=void 0===d||d;if(!a.applicationId||!a.applicationKey&&!a.masterKey)throw new Error("Not initialized");a._appRouter.refresh();var h=a._config.requestTimeout,f=function(n){var e=n.service,t=void 0===e?"api":e,i=n.version,r=void 0===i?"1.1":i,s=n.path,o=a._config.serverURLs[t];if(!o)throw new Error("undefined server URL for "+t);return"/"!==o.charAt(o.length-1)&&(o+="/"),o+=r,s&&(o+=s),o}({service:e,path:s,version:t});return p(u,m).then((function(n){return c({method:r,url:f,query:o,data:l,headers:n,timeout:h}).catch((function(n){var e={code:n.code||-1,error:n.message||n.responseText};if(n.response&&n.response.code)e=n.response;else if(n.responseText)try{e=JSON.parse(n.responseText)}catch(n){}e.rawMessage=e.rawMessage||e.error,a._sharedConfig.keepErrorRawMessage||(e.error+=" ["+(n.statusCode||"N/A")+" "+r+" "+f+"]");var t=new Error(e.error);throw delete e.error,i.extend(t,e)}))}))};a.request=h,n.exports={_request:function(n,e,t,i,r,o,a){var l="";if(n&&(l+="/"+n),e&&(l+="/"+e),t&&(l+="/"+t),r&&r._fetchWhenSave)throw new Error("_fetchWhenSave should be in the query");if(r&&r._where)throw new Error("_where should be in the query");return i&&"get"===i.toLowerCase()&&(a=s({},a,r),r=null),h({method:i,path:l,query:a,data:r,authOptions:o})},request:h}},function(n,e,t){"use strict";var i="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(n){return typeof n}:function(n){return n&&"function"==typeof Symbol&&n.constructor===Symbol&&n!==Symbol.prototype?"symbol":typeof n},r=t(0),s=t(8),o=t(6),a=o("leancloud:request"),l=o("leancloud:request:error"),u=t(1),c=0,d=function(n){return r.isArray(n)?n:null==n?[]:[n]},m=function(){};n.exports={ajax:function(n){var e=n.method,t=n.url,r=n.query,d=n.data,m=n.headers,p=void 0===m?{}:m,h=n.onprogress,f=n.timeout,g={};if(r)for(var v in r){var b=r[v];void 0!==b&&("object"===(void 0===b?"undefined":i(b))?g[v]=JSON.stringify(b):g[v]=b)}var x=c++;return a("request(%d) %s %s %o %o %o",x,e,t,g,d,p),new u((function(n,i){var u=s(e,t).set(p).query(g).send(d);h&&u.on("progress",h),f&&u.timeout(f),u.end((function(s,u){return s?(u&&(o.enabled("leancloud:request")||l("request(%d) %s %s %o %o %o",x,e,t,r,d,p),l("response(%d) %d %O %o",x,u.status,u.body||u.text,u.header),s.statusCode=u.status,s.responseText=u.text,s.response=u.body),i(s)):(a("response(%d) %d %O %o",x,u.status,u.body||u.text,u.header),n(u.body))}))}))},isNullOrUndefined:function(n){return r.isNull(n)||r.isUndefined(n)},ensureArray:d,transformFetchOptions:function(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},e=n.keys,t=n.include,i=n.includeACL,r={};return e&&(r.keys=d(e).join(",")),t&&(r.include=d(t).join(",")),i&&(r.returnACL=i),r},getSessionToken:function(n){return n.sessionToken?n.sessionToken:n.user&&"function"==typeof n.user.getSessionToken?n.user.getSessionToken():void 0},tap:function(n){return function(e){return n(e),e}},inherits:function(n,e,t){var i;return i=e&&e.hasOwnProperty("constructor")?e.constructor:function(){n.apply(this,arguments)},r.extend(i,n),m.prototype=n.prototype,i.prototype=new m,e&&r.extend(i.prototype,e),t&&r.extend(i,t),i.prototype.constructor=i,i.__super__=n.prototype,i},parseDate:function(n){var e=new RegExp("^([0-9]{1,4})-([0-9]{1,2})-([0-9]{1,2})T([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2})(.([0-9]+))?Z$").exec(n);if(!e)return null;var t=e[1]||0,i=(e[2]||1)-1,r=e[3]||0,s=e[4]||0,o=e[5]||0,a=e[6]||0,l=e[8]||0;return new Date(Date.UTC(t,i,r,s,o,a,l))},setValue:function(n,e,t){var i=e.split("."),r=i.pop(),s=n;return i.forEach((function(n){void 0===s[n]&&(s[n]={}),s=s[n]})),s[r]=t,n},findValue:function(n,e){for(var t=e.split("."),i=t[0],r=t.pop(),s=n,o=0;o<t.length;o++)if(void 0===(s=s[t[o]]))return[void 0,void 0,r];return[s[r],s,r,i]},isPlainObject:function(n){return r.isObject(n)&&Object.getPrototypeOf(n)===Object.prototype}}},function(n,e,t){"use strict";function i(n,e){var t=new Error(e);return t.code=n,t}t(0).extend(i,{OTHER_CAUSE:-1,INTERNAL_SERVER_ERROR:1,CONNECTION_FAILED:100,OBJECT_NOT_FOUND:101,INVALID_QUERY:102,INVALID_CLASS_NAME:103,MISSING_OBJECT_ID:104,INVALID_KEY_NAME:105,INVALID_POINTER:106,INVALID_JSON:107,COMMAND_UNAVAILABLE:108,NOT_INITIALIZED:109,INCORRECT_TYPE:111,INVALID_CHANNEL_NAME:112,PUSH_MISCONFIGURED:115,OBJECT_TOO_LARGE:116,OPERATION_FORBIDDEN:119,CACHE_MISS:120,INVALID_NESTED_KEY:121,INVALID_FILE_NAME:122,INVALID_ACL:123,TIMEOUT:124,INVALID_EMAIL_ADDRESS:125,MISSING_CONTENT_TYPE:126,MISSING_CONTENT_LENGTH:127,INVALID_CONTENT_LENGTH:128,FILE_TOO_LARGE:129,FILE_SAVE_ERROR:130,FILE_DELETE_ERROR:153,DUPLICATE_VALUE:137,INVALID_ROLE_NAME:139,EXCEEDED_QUOTA:140,SCRIPT_FAILED:141,VALIDATION_ERROR:142,INVALID_IMAGE_DATA:150,UNSAVED_FILE_ERROR:151,INVALID_PUSH_TIME_ERROR:152,USERNAME_MISSING:200,PASSWORD_MISSING:201,USERNAME_TAKEN:202,EMAIL_TAKEN:203,EMAIL_MISSING:204,EMAIL_NOT_FOUND:205,SESSION_MISSING:206,MUST_CREATE_USER_THROUGH_SIGNUP:207,ACCOUNT_ALREADY_LINKED:208,LINKED_ID_MISSING:250,INVALID_LINKED_SESSION:251,UNSUPPORTED_SERVICE:252,X_DOMAIN_REQUEST:602}),n.exports=i},function(n,e,t){"use strict";(function(e){var i=t(0),r=t(9),s=t(20),o=t(3),a=o.inherits,l=o.parseDate,u=t(1),c=e.AV||{};c._config={serverURLs:{},useMasterKey:!1,production:null,realtime:null,requestTimeout:null},c._sharedConfig={userAgent:s,liveQueryRealtime:null},c._getAVPath=function(n){if(!c.applicationId)throw new Error("You need to call AV.initialize before using AV.");if(n||(n=""),!i.isString(n))throw new Error("Tried to get a localStorage path that wasn't a String.");return"/"===n[0]&&(n=n.substring(1)),"AV/"+c.applicationId+"/"+n},c._installationId=null,c._getInstallationId=function(){if(c._installationId)return u.resolve(c._installationId);var n=c._getAVPath("installationId");return c.localStorage.getItemAsync(n).then((function(e){return c._installationId=e,c._installationId?e:(c._installationId=e=r(),c.localStorage.setItemAsync(n,e).then((function(){return e})))}))},c._subscriptionId=null,c._refreshSubscriptionId=function(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:c._getAVPath("subscriptionId"),e=c._subscriptionId=r();return c.localStorage.setItemAsync(n,e).then((function(){return e}))},c._getSubscriptionId=function(){if(c._subscriptionId)return u.resolve(c._subscriptionId);var n=c._getAVPath("subscriptionId");return c.localStorage.getItemAsync(n).then((function(e){return c._subscriptionId=e,c._subscriptionId||(e=c._refreshSubscriptionId(n)),e}))},c._parseDate=l,c._extend=function(n,e){var t=a(this,n,e);return t.extend=this.extend,t},c._encode=function(n,e,t){var r=!(arguments.length>3&&void 0!==arguments[3])||arguments[3];if(n instanceof c.Object){if(t)throw new Error("AV.Objects not allowed here");return e&&!i.include(e,n)&&n._hasData?n._toFullJSON(e.concat(n),r):n._toPointer()}if(n instanceof c.ACL)return n.toJSON();if(i.isDate(n))return r?{__type:"Date",iso:n.toJSON()}:n.toJSON();if(n instanceof c.GeoPoint)return n.toJSON();if(i.isArray(n))return i.map(n,(function(n){return c._encode(n,e,t,r)}));if(i.isRegExp(n))return n.source;if(n instanceof c.Relation)return n.toJSON();if(n instanceof c.Op)return n.toJSON();if(n instanceof c.File){if(!n.url()&&!n.id)throw new Error("Tried to save an object containing an unsaved file.");return n._toFullJSON(e,r)}return i.isObject(n)?i.mapObject(n,(function(n,i){return c._encode(n,e,t,r)})):n},c._decode=function(n,e){if(!i.isObject(n)||i.isDate(n))return n;if(i.isArray(n))return i.map(n,(function(n){return c._decode(n)}));if(n instanceof c.Object)return n;if(n instanceof c.File)return n;if(n instanceof c.Op)return n;if(n instanceof c.GeoPoint)return n;if(n instanceof c.ACL)return n;if("ACL"===e)return new c.ACL(n);if(n.__op)return c.Op._decode(n);var t;if("Pointer"===n.__type){t=n.className;var r=c.Object._create(t);if(Object.keys(n).length>3){var s=i.clone(n);delete s.__type,delete s.className,r._finishFetch(s,!0)}else r._finishFetch({objectId:n.objectId},!1);return r}if("Object"===n.__type){t=n.className;var o=i.clone(n);delete o.__type,delete o.className;var a=c.Object._create(t);return a._finishFetch(o,!0),a}if("Date"===n.__type)return c._parseDate(n.iso);if("GeoPoint"===n.__type)return new c.GeoPoint({latitude:n.latitude,longitude:n.longitude});if("Relation"===n.__type){if(!e)throw new Error("key missing decoding a Relation");var l=new c.Relation(null,e);return l.targetClassName=n.className,l}if("File"===n.__type){var u=new c.File(n.name),d=i.clone(n);return delete d.__type,u._finishFetch(d),u}return i.mapObject(n,c._decode)},c.parseJSON=c._decode,c._encodeObjectOrArray=function(n){var e=function(n){return n&&n._toFullJSON&&(n=n._toFullJSON([])),i.mapObject(n,(function(n){return c._encode(n,[])}))};return i.isArray(n)?n.map((function(n){return e(n)})):e(n)},c._arrayEach=i.each,c._traverse=function(n,e,t){if(n instanceof c.Object){if(t=t||[],i.indexOf(t,n)>=0)return;return t.push(n),c._traverse(n.attributes,e,t),e(n)}return n instanceof c.Relation||n instanceof c.File?e(n):i.isArray(n)?(i.each(n,(function(i,r){var s=c._traverse(i,e,t);s&&(n[r]=s)})),e(n)):i.isObject(n)?(c._each(n,(function(i,r){var s=c._traverse(i,e,t);s&&(n[r]=s)})),e(n)):e(n)},c._objectEach=c._each=function(n,e){i.isObject(n)?i.each(i.keys(n),(function(t){e(n[t],t)})):i.each(n,e)},n.exports=c}).call(e,t(7))},function(n,e,t){"use strict";function i(n){return(i="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(n){return typeof n}:function(n){return n&&"function"==typeof Symbol&&n.constructor===Symbol&&n!==Symbol.prototype?"symbol":typeof n})(n)}e.log=function(){var n;return"object"===("undefined"==typeof console?"undefined":i(console))&&console.log&&(n=console).log.apply(n,arguments)},e.formatArgs=function(e){if(e[0]=(this.useColors?"%c":"")+this.namespace+(this.useColors?" %c":" ")+e[0]+(this.useColors?"%c ":" ")+"+"+n.exports.humanize(this.diff),this.useColors){var t="color: "+this.color;e.splice(1,0,t,"color: inherit");var i=0,r=0;e[0].replace(/%[a-zA-Z%]/g,(function(n){"%%"!==n&&(i++,"%c"===n&&(r=i))})),e.splice(r,0,t)}},e.save=function(n){try{n?e.storage.setItem("debug",n):e.storage.removeItem("debug")}catch(n){}},e.load=function(){var n;try{n=e.storage.getItem("debug")}catch(n){}return!n&&"undefined"!=typeof process&&"env"in process&&(n=process.env.DEBUG),n},e.useColors=function(){return!("undefined"==typeof window||!window.process||"renderer"!==window.process.type&&!window.process.__nwjs)||("undefined"==typeof navigator||!navigator.userAgent||!navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/))&&("undefined"!=typeof document&&document.documentElement&&document.documentElement.style&&document.documentElement.style.WebkitAppearance||"undefined"!=typeof window&&window.console&&(window.console.firebug||window.console.exception&&window.console.table)||"undefined"!=typeof navigator&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)&&parseInt(RegExp.$1,10)>=31||"undefined"!=typeof navigator&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/))},e.storage=function(){try{return localStorage}catch(n){}}(),e.colors=["#0000CC","#0000FF","#0033CC","#0033FF","#0066CC","#0066FF","#0099CC","#0099FF","#00CC00","#00CC33","#00CC66","#00CC99","#00CCCC","#00CCFF","#3300CC","#3300FF","#3333CC","#3333FF","#3366CC","#3366FF","#3399CC","#3399FF","#33CC00","#33CC33","#33CC66","#33CC99","#33CCCC","#33CCFF","#6600CC","#6600FF","#6633CC","#6633FF","#66CC00","#66CC33","#9900CC","#9900FF","#9933CC","#9933FF","#99CC00","#99CC33","#CC0000","#CC0033","#CC0066","#CC0099","#CC00CC","#CC00FF","#CC3300","#CC3333","#CC3366","#CC3399","#CC33CC","#CC33FF","#CC6600","#CC6633","#CC9900","#CC9933","#CCCC00","#CCCC33","#FF0000","#FF0033","#FF0066","#FF0099","#FF00CC","#FF00FF","#FF3300","#FF3333","#FF3366","#FF3399","#FF33CC","#FF33FF","#FF6600","#FF6633","#FF9900","#FF9933","#FFCC00","#FFCC33"],n.exports=t(27)(e),n.exports.formatters.j=function(n){try{return JSON.stringify(n)}catch(n){return"[UnexpectedJSONParseError]: "+n.message}}},function(n,e){var t;t=function(){return this}();try{t=t||Function("return this")()||(0,eval)("this")}catch(n){"object"==typeof window&&(t=window)}n.exports=t},function(n,e,t){function i(){}function r(n){if(!h(n))return n;var e=[];for(var t in n)s(e,t,n[t]);return e.join("&")}function s(n,e,t){if(null!=t)if(Array.isArray(t))t.forEach((function(t){s(n,e,t)}));else if(h(t))for(var i in t)s(n,e+"["+i+"]",t[i]);else n.push(encodeURIComponent(e)+"="+encodeURIComponent(t));else null===t&&n.push(encodeURIComponent(e))}function o(n){for(var e,t,i={},r=n.split("&"),s=0,o=r.length;s<o;++s)-1==(t=(e=r[s]).indexOf("="))?i[decodeURIComponent(e)]="":i[decodeURIComponent(e.slice(0,t))]=decodeURIComponent(e.slice(t+1));return i}function a(n){return/[\/+]json($|[^-\w])/.test(n)}function l(n){this.req=n,this.xhr=this.req.xhr,this.text="HEAD"!=this.req.method&&(""===this.xhr.responseType||"text"===this.xhr.responseType)||void 0===this.xhr.responseType?this.xhr.responseText:null,this.statusText=this.req.xhr.statusText;var e=this.xhr.status;1223===e&&(e=204),this._setStatusProperties(e),this.header=this.headers=function(n){for(var e,t,i,r,s=n.split(/\r?\n/),o={},a=0,l=s.length;a<l;++a)-1!==(e=(t=s[a]).indexOf(":"))&&(i=t.slice(0,e).toLowerCase(),r=b(t.slice(e+1)),o[i]=r);return o}(this.xhr.getAllResponseHeaders()),this.header["content-type"]=this.xhr.getResponseHeader("content-type"),this._setHeaderProperties(this.header),null===this.text&&n._responseType?this.body=this.xhr.response:this.body="HEAD"!=this.req.method?this._parseBody(this.text?this.text:this.xhr.response):null}function u(n,e){var t=this;this._query=this._query||[],this.method=n,this.url=e,this.header={},this._header={},this.on("end",(function(){var n,e=null,i=null;try{i=new l(t)}catch(i){return(e=new Error("Parser is unable to parse the response")).parse=!0,e.original=i,t.xhr?(e.rawResponse=void 0===t.xhr.responseType?t.xhr.responseText:t.xhr.response,e.status=t.xhr.status?t.xhr.status:null,e.statusCode=e.status):(e.rawResponse=null,e.status=null),t.callback(e)}t.emit("response",i);try{t._isResponseOK(i)||(n=new Error(i.statusText||"Unsuccessful HTTP response"))}catch(e){n=e}n?(n.original=e,n.response=i,n.status=i.status,t.callback(n,i)):t.callback(null,i)}))}function c(n,e,t){var i=v("DELETE",n);return"function"==typeof e&&(t=e,e=null),e&&i.send(e),t&&i.end(t),i}var d;"undefined"!=typeof window?d=window:"undefined"!=typeof self?d=self:(console.warn("Using browser-only version of superagent in non-browser environment"),d=this);var m=t(22),p=t(23),h=t(11),f=t(24),g=t(26),v=e=n.exports=function(n,t){return"function"==typeof t?new e.Request("GET",n).end(t):1==arguments.length?new e.Request("GET",n):new e.Request(n,t)};e.Request=u,v.getXHR=function(){if(!(!d.XMLHttpRequest||d.location&&"file:"==d.location.protocol&&d.ActiveXObject))return new XMLHttpRequest;try{return new ActiveXObject("Microsoft.XMLHTTP")}catch(n){}try{return new ActiveXObject("Msxml2.XMLHTTP.6.0")}catch(n){}try{return new ActiveXObject("Msxml2.XMLHTTP.3.0")}catch(n){}try{return new ActiveXObject("Msxml2.XMLHTTP")}catch(n){}throw Error("Browser-only version of superagent could not find XHR")};var b="".trim?function(n){return n.trim()}:function(n){return n.replace(/(^\s*|\s*$)/g,"")};v.serializeObject=r,v.parseString=o,v.types={html:"text/html",json:"application/json",xml:"text/xml",urlencoded:"application/x-www-form-urlencoded",form:"application/x-www-form-urlencoded","form-data":"application/x-www-form-urlencoded"},v.serialize={"application/x-www-form-urlencoded":r,"application/json":JSON.stringify},v.parse={"application/x-www-form-urlencoded":o,"application/json":JSON.parse},f(l.prototype),l.prototype._parseBody=function(n){var e=v.parse[this.type];return this.req._parser?this.req._parser(this,n):(!e&&a(this.type)&&(e=v.parse["application/json"]),e&&n&&(n.length||n instanceof Object)?e(n):null)},l.prototype.toError=function(){var n=this.req,e=n.method,t=n.url,i="cannot "+e+" "+t+" ("+this.status+")",r=new Error(i);return r.status=this.status,r.method=e,r.url=t,r},v.Response=l,m(u.prototype),p(u.prototype),u.prototype.type=function(n){return this.set("Content-Type",v.types[n]||n),this},u.prototype.accept=function(n){return this.set("Accept",v.types[n]||n),this},u.prototype.auth=function(n,e,t){1===arguments.length&&(e=""),"object"==typeof e&&null!==e&&(t=e,e=""),t||(t={type:"function"==typeof btoa?"basic":"auto"});var i=function(n){if("function"==typeof btoa)return btoa(n);throw new Error("Cannot use basic auth, btoa is not a function")};return this._auth(n,e,t,i)},u.prototype.query=function(n){return"string"!=typeof n&&(n=r(n)),n&&this._query.push(n),this},u.prototype.attach=function(n,e,t){if(e){if(this._data)throw Error("superagent can't mix .send() and .attach()");this._getFormData().append(n,e,t||e.name)}return this},u.prototype._getFormData=function(){return this._formData||(this._formData=new d.FormData),this._formData},u.prototype.callback=function(n,e){if(this._shouldRetry(n,e))return this._retry();var t=this._callback;this.clearTimeout(),n&&(this._maxRetries&&(n.retries=this._retries-1),this.emit("error",n)),t(n,e)},u.prototype.crossDomainError=function(){var n=new Error("Request has been terminated\nPossible causes: the network is offline, Origin is not allowed by Access-Control-Allow-Origin, the page is being unloaded, etc.");n.crossDomain=!0,n.status=this.status,n.method=this.method,n.url=this.url,this.callback(n)},u.prototype.buffer=u.prototype.ca=u.prototype.agent=function(){return console.warn("This is not supported in browser version of superagent"),this},u.prototype.pipe=u.prototype.write=function(){throw Error("Streaming is not supported in browser version of superagent")},u.prototype._isHost=function(n){return n&&"object"==typeof n&&!Array.isArray(n)&&"[object Object]"!==Object.prototype.toString.call(n)},u.prototype.end=function(n){return this._endCalled&&console.warn("Warning: .end() was called twice. This is not supported in superagent"),this._endCalled=!0,this._callback=n||i,this._finalizeQueryString(),this._end()},u.prototype._end=function(){var n=this,e=this.xhr=v.getXHR(),t=this._formData||this._data;this._setTimeouts(),e.onreadystatechange=function(){var t=e.readyState;if(t>=2&&n._responseTimeoutTimer&&clearTimeout(n._responseTimeoutTimer),4==t){var i;try{i=e.status}catch(n){i=0}if(!i){if(n.timedout||n._aborted)return;return n.crossDomainError()}n.emit("end")}};var i=function(e,t){t.total>0&&(t.percent=t.loaded/t.total*100),t.direction=e,n.emit("progress",t)};if(this.hasListeners("progress"))try{e.onprogress=i.bind(null,"download"),e.upload&&(e.upload.onprogress=i.bind(null,"upload"))}catch(n){}try{this.username&&this.password?e.open(this.method,this.url,!0,this.username,this.password):e.open(this.method,this.url,!0)}catch(n){return this.callback(n)}if(this._withCredentials&&(e.withCredentials=!0),!this._formData&&"GET"!=this.method&&"HEAD"!=this.method&&"string"!=typeof t&&!this._isHost(t)){var r=this._header["content-type"],s=this._serializer||v.serialize[r?r.split(";")[0]:""];!s&&a(r)&&(s=v.serialize["application/json"]),s&&(t=s(t))}for(var o in this.header)null!=this.header[o]&&this.header.hasOwnProperty(o)&&e.setRequestHeader(o,this.header[o]);return this._responseType&&(e.responseType=this._responseType),this.emit("request",this),e.send(void 0!==t?t:null),this},v.agent=function(){return new g},["GET","POST","OPTIONS","PATCH","PUT","DELETE"].forEach((function(n){g.prototype[n.toLowerCase()]=function(e,t){var i=new v.Request(n,e);return this._setDefaults(i),t&&i.end(t),i}})),g.prototype.del=g.prototype.delete,v.get=function(n,e,t){var i=v("GET",n);return"function"==typeof e&&(t=e,e=null),e&&i.query(e),t&&i.end(t),i},v.head=function(n,e,t){var i=v("HEAD",n);return"function"==typeof e&&(t=e,e=null),e&&i.query(e),t&&i.end(t),i},v.options=function(n,e,t){var i=v("OPTIONS",n);return"function"==typeof e&&(t=e,e=null),e&&i.send(e),t&&i.end(t),i},v.del=c,v.delete=c,v.patch=function(n,e,t){var i=v("PATCH",n);return"function"==typeof e&&(t=e,e=null),e&&i.send(e),t&&i.end(t),i},v.post=function(n,e,t){var i=v("POST",n);return"function"==typeof e&&(t=e,e=null),e&&i.send(e),t&&i.end(t),i},v.put=function(n,e,t){var i=v("PUT",n);return"function"==typeof e&&(t=e,e=null),e&&i.send(e),t&&i.end(t),i}},function(n,e,t){var i=t(18),r=t(19);n.exports=function(n,e,t){var s=e&&t||0;"string"==typeof n&&(e="binary"===n?new Array(16):null,n=null);var o=(n=n||{}).random||(n.rng||i)();if(o[6]=15&o[6]|64,o[8]=63&o[8]|128,e)for(var a=0;a<16;++a)e[s+a]=o[a];return e||r(o)}},function(n,e,t){"use strict";n.exports="3.13.2"},function(n,e,t){"use strict";n.exports=function(n){return null!==n&&"object"==typeof n}},function(n,e,t){"use strict";var i=t(0),r=t(1),s=t(31),o=["getItem","setItem","removeItem","clear"];s.async?i(o).each((function(n){"function"!=typeof s[n]&&(s[n]=function(){var e=new Error("Synchronous API ["+n+"] is not available in this runtime.");throw e.code="SYNC_API_NOT_AVAILABLE",e})})):i(o).each((function(n){"function"==typeof s[n]&&(s[n+"Async"]=function(){return r.resolve(s[n].apply(s,arguments))})})),n.exports=s},function(n,e,t){"use strict";var i=t(12),r=t(5),s=e.removeAsync=i.removeItemAsync.bind(i);e.getAsync=function(n){return n="AV/"+r.applicationId+"/"+n,i.getItemAsync(n).then((function(e){return function(n,e){try{n=JSON.parse(n)}catch(n){return null}return n?n.expiredAt&&n.expiredAt<Date.now()?s(e).then((function(){return null})):n.value:null}(e,n)}))},e.setAsync=function(n,e,t){var s={value:e};return"number"==typeof t&&(s.expiredAt=Date.now()+t),i.setItemAsync("AV/"+r.applicationId+"/"+n,JSON.stringify(s))}},function(n,e){var t={utf8:{stringToBytes:function(n){return t.bin.stringToBytes(unescape(encodeURIComponent(n)))},bytesToString:function(n){return decodeURIComponent(escape(t.bin.bytesToString(n)))}},bin:{stringToBytes:function(n){for(var e=[],t=0;t<n.length;t++)e.push(255&n.charCodeAt(t));return e},bytesToString:function(n){for(var e=[],t=0;t<n.length;t++)e.push(String.fromCharCode(n[t]));return e.join("")}}};n.exports=t},function(n,e,t){"use strict";
/*!
 * LeanCloud JavaScript SDK
 * https://leancloud.cn
 *
 * Copyright 2016 LeanCloud.cn, Inc.
 * The LeanCloud JavaScript SDK is freely distributable under the MIT license.
 */t(16);var i=t(0),r=t(5);r._=i,r.version=t(10),r.Promise=t(1),r.localStorage=t(12),r.Cache=t(13),r.Error=t(4),t(33),t(35)(r),t(36)(r),t(37)(r),t(38)(r),t(39)(r),t(40)(r),t(48)(r),t(49)(r),t(50)(r),t(51)(r),t(52)(r),t(54)(r),t(55)(r),t(56)(r),t(57)(r),t(58)(r),t(59)(r),r.Conversation=t(60),t(61),n.exports=r},function(n,e,t){},function(n,e){n.exports=function(n){return n.webpackPolyfill||(n.deprecate=function(){},n.paths=[],n.children||(n.children=[]),Object.defineProperty(n,"loaded",{enumerable:!0,get:function(){return n.l}}),Object.defineProperty(n,"id",{enumerable:!0,get:function(){return n.i}}),n.webpackPolyfill=1),n}},function(n,e){var t="undefined"!=typeof crypto&&crypto.getRandomValues&&crypto.getRandomValues.bind(crypto)||"undefined"!=typeof msCrypto&&"function"==typeof window.msCrypto.getRandomValues&&msCrypto.getRandomValues.bind(msCrypto);if(t){var i=new Uint8Array(16);n.exports=function(){return t(i),i}}else{var r=new Array(16);n.exports=function(){for(var n,e=0;e<16;e++)0==(3&e)&&(n=4294967296*Math.random()),r[e]=n>>>((3&e)<<3)&255;return r}}},function(n,e){for(var t=[],i=0;i<256;++i)t[i]=(i+256).toString(16).substr(1);n.exports=function(n,e){var i=e||0,r=t;return[r[n[i++]],r[n[i++]],r[n[i++]],r[n[i++]],"-",r[n[i++]],r[n[i++]],"-",r[n[i++]],r[n[i++]],"-",r[n[i++]],r[n[i++]],"-",r[n[i++]],r[n[i++]],r[n[i++]],r[n[i++]],r[n[i++]],r[n[i++]]].join("")}},function(n,e,t){"use strict";var i=t(10),r=["Browser"].concat(t(21));n.exports="LeanCloud-JS-SDK/"+i+" ("+r.join("; ")+")"},function(n,e,t){"use strict";n.exports=[]},function(n,e,t){function i(n){if(n)return function(n){for(var e in i.prototype)n[e]=i.prototype[e];return n}(n)}n.exports=i,i.prototype.on=i.prototype.addEventListener=function(n,e){return this._callbacks=this._callbacks||{},(this._callbacks["$"+n]=this._callbacks["$"+n]||[]).push(e),this},i.prototype.once=function(n,e){function t(){this.off(n,t),e.apply(this,arguments)}return t.fn=e,this.on(n,t),this},i.prototype.off=i.prototype.removeListener=i.prototype.removeAllListeners=i.prototype.removeEventListener=function(n,e){if(this._callbacks=this._callbacks||{},0==arguments.length)return this._callbacks={},this;var t=this._callbacks["$"+n];if(!t)return this;if(1==arguments.length)return delete this._callbacks["$"+n],this;for(var i,r=0;r<t.length;r++)if((i=t[r])===e||i.fn===e){t.splice(r,1);break}return 0===t.length&&delete this._callbacks["$"+n],this},i.prototype.emit=function(n){this._callbacks=this._callbacks||{};for(var e=new Array(arguments.length-1),t=this._callbacks["$"+n],i=1;i<arguments.length;i++)e[i-1]=arguments[i];if(t){i=0;for(var r=(t=t.slice(0)).length;i<r;++i)t[i].apply(this,e)}return this},i.prototype.listeners=function(n){return this._callbacks=this._callbacks||{},this._callbacks["$"+n]||[]},i.prototype.hasListeners=function(n){return!!this.listeners(n).length}},function(n,e,t){"use strict";function i(n){if(n)return function(n){for(var e in i.prototype)n[e]=i.prototype[e];return n}(n)}var r=t(11);n.exports=i,i.prototype.clearTimeout=function(){return clearTimeout(this._timer),clearTimeout(this._responseTimeoutTimer),delete this._timer,delete this._responseTimeoutTimer,this},i.prototype.parse=function(n){return this._parser=n,this},i.prototype.responseType=function(n){return this._responseType=n,this},i.prototype.serialize=function(n){return this._serializer=n,this},i.prototype.timeout=function(n){if(!n||"object"!=typeof n)return this._timeout=n,this._responseTimeout=0,this;for(var e in n)switch(e){case"deadline":this._timeout=n.deadline;break;case"response":this._responseTimeout=n.response;break;default:console.warn("Unknown timeout option",e)}return this},i.prototype.retry=function(n,e){return 0!==arguments.length&&!0!==n||(n=1),n<=0&&(n=0),this._maxRetries=n,this._retries=0,this._retryCallback=e,this};var s=["ECONNRESET","ETIMEDOUT","EADDRINFO","ESOCKETTIMEDOUT"];i.prototype._shouldRetry=function(n,e){if(!this._maxRetries||this._retries++>=this._maxRetries)return!1;if(this._retryCallback)try{var t=this._retryCallback(n,e);if(!0===t)return!0;if(!1===t)return!1}catch(n){console.error(n)}if(e&&e.status&&e.status>=500&&501!=e.status)return!0;if(n){if(n.code&&~s.indexOf(n.code))return!0;if(n.timeout&&"ECONNABORTED"==n.code)return!0;if(n.crossDomain)return!0}return!1},i.prototype._retry=function(){return this.clearTimeout(),this.req&&(this.req=null,this.req=this.request()),this._aborted=!1,this.timedout=!1,this._end()},i.prototype.then=function(n,e){if(!this._fullfilledPromise){var t=this;this._endCalled&&console.warn("Warning: superagent request was sent twice, because both .end() and .then() were called. Never call .end() if you use promises"),this._fullfilledPromise=new Promise((function(n,e){t.end((function(t,i){t?e(t):n(i)}))}))}return this._fullfilledPromise.then(n,e)},i.prototype.catch=function(n){return this.then(void 0,n)},i.prototype.use=function(n){return n(this),this},i.prototype.ok=function(n){if("function"!=typeof n)throw Error("Callback required");return this._okCallback=n,this},i.prototype._isResponseOK=function(n){return!!n&&(this._okCallback?this._okCallback(n):n.status>=200&&n.status<300)},i.prototype.get=function(n){return this._header[n.toLowerCase()]},i.prototype.getHeader=i.prototype.get,i.prototype.set=function(n,e){if(r(n)){for(var t in n)this.set(t,n[t]);return this}return this._header[n.toLowerCase()]=e,this.header[n]=e,this},i.prototype.unset=function(n){return delete this._header[n.toLowerCase()],delete this.header[n],this},i.prototype.field=function(n,e){if(null==n)throw new Error(".field(name, val) name can not be empty");if(this._data&&console.error(".field() can't be used if .send() is used. Please use only .send() or only .field() & .attach()"),r(n)){for(var t in n)this.field(t,n[t]);return this}if(Array.isArray(e)){for(var i in e)this.field(n,e[i]);return this}if(null==e)throw new Error(".field(name, val) val can not be empty");return"boolean"==typeof e&&(e=""+e),this._getFormData().append(n,e),this},i.prototype.abort=function(){return this._aborted?this:(this._aborted=!0,this.xhr&&this.xhr.abort(),this.req&&this.req.abort(),this.clearTimeout(),this.emit("abort"),this)},i.prototype._auth=function(n,e,t,i){switch(t.type){case"basic":this.set("Authorization","Basic "+i(n+":"+e));break;case"auto":this.username=n,this.password=e;break;case"bearer":this.set("Authorization","Bearer "+n)}return this},i.prototype.withCredentials=function(n){return null==n&&(n=!0),this._withCredentials=n,this},i.prototype.redirects=function(n){return this._maxRedirects=n,this},i.prototype.maxResponseSize=function(n){if("number"!=typeof n)throw TypeError("Invalid argument");return this._maxResponseSize=n,this},i.prototype.toJSON=function(){return{method:this.method,url:this.url,data:this._data,headers:this._header}},i.prototype.send=function(n){var e=r(n),t=this._header["content-type"];if(this._formData&&console.error(".send() can't be used if .attach() or .field() is used. Please use only .send() or only .field() & .attach()"),e&&!this._data)Array.isArray(n)?this._data=[]:this._isHost(n)||(this._data={});else if(n&&this._data&&this._isHost(this._data))throw Error("Can't merge these send calls");if(e&&r(this._data))for(var i in n)this._data[i]=n[i];else"string"==typeof n?(t||this.type("form"),t=this._header["content-type"],this._data="application/x-www-form-urlencoded"==t?this._data?this._data+"&"+n:n:(this._data||"")+n):this._data=n;return!e||this._isHost(n)?this:(t||this.type("json"),this)},i.prototype.sortQuery=function(n){return this._sort=void 0===n||n,this},i.prototype._finalizeQueryString=function(){var n=this._query.join("&");if(n&&(this.url+=(this.url.indexOf("?")>=0?"&":"?")+n),this._query.length=0,this._sort){var e=this.url.indexOf("?");if(e>=0){var t=this.url.substring(e+1).split("&");"function"==typeof this._sort?t.sort(this._sort):t.sort(),this.url=this.url.substring(0,e)+"?"+t.join("&")}}},i.prototype._appendQueryString=function(){console.trace("Unsupported")},i.prototype._timeoutError=function(n,e,t){if(!this._aborted){var i=new Error(n+e+"ms exceeded");i.timeout=e,i.code="ECONNABORTED",i.errno=t,this.timedout=!0,this.abort(),this.callback(i)}},i.prototype._setTimeouts=function(){var n=this;this._timeout&&!this._timer&&(this._timer=setTimeout((function(){n._timeoutError("Timeout of ",n._timeout,"ETIME")}),this._timeout)),this._responseTimeout&&!this._responseTimeoutTimer&&(this._responseTimeoutTimer=setTimeout((function(){n._timeoutError("Response timeout of ",n._responseTimeout,"ETIMEDOUT")}),this._responseTimeout))}},function(n,e,t){"use strict";function i(n){if(n)return function(n){for(var e in i.prototype)n[e]=i.prototype[e];return n}(n)}var r=t(25);n.exports=i,i.prototype.get=function(n){return this.header[n.toLowerCase()]},i.prototype._setHeaderProperties=function(n){var e=n["content-type"]||"";this.type=r.type(e);var t=r.params(e);for(var i in t)this[i]=t[i];this.links={};try{n.link&&(this.links=r.parseLinks(n.link))}catch(n){}},i.prototype._setStatusProperties=function(n){var e=n/100|0;this.status=this.statusCode=n,this.statusType=e,this.info=1==e,this.ok=2==e,this.redirect=3==e,this.clientError=4==e,this.serverError=5==e,this.error=(4==e||5==e)&&this.toError(),this.created=201==n,this.accepted=202==n,this.noContent=204==n,this.badRequest=400==n,this.unauthorized=401==n,this.notAcceptable=406==n,this.forbidden=403==n,this.notFound=404==n,this.unprocessableEntity=422==n}},function(n,e,t){"use strict";e.type=function(n){return n.split(/ *; */).shift()},e.params=function(n){return n.split(/ *; */).reduce((function(n,e){var t=e.split(/ *= */),i=t.shift(),r=t.shift();return i&&r&&(n[i]=r),n}),{})},e.parseLinks=function(n){return n.split(/ *, */).reduce((function(n,e){var t=e.split(/ *; */),i=t[0].slice(1,-1);return n[t[1].split(/ *= */)[1].slice(1,-1)]=i,n}),{})},e.cleanHeader=function(n,e){return delete n["content-type"],delete n["content-length"],delete n["transfer-encoding"],delete n.host,e&&(delete n.authorization,delete n.cookie),n}},function(n,e){function t(){this._defaults=[]}["use","on","once","set","query","type","accept","auth","withCredentials","sortQuery","retry","ok","redirects","timeout","buffer","serialize","parse","ca","key","pfx","cert"].forEach((function(n){t.prototype[n]=function(){return this._defaults.push({fn:n,arguments:arguments}),this}})),t.prototype._setDefaults=function(n){this._defaults.forEach((function(e){n[e.fn].apply(n,e.arguments)}))},n.exports=t},function(n,e,t){"use strict";n.exports=function(n){function e(n){for(var e=0,t=0;t<n.length;t++)e=(e<<5)-e+n.charCodeAt(t),e|=0;return i.colors[Math.abs(e)%i.colors.length]}function i(n){function t(){if(t.enabled){for(var n=arguments.length,e=new Array(n),r=0;r<n;r++)e[r]=arguments[r];var s=t,a=Number(new Date),l=a-(o||a);s.diff=l,s.prev=o,s.curr=a,o=a,e[0]=i.coerce(e[0]),"string"!=typeof e[0]&&e.unshift("%O");var u=0;e[0]=e[0].replace(/%([a-zA-Z%])/g,(function(n,t){if("%%"===n)return n;u++;var r=i.formatters[t];if("function"==typeof r){var o=e[u];n=r.call(s,o),e.splice(u,1),u--}return n})),i.formatArgs.call(s,e),(s.log||i.log).apply(s,e)}}var o;return t.namespace=n,t.enabled=i.enabled(n),t.useColors=i.useColors(),t.color=e(n),t.destroy=r,t.extend=s,"function"==typeof i.init&&i.init(t),i.instances.push(t),t}function r(){var n=i.instances.indexOf(this);return-1!==n&&(i.instances.splice(n,1),!0)}function s(n,e){return i(this.namespace+(void 0===e?":":e)+n)}return i.debug=i,i.default=i,i.coerce=function(n){return n instanceof Error?n.stack||n.message:n},i.disable=function(){i.enable("")},i.enable=function(n){i.save(n),i.names=[],i.skips=[];var e,t=("string"==typeof n?n:"").split(/[\s,]+/),r=t.length;for(e=0;e<r;e++)t[e]&&("-"===(n=t[e].replace(/\*/g,".*?"))[0]?i.skips.push(new RegExp("^"+n.substr(1)+"$")):i.names.push(new RegExp("^"+n+"$")));for(e=0;e<i.instances.length;e++){var s=i.instances[e];s.enabled=i.enabled(s.namespace)}},i.enabled=function(n){if("*"===n[n.length-1])return!0;var e,t;for(e=0,t=i.skips.length;e<t;e++)if(i.skips[e].test(n))return!1;for(e=0,t=i.names.length;e<t;e++)if(i.names[e].test(n))return!0;return!1},i.humanize=t(28),Object.keys(n).forEach((function(e){i[e]=n[e]})),i.instances=[],i.names=[],i.skips=[],i.formatters={},i.selectColor=e,i.enable(i.load()),i}},function(n,e){function t(n){var e=Math.abs(n);return e>=a?i(n,e,a,"day"):e>=o?i(n,e,o,"hour"):e>=s?i(n,e,s,"minute"):e>=r?i(n,e,r,"second"):n+" ms"}function i(n,e,t,i){var r=e>=1.5*t;return Math.round(n/t)+" "+i+(r?"s":"")}var r=1e3,s=60*r,o=60*s,a=24*o,l=7*a,u=365.25*a;n.exports=function(n,e){e=e||{};var i=typeof n;if("string"===i&&n.length>0)return function(n){if(!((n=String(n)).length>100)){var e=/^((?:\d+)?\-?\d?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(n);if(e){var t=parseFloat(e[1]);switch((e[2]||"ms").toLowerCase()){case"years":case"year":case"yrs":case"yr":case"y":return t*u;case"weeks":case"week":case"w":return t*l;case"days":case"day":case"d":return t*a;case"hours":case"hour":case"hrs":case"hr":case"h":return t*o;case"minutes":case"minute":case"mins":case"min":case"m":return t*s;case"seconds":case"second":case"secs":case"sec":case"s":return t*r;case"milliseconds":case"millisecond":case"msecs":case"msec":case"ms":return t;default:return}}}}(n);if("number"===i&&!1===isNaN(n))return e.long?t(n):function(n){var e=Math.abs(n);return e>=a?Math.round(n/a)+"d":e>=o?Math.round(n/o)+"h":e>=s?Math.round(n/s)+"m":e>=r?Math.round(n/r)+"s":n+"ms"}(n);throw new Error("val is not a non-empty string or a valid number. val="+JSON.stringify(n))}},function(n,e,t){(function(e){
/*!
 * @overview es6-promise - a tiny implementation of Promises/A+.
 * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors (Conversion to ES6 API by Jake Archibald)
 * @license   Licensed under MIT license
 *            See https://raw.githubusercontent.com/stefanpenner/es6-promise/master/LICENSE
 * @version   v4.2.3+b33f4734
 */
!function(e,t){n.exports=t()}(0,(function(){"use strict";function n(n){return"function"==typeof n}function i(){var n=setTimeout;return function(){return n(r,1)}}function r(){for(var n=0;n<x;n+=2)(0,O[n])(O[n+1]),O[n]=void 0,O[n+1]=void 0;x=0}function s(n,e){var t=this,i=new this.constructor(a);void 0===i[S]&&v(i);var r=t._state;if(r){var s=arguments[r-1];y((function(){return g(r,i,s,t._result)}))}else h(t,i,n,e);return i}function o(n){if(n&&"object"==typeof n&&n.constructor===this)return n;var e=new this(a);return c(e,n),e}function a(){}function l(n){try{return n.then}catch(n){return T.error=n,T}}function u(e,t,i){t.constructor===e.constructor&&i===s&&t.constructor.resolve===o?function(n,e){e._state===L?m(n,e._result):e._state===C?p(n,e._result):h(e,void 0,(function(e){return c(n,e)}),(function(e){return p(n,e)}))}(e,t):i===T?(p(e,T.error),T.error=null):void 0===i?m(e,t):n(i)?function(n,e,t){y((function(n){var i=!1,r=function(n,e,t,i){try{n.call(e,t,i)}catch(n){return n}}(t,e,(function(t){i||(i=!0,e!==t?c(n,t):m(n,t))}),(function(e){i||(i=!0,p(n,e))}),n._label);!i&&r&&(i=!0,p(n,r))}),n)}(e,t,i):m(e,t)}function c(n,e){n===e?p(n,new TypeError("You cannot resolve a promise with itself")):function(n){var e=typeof n;return null!==n&&("object"===e||"function"===e)}(e)?u(n,e,l(e)):m(n,e)}function d(n){n._onerror&&n._onerror(n._result),f(n)}function m(n,e){n._state===I&&(n._result=e,n._state=L,0!==n._subscribers.length&&y(f,n))}function p(n,e){n._state===I&&(n._state=C,n._result=e,y(d,n))}function h(n,e,t,i){var r=n._subscribers,s=r.length;n._onerror=null,r[s]=e,r[s+L]=t,r[s+C]=i,0===s&&n._state&&y(f,n)}function f(n){var e=n._subscribers,t=n._state;if(0!==e.length){for(var i=void 0,r=void 0,s=n._result,o=0;o<e.length;o+=3)i=e[o],r=e[o+t],i?g(t,i,r,s):r(s);n._subscribers.length=0}}function g(e,t,i,r){var s=n(i),o=void 0,a=void 0,l=void 0,u=void 0;if(s){if((o=function(n,e){try{return n(e)}catch(n){return T.error=n,T}}(i,r))===T?(u=!0,a=o.error,o.error=null):l=!0,t===o)return void p(t,new TypeError("A promises callback cannot return that same promise."))}else o=r,l=!0;t._state!==I||(s&&l?c(t,o):u?p(t,a):e===L?m(t,o):e===C&&p(t,o))}function v(n){n[S]=D++,n._state=void 0,n._result=void 0,n._subscribers=[]}var b=Array.isArray?Array.isArray:function(n){return"[object Array]"===Object.prototype.toString.call(n)},x=0,w=void 0,E=void 0,y=function(n,e){O[x]=n,O[x+1]=e,2===(x+=2)&&(E?E(r):B())},k="undefined"!=typeof window?window:void 0,A=k||{},j=A.MutationObserver||A.WebKitMutationObserver,_="undefined"==typeof self&&"undefined"!=typeof process&&"[object process]"==={}.toString.call(process),N="undefined"!=typeof Uint8ClampedArray&&"undefined"!=typeof importScripts&&"undefined"!=typeof MessageChannel,O=new Array(1e3),B=void 0;B=_?function(){return process.nextTick(r)}:j?function(){var n=0,e=new j(r),t=document.createTextNode("");return e.observe(t,{characterData:!0}),function(){t.data=n=++n%2}}():N?function(){var n=new MessageChannel;return n.port1.onmessage=r,function(){return n.port2.postMessage(0)}}():void 0===k?function(){try{var n=t(30);return void 0!==(w=n.runOnLoop||n.runOnContext)?function(){w(r)}:i()}catch(n){return i()}}():i();var S=Math.random().toString(36).substring(2),I=void 0,L=1,C=2,T={error:null},D=0,q=function(){function n(n,e){this._instanceConstructor=n,this.promise=new n(a),this.promise[S]||v(this.promise),b(e)?(this.length=e.length,this._remaining=e.length,this._result=new Array(this.length),0===this.length?m(this.promise,this._result):(this.length=this.length||0,this._enumerate(e),0===this._remaining&&m(this.promise,this._result))):p(this.promise,new Error("Array Methods must be provided an Array"))}return n.prototype._enumerate=function(n){for(var e=0;this._state===I&&e<n.length;e++)this._eachEntry(n[e],e)},n.prototype._eachEntry=function(n,e){var t=this._instanceConstructor,i=t.resolve;if(i===o){var r=l(n);if(r===s&&n._state!==I)this._settledAt(n._state,e,n._result);else if("function"!=typeof r)this._remaining--,this._result[e]=n;else if(t===P){var c=new t(a);u(c,n,r),this._willSettleAt(c,e)}else this._willSettleAt(new t((function(e){return e(n)})),e)}else this._willSettleAt(i(n),e)},n.prototype._settledAt=function(n,e,t){var i=this.promise;i._state===I&&(this._remaining--,n===C?p(i,t):this._result[e]=t),0===this._remaining&&m(i,this._result)},n.prototype._willSettleAt=function(n,e){var t=this;h(n,void 0,(function(n){return t._settledAt(L,e,n)}),(function(n){return t._settledAt(C,e,n)}))},n}(),P=function(){function n(e){this[S]=D++,this._result=this._state=void 0,this._subscribers=[],a!==e&&("function"!=typeof e&&function(){throw new TypeError("You must pass a resolver function as the first argument to the promise constructor")}(),this instanceof n?function(n,e){try{e((function(e){c(n,e)}),(function(e){p(n,e)}))}catch(e){p(n,e)}}(this,e):function(){throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.")}())}return n.prototype.catch=function(n){return this.then(null,n)},n.prototype.finally=function(n){var e=this.constructor;return this.then((function(t){return e.resolve(n()).then((function(){return t}))}),(function(t){return e.resolve(n()).then((function(){throw t}))}))},n}();return P.prototype.then=s,P.all=function(n){return new q(this,n).promise},P.race=function(n){var e=this;return new e(b(n)?function(t,i){for(var r=n.length,s=0;s<r;s++)e.resolve(n[s]).then(t,i)}:function(n,e){return e(new TypeError("You must pass an array to race."))})},P.resolve=o,P.reject=function(n){var e=new this(a);return p(e,n),e},P._setScheduler=function(n){E=n},P._setAsap=function(n){y=n},P._asap=y,P.polyfill=function(){var n=void 0;if(void 0!==e)n=e;else if("undefined"!=typeof self)n=self;else try{n=Function("return this")()}catch(n){throw new Error("polyfill failed because global object is unavailable in this environment")}var t=n.Promise;if(t){var i=null;try{i=Object.prototype.toString.call(t.resolve())}catch(n){}if("[object Promise]"===i&&!t.cast)return}n.Promise=P},P.Promise=P,P}))}).call(e,t(7))},function(n,e){},function(n,e,t){"use strict";(function(e){var i=t(0),r={},s=e.localStorage;try{var o="__storejs__";if(s.setItem(o,o),s.getItem(o)!=o)throw new Error;s.removeItem(o)}catch(n){s=t(32)}i(["getItem","setItem","removeItem","clear"]).each((function(n){r[n]=function(){return s[n].apply(s,arguments)}})),r.async=!1,n.exports=r}).call(e,t(7))},function(n,e,t){!function(e){var t={},i={};t.length=0,t.getItem=function(n){return n in i?i[n]:null},t.setItem=function(n,e){void 0===e?t.removeItem(n):(i.hasOwnProperty(n)||t.length++,i[n]=""+e)},t.removeItem=function(n){i.hasOwnProperty(n)&&(delete i[n],t.length--)},t.key=function(n){return Object.keys(i)[n]||null},t.clear=function(){i={},t.length=0},n.exports=t}()},function(n,e,t){"use strict";function i(n){var e=void 0,t=n.slice(0,8).toLowerCase();switch(n.slice(-9)){case"-9Nh9j0Va":e="lncldapi.com";break;case"-MdYXbMMI":e="lncldglobal.com";break;default:e="lncld.net"}return{push:"https://"+t+".push."+e,stats:"https://"+t+".stats."+e,engine:"https://"+t+".engine."+e,api:"https://"+t+".api."+e}}var r=t(5),s=t(34),o=t(3).isNullOrUndefined,a=t(0),l=a.extend,u=a.isObject,c=function(n){return{push:n,stats:n,engine:n,api:n}},d=!1;r.init=function(n){if(!u(n))return r.init({appId:n,appKey:arguments.length<=1?void 0:arguments[1],masterKey:arguments.length<=2?void 0:arguments[2]});var e=n.appId,t=n.appKey,o=n.masterKey,a=(n.hookKey,n.serverURLs),m=n.disableCurrentUser,p=n.production,h=n.realtime;if(r.applicationId)throw new Error("SDK is already initialized.");if(!e)throw new TypeError("appId must be a string");if(!t)throw new TypeError("appKey must be a string");o&&console.warn("MasterKey is not supposed to be used in browser."),r._config.applicationId=e,r._config.applicationKey=t,r._config.masterKey=o,void 0!==p&&(r._config.production=p),void 0!==m&&(r._config.disableCurrentUser=m),r._appRouter=new s(r);var f=d||void 0!==a;r._setServerURLs(l({},i(e),r._config.serverURLs,"string"==typeof a?c(a):a),f),h?r._config.realtime=h:r._sharedConfig.liveQueryRealtime&&(r._config.realtime=new r._sharedConfig.liveQueryRealtime({appId:e,appKey:t}))},r.setProduction=function(n){o(n)?r._config.production=null:r._config.production=n?1:0},r._setServerURLs=function(n){var e=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];"string"!=typeof n?l(r._config.serverURLs,n):r._config.serverURLs=c(n),e&&(r._appRouter?r._appRouter.disable():d=!0)},r.setServerURLs=function(n){return r._setServerURLs(n)},r.keepErrorRawMessage=function(n){r._sharedConfig.keepErrorRawMessage=n},r.setRequestTimeout=function(n){r._config.requestTimeout=n},r.initialize=r.init,["applicationId","applicationKey","masterKey","hookKey"].forEach((function(n){return Object.defineProperty(r,n,{get:function(){return r._config[n]},set:function(e){r._config[n]=e}})}))},function(n,e,t){"use strict";function i(n){var e=this;this.AV=n,this.lockedUntil=0,s.getAsync("serverURLs").then((function(n){if(!e.disabled){if(!n)return e.lock(0);var t=n.serverURLs,i=n.lockedUntil;e.AV._setServerURLs(t,!1),e.lockedUntil=i}})).catch((function(){return e.lock(0)}))}var r=t(3).ajax,s=t(13);i.prototype.disable=function(){this.disabled=!0},i.prototype.lock=function(n){this.lockedUntil=Date.now()+n},i.prototype.refresh=function(){var n=this;if(!(this.disabled||Date.now()<this.lockedUntil))return this.lock(10),r({method:"get",url:"https://app-router.leancloud.cn/2/route",query:{appId:this.AV.applicationId}}).then((function(e){if(!n.disabled){var t=e.ttl;if(!t)throw new Error("missing ttl");t*=1e3;var i={push:"https://"+e.push_server,stats:"https://"+e.stats_server,engine:"https://"+e.engine_server,api:"https://"+e.api_server};return n.AV._setServerURLs(i,!1),n.lock(t),s.setAsync("serverURLs",{serverURLs:i,lockedUntil:n.lockedUntil},t)}})).catch((function(e){console.warn("refresh server URLs failed: "+e.message),n.lock(600)}))},n.exports=i},function(n,e,t){"use strict";var i=t(0);n.exports=function(n){var e=/\s+/,t=Array.prototype.slice;n.Events={on:function(n,t,i){var r,s,o,a,l;if(!t)return this;for(n=n.split(e),r=this._callbacks||(this._callbacks={}),s=n.shift();s;)(o=(l=r[s])?l.tail:{}).next=a={},o.context=i,o.callback=t,r[s]={tail:a,next:l?l.next:o},s=n.shift();return this},off:function(n,t,r){var s,o,a,l,u,c;if(o=this._callbacks){if(!(n||t||r))return delete this._callbacks,this;for(s=(n=n?n.split(e):i.keys(o)).shift();s;)if(a=o[s],delete o[s],a&&(t||r)){for(l=a.tail,a=a.next;a!==l;)u=a.callback,c=a.context,(t&&u!==t||r&&c!==r)&&this.on(s,u,c),a=a.next;s=n.shift()}return this}},trigger:function(n){var i,r,s,o,a,l,u;if(!(s=this._callbacks))return this;for(l=s.all,n=n.split(e),u=t.call(arguments,1),i=n.shift();i;){if(r=s[i])for(o=r.tail;(r=r.next)!==o;)r.callback.apply(r.context||this,u);if(r=l)for(o=r.tail,a=[i].concat(u);(r=r.next)!==o;)r.callback.apply(r.context||this,a);i=n.shift()}return this}},n.Events.bind=n.Events.on,n.Events.unbind=n.Events.off}},function(n,e,t){"use strict";var i=t(0),r=t(1);n.exports=function(n){n.GeoPoint=function(e,t){i.isArray(e)?(n.GeoPoint._validate(e[0],e[1]),this.latitude=e[0],this.longitude=e[1]):i.isObject(e)?(n.GeoPoint._validate(e.latitude,e.longitude),this.latitude=e.latitude,this.longitude=e.longitude):i.isNumber(e)&&i.isNumber(t)?(n.GeoPoint._validate(e,t),this.latitude=e,this.longitude=t):(this.latitude=0,this.longitude=0);var r=this;this.__defineGetter__&&this.__defineSetter__&&(this._latitude=this.latitude,this._longitude=this.longitude,this.__defineGetter__("latitude",(function(){return r._latitude})),this.__defineGetter__("longitude",(function(){return r._longitude})),this.__defineSetter__("latitude",(function(e){n.GeoPoint._validate(e,r.longitude),r._latitude=e})),this.__defineSetter__("longitude",(function(e){n.GeoPoint._validate(r.latitude,e),r._longitude=e})))},n.GeoPoint._validate=function(n,e){if(n<-90)throw new Error("AV.GeoPoint latitude "+n+" < -90.0.");if(n>90)throw new Error("AV.GeoPoint latitude "+n+" > 90.0.");if(e<-180)throw new Error("AV.GeoPoint longitude "+e+" < -180.0.");if(e>180)throw new Error("AV.GeoPoint longitude "+e+" > 180.0.")},n.GeoPoint.current=function(){return new r((function(e,t){navigator.geolocation.getCurrentPosition((function(t){e(new n.GeoPoint({latitude:t.coords.latitude,longitude:t.coords.longitude}))}),t)}))},i.extend(n.GeoPoint.prototype,{toJSON:function(){return n.GeoPoint._validate(this.latitude,this.longitude),{__type:"GeoPoint",latitude:this.latitude,longitude:this.longitude}},radiansTo:function(n){var e=Math.PI/180,t=this.latitude*e,i=this.longitude*e,r=n.latitude*e,s=t-r,o=i-n.longitude*e,a=Math.sin(s/2),l=Math.sin(o/2),u=a*a+Math.cos(t)*Math.cos(r)*l*l;return u=Math.min(1,u),2*Math.asin(Math.sqrt(u))},kilometersTo:function(n){return 6371*this.radiansTo(n)},milesTo:function(n){return 3958.8*this.radiansTo(n)}})}},function(n,e,t){"use strict";var i=t(0);n.exports=function(n){n.ACL=function(e){var t=this;if(t.permissionsById={},i.isObject(e))if(e instanceof n.User)t.setReadAccess(e,!0),t.setWriteAccess(e,!0);else{if(i.isFunction(e))throw new Error("AV.ACL() called with a function.  Did you forget ()?");n._objectEach(e,(function(e,r){if(!i.isString(r))throw new Error("Tried to create an ACL with an invalid userId.");t.permissionsById[r]={},n._objectEach(e,(function(n,e){if("read"!==e&&"write"!==e)throw new Error("Tried to create an ACL with an invalid permission type.");if(!i.isBoolean(n))throw new Error("Tried to create an ACL with an invalid permission value.");t.permissionsById[r][e]=n}))}))}},n.ACL.prototype.toJSON=function(){return i.clone(this.permissionsById)},n.ACL.prototype._setAccess=function(e,t,r){if(t instanceof n.User?t=t.id:t instanceof n.Role&&(t="role:"+t.getName()),!i.isString(t))throw new Error("userId must be a string.");if(!i.isBoolean(r))throw new Error("allowed must be either true or false.");var s=this.permissionsById[t];if(!s){if(!r)return;s={},this.permissionsById[t]=s}r?this.permissionsById[t][e]=!0:(delete s[e],i.isEmpty(s)&&delete this.permissionsById[t])},n.ACL.prototype._getAccess=function(e,t){t instanceof n.User?t=t.id:t instanceof n.Role&&(t="role:"+t.getName());var i=this.permissionsById[t];return!!i&&!!i[e]},n.ACL.prototype.setReadAccess=function(n,e){this._setAccess("read",n,e)},n.ACL.prototype.getReadAccess=function(n){return this._getAccess("read",n)},n.ACL.prototype.setWriteAccess=function(n,e){this._setAccess("write",n,e)},n.ACL.prototype.getWriteAccess=function(n){return this._getAccess("write",n)},n.ACL.prototype.setPublicReadAccess=function(n){this.setReadAccess("*",n)},n.ACL.prototype.getPublicReadAccess=function(){return this.getReadAccess("*")},n.ACL.prototype.setPublicWriteAccess=function(n){this.setWriteAccess("*",n)},n.ACL.prototype.getPublicWriteAccess=function(){return this.getWriteAccess("*")},n.ACL.prototype.getRoleReadAccess=function(e){if(e instanceof n.Role&&(e=e.getName()),i.isString(e))return this.getReadAccess("role:"+e);throw new Error("role must be a AV.Role or a String")},n.ACL.prototype.getRoleWriteAccess=function(e){if(e instanceof n.Role&&(e=e.getName()),i.isString(e))return this.getWriteAccess("role:"+e);throw new Error("role must be a AV.Role or a String")},n.ACL.prototype.setRoleReadAccess=function(e,t){if(e instanceof n.Role&&(e=e.getName()),!i.isString(e))throw new Error("role must be a AV.Role or a String");this.setReadAccess("role:"+e,t)},n.ACL.prototype.setRoleWriteAccess=function(e,t){if(e instanceof n.Role&&(e=e.getName()),!i.isString(e))throw new Error("role must be a AV.Role or a String");this.setWriteAccess("role:"+e,t)}}},function(n,e,t){"use strict";var i=t(0);n.exports=function(n){n.Op=function(){this._initialize.apply(this,arguments)},i.extend(n.Op.prototype,{_initialize:function(){}}),i.extend(n.Op,{_extend:n._extend,_opDecoderMap:{},_registerDecoder:function(e,t){n.Op._opDecoderMap[e]=t},_decode:function(e){var t=n.Op._opDecoderMap[e.__op];return t?t(e):void 0}}),n.Op._registerDecoder("Batch",(function(e){var t=null;return n._arrayEach(e.ops,(function(e){e=n.Op._decode(e),t=e._mergeWithPrevious(t)})),t})),n.Op.Set=n.Op._extend({_initialize:function(n){this._value=n},value:function(){return this._value},toJSON:function(){return n._encode(this.value())},_mergeWithPrevious:function(n){return this},_estimate:function(n){return this.value()}}),n.Op._UNSET={},n.Op.Unset=n.Op._extend({toJSON:function(){return{__op:"Delete"}},_mergeWithPrevious:function(n){return this},_estimate:function(e){return n.Op._UNSET}}),n.Op._registerDecoder("Delete",(function(e){return new n.Op.Unset})),n.Op.Increment=n.Op._extend({_initialize:function(n){this._amount=n},amount:function(){return this._amount},toJSON:function(){return{__op:"Increment",amount:this._amount}},_mergeWithPrevious:function(e){if(e){if(e instanceof n.Op.Unset)return new n.Op.Set(this.amount());if(e instanceof n.Op.Set)return new n.Op.Set(e.value()+this.amount());if(e instanceof n.Op.Increment)return new n.Op.Increment(this.amount()+e.amount());throw new Error("Op is invalid after previous op.")}return this},_estimate:function(n){return n?n+this.amount():this.amount()}}),n.Op._registerDecoder("Increment",(function(e){return new n.Op.Increment(e.amount)})),n.Op.BitAnd=n.Op._extend({_initialize:function(n){this._value=n},value:function(){return this._value},toJSON:function(){return{__op:"BitAnd",value:this.value()}},_mergeWithPrevious:function(e){if(e){if(e instanceof n.Op.Unset)return new n.Op.Set(0);if(e instanceof n.Op.Set)return new n.Op.Set(e.value()&this.value());throw new Error("Op is invalid after previous op.")}return this},_estimate:function(n){return n&this.value()}}),n.Op._registerDecoder("BitAnd",(function(e){return new n.Op.BitAnd(e.value)})),n.Op.BitOr=n.Op._extend({_initialize:function(n){this._value=n},value:function(){return this._value},toJSON:function(){return{__op:"BitOr",value:this.value()}},_mergeWithPrevious:function(e){if(e){if(e instanceof n.Op.Unset)return new n.Op.Set(this.value());if(e instanceof n.Op.Set)return new n.Op.Set(e.value()|this.value());throw new Error("Op is invalid after previous op.")}return this},_estimate:function(n){return n|this.value()}}),n.Op._registerDecoder("BitOr",(function(e){return new n.Op.BitOr(e.value)})),n.Op.BitXor=n.Op._extend({_initialize:function(n){this._value=n},value:function(){return this._value},toJSON:function(){return{__op:"BitXor",value:this.value()}},_mergeWithPrevious:function(e){if(e){if(e instanceof n.Op.Unset)return new n.Op.Set(this.value());if(e instanceof n.Op.Set)return new n.Op.Set(e.value()^this.value());throw new Error("Op is invalid after previous op.")}return this},_estimate:function(n){return n^this.value()}}),n.Op._registerDecoder("BitXor",(function(e){return new n.Op.BitXor(e.value)})),n.Op.Add=n.Op._extend({_initialize:function(n){this._objects=n},objects:function(){return this._objects},toJSON:function(){return{__op:"Add",objects:n._encode(this.objects())}},_mergeWithPrevious:function(e){if(e){if(e instanceof n.Op.Unset)return new n.Op.Set(this.objects());if(e instanceof n.Op.Set)return new n.Op.Set(this._estimate(e.value()));if(e instanceof n.Op.Add)return new n.Op.Add(e.objects().concat(this.objects()));throw new Error("Op is invalid after previous op.")}return this},_estimate:function(n){return n?n.concat(this.objects()):i.clone(this.objects())}}),n.Op._registerDecoder("Add",(function(e){return new n.Op.Add(n._decode(e.objects))})),n.Op.AddUnique=n.Op._extend({_initialize:function(n){this._objects=i.uniq(n)},objects:function(){return this._objects},toJSON:function(){return{__op:"AddUnique",objects:n._encode(this.objects())}},_mergeWithPrevious:function(e){if(e){if(e instanceof n.Op.Unset)return new n.Op.Set(this.objects());if(e instanceof n.Op.Set)return new n.Op.Set(this._estimate(e.value()));if(e instanceof n.Op.AddUnique)return new n.Op.AddUnique(this._estimate(e.objects()));throw new Error("Op is invalid after previous op.")}return this},_estimate:function(e){if(e){var t=i.clone(e);return n._arrayEach(this.objects(),(function(e){if(e instanceof n.Object&&e.id){var r=i.find(t,(function(t){return t instanceof n.Object&&t.id===e.id}));if(r){var s=i.indexOf(t,r);t[s]=e}else t.push(e)}else i.contains(t,e)||t.push(e)})),t}return i.clone(this.objects())}}),n.Op._registerDecoder("AddUnique",(function(e){return new n.Op.AddUnique(n._decode(e.objects))})),n.Op.Remove=n.Op._extend({_initialize:function(n){this._objects=i.uniq(n)},objects:function(){return this._objects},toJSON:function(){return{__op:"Remove",objects:n._encode(this.objects())}},_mergeWithPrevious:function(e){if(e){if(e instanceof n.Op.Unset)return e;if(e instanceof n.Op.Set)return new n.Op.Set(this._estimate(e.value()));if(e instanceof n.Op.Remove)return new n.Op.Remove(i.union(e.objects(),this.objects()));throw new Error("Op is invalid after previous op.")}return this},_estimate:function(e){if(e){var t=i.difference(e,this.objects());return n._arrayEach(this.objects(),(function(e){e instanceof n.Object&&e.id&&(t=i.reject(t,(function(t){return t instanceof n.Object&&t.id===e.id})))})),t}return[]}}),n.Op._registerDecoder("Remove",(function(e){return new n.Op.Remove(n._decode(e.objects))})),n.Op.Relation=n.Op._extend({_initialize:function(e,t){this._targetClassName=null;var r=this,s=function(e){if(e instanceof n.Object){if(!e.id)throw new Error("You can't add an unsaved AV.Object to a relation.");if(r._targetClassName||(r._targetClassName=e.className),r._targetClassName!==e.className)throw new Error("Tried to create a AV.Relation with 2 different types: "+r._targetClassName+" and "+e.className+".");return e.id}return e};this.relationsToAdd=i.uniq(i.map(e,s)),this.relationsToRemove=i.uniq(i.map(t,s))},added:function(){var e=this;return i.map(this.relationsToAdd,(function(t){var i=n.Object._create(e._targetClassName);return i.id=t,i}))},removed:function(){var e=this;return i.map(this.relationsToRemove,(function(t){var i=n.Object._create(e._targetClassName);return i.id=t,i}))},toJSON:function(){var n=null,e=null,t=this,r=function(n){return{__type:"Pointer",className:t._targetClassName,objectId:n}};return this.relationsToAdd.length>0&&(n={__op:"AddRelation",objects:i.map(this.relationsToAdd,r)}),this.relationsToRemove.length>0&&(e={__op:"RemoveRelation",objects:i.map(this.relationsToRemove,r)}),n&&e?{__op:"Batch",ops:[n,e]}:n||e||{}},_mergeWithPrevious:function(e){if(e){if(e instanceof n.Op.Unset)throw new Error("You can't modify a relation after deleting it.");if(e instanceof n.Op.Relation){if(e._targetClassName&&e._targetClassName!==this._targetClassName)throw new Error("Related object must be of class "+e._targetClassName+", but "+this._targetClassName+" was passed in.");var t=i.union(i.difference(e.relationsToAdd,this.relationsToRemove),this.relationsToAdd),r=i.union(i.difference(e.relationsToRemove,this.relationsToAdd),this.relationsToRemove),s=new n.Op.Relation(t,r);return s._targetClassName=this._targetClassName,s}throw new Error("Op is invalid after previous op.")}return this},_estimate:function(e,t,i){if(e){if(e instanceof n.Relation){if(this._targetClassName)if(e.targetClassName){if(e.targetClassName!==this._targetClassName)throw new Error("Related object must be a "+e.targetClassName+", but a "+this._targetClassName+" was passed in.")}else e.targetClassName=this._targetClassName;return e}throw new Error("Op is invalid after previous op.")}new n.Relation(t,i).targetClassName=this._targetClassName}}),n.Op._registerDecoder("AddRelation",(function(e){return new n.Op.Relation(n._decode(e.objects),[])})),n.Op._registerDecoder("RemoveRelation",(function(e){return new n.Op.Relation([],n._decode(e.objects))}))}},function(n,e,t){"use strict";var i=t(0);n.exports=function(n){n.Relation=function(n,e){if(!i.isString(e))throw new TypeError("key must be a string");this.parent=n,this.key=e,this.targetClassName=null},n.Relation.reverseQuery=function(e,t,i){var r=new n.Query(e);return r.equalTo(t,i._toPointer()),r},i.extend(n.Relation.prototype,{_ensureParentAndKey:function(n,e){if(this.parent=this.parent||n,this.key=this.key||e,this.parent!==n)throw new Error("Internal Error. Relation retrieved from two different Objects.");if(this.key!==e)throw new Error("Internal Error. Relation retrieved from two different keys.")},add:function(e){i.isArray(e)||(e=[e]);var t=new n.Op.Relation(e,[]);this.parent.set(this.key,t),this.targetClassName=t._targetClassName},remove:function(e){i.isArray(e)||(e=[e]);var t=new n.Op.Relation([],e);this.parent.set(this.key,t),this.targetClassName=t._targetClassName},toJSON:function(){return{__type:"Relation",className:this.targetClassName}},query:function(){var e,t;return this.targetClassName?(e=n.Object._getSubclass(this.targetClassName),t=new n.Query(e)):(e=n.Object._getSubclass(this.parent.className),(t=new n.Query(e))._extraOptions.redirectClassNameForKey=this.key),t._addCondition("$relatedTo","object",this.parent._toPointer()),t._addCondition("$relatedTo","key",this.key),t}})}},function(n,e,t){"use strict";var i=t(0),r=t(41),s=t(42),o=t(43),a=t(4),l=t(2)._request,u=t(1),c=t(3),d=c.tap,m=c.transformFetchOptions,p=t(6)("leancloud:file"),h=t(47);n.exports=function(n){var e=function(){return Math.floor(65536*(1+Math.random())).toString(16).substring(1)},t=function(n){return i.isString(n)?n.match(/^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/)[4]:""},c=function(n){if(n<26)return String.fromCharCode(65+n);if(n<52)return String.fromCharCode(n-26+97);if(n<62)return String.fromCharCode(n-52+48);if(62===n)return"+";if(63===n)return"/";throw new Error("Tried to encode large digit "+n+" in base64.")},f=function(n){var e=[];return e.length=Math.ceil(n.length/3),i.times(e.length,(function(t){var i=n[3*t],r=n[3*t+1]||0,s=n[3*t+2]||0,o=3*t+1<n.length,a=3*t+2<n.length;e[t]=[c(i>>2&63),c(i<<4&48|r>>4&15),o?c(r<<2&60|s>>6&3):"=",a?c(63&s):"="].join("")})),e.join("")};n.File=function(e,r,s){if(this.attributes={name:e,url:"",metaData:{},base64:""},i.isString(r))throw new TypeError("Creating an AV.File from a String is not yet supported.");i.isArray(r)&&(this.attributes.metaData.size=r.length,r={base64:f(r)}),this._extName="",this._data=r,this._uploadHeaders={},"undefined"!=typeof Blob&&r instanceof Blob&&(r.size&&(this.attributes.metaData.size=r.size),r.name&&(this._extName=t(r.name)));var o=void 0;if(r&&r.owner)o=r.owner;else if(!n._config.disableCurrentUser)try{o=n.User.current()}catch(n){if("SYNC_API_NOT_AVAILABLE"!==n.code)throw n}this.attributes.metaData.owner=o?o.id:"unknown",this.set("mime_type",s)},n.File.withURL=function(e,t,i,r){if(!e||!t)throw new Error("Please provide file name and url");var s=new n.File(e,null,r);if(i)for(var o in i)s.attributes.metaData[o]||(s.attributes.metaData[o]=i[o]);return s.attributes.url=t,s.attributes.metaData.__source="external",s},n.File.createWithoutData=function(e){var t=new n.File;return t.id=e,t},i.extend(n.File.prototype,{className:"_File",_toFullJSON:function(e){var t=this,r=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],s=i.clone(this.attributes);return n._objectEach(s,(function(t,i){s[i]=n._encode(t,e,void 0,r)})),n._objectEach(this._operations,(function(n,e){s[e]=n})),i.has(this,"id")&&(s.objectId=this.id),i(["createdAt","updatedAt"]).each((function(n){if(i.has(t,n)){var e=t[n];s[n]=i.isDate(e)?e.toJSON():e}})),r&&(s.__type="File"),s},toFullJSON:function(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[];return this._toFullJSON(n)},toJSON:function(n,e){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:[this];return this._toFullJSON(t,!1)},_toPointer:function(){return{__type:"Pointer",className:this.className,objectId:this.id}},getACL:function(){return this._acl},setACL:function(e){return e instanceof n.ACL?(this._acl=e,this):new a(a.OTHER_CAUSE,"ACL must be a AV.ACL.")},name:function(){return this.get("name")},url:function(){return this.get("url")},get:function(n){switch(n){case"objectId":return this.id;case"url":case"name":case"mime_type":case"metaData":case"createdAt":case"updatedAt":return this.attributes[n];default:return this.attributes.metaData[n]}},set:function(){for(var n=this,e=function(e,t){switch(e){case"name":case"url":case"mime_type":case"base64":case"metaData":n.attributes[e]=t;break;default:n.attributes.metaData[e]=t}},t=arguments.length,i=Array(t),r=0;r<t;r++)i[r]=arguments[r];switch(i.length){case 1:for(var s in i[0])e(s,i[0][s]);break;case 2:e(i[0],i[1])}return this},setUploadHeader:function(n,e){return this._uploadHeaders[n]=e,this},metaData:function(n,e){return n&&e?(this.attributes.metaData[n]=e,this):n&&!e?this.attributes.metaData[n]:this.attributes.metaData},thumbnailURL:function(n,e){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:100,i=!(arguments.length>3&&void 0!==arguments[3])||arguments[3],r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"png",s=this.attributes.url;if(!s)throw new Error("Invalid url.");if(!n||!e||n<=0||e<=0)throw new Error("Invalid width or height value.");if(t<=0||t>100)throw new Error("Invalid quality value.");return s+"?imageView/"+(i?2:1)+"/w/"+n+"/h/"+e+"/q/"+t+"/format/"+r},size:function(){return this.metaData().size},ownerId:function(){return this.metaData().owner},destroy:function(n){return this.id?l("files",null,this.id,"DELETE",null,n):u.reject(new Error("The file id does not eixst."))},_fileToken:function(n,i){var r=this.attributes.name,s=t(r);!s&&this._extName&&(r+=this._extName,s=this._extName);var o=e()+e()+e()+e()+e()+s,a={key:o,name:r,keep_file_name:i.keepFileName,ACL:this._acl,mime_type:n,metaData:this.attributes.metaData};return this._qiniu_key=o,l("fileTokens",null,null,"POST",a,i)},save:function(){var n=this,e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};if(this.id)throw new Error("File is already saved.");if(!this._previousSave)if(this._data){var t=this.get("mime_type");this._previousSave=this._fileToken(t,e).then((function(a){return a.mime_type&&(t=a.mime_type,n.set("mime_type",t)),n._token=a.token,u.resolve().then((function(){var e=n._data;if(e&&e.base64)return h(e.base64,t);if(e&&e.blob)return!e.blob.type&&t&&(e.blob.type=t),e.blob.name||(e.blob.name=n.get("name")),e.blob;if("undefined"!=typeof Blob&&e instanceof Blob)return e;throw new TypeError("malformed file data")})).then((function(t){var l=i.extend({},e);switch(e.onprogress&&(l.onprogress=function(n){if("download"!==n.direction)return e.onprogress(n)}),a.provider){case"s3":return o(a,t,n,l);case"qcloud":return r(a,t,n,l);case"qiniu":default:return s(a,t,n,l)}})).then(d((function(){return n._callback(!0)})),(function(e){throw n._callback(!1),e}))}))}else if(this.attributes.url&&"external"===this.attributes.metaData.__source){var a={name:this.attributes.name,ACL:this._acl,metaData:this.attributes.metaData,mime_type:this.mimeType,url:this.attributes.url};this._previousSave=l("files",this.attributes.name,null,"post",a,e).then((function(e){return n.attributes.name=e.name,n.attributes.url=e.url,n.id=e.objectId,e.size&&(n.attributes.metaData.size=e.size),n}))}return this._previousSave},_callback:function(n){l("fileCallback",null,null,"post",{token:this._token,result:n}).catch(p),delete this._token,delete this._data},fetch:function(n,e){return l("files",null,this.id,"GET",m(n),e).then(this._finishFetch.bind(this))},_finishFetch:function(e){var t=n.Object.prototype.parse(e);return t.attributes={name:t.name,url:t.url,mime_type:t.mime_type,bucket:t.bucket},t.attributes.metaData=t.metaData||{},t.id=t.objectId,delete t.objectId,delete t.metaData,delete t.url,delete t.name,delete t.mime_type,delete t.bucket,i.extend(this,t),this}})}},function(n,e,t){"use strict";var i=t(8),r=t(6)("cos"),s=t(1);n.exports=function(n,e,t){var o=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};t.attributes.url=n.url,t._bucket=n.bucket,t.id=n.objectId;var a=n.upload_url+"?sign="+encodeURIComponent(n.token);return new s((function(n,s){var l=i("POST",a).set(t._uploadHeaders).attach("fileContent",e,t.attributes.name).field("op","upload");o.onprogress&&l.on("progress",o.onprogress),l.end((function(e,i){if(i&&r(i.status,i.body,i.text),e)return i&&(e.statusCode=i.status,e.responseText=i.text,e.response=i.body),s(e);n(t)}))}))}},function(n,e,t){"use strict";var i=t(8),r=t(1),s=t(6)("qiniu");n.exports=function(n,e,t){var o=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};t.attributes.url=n.url,t._bucket=n.bucket,t.id=n.objectId;var a=n.token,l=n.upload_url||"https://upload.qiniup.com";return new r((function(r,u){var c=i("POST",l).set(t._uploadHeaders).attach("file",e,t.attributes.name).field("name",t.attributes.name).field("key",n.key||t._qiniu_key).field("token",a);o.onprogress&&c.on("progress",o.onprogress),c.end((function(n,e){if(e&&s(e.status,e.body,e.text),n)return e&&(n.statusCode=e.status,n.responseText=e.text,n.response=e.body),u(n);r(t)}))}))}},function(n,e,t){"use strict";var i=t(8),r=t(1),s=function(n,e){return e&&(n.statusCode=e.status,n.responseText=e.text,n.response=e.body),n};n.exports=function(n,e,t){var o=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};return t.attributes.url=n.url,t._bucket=n.bucket,t.id=n.objectId,new r((function(r,a){var l=i("PUT",n.upload_url).set(Object.assign({"Content-Type":t.get("mime_type"),"Cache-Control":"public, max-age=31536000"},t._uploadHeaders));o.onprogress&&l.on("progress",o.onprogress),l.on("response",(function(n){if(n.ok)return r(t);a(s(n.error,n))})),l.on("error",(function(n,e){return a(s(n,e))})),l.send(e).end()}))}},function(n,e,t){!function(){var e=t(45),i=t(14).utf8,r=t(46),s=t(14).bin,o=function(n,t){n.constructor==String?n=t&&"binary"===t.encoding?s.stringToBytes(n):i.stringToBytes(n):r(n)?n=Array.prototype.slice.call(n,0):Array.isArray(n)||(n=n.toString());for(var a=e.bytesToWords(n),l=8*n.length,u=1732584193,c=-271733879,d=-1732584194,m=271733878,p=0;p<a.length;p++)a[p]=16711935&(a[p]<<8|a[p]>>>24)|4278255360&(a[p]<<24|a[p]>>>8);a[l>>>5]|=128<<l%32,a[14+(l+64>>>9<<4)]=l;var h=o._ff,f=o._gg,g=o._hh,v=o._ii;for(p=0;p<a.length;p+=16){var b=u,x=c,w=d,E=m;u=h(u,c,d,m,a[p+0],7,-680876936),m=h(m,u,c,d,a[p+1],12,-389564586),d=h(d,m,u,c,a[p+2],17,606105819),c=h(c,d,m,u,a[p+3],22,-1044525330),u=h(u,c,d,m,a[p+4],7,-176418897),m=h(m,u,c,d,a[p+5],12,1200080426),d=h(d,m,u,c,a[p+6],17,-1473231341),c=h(c,d,m,u,a[p+7],22,-45705983),u=h(u,c,d,m,a[p+8],7,1770035416),m=h(m,u,c,d,a[p+9],12,-1958414417),d=h(d,m,u,c,a[p+10],17,-42063),c=h(c,d,m,u,a[p+11],22,-1990404162),u=h(u,c,d,m,a[p+12],7,1804603682),m=h(m,u,c,d,a[p+13],12,-40341101),d=h(d,m,u,c,a[p+14],17,-1502002290),u=f(u,c=h(c,d,m,u,a[p+15],22,1236535329),d,m,a[p+1],5,-165796510),m=f(m,u,c,d,a[p+6],9,-1069501632),d=f(d,m,u,c,a[p+11],14,643717713),c=f(c,d,m,u,a[p+0],20,-373897302),u=f(u,c,d,m,a[p+5],5,-701558691),m=f(m,u,c,d,a[p+10],9,38016083),d=f(d,m,u,c,a[p+15],14,-660478335),c=f(c,d,m,u,a[p+4],20,-405537848),u=f(u,c,d,m,a[p+9],5,568446438),m=f(m,u,c,d,a[p+14],9,-1019803690),d=f(d,m,u,c,a[p+3],14,-187363961),c=f(c,d,m,u,a[p+8],20,1163531501),u=f(u,c,d,m,a[p+13],5,-1444681467),m=f(m,u,c,d,a[p+2],9,-51403784),d=f(d,m,u,c,a[p+7],14,1735328473),u=g(u,c=f(c,d,m,u,a[p+12],20,-1926607734),d,m,a[p+5],4,-378558),m=g(m,u,c,d,a[p+8],11,-2022574463),d=g(d,m,u,c,a[p+11],16,1839030562),c=g(c,d,m,u,a[p+14],23,-35309556),u=g(u,c,d,m,a[p+1],4,-1530992060),m=g(m,u,c,d,a[p+4],11,1272893353),d=g(d,m,u,c,a[p+7],16,-155497632),c=g(c,d,m,u,a[p+10],23,-1094730640),u=g(u,c,d,m,a[p+13],4,681279174),m=g(m,u,c,d,a[p+0],11,-358537222),d=g(d,m,u,c,a[p+3],16,-722521979),c=g(c,d,m,u,a[p+6],23,76029189),u=g(u,c,d,m,a[p+9],4,-640364487),m=g(m,u,c,d,a[p+12],11,-421815835),d=g(d,m,u,c,a[p+15],16,530742520),u=v(u,c=g(c,d,m,u,a[p+2],23,-995338651),d,m,a[p+0],6,-198630844),m=v(m,u,c,d,a[p+7],10,1126891415),d=v(d,m,u,c,a[p+14],15,-1416354905),c=v(c,d,m,u,a[p+5],21,-57434055),u=v(u,c,d,m,a[p+12],6,1700485571),m=v(m,u,c,d,a[p+3],10,-1894986606),d=v(d,m,u,c,a[p+10],15,-1051523),c=v(c,d,m,u,a[p+1],21,-2054922799),u=v(u,c,d,m,a[p+8],6,1873313359),m=v(m,u,c,d,a[p+15],10,-30611744),d=v(d,m,u,c,a[p+6],15,-1560198380),c=v(c,d,m,u,a[p+13],21,1309151649),u=v(u,c,d,m,a[p+4],6,-145523070),m=v(m,u,c,d,a[p+11],10,-1120210379),d=v(d,m,u,c,a[p+2],15,718787259),c=v(c,d,m,u,a[p+9],21,-343485551),u=u+b>>>0,c=c+x>>>0,d=d+w>>>0,m=m+E>>>0}return e.endian([u,c,d,m])};o._ff=function(n,e,t,i,r,s,o){var a=n+(e&t|~e&i)+(r>>>0)+o;return(a<<s|a>>>32-s)+e},o._gg=function(n,e,t,i,r,s,o){var a=n+(e&i|t&~i)+(r>>>0)+o;return(a<<s|a>>>32-s)+e},o._hh=function(n,e,t,i,r,s,o){var a=n+(e^t^i)+(r>>>0)+o;return(a<<s|a>>>32-s)+e},o._ii=function(n,e,t,i,r,s,o){var a=n+(t^(e|~i))+(r>>>0)+o;return(a<<s|a>>>32-s)+e},o._blocksize=16,o._digestsize=16,n.exports=function(n,t){if(null==n)throw new Error("Illegal argument "+n);var i=e.wordsToBytes(o(n,t));return t&&t.asBytes?i:t&&t.asString?s.bytesToString(i):e.bytesToHex(i)}}()},function(n,e){!function(){var e="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",t={rotl:function(n,e){return n<<e|n>>>32-e},rotr:function(n,e){return n<<32-e|n>>>e},endian:function(n){if(n.constructor==Number)return 16711935&t.rotl(n,8)|4278255360&t.rotl(n,24);for(var e=0;e<n.length;e++)n[e]=t.endian(n[e]);return n},randomBytes:function(n){for(var e=[];n>0;n--)e.push(Math.floor(256*Math.random()));return e},bytesToWords:function(n){for(var e=[],t=0,i=0;t<n.length;t++,i+=8)e[i>>>5]|=n[t]<<24-i%32;return e},wordsToBytes:function(n){for(var e=[],t=0;t<32*n.length;t+=8)e.push(n[t>>>5]>>>24-t%32&255);return e},bytesToHex:function(n){for(var e=[],t=0;t<n.length;t++)e.push((n[t]>>>4).toString(16)),e.push((15&n[t]).toString(16));return e.join("")},hexToBytes:function(n){for(var e=[],t=0;t<n.length;t+=2)e.push(parseInt(n.substr(t,2),16));return e},bytesToBase64:function(n){for(var t=[],i=0;i<n.length;i+=3)for(var r=n[i]<<16|n[i+1]<<8|n[i+2],s=0;s<4;s++)8*i+6*s<=8*n.length?t.push(e.charAt(r>>>6*(3-s)&63)):t.push("=");return t.join("")},base64ToBytes:function(n){n=n.replace(/[^A-Z0-9+\/]/gi,"");for(var t=[],i=0,r=0;i<n.length;r=++i%4)0!=r&&t.push((e.indexOf(n.charAt(i-1))&Math.pow(2,-2*r+8)-1)<<2*r|e.indexOf(n.charAt(i))>>>6-2*r);return t}};n.exports=t}()},function(n,e){function t(n){return!!n.constructor&&"function"==typeof n.constructor.isBuffer&&n.constructor.isBuffer(n)}
/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
n.exports=function(n){return null!=n&&(t(n)||function(n){return"function"==typeof n.readFloatLE&&"function"==typeof n.slice&&t(n.slice(0,0))}(n)||!!n._isBuffer)}},function(n,e,t){"use strict";n.exports=function(n,e){var t;n.indexOf("base64")<0?t=atob(n):n.split(",")[0].indexOf("base64")>=0?(e=e||n.split(",")[0].split(":")[1].split(";")[0],t=atob(n.split(",")[1])):t=unescape(n.split(",")[1]);for(var i=new Uint8Array(t.length),r=0;r<t.length;r++)i[r]=t.charCodeAt(r);return new Blob([i],{type:e})}},function(n,e,t){"use strict";function i(n,e){return n&&n[e]?s.isFunction(n[e])?n[e]():n[e]:null}var r=function(n,e){if(Array.isArray(n))return n;if(Symbol.iterator in Object(n))return function(n,e){var t=[],i=!0,r=!1,s=void 0;try{for(var o,a=n[Symbol.iterator]();!(i=(o=a.next()).done)&&(t.push(o.value),!e||t.length!==e);i=!0);}catch(n){r=!0,s=n}finally{try{!i&&a.return&&a.return()}finally{if(r)throw s}}return t}(n,e);throw new TypeError("Invalid attempt to destructure non-iterable instance")},s=t(0),o=t(4),a=t(1),l=t(2)._request,u=t(3),c=u.isNullOrUndefined,d=u.ensureArray,m=u.transformFetchOptions,p=u.setValue,h=u.findValue,f=u.isPlainObject,g=["objectId","createdAt","updatedAt"],v=function(n){if(-1!==g.indexOf(n))throw new Error("key["+n+"] is reserved")},b=function(n){var e=s.find(n,(function(n){return n instanceof Error}));if(!e)return n;var t=new o(e.code,e.message);throw t.results=n,t};n.exports=function(n){n.Object=function(e,t){if(s.isString(e))return n.Object._create.apply(this,arguments);e=e||{},t&&t.parse&&(e=this.parse(e),e=this._mergeMagicFields(e));var r=i(this,"defaults");r&&(e=s.extend({},r,e)),t&&t.collection&&(this.collection=t.collection),this._serverData={},this._opSetQueue=[{}],this._flags={},this.attributes={},this._hashedJSON={},this._escapedAttributes={},this.cid=s.uniqueId("c"),this.changed={},this._silent={},this._pending={},this.set(e,{silent:!0}),this.changed={},this._silent={},this._pending={},this._hasData=!0,this._previousAttributes=s.clone(this.attributes),this.initialize.apply(this,arguments)},n.Object.saveAll=function(e,t){return n.Object._deepSaveAsync(e,null,t)},n.Object.fetchAll=function(n,e){return a.resolve().then((function(){return l("batch",null,null,"POST",{requests:s.map(n,(function(n){if(!n.className)throw new Error("object must have className to fetch");if(!n.id)throw new Error("object must have id to fetch");if(n.dirty())throw new Error("object is modified but not saved");return{method:"GET",path:"/1.1/classes/"+n.className+"/"+n.id}}))},e)})).then((function(e){var t=s.map(n,(function(n,t){if(e[t].success){var i=n.parse(e[t].success);return n._cleanupUnsetKeys(i),n._finishFetch(i),n}return null===e[t].success?new o(o.OBJECT_NOT_FOUND,"Object not found."):new o(e[t].error.code,e[t].error.error)}));return b(t)}))},s.extend(n.Object.prototype,n.Events,{_fetchWhenSave:!1,initialize:function(){},fetchWhenSave:function(n){if(console.warn("AV.Object#fetchWhenSave is deprecated, use AV.Object#save with options.fetchWhenSave instead."),!s.isBoolean(n))throw new Error("Expect boolean value for fetchWhenSave");this._fetchWhenSave=n},getObjectId:function(){return this.id},getCreatedAt:function(){return this.createdAt||this.get("createdAt")},getUpdatedAt:function(){return this.updatedAt||this.get("updatedAt")},toJSON:function(n,e){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:[];return this._toFullJSON(t,!1)},toFullJSON:function(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[];return this._toFullJSON(n)},_toFullJSON:function(e){var t=this,i=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],r=s.clone(this.attributes);if(s.isArray(e))var o=e.concat(this);return n._objectEach(r,(function(e,t){r[t]=n._encode(e,o,void 0,i)})),n._objectEach(this._operations,(function(n,e){r[e]=n})),s.has(this,"id")&&(r.objectId=this.id),s(["createdAt","updatedAt"]).each((function(n){if(s.has(t,n)){var e=t[n];r[n]=s.isDate(e)?e.toJSON():e}})),i&&(r.__type="Object",s.isArray(e)&&e.length&&(r.__type="Pointer"),r.className=this.className),r},_refreshCache:function(){var e=this;e._refreshingCache||(e._refreshingCache=!0,n._objectEach(this.attributes,(function(t,i){t instanceof n.Object?t._refreshCache():s.isObject(t)&&e._resetCacheForKey(i)&&e.set(i,new n.Op.Set(t),{silent:!0})})),delete e._refreshingCache)},dirty:function(n){this._refreshCache();var e=s.last(this._opSetQueue);return n?!!e[n]:!this.id||s.keys(e).length>0},_toPointer:function(){return{__type:"Pointer",className:this.className,objectId:this.id}},get:function(n){switch(n){case"objectId":return this.id;case"createdAt":case"updatedAt":return this[n];default:return this.attributes[n]}},relation:function(e){var t=this.get(e);if(t){if(!(t instanceof n.Relation))throw new Error("Called relation() on non-relation field "+e);return t._ensureParentAndKey(this,e),t}return new n.Relation(this,e)},escape:function(n){var e=this._escapedAttributes[n];if(e)return e;var t,i=this.attributes[n];return t=c(i)?"":s.escape(i.toString()),this._escapedAttributes[n]=t,t},has:function(n){return!c(this.attributes[n])},_mergeMagicFields:function(e){var t=this;return n._arrayEach(["objectId","createdAt","updatedAt"],(function(i){e[i]&&("objectId"===i?t.id=e[i]:"createdAt"!==i&&"updatedAt"!==i||s.isDate(e[i])?t[i]=e[i]:t[i]=n._parseDate(e[i]),delete e[i])})),e},_startSave:function(){this._opSetQueue.push({})},_cancelSave:function(){var e=s.first(this._opSetQueue);this._opSetQueue=s.rest(this._opSetQueue);var t=s.first(this._opSetQueue);n._objectEach(e,(function(n,i){var r=e[i],s=t[i];r&&s?t[i]=s._mergeWithPrevious(r):r&&(t[i]=r)})),this._saving=this._saving-1},_finishSave:function(e){var t={};n._traverse(this.attributes,(function(e){e instanceof n.Object&&e.id&&e._hasData&&(t[e.id]=e)}));var i=s.first(this._opSetQueue);this._opSetQueue=s.rest(this._opSetQueue),this._applyOpSet(i,this._serverData),this._mergeMagicFields(e);var r=this;n._objectEach(e,(function(e,i){r._serverData[i]=n._decode(e,i);var s=n._traverse(r._serverData[i],(function(e){if(e instanceof n.Object&&t[e.id])return t[e.id]}));s&&(r._serverData[i]=s)})),this._rebuildAllEstimatedData();var o=this._opSetQueue.map(s.clone);this._refreshCache(),this._opSetQueue=o,this._saving=this._saving-1},_finishFetch:function(e,t){this._opSetQueue=[{}],this._mergeMagicFields(e);var i=this;n._objectEach(e,(function(e,t){i._serverData[t]=n._decode(e,t)})),this._rebuildAllEstimatedData(),this._refreshCache(),this._opSetQueue=[{}],this._hasData=t},_applyOpSet:function(e,t){var i=this;n._objectEach(e,(function(e,s){var o=h(t,s),a=r(o,3),l=a[0],u=a[1],c=a[2];p(t,s,e._estimate(l,i,s)),u&&u[c]===n.Op._UNSET&&delete u[c]}))},_resetCacheForKey:function(e){var t=this.attributes[e];if(s.isObject(t)&&!(t instanceof n.Object)&&!(t instanceof n.File)){var i=JSON.stringify(function n(e){return s.isArray(e)?e.map(n):f(e)?s.mapObject(e,n):s.isObject(e)&&e._toPointer?e._toPointer():e}(t));if(this._hashedJSON[e]!==i){var r=!!this._hashedJSON[e];return this._hashedJSON[e]=i,r}}return!1},_rebuildEstimatedDataForKey:function(e){var t=this;delete this.attributes[e],this._serverData[e]&&(this.attributes[e]=this._serverData[e]),n._arrayEach(this._opSetQueue,(function(i){var s=i[e];if(s){var o=h(t.attributes,e),a=r(o,4),l=a[0],u=a[1],c=a[2],d=a[3];p(t.attributes,e,s._estimate(l,t,e)),u&&u[c]===n.Op._UNSET&&delete u[c],t._resetCacheForKey(d)}}))},_rebuildAllEstimatedData:function(){var e=this,t=s.clone(this.attributes);this.attributes=s.clone(this._serverData),n._arrayEach(this._opSetQueue,(function(t){e._applyOpSet(t,e.attributes),n._objectEach(t,(function(n,t){e._resetCacheForKey(t)}))})),n._objectEach(t,(function(n,t){e.attributes[t]!==n&&e.trigger("change:"+t,e,e.attributes[t],{})})),n._objectEach(this.attributes,(function(n,i){s.has(t,i)||e.trigger("change:"+i,e,n,{})}))},set:function(e,t,i){var r;if(s.isObject(e)||c(e)?(r=s.mapObject(e,(function(e,t){return v(t),n._decode(e,t)})),i=t):(r={},v(e),r[e]=n._decode(t,e)),i=i||{},!r)return this;r instanceof n.Object&&(r=r.attributes),i.unset&&n._objectEach(r,(function(e,t){r[t]=new n.Op.Unset}));var o=s.clone(r),a=this;n._objectEach(o,(function(e,t){e instanceof n.Op&&(o[t]=e._estimate(a.attributes[t],a,t),o[t]===n.Op._UNSET&&delete o[t])})),this._validate(r,i),i.changes={};var l=this._escapedAttributes;return n._arrayEach(s.keys(r),(function(e){var t=r[e];t instanceof n.Relation&&(t.parent=a),t instanceof n.Op||(t=new n.Op.Set(t));var o=!0;t instanceof n.Op.Set&&s.isEqual(a.attributes[e],t.value)&&(o=!1),o&&(delete l[e],i.silent?a._silent[e]=!0:i.changes[e]=!0);var u=s.last(a._opSetQueue);u[e]=t._mergeWithPrevious(u[e]),a._rebuildEstimatedDataForKey(e),o?(a.changed[e]=a.attributes[e],i.silent||(a._pending[e]=!0)):(delete a.changed[e],delete a._pending[e])})),i.silent||this.change(i),this},unset:function(n,e){return(e=e||{}).unset=!0,this.set(n,null,e)},increment:function(e,t){return(s.isUndefined(t)||s.isNull(t))&&(t=1),this.set(e,new n.Op.Increment(t))},add:function(e,t){return this.set(e,new n.Op.Add(d(t)))},addUnique:function(e,t){return this.set(e,new n.Op.AddUnique(d(t)))},remove:function(e,t){return this.set(e,new n.Op.Remove(d(t)))},bitAnd:function(e,t){return this.set(e,new n.Op.BitAnd(t))},bitOr:function(e,t){return this.set(e,new n.Op.BitOr(t))},bitXor:function(e,t){return this.set(e,new n.Op.BitXor(t))},op:function(n){return s.last(this._opSetQueue)[n]},clear:function(n){(n=n||{}).unset=!0;var e=s.extend(this.attributes,this._operations);return this.set(e,n)},revert:function(n){var e=s.last(this._opSetQueue);return d(n||s.keys(e)).forEach((function(n){delete e[n]})),this._rebuildAllEstimatedData(),this},_getSaveJSON:function(){var e=s.clone(s.first(this._opSetQueue));return n._objectEach(e,(function(n,t){e[t]=n.toJSON()})),e},_canBeSerialized:function(){return n.Object._canBeSerializedAsValue(this.attributes)},fetch:function(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},e=arguments[1],t=this;return l("classes",this.className,this.id,"GET",m(n),e).then((function(e){var i=t.parse(e);return n.keys||t._cleanupUnsetKeys(i),t._finishFetch(i,!0),t}))},_cleanupUnsetKeys:function(e){var t=this;n._objectEach(this._serverData,(function(n,i){void 0===e[i]&&delete t._serverData[i]}))},save:function(e,t,i){var r,o,u;s.isObject(e)||c(e)?(r=e,u=t):((r={})[e]=t,u=i),(u=s.clone(u)||{}).wait&&(o=s.clone(this.attributes));var d=s.clone(u)||{};d.wait&&(d.silent=!0),r&&this.set(r,d);var m=this,p=[],h=[];return n.Object._findUnsavedChildren(m,p,h),p.length+h.length>1?n.Object._deepSaveAsync(this,m,u):(this._startSave(),this._saving=(this._saving||0)+1,this._allPreviousSaves=this._allPreviousSaves||a.resolve(),this._allPreviousSaves=this._allPreviousSaves.catch((function(n){})).then((function(){var n,e=m.id?"PUT":"POST",t=m._getSaveJSON(),i={};if((m._fetchWhenSave||u.fetchWhenSave)&&(i.new="true"),u._failOnNotExist&&(i.failOnNotExist="true"),u.query&&("function"==typeof u.query.toJSON&&(n=u.query.toJSON())&&(i.where=n.where),!i.where))throw new Error("options.query is not an AV.Query");s.extend(t,m._flags);var a="classes",c=m.className;"_User"!==m.className||m.id||(a="users",c=null);var p=(u._makeRequest||l)(a,c,m.id,e,t,u,i);return p.then((function(n){var e=m.parse(n);return u.wait&&(e=s.extend(r||{},e)),m._finishSave(e),u.wait&&m.set(o,d),m}),(function(n){throw m._cancelSave(),n}))})),this._allPreviousSaves)},destroy:function(n){n=n||{};var e=this,t=function(){e.trigger("destroy",e,e.collection,n)};return this.id?(n.wait||t(),l("classes",this.className,this.id,"DELETE",this._flags,n).then((function(){return n.wait&&t(),e}))):t()},parse:function(e){var t=s.clone(e);return s(["createdAt","updatedAt"]).each((function(e){t[e]&&(t[e]=n._parseDate(t[e]))})),t.createdAt&&!t.updatedAt&&(t.updatedAt=t.createdAt),t},clone:function(){return new this.constructor(this.attributes)},isNew:function(){return!this.id},change:function(e){e=e||{};var t=this._changing;this._changing=!0;var i=this;n._objectEach(this._silent,(function(n){i._pending[n]=!0}));var r=s.extend({},e.changes,this._silent);if(this._silent={},n._objectEach(r,(function(n,t){i.trigger("change:"+t,i,i.get(t),e)})),t)return this;for(var o=function(n,e){i._pending[e]||i._silent[e]||delete i.changed[e]};!s.isEmpty(this._pending);)this._pending={},this.trigger("change",this,e),n._objectEach(this.changed,o),i._previousAttributes=s.clone(this.attributes);return this._changing=!1,this},hasChanged:function(n){return arguments.length?this.changed&&s.has(this.changed,n):!s.isEmpty(this.changed)},changedAttributes:function(e){if(!e)return!!this.hasChanged()&&s.clone(this.changed);var t={},i=this._previousAttributes;return n._objectEach(e,(function(n,e){s.isEqual(i[e],n)||(t[e]=n)})),t},previous:function(n){return arguments.length&&this._previousAttributes?this._previousAttributes[n]:null},previousAttributes:function(){return s.clone(this._previousAttributes)},isValid:function(){try{this.validate(this.attributes)}catch(n){return!1}return!0},validate:function(e){if(s.has(e,"ACL")&&!(e.ACL instanceof n.ACL))throw new o(o.OTHER_CAUSE,"ACL must be a AV.ACL.")},_validate:function(n,e){!e.silent&&this.validate&&(n=s.extend({},this.attributes,n),this.validate(n))},getACL:function(){return this.get("ACL")},setACL:function(n,e){return this.set("ACL",n,e)},disableBeforeHook:function(){this.ignoreHook("beforeSave"),this.ignoreHook("beforeUpdate"),this.ignoreHook("beforeDelete")},disableAfterHook:function(){this.ignoreHook("afterSave"),this.ignoreHook("afterUpdate"),this.ignoreHook("afterDelete")},ignoreHook:function(e){s.contains(["beforeSave","afterSave","beforeUpdate","afterUpdate","beforeDelete","afterDelete"],e)||console.trace("Unsupported hookName: "+e),n.hookKey||console.trace("ignoreHook required hookKey"),this._flags.__ignore_hooks||(this._flags.__ignore_hooks=[]),this._flags.__ignore_hooks.push(e)}}),n.Object.createWithoutData=function(e,t,i){var r=void 0;if(s.isString(e))r=n.Object._getSubclass(e);else{if(!(e.prototype&&e.prototype instanceof n.Object))throw new Error("class must be a string or a subclass of AV.Object.");r=e}var o=new r;return o.id=t,o._hasData=i,o},n.Object.destroyAll=function(n){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(!n||0===n.length)return a.resolve();var t=s.groupBy(n,(function(n){return JSON.stringify({className:n.className,flags:n._flags})})),i={requests:s.map(t,(function(n){var e=s.map(n,"id").join(",");return{method:"DELETE",path:"/1.1/classes/"+n[0].className+"/"+e,body:n[0]._flags}}))};return l("batch",null,null,"POST",i,e).then((function(n){var e=s.find(n,(function(n){return!n.success}));if(e)throw new o(e.error.code,e.error.error)}))},n.Object._getSubclass=function(e){if(!s.isString(e))throw new Error("AV.Object._getSubclass requires a string argument.");var t=n.Object._classMap[e];return t||(t=n.Object.extend(e),n.Object._classMap[e]=t),t},n.Object._create=function(e,t,i){return new(n.Object._getSubclass(e))(t,i)},n.Object._classMap={},n.Object._extend=n._extend,n.Object.new=function(e,t){return new n.Object(e,t)},n.Object.extend=function(e,t,i){if(!s.isString(e)){if(e&&s.has(e,"className"))return n.Object.extend(e.className,e,t);throw new Error("AV.Object.extend's first argument should be the className.")}"User"===e&&(e="_User");var r=null;if(s.has(n.Object._classMap,e)){var o=n.Object._classMap[e];if(!t&&!i)return o;r=o._extend(t,i)}else(t=t||{})._className=e,r=this._extend(t,i);return r.extend=function(t){if(s.isString(t)||t&&s.has(t,"className"))return n.Object.extend.apply(r,arguments);var i=[e].concat(s.toArray(arguments));return n.Object.extend.apply(r,i)},Object.defineProperty(r,"query",Object.getOwnPropertyDescriptor(n.Object,"query")),r.new=function(n,e){return new r(n,e)},n.Object._classMap[e]=r,r},Object.defineProperty(n.Object.prototype,"className",{get:function(){var n=this._className||this.constructor._LCClassName||this.constructor.name;return"User"===n?"_User":n}}),n.Object.register=function(e,t){if(!(e.prototype instanceof n.Object))throw new Error("registered class is not a subclass of AV.Object");var i=t||e.name;if(!i.length)throw new Error("registered class must be named");t&&(e._LCClassName=t),n.Object._classMap[i]=e},Object.defineProperty(n.Object,"query",{get:function(){return new n.Query(this.prototype.className)}}),n.Object._findUnsavedChildren=function(e,t,i){n._traverse(e,(function(e){return e instanceof n.Object?void(e.dirty()&&t.push(e)):e instanceof n.File?void(e.id||i.push(e)):void 0}))},n.Object._canBeSerializedAsValue=function(e){var t=!0;return e instanceof n.Object||e instanceof n.File?t=!!e.id:s.isArray(e)?n._arrayEach(e,(function(e){n.Object._canBeSerializedAsValue(e)||(t=!1)})):s.isObject(e)&&n._objectEach(e,(function(e){n.Object._canBeSerializedAsValue(e)||(t=!1)})),t},n.Object._deepSaveAsync=function(e,t,i){var r=[],u=[];n.Object._findUnsavedChildren(e,r,u);var c=a.resolve();s.each(u,(function(n){c=c.then((function(){return n.save()}))}));var d=s.uniq(r),m=s.uniq(d);return c.then((function(){return a._continueWhile((function(){return m.length>0}),(function(){var e=[],t=[];if(n._arrayEach(m,(function(n){e.length>20?t.push(n):n._canBeSerialized()?e.push(n):t.push(n)})),m=t,0===e.length)return a.reject(new o(o.OTHER_CAUSE,"Tried to save a batch with a cycle."));var r=a.resolve(s.map(e,(function(n){return n._allPreviousSaves||a.resolve()}))).then((function(){return l("batch",null,null,"POST",{requests:s.map(e,(function(n){var e=n.id?"PUT":"POST",t=n._getSaveJSON();s.extend(t,n._flags);var i="/classes/"+n.className;return"_User"!==n.className||n.id||(i="/users"),i="/1.1"+i,n.id&&(i=i+"/"+n.id),n._startSave(),{method:e,path:i,body:t}}))},i).then((function(n){var t=s.map(e,(function(e,t){return n[t].success?(e._finishSave(e.parse(n[t].success)),e):(e._cancelSave(),new o(n[t].error.code,n[t].error.error))}));return b(t)}))}));return n._arrayEach(e,(function(n){n._allPreviousSaves=r})),r}))})).then((function(){return e}))}}},function(n,e,t){"use strict";var i=t(0),r=t(4);n.exports=function(n){n.Role=n.Object.extend("_Role",{constructor:function(e,t){if(i.isString(e)?(n.Object.prototype.constructor.call(this,null,null),this.setName(e)):n.Object.prototype.constructor.call(this,e,t),t){if(!(t instanceof n.ACL))throw new TypeError("acl must be an instance of AV.ACL");this.setACL(t)}},getName:function(){return this.get("name")},setName:function(n,e){return this.set("name",n,e)},getUsers:function(){return this.relation("users")},getRoles:function(){return this.relation("roles")},validate:function(e,t){if("name"in e&&e.name!==this.getName()){var s=e.name;if(this.id&&this.id!==e.objectId)return new r(r.OTHER_CAUSE,"A role's name can only be set before it has been saved.");if(!i.isString(s))return new r(r.OTHER_CAUSE,"A role's name must be a String.");if(!/^[0-9a-zA-Z\-_ ]+$/.test(s))return new r(r.OTHER_CAUSE,"A role's name can only contain alphanumeric characters, _, -, and spaces.")}return!!n.Object.prototype.validate&&n.Object.prototype.validate.call(this,e,t)}})}},function(n,e,t){"use strict";function i(n,e,t){return e in n?Object.defineProperty(n,e,{value:t,enumerable:!0,configurable:!0,writable:!0}):n[e]=t,n}var r=t(0),s=t(9),o=t(4),a=t(2),l=a._request,u=a.request,c=t(1),d=function(){if("undefined"==typeof wx||"function"!=typeof wx.login)throw new Error("Weapp Login is only available in Weapp");return new c((function(n,e){wx.login({success:function(t){var i=t.code,r=t.errMsg;i?n(i):e(new Error(r))},fail:function(){return e(new Error("wx.login 失败"))}})}))},m=function(n){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},t=e.preferUnionId,i=e.unionIdPlatform,r=void 0===i?"weixin":i,s=e.asMainAccount,o=void 0===s||s;return t?{platform:r,main_account:o,code:n}:{code:n}},p=function(n,e){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},i=t.unionIdPlatform,s=void 0===i?"weixin":i,a=t.asMainAccount,l=void 0!==a&&a;if("string"!=typeof e)throw new o(o.OTHER_CAUSE,"unionId is not a string");if("string"!=typeof s)throw new o(o.OTHER_CAUSE,"unionIdPlatform is not a string");return r.extend({},n,{platform:s,unionid:e,main_account:Boolean(l)})};n.exports=function(n){n.User=n.Object.extend("_User",{_isCurrentUser:!1,_mergeMagicFields:function(e){return e.sessionToken&&(this._sessionToken=e.sessionToken,delete e.sessionToken),n.User.__super__._mergeMagicFields.call(this,e)},_cleanupAuthData:function(){if(this.isCurrent()){var e=this.get("authData");e&&n._objectEach(this.get("authData"),(function(n,t){e[t]||delete e[t]}))}},_synchronizeAllAuthData:function(){if(this.get("authData")){var e=this;n._objectEach(this.get("authData"),(function(n,t){e._synchronizeAuthData(t)}))}},_synchronizeAuthData:function(e){if(this.isCurrent()){var t;r.isString(e)?(t=e,e=n.User._authProviders[t]):t=e.getAuthType();var i=this.get("authData");i&&e&&(e.restoreAuthentication(i[t])||this.dissociateAuthData(e))}},_handleSaveResult:function(e){return e&&!n._config.disableCurrentUser&&(this._isCurrentUser=!0),this._cleanupAuthData(),this._synchronizeAllAuthData(),delete this._serverData.password,this._rebuildEstimatedDataForKey("password"),this._refreshCache(),!e&&!this.isCurrent()||n._config.disableCurrentUser?c.resolve():c.resolve(n.User._saveCurrentUser(this))},_linkWith:function(e,t){var s,o=this,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},l=a.failOnNotExist,u=void 0!==l&&l;return r.isString(e)?(s=e,e=n.User._authProviders[e]):s=e.getAuthType(),t?this.save({authData:i({},s,t)},{fetchWhenSave:!!this.get("authData"),_failOnNotExist:u}).then((function(n){return n._handleSaveResult(!0).then((function(){return n}))})):e.authenticate().then((function(n){return o._linkWith(e,n)}))},associateWithAuthData:function(n,e){return this._linkWith(e,n)},associateWithAuthDataAndUnionId:function(n,e,t,i){return this._linkWith(e,p(n,t,i))},associateWithWeapp:function(n){var e=this;return d().then((function(t){return e._linkWith("lc_weapp",m(t,n))}))},linkWithWeapp:function(n){return console.warn("DEPRECATED: User#linkWithWeapp 已废弃，请使用 User#associateWithWeapp 代替"),this.associateWithWeapp(n)},associateWithWeappWithUnionId:function(n,e){var t=this;return d().then((function(i){return t._linkWith("lc_weapp",p({code:i},n,e))}))},dissociateAuthData:function(n){return this.unset("authData."+n),this.save().then((function(n){return n._handleSaveResult(!0).then((function(){return n}))}))},_unlinkFrom:function(n){return console.warn("DEPRECATED: User#_unlinkFrom 已废弃，请使用 User#dissociateAuthData 代替"),this.dissociateAuthData(n)},_isLinked:function(n){var e;return e=r.isString(n)?n:n.getAuthType(),!!(this.get("authData")||{})[e]},isAnonymous:function(){return this._isLinked("anonymous")},logOut:function(){this._logOutWithAll(),this._isCurrentUser=!1},_logOutWithAll:function(){if(this.get("authData")){var e=this;n._objectEach(this.get("authData"),(function(n,t){e._logOutWith(t)}))}},_logOutWith:function(e){this.isCurrent()&&(r.isString(e)&&(e=n.User._authProviders[e]),e&&e.deauthenticate&&e.deauthenticate())},signUp:function(n,e){var t=n&&n.username||this.get("username");if(!t||""===t)throw new o(o.OTHER_CAUSE,"Cannot sign up user with an empty name.");var i=n&&n.password||this.get("password");if(!i||""===i)throw new o(o.OTHER_CAUSE,"Cannot sign up user with an empty password.");return this.save(n,e).then((function(n){return n.isAnonymous()&&(n.unset("authData.anonymous"),n._opSetQueue=[{}]),n._handleSaveResult(!0).then((function(){return n}))}))},signUpOrlogInWithMobilePhone:function(n){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},t=n&&n.mobilePhoneNumber||this.get("mobilePhoneNumber");if(!t||""===t)throw new o(o.OTHER_CAUSE,"Cannot sign up or login user by mobilePhoneNumber with an empty mobilePhoneNumber.");var i=n&&n.smsCode||this.get("smsCode");if(!i||""===i)throw new o(o.OTHER_CAUSE,"Cannot sign up or login user by mobilePhoneNumber  with an empty smsCode.");return e._makeRequest=function(n,e,t,i,r){return l("usersByMobilePhone",null,null,"POST",r)},this.save(n,e).then((function(n){return delete n.attributes.smsCode,delete n._serverData.smsCode,n._handleSaveResult(!0).then((function(){return n}))}))},loginWithAuthData:function(n,e,t){return this._linkWith(e,n,t)},loginWithAuthDataAndUnionId:function(n,e,t,i){return this.loginWithAuthData(p(n,t,i),e,i)},loginWithWeapp:function(n){var e=this;return d().then((function(t){return e.loginWithAuthData(m(t,n),"lc_weapp",n)}))},loginWithWeappWithUnionId:function(n,e){var t=this;return d().then((function(i){return t.loginWithAuthData(p({code:i},n,e),"lc_weapp",e)}))},logIn:function(){var n=this;return l("login",null,null,"POST",this.toJSON()).then((function(e){var t=n.parse(e);return n._finishFetch(t),n._handleSaveResult(!0).then((function(){return t.smsCode||delete n.attributes.smsCode,n}))}))},save:function(e,t,i){var s,o;return r.isObject(e)||r.isNull(e)||r.isUndefined(e)?(s=e,o=t):((s={})[e]=t,o=i),o=o||{},n.Object.prototype.save.call(this,s,o).then((function(n){return n._handleSaveResult(!1).then((function(){return n}))}))},follow:function(e,t){if(!this.id)throw new Error("Please signin.");var i=void 0,s=void 0;e.user?(i=e.user,s=e.attributes):i=e;var o=r.isString(i)?i:i.id;if(!o)throw new Error("Invalid target user.");var a="users/"+this.id+"/friendship/"+o;return l(a,null,null,"POST",n._encode(s),t)},unfollow:function(n,e){if(!this.id)throw new Error("Please signin.");var t;t=n.user?n.user:n;var i=r.isString(t)?t:t.id;if(!i)throw new Error("Invalid target user.");var s="users/"+this.id+"/friendship/"+i;return l(s,null,null,"DELETE",null,e)},followerQuery:function(){return n.User.followerQuery(this.id)},followeeQuery:function(){return n.User.followeeQuery(this.id)},fetch:function(e,t){return n.Object.prototype.fetch.call(this,e,t).then((function(n){return n._handleSaveResult(!1).then((function(){return n}))}))},updatePassword:function(n,e,t){var i="users/"+this.id+"/updatePassword";return l(i,null,null,"PUT",{old_password:n,new_password:e},t)},isCurrent:function(){return this._isCurrentUser},getUsername:function(){return this.get("username")},getMobilePhoneNumber:function(){return this.get("mobilePhoneNumber")},setMobilePhoneNumber:function(n,e){return this.set("mobilePhoneNumber",n,e)},setUsername:function(n,e){return this.set("username",n,e)},setPassword:function(n,e){return this.set("password",n,e)},getEmail:function(){return this.get("email")},setEmail:function(n,e){return this.set("email",n,e)},authenticated:function(){return console.warn("DEPRECATED: 如果要判断当前用户的登录状态是否有效，请使用 currentUser.isAuthenticated().then()，如果要判断该用户是否是当前登录用户，请使用 user.id === currentUser.id。"),!!this._sessionToken&&!n._config.disableCurrentUser&&n.User.current()&&n.User.current().id===this.id},isAuthenticated:function(){var e=this;return c.resolve().then((function(){return!!e._sessionToken&&n.User._fetchUserBySessionToken(e._sessionToken).then((function(){return!0}),(function(n){if(211===n.code)return!1;throw n}))}))},getSessionToken:function(){return this._sessionToken},refreshSessionToken:function(n){var e=this;return l("users/"+this.id+"/refreshSessionToken",null,null,"PUT",null,n).then((function(n){return e._finishFetch(n),e._handleSaveResult(!0).then((function(){return e}))}))},getRoles:function(e){return n.Relation.reverseQuery("_Role","users",this).find(e)}},{_currentUser:null,_currentUserMatchesDisk:!1,_CURRENT_USER_KEY:"currentUser",_authProviders:{},signUp:function(e,t,i,r){return(i=i||{}).username=e,i.password=t,n.Object._create("_User").signUp(i,r)},logIn:function(e,t){var i=n.Object._create("_User");return i._finishFetch({username:e,password:t}),i.logIn()},become:function(n){return this._fetchUserBySessionToken(n).then((function(n){return n._handleSaveResult(!0).then((function(){return n}))}))},_fetchUserBySessionToken:function(e){var t=n.Object._create("_User");return u({method:"GET",path:"/users/me",authOptions:{sessionToken:e}}).then((function(n){var e=t.parse(n);return t._finishFetch(e),t}))},logInWithMobilePhoneSmsCode:function(e,t){var i=n.Object._create("_User");return i._finishFetch({mobilePhoneNumber:e,smsCode:t}),i.logIn()},signUpOrlogInWithMobilePhone:function(e,t,i,r){return(i=i||{}).mobilePhoneNumber=e,i.smsCode=t,n.Object._create("_User").signUpOrlogInWithMobilePhone(i,r)},logInWithMobilePhone:function(e,t){var i=n.Object._create("_User");return i._finishFetch({mobilePhoneNumber:e,password:t}),i.logIn()},loginWithEmail:function(e,t){var i=n.Object._create("_User");return i._finishFetch({email:e,password:t}),i.logIn()},loginWithAuthData:function(e,t,i){return n.User._logInWith(t,e,i)},signUpOrlogInWithAuthData:function(){return console.warn("DEPRECATED: User.signUpOrlogInWithAuthData 已废弃，请使用 User#loginWithAuthData 代替"),this.loginWithAuthData.apply(this,arguments)},loginWithAuthDataAndUnionId:function(n,e,t,i){return this.loginWithAuthData(p(n,t,i),e,i)},signUpOrlogInWithAuthDataAndUnionId:function(){return console.warn("DEPRECATED: User.signUpOrlogInWithAuthDataAndUnionId 已废弃，请使用 User#loginWithAuthDataAndUnionId 代替"),this.loginWithAuthDataAndUnionId.apply(this,arguments)},loginWithWeapp:function(n){var e=this;return d().then((function(t){return e.loginWithAuthData(m(t,n),"lc_weapp",n)}))},loginWithWeappWithUnionId:function(n,e){var t=this;return d().then((function(i){return t.loginWithAuthData(p({code:i},n,e),"lc_weapp",e)}))},loginAnonymously:function(){return this.loginWithAuthData({id:s()},"anonymous")},associateWithAuthData:function(n,e,t){return console.warn("DEPRECATED: User.associateWithAuthData 已废弃，请使用 User#associateWithAuthData 代替"),n._linkWith(e,t)},logOut:function(){return n._config.disableCurrentUser?(console.warn("AV.User.current() was disabled in multi-user environment, call logOut() from user object instead https://leancloud.cn/docs/leanengine-node-sdk-upgrade-1.html"),c.resolve(null)):(null!==n.User._currentUser&&(n.User._currentUser._logOutWithAll(),n.User._currentUser._isCurrentUser=!1),n.User._currentUserMatchesDisk=!0,n.User._currentUser=null,n.localStorage.removeItemAsync(n._getAVPath(n.User._CURRENT_USER_KEY)).then((function(){return n._refreshSubscriptionId()})))},followerQuery:function(e){if(!e||!r.isString(e))throw new Error("Invalid user object id.");var t=new n.FriendShipQuery("_Follower");return t._friendshipTag="follower",t.equalTo("user",n.Object.createWithoutData("_User",e)),t},followeeQuery:function(e){if(!e||!r.isString(e))throw new Error("Invalid user object id.");var t=new n.FriendShipQuery("_Followee");return t._friendshipTag="followee",t.equalTo("user",n.Object.createWithoutData("_User",e)),t},requestPasswordReset:function(n){return l("requestPasswordReset",null,null,"POST",{email:n})},requestEmailVerify:function(n){return l("requestEmailVerify",null,null,"POST",{email:n})},requestMobilePhoneVerify:function(n){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},t={mobilePhoneNumber:n};return e.validateToken&&(t.validate_token=e.validateToken),l("requestMobilePhoneVerify",null,null,"POST",t,e)},requestPasswordResetBySmsCode:function(n){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},t={mobilePhoneNumber:n};return e.validateToken&&(t.validate_token=e.validateToken),l("requestPasswordResetBySmsCode",null,null,"POST",t,e)},resetPasswordBySmsCode:function(n,e){return l("resetPasswordBySmsCode",null,n,"PUT",{password:e})},verifyMobilePhone:function(n){return l("verifyMobilePhone",null,n,"POST",null)},requestLoginSmsCode:function(n){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},t={mobilePhoneNumber:n};return e.validateToken&&(t.validate_token=e.validateToken),l("requestLoginSmsCode",null,null,"POST",t,e)},currentAsync:function(){return n._config.disableCurrentUser?(console.warn("AV.User.currentAsync() was disabled in multi-user environment, access user from request instead https://leancloud.cn/docs/leanengine-node-sdk-upgrade-1.html"),c.resolve(null)):n.User._currentUser?c.resolve(n.User._currentUser):n.User._currentUserMatchesDisk?c.resolve(n.User._currentUser):n.localStorage.getItemAsync(n._getAVPath(n.User._CURRENT_USER_KEY)).then((function(e){if(!e)return null;n.User._currentUserMatchesDisk=!0,n.User._currentUser=n.Object._create("_User"),n.User._currentUser._isCurrentUser=!0;var t=JSON.parse(e);return n.User._currentUser.id=t._id,delete t._id,n.User._currentUser._sessionToken=t._sessionToken,delete t._sessionToken,n.User._currentUser._finishFetch(t),n.User._currentUser._synchronizeAllAuthData(),n.User._currentUser._refreshCache(),n.User._currentUser._opSetQueue=[{}],n.User._currentUser}))},current:function(){if(n._config.disableCurrentUser)return console.warn("AV.User.current() was disabled in multi-user environment, access user from request instead https://leancloud.cn/docs/leanengine-node-sdk-upgrade-1.html"),null;if(n.User._currentUser)return n.User._currentUser;if(n.User._currentUserMatchesDisk)return n.User._currentUser;n.User._currentUserMatchesDisk=!0;var e=n.localStorage.getItem(n._getAVPath(n.User._CURRENT_USER_KEY));if(!e)return null;n.User._currentUser=n.Object._create("_User"),n.User._currentUser._isCurrentUser=!0;var t=JSON.parse(e);return n.User._currentUser.id=t._id,delete t._id,n.User._currentUser._sessionToken=t._sessionToken,delete t._sessionToken,n.User._currentUser._finishFetch(t),n.User._currentUser._synchronizeAllAuthData(),n.User._currentUser._refreshCache(),n.User._currentUser._opSetQueue=[{}],n.User._currentUser},_saveCurrentUser:function(e){return(n.User._currentUser!==e?n.User.logOut():c.resolve()).then((function(){e._isCurrentUser=!0,n.User._currentUser=e;var t=e._toFullJSON();return t._id=e.id,t._sessionToken=e._sessionToken,n.localStorage.setItemAsync(n._getAVPath(n.User._CURRENT_USER_KEY),JSON.stringify(t)).then((function(){return n.User._currentUserMatchesDisk=!0,n._refreshSubscriptionId()}))}))},_registerAuthenticationProvider:function(e){n.User._authProviders[e.getAuthType()]=e,!n._config.disableCurrentUser&&n.User.current()&&n.User.current()._synchronizeAuthData(e.getAuthType())},_logInWith:function(e,t,i){return n.Object._create("_User")._linkWith(e,t,i)}})}},function(n,e,t){"use strict";var i=t(0),r=t(6)("leancloud:query"),s=t(1),o=t(4),a=t(2),l=a._request,u=a.request,c=t(3),d=c.ensureArray,m=c.transformFetchOptions,p=function(n,e){if(void 0===n)throw new Error(e)};n.exports=function(n){n.Query=function(e){i.isString(e)&&(e=n.Object._getSubclass(e)),this.objectClass=e,this.className=e.prototype.className,this._where={},this._include=[],this._select=[],this._limit=-1,this._skip=0,this._extraOptions={}},n.Query.or=function(){var e=i.toArray(arguments),t=null;n._arrayEach(e,(function(n){if(i.isNull(t)&&(t=n.className),t!==n.className)throw new Error("All queries must be for the same class")}));var r=new n.Query(t);return r._orQuery(e),r},n.Query.and=function(){var e=i.toArray(arguments),t=null;n._arrayEach(e,(function(n){if(i.isNull(t)&&(t=n.className),t!==n.className)throw new Error("All queries must be for the same class")}));var r=new n.Query(t);return r._andQuery(e),r},n.Query.doCloudQuery=function(e,t,r){var s={cql:e};return i.isArray(t)?s.pvalues=t:r=t,l("cloudQuery",null,null,"GET",s,r).then((function(e){var t=new n.Query(e.className);return{results:i.map(e.results,(function(n){var i=t._newObject(e);return i._finishFetch&&i._finishFetch(t._processResult(n),!0),i})),count:e.count,className:e.className}}))},n.Query._extend=n._extend,i.extend(n.Query.prototype,{_processResult:function(n){return n},get:function(n,e){if(!n)throw new o(o.OBJECT_NOT_FOUND,"Object not found.");var t=this._newObject();t.id=n;var r=this.toJSON(),s={};return r.keys&&(s.keys=r.keys),r.include&&(s.include=r.include),r.includeACL&&(s.includeACL=r.includeACL),l("classes",this.className,n,"GET",m(s),e).then((function(n){if(i.isEmpty(n))throw new o(o.OBJECT_NOT_FOUND,"Object not found.");return t._finishFetch(t.parse(n),!0),t}))},toJSON:function(){var e={where:this._where};return this._include.length>0&&(e.include=this._include.join(",")),this._select.length>0&&(e.keys=this._select.join(",")),void 0!==this._includeACL&&(e.returnACL=this._includeACL),this._limit>=0&&(e.limit=this._limit),this._skip>0&&(e.skip=this._skip),void 0!==this._order&&(e.order=this._order),n._objectEach(this._extraOptions,(function(n,t){e[t]=n})),e},_newObject:function(e){return e&&e.className?new n.Object(e.className):new this.objectClass},_createRequest:function(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this.toJSON(),e=arguments[1],t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"/classes/"+this.className;return encodeURIComponent(JSON.stringify(n)).length>2e3?u({path:"/batch",method:"POST",data:{requests:[{method:"GET",path:"/1.1"+t,params:n}]},authOptions:e}).then((function(n){var e=n[0];if(e.success)return e.success;var t=new Error(e.error.error||"Unknown batch error");throw t.code=e.error.code,t})):u({method:"GET",path:t,query:n,authOptions:e})},_parseResponse:function(n){var e=this;return i.map(n.results,(function(t){var i=e._newObject(n);return i._finishFetch&&i._finishFetch(e._processResult(t),!0),i}))},find:function(n){return this._createRequest(void 0,n).then(this._parseResponse.bind(this))},scan:function(){var n=this,e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t=e.orderedBy,o=e.batchSize,a=arguments[1],u=this.toJSON();r("scan %O",u),u.order&&(console.warn("The order of the query is ignored for Query#scan. Checkout the orderedBy option of Query#scan."),delete u.order),u.skip&&(console.warn("The skip option of the query is ignored for Query#scan."),delete u.skip),u.limit&&(console.warn("The limit option of the query is ignored for Query#scan."),delete u.limit),t&&(u.scan_key=t),o&&(u.limit=o);var c=s.resolve([]),d=void 0,m=!1;return{next:function(){return(c=c.then((function(e){return m?[]:e.length>1?e:d||0===e.length?l("scan/classes",n.className,null,"GET",d?i.extend({},u,{cursor:d}):u,a).then((function(e){return d=e.cursor,n._parseResponse(e)})).then((function(n){return n.length||(m=!0),e.concat(n)})):(m=!0,e)}))).then((function(n){return n.shift()})).then((function(n){return{value:n,done:m}}))}}},destroyAll:function(e){return this.find(e).then((function(t){return n.Object.destroyAll(t,e)}))},count:function(n){var e=this.toJSON();return e.limit=0,e.count=1,this._createRequest(e,n).then((function(n){return n.count}))},first:function(n){var e=this,t=this.toJSON();return t.limit=1,this._createRequest(t,n).then((function(n){return i.map(n.results,(function(n){var t=e._newObject();return t._finishFetch&&t._finishFetch(e._processResult(n),!0),t}))[0]}))},skip:function(n){return p(n,"undefined is not a valid skip value"),this._skip=n,this},limit:function(n){return p(n,"undefined is not a valid limit value"),this._limit=n,this},equalTo:function(e,t){return p(e,"undefined is not a valid key"),p(t,"undefined is not a valid value"),this._where[e]=n._encode(t),this},_addCondition:function(e,t,i){return p(e,"undefined is not a valid condition key"),p(t,"undefined is not a valid condition"),p(i,"undefined is not a valid condition value"),this._where[e]||(this._where[e]={}),this._where[e][t]=n._encode(i),this},sizeEqualTo:function(n,e){return this._addCondition(n,"$size",e),this},notEqualTo:function(n,e){return this._addCondition(n,"$ne",e),this},lessThan:function(n,e){return this._addCondition(n,"$lt",e),this},greaterThan:function(n,e){return this._addCondition(n,"$gt",e),this},lessThanOrEqualTo:function(n,e){return this._addCondition(n,"$lte",e),this},greaterThanOrEqualTo:function(n,e){return this._addCondition(n,"$gte",e),this},containedIn:function(n,e){return this._addCondition(n,"$in",e),this},notContainedIn:function(n,e){return this._addCondition(n,"$nin",e),this},containsAll:function(n,e){return this._addCondition(n,"$all",e),this},exists:function(n){return this._addCondition(n,"$exists",!0),this},doesNotExist:function(n){return this._addCondition(n,"$exists",!1),this},matches:function(n,e,t){return this._addCondition(n,"$regex",e),t||(t=""),e.ignoreCase&&(t+="i"),e.multiline&&(t+="m"),t&&t.length&&this._addCondition(n,"$options",t),this},matchesQuery:function(n,e){var t=e.toJSON();return t.className=e.className,this._addCondition(n,"$inQuery",t),this},doesNotMatchQuery:function(n,e){var t=e.toJSON();return t.className=e.className,this._addCondition(n,"$notInQuery",t),this},matchesKeyInQuery:function(n,e,t){var i=t.toJSON();return i.className=t.className,this._addCondition(n,"$select",{key:e,query:i}),this},doesNotMatchKeyInQuery:function(n,e,t){var i=t.toJSON();return i.className=t.className,this._addCondition(n,"$dontSelect",{key:e,query:i}),this},_orQuery:function(n){var e=i.map(n,(function(n){return n.toJSON().where}));return this._where.$or=e,this},_andQuery:function(n){var e=i.map(n,(function(n){return n.toJSON().where}));return this._where.$and=e,this},_quote:function(n){return"\\Q"+n.replace("\\E","\\E\\\\E\\Q")+"\\E"},contains:function(n,e){return this._addCondition(n,"$regex",this._quote(e)),this},startsWith:function(n,e){return this._addCondition(n,"$regex","^"+this._quote(e)),this},endsWith:function(n,e){return this._addCondition(n,"$regex",this._quote(e)+"$"),this},ascending:function(n){return p(n,"undefined is not a valid key"),this._order=n,this},addAscending:function(n){return p(n,"undefined is not a valid key"),this._order?this._order+=","+n:this._order=n,this},descending:function(n){return p(n,"undefined is not a valid key"),this._order="-"+n,this},addDescending:function(n){return p(n,"undefined is not a valid key"),this._order?this._order+=",-"+n:this._order="-"+n,this},near:function(e,t){return t instanceof n.GeoPoint||(t=new n.GeoPoint(t)),this._addCondition(e,"$nearSphere",t),this},withinRadians:function(n,e,t){return this.near(n,e),this._addCondition(n,"$maxDistance",t),this},withinMiles:function(n,e,t){return this.withinRadians(n,e,t/3958.8)},withinKilometers:function(n,e,t){return this.withinRadians(n,e,t/6371)},withinGeoBox:function(e,t,i){return t instanceof n.GeoPoint||(t=new n.GeoPoint(t)),i instanceof n.GeoPoint||(i=new n.GeoPoint(i)),this._addCondition(e,"$within",{$box:[t,i]}),this},include:function(n){var e=this;return p(n,"undefined is not a valid key"),i(arguments).forEach((function(n){e._include=e._include.concat(d(n))})),this},includeACL:function(){var n=!(arguments.length>0&&void 0!==arguments[0])||arguments[0];return this._includeACL=n,this},select:function(n){var e=this;return p(n,"undefined is not a valid key"),i(arguments).forEach((function(n){e._select=e._select.concat(d(n))})),this},each:function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(this._order||this._skip||this._limit>=0){var r=new Error("Cannot iterate on a query with sort, skip, or limit.");return s.reject(r)}var o=new n.Query(this.objectClass);o._limit=t.batchSize||100,o._where=i.clone(this._where),o._include=i.clone(this._include),o.ascending("objectId");var a=!1;return s._continueWhile((function(){return!a}),(function(){return o.find(t).then((function(n){var t=s.resolve();return i.each(n,(function(n){t=t.then((function(){return e(n)}))})),t.then((function(){n.length>=o._limit?o.greaterThan("objectId",n[n.length-1].id):a=!0}))}))}))},subscribe:function(e){return n.LiveQuery.init(this,e)}}),n.FriendShipQuery=n.Query._extend({_newObject:function(){return new(n.Object._getSubclass("_User"))},_processResult:function(n){if(n&&n[this._friendshipTag]){var e=n[this._friendshipTag];return"Pointer"===e.__type&&"_User"===e.className&&(delete e.__type,delete e.className),e}return null}})}},function(n,e,t){"use strict";var i=t(0),r=t(53),s=t(1),o=t(3).inherits,a=t(2).request,l=function(n,e){return a({method:"POST",path:"/LiveQuery/subscribe",data:{query:n,id:e}})};n.exports=function(n){var e=function(){if(!n._config.realtime)throw new Error("LiveQuery not supported. Please use the LiveQuery bundle. https://url.leanapp.cn/enable-live-query")};n.LiveQuery=o(r,{constructor:function(n,e,t,i){var s=this;r.apply(this),this.id=n,this._client=e,this._client.register(this),this._queryJSON=t,this._subscriptionId=i,this._onMessage=this._dispatch.bind(this),this._onReconnect=function(){l(s._queryJSON,s._subscriptionId).catch((function(n){return console.error("LiveQuery resubscribe error: "+n.message)}))},e.on("message",this._onMessage),e.on("reconnect",this._onReconnect)},_dispatch:function(e){var t=this;e.forEach((function(e){var r=e.op,s=e.object,o=e.query_id,a=e.updatedKeys;if(o===t.id){var l=n.parseJSON(i.extend({__type:"_File"===s.className?"File":"Object"},s));a?t.emit(r,l,a):t.emit(r,l)}}))},unsubscribe:function(){var n=this._client;return n.off("message",this._onMessage),n.off("reconnect",this._onReconnect),n.deregister(this),a({method:"POST",path:"/LiveQuery/unsubscribe",data:{id:n.id,query_id:this.id}})}},{init:function(t){var i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},r=i.subscriptionId,o=void 0===r?n._getSubscriptionId():r;if(e(),!(t instanceof n.Query))throw new TypeError("LiveQuery must be inited with a Query");return s.resolve(o).then((function(e){return n._config.realtime.createLiveQueryClient(e).then((function(i){var r=t.toJSON(),s={where:r.where,keys:r.keys,returnACL:r.returnACL,className:t.className},o=l(s,e).then((function(t){var r=t.query_id;return new n.LiveQuery(r,i,s,e)})).finally((function(){i.deregister(o)}));return i.register(o),o}))}))},pause:function(){return e(),n._config.realtime.pause()},resume:function(){return e(),n._config.realtime.resume()}})}},function(n,e,t){"use strict";function i(){}function r(n,e,t){this.fn=n,this.context=e,this.once=t||!1}function s(){this._events=new i,this._eventsCount=0}var o=Object.prototype.hasOwnProperty,a="~";Object.create&&(i.prototype=Object.create(null),(new i).__proto__||(a=!1)),s.prototype.eventNames=function(){var n,e,t=[];if(0===this._eventsCount)return t;for(e in n=this._events)o.call(n,e)&&t.push(a?e.slice(1):e);return Object.getOwnPropertySymbols?t.concat(Object.getOwnPropertySymbols(n)):t},s.prototype.listeners=function(n,e){var t=a?a+n:n,i=this._events[t];if(e)return!!i;if(!i)return[];if(i.fn)return[i.fn];for(var r=0,s=i.length,o=new Array(s);r<s;r++)o[r]=i[r].fn;return o},s.prototype.emit=function(n,e,t,i,r,s){var o=a?a+n:n;if(!this._events[o])return!1;var l,u,c=this._events[o],d=arguments.length;if(c.fn){switch(c.once&&this.removeListener(n,c.fn,void 0,!0),d){case 1:return c.fn.call(c.context),!0;case 2:return c.fn.call(c.context,e),!0;case 3:return c.fn.call(c.context,e,t),!0;case 4:return c.fn.call(c.context,e,t,i),!0;case 5:return c.fn.call(c.context,e,t,i,r),!0;case 6:return c.fn.call(c.context,e,t,i,r,s),!0}for(u=1,l=new Array(d-1);u<d;u++)l[u-1]=arguments[u];c.fn.apply(c.context,l)}else{var m,p=c.length;for(u=0;u<p;u++)switch(c[u].once&&this.removeListener(n,c[u].fn,void 0,!0),d){case 1:c[u].fn.call(c[u].context);break;case 2:c[u].fn.call(c[u].context,e);break;case 3:c[u].fn.call(c[u].context,e,t);break;case 4:c[u].fn.call(c[u].context,e,t,i);break;default:if(!l)for(m=1,l=new Array(d-1);m<d;m++)l[m-1]=arguments[m];c[u].fn.apply(c[u].context,l)}}return!0},s.prototype.on=function(n,e,t){var i=new r(e,t||this),s=a?a+n:n;return this._events[s]?this._events[s].fn?this._events[s]=[this._events[s],i]:this._events[s].push(i):(this._events[s]=i,this._eventsCount++),this},s.prototype.once=function(n,e,t){var i=new r(e,t||this,!0),s=a?a+n:n;return this._events[s]?this._events[s].fn?this._events[s]=[this._events[s],i]:this._events[s].push(i):(this._events[s]=i,this._eventsCount++),this},s.prototype.removeListener=function(n,e,t,r){var s=a?a+n:n;if(!this._events[s])return this;if(!e)return 0==--this._eventsCount?this._events=new i:delete this._events[s],this;var o=this._events[s];if(o.fn)o.fn!==e||r&&!o.once||t&&o.context!==t||(0==--this._eventsCount?this._events=new i:delete this._events[s]);else{for(var l=0,u=[],c=o.length;l<c;l++)(o[l].fn!==e||r&&!o[l].once||t&&o[l].context!==t)&&u.push(o[l]);u.length?this._events[s]=1===u.length?u[0]:u:0==--this._eventsCount?this._events=new i:delete this._events[s]}return this},s.prototype.removeAllListeners=function(n){var e;return n?(e=a?a+n:n,this._events[e]&&(0==--this._eventsCount?this._events=new i:delete this._events[e])):(this._events=new i,this._eventsCount=0),this},s.prototype.off=s.prototype.removeListener,s.prototype.addListener=s.prototype.on,s.prototype.setMaxListeners=function(){return this},s.prefixed=a,s.EventEmitter=s,n.exports=s},function(n,e,t){"use strict";var i=t(0),r=t(3).tap;n.exports=function(n){n.Captcha=function(n,e){this._options=n,this._authOptions=e,this.url=void 0,this.captchaToken=void 0,this.validateToken=void 0},n.Captcha.prototype.refresh=function(){var e=this;return n.Cloud._requestCaptcha(this._options,this._authOptions).then((function(n){var t=n.captchaToken,r=n.url;return i.extend(e,{captchaToken:t,url:r}),r}))},n.Captcha.prototype.verify=function(e){var t=this;return n.Cloud.verifyCaptcha(e,this.captchaToken).then(r((function(n){return t.validateToken=n})))},n.Captcha.prototype.bind=function(n,e){var t=this,i=n.textInput,r=n.image,s=n.verifyButton,o=e.success,a=e.error;if("string"==typeof i&&!(i=document.getElementById(i)))throw new Error("textInput with id "+i+" not found");if("string"==typeof r&&!(r=document.getElementById(r)))throw new Error("image with id "+r+" not found");if("string"==typeof s&&!(s=document.getElementById(s)))throw new Error("verifyButton with id "+s+" not found");this.__refresh=function(){return t.refresh().then((function(n){r.src=n,i&&(i.value="",i.focus())})).catch((function(n){return console.warn("refresh captcha fail: "+n.message)}))},r&&(this.__image=r,r.src=this.url,r.addEventListener("click",this.__refresh)),this.__verify=function(){var n=i.value;t.verify(n).catch((function(n){throw t.__refresh(),n})).then(o,a).catch((function(n){return console.warn("verify captcha fail: "+n.message)}))},i&&s&&(this.__verifyButton=s,s.addEventListener("click",this.__verify))},n.Captcha.prototype.unbind=function(){this.__image&&this.__image.removeEventListener("click",this.__refresh),this.__verifyButton&&this.__verifyButton.removeEventListener("click",this.__verify)},n.Captcha.request=function(e,t){var i=new n.Captcha(e,t);return i.refresh().then((function(){return i}))}}},function(n,e,t){"use strict";var i=t(0),r=t(2),s=r._request,o=r.request,a=t(1);n.exports=function(n){n.Cloud=n.Cloud||{},i.extend(n.Cloud,{run:function(e,t,i){return o({service:"engine",method:"POST",path:"/functions/"+e,data:n._encode(t,null,!0),authOptions:i}).then((function(e){return n._decode(e).result}))},rpc:function(e,t,r){return i.isArray(t)?a.reject(new Error("Can't pass Array as the param of rpc function in JavaScript SDK.")):o({service:"engine",method:"POST",path:"/call/"+e,data:n._encodeObjectOrArray(t),authOptions:r}).then((function(e){return n._decode(e).result}))},getServerDate:function(){return s("date",null,null,"GET").then((function(e){return n._decode(e)}))},requestSmsCode:function(n){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(i.isString(n)&&(n={mobilePhoneNumber:n}),!n.mobilePhoneNumber)throw new Error("Missing mobilePhoneNumber.");return e.validateToken&&(n=i.extend({},n,{validate_token:e.validateToken})),s("requestSmsCode",null,null,"POST",n,e)},verifySmsCode:function(n,e){if(!n)throw new Error("Missing sms code.");var t={};return i.isString(e)&&(t.mobilePhoneNumber=e),s("verifySmsCode",n,null,"POST",t)},_requestCaptcha:function(n,e){return s("requestCaptcha",null,null,"GET",n,e).then((function(n){var e=n.captcha_url;return{captchaToken:n.captcha_token,url:e}}))},requestCaptcha:n.Captcha.request,verifyCaptcha:function(n,e){return s("verifyCaptcha",null,null,"POST",{captcha_code:n,captcha_token:e}).then((function(n){return n.validate_token}))}})}},function(n,e,t){"use strict";var i=t(2).request;n.exports=function(n){n.Installation=n.Object.extend("_Installation"),n.Push=n.Push||{},n.Push.send=function(n,e){if(n.where&&(n.where=n.where.toJSON().where),n.where&&n.cql)throw new Error("Both where and cql can't be set");if(n.push_time&&(n.push_time=n.push_time.toJSON()),n.expiration_time&&(n.expiration_time=n.expiration_time.toJSON()),n.expiration_time&&n.expiration_time_interval)throw new Error("Both expiration_time and expiration_time_interval can't be set");return i({service:"push",method:"POST",path:"/push",data:n,authOptions:e})}}},function(n,e,t){"use strict";var i="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(n){return typeof n}:function(n){return n&&"function"==typeof Symbol&&n.constructor===Symbol&&n!==Symbol.prototype?"symbol":typeof n},r=t(0),s=t(1),o=t(2)._request,a=t(3).getSessionToken;n.exports=function(n){var e=function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return a(e)?n.User._fetchUserBySessionToken(a(e)):n.User.currentAsync()},t=function(t){return e(t).then((function(e){return n.Object.createWithoutData("_User",e.id)._toPointer()}))};n.Status=function(n,e){return this.data={},this.inboxType="default",this.query=null,n&&"object"===(void 0===n?"undefined":i(n))?this.data=n:(n&&(this.data.image=n),e&&(this.data.message=e)),this},r.extend(n.Status.prototype,{get:function(n){return this.data[n]},set:function(n,e){return this.data[n]=e,this},destroy:function(n){return this.id?o("statuses",null,this.id,"DELETE",n):s.reject(new Error("The status id is not exists."))},toObject:function(){return this.id?n.Object.createWithoutData("_Status",this.id):null},_getDataJSON:function(){var e=r.clone(this.data);return n._encode(e)},send:function(){var e=this,i=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};if(!a(i)&&!n.User.current())throw new Error("Please signin an user.");return this.query?t(i).then((function(n){var t=e.query.toJSON();t.className=e.query.className;var r={};return r.query=t,e.data=e.data||{},e.data.source=e.data.source||n,r.data=e._getDataJSON(),r.inboxType=e.inboxType||"default",o("statuses",null,null,"POST",r,i)})).then((function(t){return e.id=t.objectId,e.createdAt=n._parseDate(t.createdAt),e})):n.Status.sendStatusToFollowers(this,i)},_finishFetch:function(e){this.id=e.objectId,this.createdAt=n._parseDate(e.createdAt),this.updatedAt=n._parseDate(e.updatedAt),this.messageId=e.messageId,delete e.messageId,delete e.objectId,delete e.createdAt,delete e.updatedAt,this.data=n._decode(e)}}),n.Status.sendStatusToFollowers=function(e){var i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(!a(i)&&!n.User.current())throw new Error("Please signin an user.");return t(i).then((function(t){var r={className:"_Follower",keys:"follower"};r.where={user:t};var s={};return s.query=r,e.data=e.data||{},e.data.source=e.data.source||t,s.data=e._getDataJSON(),s.inboxType=e.inboxType||"default",o("statuses",null,null,"POST",s,i).then((function(t){return e.id=t.objectId,e.createdAt=n._parseDate(t.createdAt),e}))}))},n.Status.sendPrivateStatus=function(e,i){var s=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(!a(s)&&!n.User.current())throw new Error("Please signin an user.");if(!i)throw new Error("Invalid target user.");var l=r.isString(i)?i:i.id;if(!l)throw new Error("Invalid target user.");return t(s).then((function(t){var i={className:"_User"};i.where={objectId:l};var r={};return r.query=i,e.data=e.data||{},e.data.source=e.data.source||t,r.data=e._getDataJSON(),r.inboxType="private",e.inboxType="private",o("statuses",null,null,"POST",r,s).then((function(t){return e.id=t.objectId,e.createdAt=n._parseDate(t.createdAt),e}))}))},n.Status.countUnreadStatuses=function(t){var i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"default",l=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(r.isString(i)||(l=i),!a(l)&&null==t&&!n.User.current())throw new Error("Please signin an user or pass the owner objectId.");return s.resolve(t||e(l)).then((function(e){var t={};return t.inboxType=n._encode(i),t.owner=n._encode(e),o("subscribe/statuses/count",null,null,"GET",t,l)}))},n.Status.resetUnreadCount=function(t){var i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"default",l=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(r.isString(i)||(l=i),!a(l)&&null==t&&!n.User.current())throw new Error("Please signin an user or pass the owner objectId.");return s.resolve(t||e(l)).then((function(e){var t={};return t.inboxType=n._encode(i),t.owner=n._encode(e),o("subscribe/statuses/resetUnreadCount",null,null,"POST",t,l)}))},n.Status.statusQuery=function(e){var t=new n.Query("_Status");return e&&t.equalTo("source",e),t},n.InboxQuery=n.Query._extend({_objectClass:n.Status,_sinceId:0,_maxId:0,_inboxType:"default",_owner:null,_newObject:function(){return new n.Status},_createRequest:function(e,t){return n.InboxQuery.__super__._createRequest.call(this,e,t,"/subscribe/statuses")},sinceId:function(n){return this._sinceId=n,this},maxId:function(n){return this._maxId=n,this},owner:function(n){return this._owner=n,this},inboxType:function(n){return this._inboxType=n,this},toJSON:function(){var e=n.InboxQuery.__super__.toJSON.call(this);return e.owner=n._encode(this._owner),e.inboxType=n._encode(this._inboxType),e.sinceId=n._encode(this._sinceId),e.maxId=n._encode(this._maxId),e}}),n.Status.inboxQuery=function(e,t){var i=new n.InboxQuery(n.Status);return e&&(i._owner=e),t&&(i._inboxType=t),i}}},function(n,e,t){"use strict";var i=t(0),r=t(2)._request;n.exports=function(n){n.SearchSortBuilder=function(){this._sortFields=[]},i.extend(n.SearchSortBuilder.prototype,{_addField:function(n,e,t,i){var r={};return r[n]={order:e||"asc",mode:t||"avg",missing:"_"+(i||"last")},this._sortFields.push(r),this},ascending:function(n,e,t){return this._addField(n,"asc",e,t)},descending:function(n,e,t){return this._addField(n,"desc",e,t)},whereNear:function(n,e,t){t=t||{};var i={},r={lat:e.latitude,lon:e.longitude},s={order:t.order||"asc",mode:t.mode||"avg",unit:t.unit||"km"};return s[n]=r,i._geo_distance=s,this._sortFields.push(i),this},build:function(){return JSON.stringify(n._encode(this._sortFields))}}),n.SearchQuery=n.Query._extend({_sid:null,_hits:0,_queryString:null,_highlights:null,_sortBuilder:null,_createRequest:function(n,e){return r("search/select",null,null,"GET",n||this.toJSON(),e)},sid:function(n){return this._sid=n,this},queryString:function(n){return this._queryString=n,this},highlights:function(n){var e;return e=n&&i.isString(n)?arguments:n,this._highlights=e,this},sortBy:function(n){return this._sortBuilder=n,this},hits:function(){return this._hits||(this._hits=0),this._hits},_processResult:function(n){return delete n.className,delete n._app_url,delete n._deeplink,n},hasMore:function(){return!this._hitEnd},reset:function(){this._hitEnd=!1,this._sid=null,this._hits=0},find:function(){var n=this;return this._createRequest().then((function(e){return e.sid?(n._oldSid=n._sid,n._sid=e.sid):(n._sid=null,n._hitEnd=!0),n._hits=e.hits||0,i.map(e.results,(function(t){t.className&&(e.className=t.className);var i=n._newObject(e);return i.appURL=t._app_url,i._finishFetch(n._processResult(t),!0),i}))}))},toJSON:function(){var e=n.SearchQuery.__super__.toJSON.call(this);if(delete e.where,this.className&&(e.clazz=this.className),this._sid&&(e.sid=this._sid),!this._queryString)throw new Error("Please set query string.");if(e.q=this._queryString,this._highlights&&(e.highlights=this._highlights.join(",")),this._sortBuilder&&e.order)throw new Error("sort and order can not be set at same time.");return this._sortBuilder&&(e.sort=this._sortBuilder.build()),e}})}},function(n,e,t){"use strict";var i=t(0),r=t(4),s=t(2).request,o=t(1);n.exports=function(n){n.Insight=n.Insight||{},i.extend(n.Insight,{startJob:function(e,t){if(!e||!e.sql)throw new Error("Please provide the sql to run the job.");var i={jobConfig:e,appId:n.applicationId};return s({path:"/bigquery/jobs",method:"POST",data:n._encode(i,null,!0),authOptions:t,signKey:!1}).then((function(e){return n._decode(e).id}))},on:function(n,e){}}),n.Insight.JobQuery=function(n,e){if(!n)throw new Error("Please provide the job id.");this.id=n,this.className=e,this._skip=0,this._limit=100},i.extend(n.Insight.JobQuery.prototype,{skip:function(n){return this._skip=n,this},limit:function(n){return this._limit=n,this},find:function(n){var e={skip:this._skip,limit:this._limit};return s({path:"/bigquery/jobs/"+this.id,method:"GET",query:e,authOptions:n,signKey:!1}).then((function(n){return n.error?o.reject(new r(n.code,n.error)):o.resolve(n)}))}})}},function(n,e,t){"use strict";var i=t(0),r=t(2)._request,s=t(5),o=function(n){return"string"==typeof n?n:"function"==typeof n.getPayload?JSON.stringify(n.getPayload()):JSON.stringify(n)};n.exports=s.Object.extend("_Conversation",{constructor:function(n){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};s.Object.prototype.constructor.call(this,null,null),this.set("name",n),void 0!==e.isSystem&&this.set("sys",!!e.isSystem),void 0!==e.isTransient&&this.set("tr",!!e.isTransient)},getCreator:function(){return this.get("c")},getLastMessageAt:function(){return this.get("lm")},getMembers:function(){return this.get("m")},addMember:function(n){return this.add("m",n)},getMutedMembers:function(){return this.get("mu")},getName:function(){return this.get("name")},isTransient:function(){return this.get("tr")},isSystem:function(){return this.get("sys")},send:function(n,e){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{},s={from_peer:n,conv_id:this.id,transient:!1,message:o(e)};return void 0!==t.toClients&&(s.to_peers=t.toClients),void 0!==t.transient&&(s.transient=!!t.transient),void 0!==t.pushData&&(s.push_data=t.pushData),r("rtm","messages",null,"POST",s,i)},broadcast:function(n,e){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},s=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{},a={from_peer:n,conv_id:this.id,message:o(e)};if(void 0!==t.pushData&&(a.push=t.pushData),void 0!==t.validTill){var l=t.validTill;i.isDate(l)&&(l=l.getTime()),t.valid_till=l}return r("rtm","broadcast",null,"POST",a,s)}})},function(n,e,t){"use strict";function i(n){var e=n.name,t=n.value,i=n.version;this.name=e,this.value=t,this.version=i}var r=t(0),s=t(1),o=t(2).request,a=t(3),l=a.ensureArray,u=a.parseDate,c=t(5);c.LeaderboardVersionChangeInterval={NEVER:"never",DAY:"day",WEEK:"week",MONTH:"month"},c.LeaderboardOrder={ASCENDING:"ascending",DESCENDING:"descending"},c.LeaderboardUpdateStrategy={BETTER:"better",LAST:"last",SUM:"sum"};var d=function(n){var e=c._decode(n);return new i({name:e.statisticName,value:e.statisticValue,version:e.version})};c.Leaderboard=function(n){this.statisticName=n,this.order=void 0,this.updateStrategy=void 0,this.versionChangeInterval=void 0,this.version=void 0,this.nextResetAt=void 0,this.createdAt=void 0};var m=c.Leaderboard;c.Leaderboard.createWithoutData=function(n){return new m(n)},c.Leaderboard.createLeaderboard=function(n,e){var t=n.statisticName,i=n.order,r=n.versionChangeInterval,s=n.updateStrategy;return o({method:"POST",path:"/leaderboard/leaderboards",data:{statisticName:t,order:i,versionChangeInterval:r,updateStrategy:s},authOptions:e}).then((function(n){return new m(t)._finishFetch(n)}))},c.Leaderboard.getLeaderboard=function(n,e){return m.createWithoutData(n).fetch(e)},c.Leaderboard.getStatistics=function(n){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},t=e.statisticNames,i=arguments[2];return s.resolve().then((function(){if(!n||!n.id)throw new Error("user must be an AV.User");return o({method:"GET",path:"/leaderboard/users/"+n.id+"/statistics",query:{statistics:t?l(t).join(","):void 0},authOptions:i}).then((function(n){return n.results.map(d)}))}))},c.Leaderboard.updateStatistics=function(n,e){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};return s.resolve().then((function(){if(!n||!n.id)throw new Error("user must be an AV.User");var i=r.map(e,(function(n,e){return{statisticName:e,statisticValue:n}})),s=t.overwrite;return o({method:"POST",path:"/leaderboard/users/"+n.id+"/statistics",query:{overwrite:s?1:void 0},data:i,authOptions:t}).then((function(n){return n.results.map(d)}))}))},c.Leaderboard.deleteStatistics=function(n,e,t){return s.resolve().then((function(){if(!n||!n.id)throw new Error("user must be an AV.User");return o({method:"DELETE",path:"/leaderboard/users/"+n.id+"/statistics",query:{statistics:l(e).join(",")},authOptions:t}).then((function(){}))}))},r.extend(m.prototype,{_finishFetch:function(n){var e=this;return r.forEach(n,(function(n,t){"updatedAt"!==t&&"objectId"!==t&&("expiredAt"===t&&(t="nextResetAt"),"createdAt"===t&&(n=u(n)),n&&"Date"===n.__type&&(n=u(n.iso)),e[t]=n)})),this},fetch:function(n){var e=this;return o({method:"GET",path:"/leaderboard/leaderboards/"+this.statisticName,authOptions:n}).then((function(n){return e._finishFetch(n)}))},_getResults:function(n,e,t){var i=n.skip,r=n.limit,s=n.selectUserKeys,a=n.includeStatistics,u=n.version;return o({method:"GET",path:"/leaderboard/leaderboards/"+this.statisticName+"/ranks"+(t?"/"+t:""),query:{skip:i,limit:r,includeUser:s?l(s).join(","):void 0,includeStatistics:a?l(a).join(","):void 0,version:u},authOptions:e}).then((function(n){return n.results.map((function(n){var e=c._decode(n),t=e.user,i=e.statisticValue,r=e.rank,s=e.statistics;return{user:t,value:i,rank:r,includedStatistics:(void 0===s?[]:s).map(d)}}))}))},getResults:function(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},e=n.skip,t=n.limit,i=n.selectUserKeys,r=n.includeStatistics,s=n.version,o=arguments[1];return this._getResults({skip:e,limit:t,selectUserKeys:i,includeStatistics:r,version:s},o)},getResultsAroundUser:function(n){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},t=arguments[2];if(n&&"string"!=typeof n.id)return this.getResultsAroundUser(void 0,n,e);var i=e.limit,r=e.selectUserKeys,s=e.includeStatistics,o=e.version;return this._getResults({limit:i,selectUserKeys:r,includeStatistics:s,version:o},t,n?n.id:"self")},_update:function(n,e){var t=this;return o({method:"PUT",path:"/leaderboard/leaderboards/"+this.statisticName,data:n,authOptions:e}).then((function(n){return t._finishFetch(n)}))},updateVersionChangeInterval:function(n,e){return this._update({versionChangeInterval:n},e)},updateUpdateStrategy:function(n,e){return this._update({updateStrategy:n},e)},reset:function(n){var e=this;return o({method:"PUT",path:"/leaderboard/leaderboards/"+this.statisticName+"/incrementVersion",authOptions:n}).then((function(n){return e._finishFetch(n)}))},destroy:function(n){return c.request({method:"DELETE",path:"/leaderboard/leaderboards/"+this.statisticName,authOptions:n}).then((function(){}))},getArchives:function(){var n=this,e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t=e.skip,i=e.limit,r=arguments[1];return o({method:"GET",path:"/leaderboard/leaderboards/"+this.statisticName+"/archives",query:{skip:t,limit:i},authOptions:r}).then((function(e){return e.results.map((function(e){var t=e.version,i=e.status,r=e.url,s=e.activatedAt,o=e.deactivatedAt;return{statisticName:n.statisticName,version:t,status:i,url:r,activatedAt:u(s.iso),deactivatedAt:u(o.iso)}}))}))}})}])},function(n,e,t){"use strict";var i=t(32);t.n(i).a},function(n,e,t){var i=t(12),r=t(142),s=t(143);n.exports=function(n){var e=i(n);return s(e,r(e))+1}},function(n,e){n.exports=function(n){var e=new Date(n.getTime()),t=e.getTimezoneOffset();return e.setSeconds(0,0),6e4*t+e.getTime()%6e4}},function(n,e,t){var i=t(12);n.exports=function(n){var e=i(n),t=new Date(0);return t.setFullYear(e.getFullYear(),0,1),t.setHours(0,0,0,0),t}},function(n,e,t){var i=t(144);n.exports=function(n,e){var t=i(n),r=i(e),s=t.getTime()-6e4*t.getTimezoneOffset(),o=r.getTime()-6e4*r.getTimezoneOffset();return Math.round((s-o)/864e5)}},function(n,e,t){var i=t(12);n.exports=function(n){var e=i(n);return e.setHours(0,0,0,0),e}},function(n,e,t){var i=t(12),r=t(50),s=t(147);n.exports=function(n){var e=i(n),t=r(e).getTime()-s(e).getTime();return Math.round(t/6048e5)+1}},function(n,e,t){var i=t(12);n.exports=function(n,e){var t=e&&Number(e.weekStartsOn)||0,r=i(n),s=r.getDay(),o=(s<t?7:0)+s-t;return r.setDate(r.getDate()-o),r.setHours(0,0,0,0),r}},function(n,e,t){var i=t(76),r=t(50);n.exports=function(n){var e=i(n),t=new Date(0);return t.setFullYear(e,0,4),t.setHours(0,0,0,0),r(t)}},function(n,e,t){var i=t(75);n.exports=function(n){if(i(n))return!isNaN(n);throw new TypeError(toString.call(n)+" is not an instance of Date")}},function(n,e,t){var i=t(150),r=t(151);n.exports={distanceInWords:i(),format:r()}},function(n,e){n.exports=function(){var n={lessThanXSeconds:{one:"less than a second",other:"less than {{count}} seconds"},xSeconds:{one:"1 second",other:"{{count}} seconds"},halfAMinute:"half a minute",lessThanXMinutes:{one:"less than a minute",other:"less than {{count}} minutes"},xMinutes:{one:"1 minute",other:"{{count}} minutes"},aboutXHours:{one:"about 1 hour",other:"about {{count}} hours"},xHours:{one:"1 hour",other:"{{count}} hours"},xDays:{one:"1 day",other:"{{count}} days"},aboutXMonths:{one:"about 1 month",other:"about {{count}} months"},xMonths:{one:"1 month",other:"{{count}} months"},aboutXYears:{one:"about 1 year",other:"about {{count}} years"},xYears:{one:"1 year",other:"{{count}} years"},overXYears:{one:"over 1 year",other:"over {{count}} years"},almostXYears:{one:"almost 1 year",other:"almost {{count}} years"}};return{localize:function(e,t,i){var r;return i=i||{},r="string"==typeof n[e]?n[e]:1===t?n[e].one:n[e].other.replace("{{count}}",t),i.addSuffix?i.comparison>0?"in "+r:r+" ago":r}}}},function(n,e,t){var i=t(152);n.exports=function(){var n=["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],e=["January","February","March","April","May","June","July","August","September","October","November","December"],t=["Su","Mo","Tu","We","Th","Fr","Sa"],r=["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],s=["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],o=["AM","PM"],a=["am","pm"],l=["a.m.","p.m."],u={MMM:function(e){return n[e.getMonth()]},MMMM:function(n){return e[n.getMonth()]},dd:function(n){return t[n.getDay()]},ddd:function(n){return r[n.getDay()]},dddd:function(n){return s[n.getDay()]},A:function(n){return n.getHours()/12>=1?o[1]:o[0]},a:function(n){return n.getHours()/12>=1?a[1]:a[0]},aa:function(n){return n.getHours()/12>=1?l[1]:l[0]}};return["M","D","DDD","d","Q","W"].forEach((function(n){u[n+"o"]=function(e,t){return function(n){var e=n%100;if(e>20||e<10)switch(e%10){case 1:return n+"st";case 2:return n+"nd";case 3:return n+"rd"}return n+"th"}(t[n](e))}})),{formatters:u,formattingTokensRegExp:i(u)}}},function(n,e){var t=["M","MM","Q","D","DD","DDD","DDDD","d","E","W","WW","YY","YYYY","GG","GGGG","H","HH","h","hh","m","mm","s","ss","S","SS","SSS","Z","ZZ","X","x"];n.exports=function(n){var e=[];for(var i in n)n.hasOwnProperty(i)&&e.push(i);var r=t.concat(e).sort().reverse();return new RegExp("(\\[[^\\[]*\\])|(\\\\)?("+r.join("|")+"|.)","g")}},function(n,e,t){"use strict";var i=t(77),r=t(78),s=Object.prototype.hasOwnProperty,o={brackets:function(n){return n+"[]"},comma:"comma",indices:function(n,e){return n+"["+e+"]"},repeat:function(n){return n}},a=Array.isArray,l=Array.prototype.push,u=function(n,e){l.apply(n,a(e)?e:[e])},c=Date.prototype.toISOString,d={addQueryPrefix:!1,allowDots:!1,charset:"utf-8",charsetSentinel:!1,delimiter:"&",encode:!0,encoder:i.encode,encodeValuesOnly:!1,formatter:r.formatters[r.default],indices:!1,serializeDate:function(n){return c.call(n)},skipNulls:!1,strictNullHandling:!1},m=function n(e,t,r,s,o,l,c,m,p,h,f,g,v){var b=e;if("function"==typeof c?b=c(t,b):b instanceof Date?b=h(b):"comma"===r&&a(b)&&(b=b.join(",")),null===b){if(s)return l&&!g?l(t,d.encoder,v):t;b=""}if("string"==typeof b||"number"==typeof b||"boolean"==typeof b||i.isBuffer(b))return l?[f(g?t:l(t,d.encoder,v))+"="+f(l(b,d.encoder,v))]:[f(t)+"="+f(String(b))];var x,w=[];if(void 0===b)return w;if(a(c))x=c;else{var E=Object.keys(b);x=m?E.sort(m):E}for(var y=0;y<x.length;++y){var k=x[y];o&&null===b[k]||(a(b)?u(w,n(b[k],"function"==typeof r?r(t,k):t,r,s,o,l,c,m,p,h,f,g,v)):u(w,n(b[k],t+(p?"."+k:"["+k+"]"),r,s,o,l,c,m,p,h,f,g,v)))}return w};n.exports=function(n,e){var t,i=n,l=function(n){if(!n)return d;if(null!==n.encoder&&void 0!==n.encoder&&"function"!=typeof n.encoder)throw new TypeError("Encoder has to be a function.");var e=n.charset||d.charset;if(void 0!==n.charset&&"utf-8"!==n.charset&&"iso-8859-1"!==n.charset)throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");var t=r.default;if(void 0!==n.format){if(!s.call(r.formatters,n.format))throw new TypeError("Unknown format option provided.");t=n.format}var i=r.formatters[t],o=d.filter;return("function"==typeof n.filter||a(n.filter))&&(o=n.filter),{addQueryPrefix:"boolean"==typeof n.addQueryPrefix?n.addQueryPrefix:d.addQueryPrefix,allowDots:void 0===n.allowDots?d.allowDots:!!n.allowDots,charset:e,charsetSentinel:"boolean"==typeof n.charsetSentinel?n.charsetSentinel:d.charsetSentinel,delimiter:void 0===n.delimiter?d.delimiter:n.delimiter,encode:"boolean"==typeof n.encode?n.encode:d.encode,encoder:"function"==typeof n.encoder?n.encoder:d.encoder,encodeValuesOnly:"boolean"==typeof n.encodeValuesOnly?n.encodeValuesOnly:d.encodeValuesOnly,filter:o,formatter:i,serializeDate:"function"==typeof n.serializeDate?n.serializeDate:d.serializeDate,skipNulls:"boolean"==typeof n.skipNulls?n.skipNulls:d.skipNulls,sort:"function"==typeof n.sort?n.sort:null,strictNullHandling:"boolean"==typeof n.strictNullHandling?n.strictNullHandling:d.strictNullHandling}}(e);"function"==typeof l.filter?i=(0,l.filter)("",i):a(l.filter)&&(t=l.filter);var c,p=[];if("object"!=typeof i||null===i)return"";c=e&&e.arrayFormat in o?e.arrayFormat:e&&"indices"in e?e.indices?"indices":"repeat":"indices";var h=o[c];t||(t=Object.keys(i)),l.sort&&t.sort(l.sort);for(var f=0;f<t.length;++f){var g=t[f];l.skipNulls&&null===i[g]||u(p,m(i[g],g,h,l.strictNullHandling,l.skipNulls,l.encode?l.encoder:null,l.filter,l.sort,l.allowDots,l.serializeDate,l.formatter,l.encodeValuesOnly,l.charset))}var v=p.join(l.delimiter),b=!0===l.addQueryPrefix?"?":"";return l.charsetSentinel&&("iso-8859-1"===l.charset?b+="utf8=%26%2310003%3B&":b+="utf8=%E2%9C%93&"),v.length>0?b+v:""}},function(n,e,t){"use strict";var i=t(77),r=Object.prototype.hasOwnProperty,s={allowDots:!1,allowPrototypes:!1,arrayLimit:20,charset:"utf-8",charsetSentinel:!1,comma:!1,decoder:i.decode,delimiter:"&",depth:5,ignoreQueryPrefix:!1,interpretNumericEntities:!1,parameterLimit:1e3,parseArrays:!0,plainObjects:!1,strictNullHandling:!1},o=function(n){return n.replace(/&#(\d+);/g,(function(n,e){return String.fromCharCode(parseInt(e,10))}))},a=function(n,e,t){if(n){var i=t.allowDots?n.replace(/\.([^.[]+)/g,"[$1]"):n,s=/(\[[^[\]]*])/g,o=/(\[[^[\]]*])/.exec(i),a=o?i.slice(0,o.index):i,l=[];if(a){if(!t.plainObjects&&r.call(Object.prototype,a)&&!t.allowPrototypes)return;l.push(a)}for(var u=0;null!==(o=s.exec(i))&&u<t.depth;){if(u+=1,!t.plainObjects&&r.call(Object.prototype,o[1].slice(1,-1))&&!t.allowPrototypes)return;l.push(o[1])}return o&&l.push("["+i.slice(o.index)+"]"),function(n,e,t){for(var i=e,r=n.length-1;r>=0;--r){var s,o=n[r];if("[]"===o&&t.parseArrays)s=[].concat(i);else{s=t.plainObjects?Object.create(null):{};var a="["===o.charAt(0)&&"]"===o.charAt(o.length-1)?o.slice(1,-1):o,l=parseInt(a,10);t.parseArrays||""!==a?!isNaN(l)&&o!==a&&String(l)===a&&l>=0&&t.parseArrays&&l<=t.arrayLimit?(s=[])[l]=i:s[a]=i:s={0:i}}i=s}return i}(l,e,t)}};n.exports=function(n,e){var t=function(n){if(!n)return s;if(null!==n.decoder&&void 0!==n.decoder&&"function"!=typeof n.decoder)throw new TypeError("Decoder has to be a function.");if(void 0!==n.charset&&"utf-8"!==n.charset&&"iso-8859-1"!==n.charset)throw new Error("The charset option must be either utf-8, iso-8859-1, or undefined");var e=void 0===n.charset?s.charset:n.charset;return{allowDots:void 0===n.allowDots?s.allowDots:!!n.allowDots,allowPrototypes:"boolean"==typeof n.allowPrototypes?n.allowPrototypes:s.allowPrototypes,arrayLimit:"number"==typeof n.arrayLimit?n.arrayLimit:s.arrayLimit,charset:e,charsetSentinel:"boolean"==typeof n.charsetSentinel?n.charsetSentinel:s.charsetSentinel,comma:"boolean"==typeof n.comma?n.comma:s.comma,decoder:"function"==typeof n.decoder?n.decoder:s.decoder,delimiter:"string"==typeof n.delimiter||i.isRegExp(n.delimiter)?n.delimiter:s.delimiter,depth:"number"==typeof n.depth?n.depth:s.depth,ignoreQueryPrefix:!0===n.ignoreQueryPrefix,interpretNumericEntities:"boolean"==typeof n.interpretNumericEntities?n.interpretNumericEntities:s.interpretNumericEntities,parameterLimit:"number"==typeof n.parameterLimit?n.parameterLimit:s.parameterLimit,parseArrays:!1!==n.parseArrays,plainObjects:"boolean"==typeof n.plainObjects?n.plainObjects:s.plainObjects,strictNullHandling:"boolean"==typeof n.strictNullHandling?n.strictNullHandling:s.strictNullHandling}}(e);if(""===n||null==n)return t.plainObjects?Object.create(null):{};for(var l="string"==typeof n?function(n,e){var t,a={},l=e.ignoreQueryPrefix?n.replace(/^\?/,""):n,u=e.parameterLimit===1/0?void 0:e.parameterLimit,c=l.split(e.delimiter,u),d=-1,m=e.charset;if(e.charsetSentinel)for(t=0;t<c.length;++t)0===c[t].indexOf("utf8=")&&("utf8=%E2%9C%93"===c[t]?m="utf-8":"utf8=%26%2310003%3B"===c[t]&&(m="iso-8859-1"),d=t,t=c.length);for(t=0;t<c.length;++t)if(t!==d){var p,h,f=c[t],g=f.indexOf("]="),v=-1===g?f.indexOf("="):g+1;-1===v?(p=e.decoder(f,s.decoder,m),h=e.strictNullHandling?null:""):(p=e.decoder(f.slice(0,v),s.decoder,m),h=e.decoder(f.slice(v+1),s.decoder,m)),h&&e.interpretNumericEntities&&"iso-8859-1"===m&&(h=o(h)),h&&e.comma&&h.indexOf(",")>-1&&(h=h.split(",")),r.call(a,p)?a[p]=i.combine(a[p],h):a[p]=h}return a}(n,t):n,u=t.plainObjects?Object.create(null):{},c=Object.keys(l),d=0;d<c.length;++d){var m=c[d],p=a(m,l[m],t);u=i.merge(u,p,t)}return i.compact(u)}},function(n,e,t){"use strict";var i=t(3),r=t(79),s=t(156),o=t(51);function a(n){var e=new s(n),t=r(s.prototype.request,e);return i.extend(t,s.prototype,e),i.extend(t,e),t}var l=a(o);l.Axios=s,l.create=function(n){return a(i.merge(o,n))},l.Cancel=t(83),l.CancelToken=t(169),l.isCancel=t(82),l.all=function(n){return Promise.all(n)},l.spread=t(170),n.exports=l,n.exports.default=l},function(n,e,t){"use strict";var i=t(51),r=t(3),s=t(164),o=t(165);function a(n){this.defaults=n,this.interceptors={request:new s,response:new s}}a.prototype.request=function(n){"string"==typeof n&&(n=r.merge({url:arguments[0]},arguments[1])),(n=r.merge(i,{method:"get"},this.defaults,n)).method=n.method.toLowerCase();var e=[o,void 0],t=Promise.resolve(n);for(this.interceptors.request.forEach((function(n){e.unshift(n.fulfilled,n.rejected)})),this.interceptors.response.forEach((function(n){e.push(n.fulfilled,n.rejected)}));e.length;)t=t.then(e.shift(),e.shift());return t},r.forEach(["delete","get","head","options"],(function(n){a.prototype[n]=function(e,t){return this.request(r.merge(t||{},{method:n,url:e}))}})),r.forEach(["post","put","patch"],(function(n){a.prototype[n]=function(e,t,i){return this.request(r.merge(i||{},{method:n,url:e,data:t}))}})),n.exports=a},function(n,e,t){"use strict";var i=t(3);n.exports=function(n,e){i.forEach(n,(function(t,i){i!==e&&i.toUpperCase()===e.toUpperCase()&&(n[e]=t,delete n[i])}))}},function(n,e,t){"use strict";var i=t(81);n.exports=function(n,e,t){var r=t.config.validateStatus;t.status&&r&&!r(t.status)?e(i("Request failed with status code "+t.status,t.config,null,t.request,t)):n(t)}},function(n,e,t){"use strict";n.exports=function(n,e,t,i,r){return n.config=e,t&&(n.code=t),n.request=i,n.response=r,n}},function(n,e,t){"use strict";var i=t(3);function r(n){return encodeURIComponent(n).replace(/%40/gi,"@").replace(/%3A/gi,":").replace(/%24/g,"$").replace(/%2C/gi,",").replace(/%20/g,"+").replace(/%5B/gi,"[").replace(/%5D/gi,"]")}n.exports=function(n,e,t){if(!e)return n;var s;if(t)s=t(e);else if(i.isURLSearchParams(e))s=e.toString();else{var o=[];i.forEach(e,(function(n,e){null!=n&&(i.isArray(n)?e+="[]":n=[n],i.forEach(n,(function(n){i.isDate(n)?n=n.toISOString():i.isObject(n)&&(n=JSON.stringify(n)),o.push(r(e)+"="+r(n))})))})),s=o.join("&")}return s&&(n+=(-1===n.indexOf("?")?"?":"&")+s),n}},function(n,e,t){"use strict";var i=t(3),r=["age","authorization","content-length","content-type","etag","expires","from","host","if-modified-since","if-unmodified-since","last-modified","location","max-forwards","proxy-authorization","referer","retry-after","user-agent"];n.exports=function(n){var e,t,s,o={};return n?(i.forEach(n.split("\n"),(function(n){if(s=n.indexOf(":"),e=i.trim(n.substr(0,s)).toLowerCase(),t=i.trim(n.substr(s+1)),e){if(o[e]&&r.indexOf(e)>=0)return;o[e]="set-cookie"===e?(o[e]?o[e]:[]).concat([t]):o[e]?o[e]+", "+t:t}})),o):o}},function(n,e,t){"use strict";var i=t(3);n.exports=i.isStandardBrowserEnv()?function(){var n,e=/(msie|trident)/i.test(navigator.userAgent),t=document.createElement("a");function r(n){var i=n;return e&&(t.setAttribute("href",i),i=t.href),t.setAttribute("href",i),{href:t.href,protocol:t.protocol?t.protocol.replace(/:$/,""):"",host:t.host,search:t.search?t.search.replace(/^\?/,""):"",hash:t.hash?t.hash.replace(/^#/,""):"",hostname:t.hostname,port:t.port,pathname:"/"===t.pathname.charAt(0)?t.pathname:"/"+t.pathname}}return n=r(window.location.href),function(e){var t=i.isString(e)?r(e):e;return t.protocol===n.protocol&&t.host===n.host}}():function(){return!0}},function(n,e,t){"use strict";var i=t(3);n.exports=i.isStandardBrowserEnv()?{write:function(n,e,t,r,s,o){var a=[];a.push(n+"="+encodeURIComponent(e)),i.isNumber(t)&&a.push("expires="+new Date(t).toGMTString()),i.isString(r)&&a.push("path="+r),i.isString(s)&&a.push("domain="+s),!0===o&&a.push("secure"),document.cookie=a.join("; ")},read:function(n){var e=document.cookie.match(new RegExp("(^|;\\s*)("+n+")=([^;]*)"));return e?decodeURIComponent(e[3]):null},remove:function(n){this.write(n,"",Date.now()-864e5)}}:{write:function(){},read:function(){return null},remove:function(){}}},function(n,e,t){"use strict";var i=t(3);function r(){this.handlers=[]}r.prototype.use=function(n,e){return this.handlers.push({fulfilled:n,rejected:e}),this.handlers.length-1},r.prototype.eject=function(n){this.handlers[n]&&(this.handlers[n]=null)},r.prototype.forEach=function(n){i.forEach(this.handlers,(function(e){null!==e&&n(e)}))},n.exports=r},function(n,e,t){"use strict";var i=t(3),r=t(166),s=t(82),o=t(51),a=t(167),l=t(168);function u(n){n.cancelToken&&n.cancelToken.throwIfRequested()}n.exports=function(n){return u(n),n.baseURL&&!a(n.url)&&(n.url=l(n.baseURL,n.url)),n.headers=n.headers||{},n.data=r(n.data,n.headers,n.transformRequest),n.headers=i.merge(n.headers.common||{},n.headers[n.method]||{},n.headers||{}),i.forEach(["delete","get","head","post","put","patch","common"],(function(e){delete n.headers[e]})),(n.adapter||o.adapter)(n).then((function(e){return u(n),e.data=r(e.data,e.headers,n.transformResponse),e}),(function(e){return s(e)||(u(n),e&&e.response&&(e.response.data=r(e.response.data,e.response.headers,n.transformResponse))),Promise.reject(e)}))}},function(n,e,t){"use strict";var i=t(3);n.exports=function(n,e,t){return i.forEach(t,(function(t){n=t(n,e)})),n}},function(n,e,t){"use strict";n.exports=function(n){return/^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(n)}},function(n,e,t){"use strict";n.exports=function(n,e){return e?n.replace(/\/+$/,"")+"/"+e.replace(/^\/+/,""):n}},function(n,e,t){"use strict";var i=t(83);function r(n){if("function"!=typeof n)throw new TypeError("executor must be a function.");var e;this.promise=new Promise((function(n){e=n}));var t=this;n((function(n){t.reason||(t.reason=new i(n),e(t.reason))}))}r.prototype.throwIfRequested=function(){if(this.reason)throw this.reason},r.source=function(){var n;return{token:new r((function(e){n=e})),cancel:n}},n.exports=r},function(n,e,t){"use strict";n.exports=function(n){return function(e){return n.apply(null,e)}}},function(n,e,t){},function(n,e,t){"use strict";var i=t(33);t.n(i).a},function(n,e,t){},function(n,e,t){var i;function r(n){function t(){if(t.enabled){var n=t,r=+new Date,s=r-(i||r);n.diff=s,n.prev=i,n.curr=r,i=r;for(var o=new Array(arguments.length),a=0;a<o.length;a++)o[a]=arguments[a];o[0]=e.coerce(o[0]),"string"!=typeof o[0]&&o.unshift("%O");var l=0;o[0]=o[0].replace(/%([a-zA-Z%])/g,(function(t,i){if("%%"===t)return t;l++;var r=e.formatters[i];if("function"==typeof r){var s=o[l];t=r.call(n,s),o.splice(l,1),l--}return t})),e.formatArgs.call(n,o);var u=t.log||e.log||console.log.bind(console);u.apply(n,o)}}return t.namespace=n,t.enabled=e.enabled(n),t.useColors=e.useColors(),t.color=function(n){var t,i=0;for(t in n)i=(i<<5)-i+n.charCodeAt(t),i|=0;return e.colors[Math.abs(i)%e.colors.length]}(n),"function"==typeof e.init&&e.init(t),t}(e=n.exports=r.debug=r.default=r).coerce=function(n){return n instanceof Error?n.stack||n.message:n},e.disable=function(){e.enable("")},e.enable=function(n){e.save(n),e.names=[],e.skips=[];for(var t=("string"==typeof n?n:"").split(/[\s,]+/),i=t.length,r=0;r<i;r++)t[r]&&("-"===(n=t[r].replace(/\*/g,".*?"))[0]?e.skips.push(new RegExp("^"+n.substr(1)+"$")):e.names.push(new RegExp("^"+n+"$")))},e.enabled=function(n){var t,i;for(t=0,i=e.skips.length;t<i;t++)if(e.skips[t].test(n))return!1;for(t=0,i=e.names.length;t<i;t++)if(e.names[t].test(n))return!0;return!1},e.humanize=t(175),e.names=[],e.skips=[],e.formatters={}},function(n,e){var t=1e3,i=6e4,r=36e5,s=24*r;function o(n,e,t){if(!(n<e))return n<1.5*e?Math.floor(n/e)+" "+t:Math.ceil(n/e)+" "+t+"s"}n.exports=function(n,e){e=e||{};var a,l=typeof n;if("string"===l&&n.length>0)return function(n){if((n=String(n)).length>100)return;var e=/^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(n);if(!e)return;var o=parseFloat(e[1]);switch((e[2]||"ms").toLowerCase()){case"years":case"year":case"yrs":case"yr":case"y":return 315576e5*o;case"days":case"day":case"d":return o*s;case"hours":case"hour":case"hrs":case"hr":case"h":return o*r;case"minutes":case"minute":case"mins":case"min":case"m":return o*i;case"seconds":case"second":case"secs":case"sec":case"s":return o*t;case"milliseconds":case"millisecond":case"msecs":case"msec":case"ms":return o;default:return}}(n);if("number"===l&&!1===isNaN(n))return e.long?o(a=n,s,"day")||o(a,r,"hour")||o(a,i,"minute")||o(a,t,"second")||a+" ms":function(n){if(n>=s)return Math.round(n/s)+"d";if(n>=r)return Math.round(n/r)+"h";if(n>=i)return Math.round(n/i)+"m";if(n>=t)return Math.round(n/t)+"s";return n+"ms"}(n);throw new Error("val is not a non-empty string or a valid number. val="+JSON.stringify(n))}},function(n,e,t){},function(n,e,t){},function(n,e,t){var i=t(25),r=t(17);n.exports=function(n){return function(e,t){var s,o,a=String(r(e)),l=i(t),u=a.length;return l<0||l>=u?n?"":void 0:(s=a.charCodeAt(l))<55296||s>56319||l+1===u||(o=a.charCodeAt(l+1))<56320||o>57343?n?a.charAt(l):s:n?a.slice(l,l+2):o-56320+(s-55296<<10)+65536}}},function(n,e,t){var i=t(24),r=t(7)("toStringTag"),s="Arguments"==i(function(){return arguments}());n.exports=function(n){var e,t,o;return void 0===n?"Undefined":null===n?"Null":"string"==typeof(t=function(n,e){try{return n[e]}catch(n){}}(e=Object(n),r))?t:s?i(e):"Object"==(o=i(e))&&"function"==typeof e.callee?"Arguments":o}},function(n,e,t){"use strict";var i=t(65);t(4)({target:"RegExp",proto:!0,forced:i!==/./.exec},{exec:i})},function(n,e,t){"use strict";var i=t(34);t.n(i).a},function(n,e,t){"use strict";var i=t(35);t.n(i).a},function(n,e,t){"use strict";t.r(e);var i=t(1);
/*!
  * vue-router v3.1.3
  * (c) 2019 Evan You
  * @license MIT
  */function r(n){return Object.prototype.toString.call(n).indexOf("Error")>-1}function s(n,e){return e instanceof n||e&&(e.name===n.name||e._name===n._name)}function o(n,e){for(var t in e)n[t]=e[t];return n}var a={name:"RouterView",functional:!0,props:{name:{type:String,default:"default"}},render:function(n,e){var t=e.props,i=e.children,r=e.parent,s=e.data;s.routerView=!0;for(var a=r.$createElement,l=t.name,u=r.$route,c=r._routerViewCache||(r._routerViewCache={}),d=0,m=!1;r&&r._routerRoot!==r;){var p=r.$vnode&&r.$vnode.data;p&&(p.routerView&&d++,p.keepAlive&&r._inactive&&(m=!0)),r=r.$parent}if(s.routerViewDepth=d,m)return a(c[l],s,i);var h=u.matched[d];if(!h)return c[l]=null,a();var f=c[l]=h.components[l];s.registerRouteInstance=function(n,e){var t=h.instances[l];(e&&t!==n||!e&&t===n)&&(h.instances[l]=e)},(s.hook||(s.hook={})).prepatch=function(n,e){h.instances[l]=e.componentInstance},s.hook.init=function(n){n.data.keepAlive&&n.componentInstance&&n.componentInstance!==h.instances[l]&&(h.instances[l]=n.componentInstance)};var g=s.props=function(n,e){switch(typeof e){case"undefined":return;case"object":return e;case"function":return e(n);case"boolean":return e?n.params:void 0;default:0}}(u,h.props&&h.props[l]);if(g){g=s.props=o({},g);var v=s.attrs=s.attrs||{};for(var b in g)f.props&&b in f.props||(v[b]=g[b],delete g[b])}return a(f,s,i)}};var l=/[!'()*]/g,u=function(n){return"%"+n.charCodeAt(0).toString(16)},c=/%2C/g,d=function(n){return encodeURIComponent(n).replace(l,u).replace(c,",")},m=decodeURIComponent;function p(n){var e={};return(n=n.trim().replace(/^(\?|#|&)/,""))?(n.split("&").forEach((function(n){var t=n.replace(/\+/g," ").split("="),i=m(t.shift()),r=t.length>0?m(t.join("=")):null;void 0===e[i]?e[i]=r:Array.isArray(e[i])?e[i].push(r):e[i]=[e[i],r]})),e):e}function h(n){var e=n?Object.keys(n).map((function(e){var t=n[e];if(void 0===t)return"";if(null===t)return d(e);if(Array.isArray(t)){var i=[];return t.forEach((function(n){void 0!==n&&(null===n?i.push(d(e)):i.push(d(e)+"="+d(n)))})),i.join("&")}return d(e)+"="+d(t)})).filter((function(n){return n.length>0})).join("&"):null;return e?"?"+e:""}var f=/\/?$/;function g(n,e,t,i){var r=i&&i.options.stringifyQuery,s=e.query||{};try{s=v(s)}catch(n){}var o={name:e.name||n&&n.name,meta:n&&n.meta||{},path:e.path||"/",hash:e.hash||"",query:s,params:e.params||{},fullPath:w(e,r),matched:n?x(n):[]};return t&&(o.redirectedFrom=w(t,r)),Object.freeze(o)}function v(n){if(Array.isArray(n))return n.map(v);if(n&&"object"==typeof n){var e={};for(var t in n)e[t]=v(n[t]);return e}return n}var b=g(null,{path:"/"});function x(n){for(var e=[];n;)e.unshift(n),n=n.parent;return e}function w(n,e){var t=n.path,i=n.query;void 0===i&&(i={});var r=n.hash;return void 0===r&&(r=""),(t||"/")+(e||h)(i)+r}function E(n,e){return e===b?n===e:!!e&&(n.path&&e.path?n.path.replace(f,"")===e.path.replace(f,"")&&n.hash===e.hash&&y(n.query,e.query):!(!n.name||!e.name)&&(n.name===e.name&&n.hash===e.hash&&y(n.query,e.query)&&y(n.params,e.params)))}function y(n,e){if(void 0===n&&(n={}),void 0===e&&(e={}),!n||!e)return n===e;var t=Object.keys(n),i=Object.keys(e);return t.length===i.length&&t.every((function(t){var i=n[t],r=e[t];return"object"==typeof i&&"object"==typeof r?y(i,r):String(i)===String(r)}))}function k(n,e,t){var i=n.charAt(0);if("/"===i)return n;if("?"===i||"#"===i)return e+n;var r=e.split("/");t&&r[r.length-1]||r.pop();for(var s=n.replace(/^\//,"").split("/"),o=0;o<s.length;o++){var a=s[o];".."===a?r.pop():"."!==a&&r.push(a)}return""!==r[0]&&r.unshift(""),r.join("/")}function A(n){return n.replace(/\/\//g,"/")}var j=Array.isArray||function(n){return"[object Array]"==Object.prototype.toString.call(n)},_=z,N=L,O=function(n,e){return T(L(n,e))},B=T,S=F,I=new RegExp(["(\\\\.)","([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?|(\\*))"].join("|"),"g");function L(n,e){for(var t,i=[],r=0,s=0,o="",a=e&&e.delimiter||"/";null!=(t=I.exec(n));){var l=t[0],u=t[1],c=t.index;if(o+=n.slice(s,c),s=c+l.length,u)o+=u[1];else{var d=n[s],m=t[2],p=t[3],h=t[4],f=t[5],g=t[6],v=t[7];o&&(i.push(o),o="");var b=null!=m&&null!=d&&d!==m,x="+"===g||"*"===g,w="?"===g||"*"===g,E=t[2]||a,y=h||f;i.push({name:p||r++,prefix:m||"",delimiter:E,optional:w,repeat:x,partial:b,asterisk:!!v,pattern:y?q(y):v?".*":"[^"+D(E)+"]+?"})}}return s<n.length&&(o+=n.substr(s)),o&&i.push(o),i}function C(n){return encodeURI(n).replace(/[\/?#]/g,(function(n){return"%"+n.charCodeAt(0).toString(16).toUpperCase()}))}function T(n){for(var e=new Array(n.length),t=0;t<n.length;t++)"object"==typeof n[t]&&(e[t]=new RegExp("^(?:"+n[t].pattern+")$"));return function(t,i){for(var r="",s=t||{},o=(i||{}).pretty?C:encodeURIComponent,a=0;a<n.length;a++){var l=n[a];if("string"!=typeof l){var u,c=s[l.name];if(null==c){if(l.optional){l.partial&&(r+=l.prefix);continue}throw new TypeError('Expected "'+l.name+'" to be defined')}if(j(c)){if(!l.repeat)throw new TypeError('Expected "'+l.name+'" to not repeat, but received `'+JSON.stringify(c)+"`");if(0===c.length){if(l.optional)continue;throw new TypeError('Expected "'+l.name+'" to not be empty')}for(var d=0;d<c.length;d++){if(u=o(c[d]),!e[a].test(u))throw new TypeError('Expected all "'+l.name+'" to match "'+l.pattern+'", but received `'+JSON.stringify(u)+"`");r+=(0===d?l.prefix:l.delimiter)+u}}else{if(u=l.asterisk?encodeURI(c).replace(/[?#]/g,(function(n){return"%"+n.charCodeAt(0).toString(16).toUpperCase()})):o(c),!e[a].test(u))throw new TypeError('Expected "'+l.name+'" to match "'+l.pattern+'", but received "'+u+'"');r+=l.prefix+u}}else r+=l}return r}}function D(n){return n.replace(/([.+*?=^!:${}()[\]|\/\\])/g,"\\$1")}function q(n){return n.replace(/([=!:$\/()])/g,"\\$1")}function P(n,e){return n.keys=e,n}function M(n){return n.sensitive?"":"i"}function F(n,e,t){j(e)||(t=e||t,e=[]);for(var i=(t=t||{}).strict,r=!1!==t.end,s="",o=0;o<n.length;o++){var a=n[o];if("string"==typeof a)s+=D(a);else{var l=D(a.prefix),u="(?:"+a.pattern+")";e.push(a),a.repeat&&(u+="(?:"+l+u+")*"),s+=u=a.optional?a.partial?l+"("+u+")?":"(?:"+l+"("+u+"))?":l+"("+u+")"}}var c=D(t.delimiter||"/"),d=s.slice(-c.length)===c;return i||(s=(d?s.slice(0,-c.length):s)+"(?:"+c+"(?=$))?"),s+=r?"$":i&&d?"":"(?="+c+"|$)",P(new RegExp("^"+s,M(t)),e)}function z(n,e,t){return j(e)||(t=e||t,e=[]),t=t||{},n instanceof RegExp?function(n,e){var t=n.source.match(/\((?!\?)/g);if(t)for(var i=0;i<t.length;i++)e.push({name:i,prefix:null,delimiter:null,optional:!1,repeat:!1,partial:!1,asterisk:!1,pattern:null});return P(n,e)}(n,e):j(n)?function(n,e,t){for(var i=[],r=0;r<n.length;r++)i.push(z(n[r],e,t).source);return P(new RegExp("(?:"+i.join("|")+")",M(t)),e)}(n,e,t):function(n,e,t){return F(L(n,t),e,t)}(n,e,t)}_.parse=N,_.compile=O,_.tokensToFunction=B,_.tokensToRegExp=S;var R=Object.create(null);function $(n,e,t){e=e||{};try{var i=R[n]||(R[n]=_.compile(n));return e.pathMatch&&(e[0]=e.pathMatch),i(e,{pretty:!0})}catch(n){return""}finally{delete e[0]}}function U(n,e,t,i){var r="string"==typeof n?{path:n}:n;if(r._normalized)return r;if(r.name)return o({},n);if(!r.path&&r.params&&e){(r=o({},r))._normalized=!0;var s=o(o({},e.params),r.params);if(e.name)r.name=e.name,r.params=s;else if(e.matched.length){var a=e.matched[e.matched.length-1].path;r.path=$(a,s,e.path)}else 0;return r}var l=function(n){var e="",t="",i=n.indexOf("#");i>=0&&(e=n.slice(i),n=n.slice(0,i));var r=n.indexOf("?");return r>=0&&(t=n.slice(r+1),n=n.slice(0,r)),{path:n,query:t,hash:e}}(r.path||""),u=e&&e.path||"/",c=l.path?k(l.path,u,t||r.append):u,d=function(n,e,t){void 0===e&&(e={});var i,r=t||p;try{i=r(n||"")}catch(n){i={}}for(var s in e)i[s]=e[s];return i}(l.query,r.query,i&&i.options.parseQuery),m=r.hash||l.hash;return m&&"#"!==m.charAt(0)&&(m="#"+m),{_normalized:!0,path:c,query:d,hash:m}}var H,V=function(){},W={name:"RouterLink",props:{to:{type:[String,Object],required:!0},tag:{type:String,default:"a"},exact:Boolean,append:Boolean,replace:Boolean,activeClass:String,exactActiveClass:String,event:{type:[String,Array],default:"click"}},render:function(n){var e=this,t=this.$router,i=this.$route,r=t.resolve(this.to,i,this.append),s=r.location,a=r.route,l=r.href,u={},c=t.options.linkActiveClass,d=t.options.linkExactActiveClass,m=null==c?"router-link-active":c,p=null==d?"router-link-exact-active":d,h=null==this.activeClass?m:this.activeClass,v=null==this.exactActiveClass?p:this.exactActiveClass,b=a.redirectedFrom?g(null,U(a.redirectedFrom),null,t):a;u[v]=E(i,b),u[h]=this.exact?u[v]:function(n,e){return 0===n.path.replace(f,"/").indexOf(e.path.replace(f,"/"))&&(!e.hash||n.hash===e.hash)&&function(n,e){for(var t in e)if(!(t in n))return!1;return!0}(n.query,e.query)}(i,b);var x=function(n){K(n)&&(e.replace?t.replace(s,V):t.push(s,V))},w={click:K};Array.isArray(this.event)?this.event.forEach((function(n){w[n]=x})):w[this.event]=x;var y={class:u},k=!this.$scopedSlots.$hasNormal&&this.$scopedSlots.default&&this.$scopedSlots.default({href:l,route:a,navigate:x,isActive:u[h],isExactActive:u[v]});if(k){if(1===k.length)return k[0];if(k.length>1||!k.length)return 0===k.length?n():n("span",{},k)}if("a"===this.tag)y.on=w,y.attrs={href:l};else{var A=function n(e){var t;if(e)for(var i=0;i<e.length;i++){if("a"===(t=e[i]).tag)return t;if(t.children&&(t=n(t.children)))return t}}(this.$slots.default);if(A){A.isStatic=!1;var j=A.data=o({},A.data);for(var _ in j.on=j.on||{},j.on){var N=j.on[_];_ in w&&(j.on[_]=Array.isArray(N)?N:[N])}for(var O in w)O in j.on?j.on[O].push(w[O]):j.on[O]=x;(A.data.attrs=o({},A.data.attrs)).href=l}else y.on=w}return n(this.tag,y,this.$slots.default)}};function K(n){if(!(n.metaKey||n.altKey||n.ctrlKey||n.shiftKey||n.defaultPrevented||void 0!==n.button&&0!==n.button)){if(n.currentTarget&&n.currentTarget.getAttribute){var e=n.currentTarget.getAttribute("target");if(/\b_blank\b/i.test(e))return}return n.preventDefault&&n.preventDefault(),!0}}var Q="undefined"!=typeof window;function G(n,e,t,i){var r=e||[],s=t||Object.create(null),o=i||Object.create(null);n.forEach((function(n){!function n(e,t,i,r,s,o){var a=r.path,l=r.name;0;var u=r.pathToRegexpOptions||{},c=function(n,e,t){t||(n=n.replace(/\/$/,""));if("/"===n[0])return n;if(null==e)return n;return A(e.path+"/"+n)}(a,s,u.strict);"boolean"==typeof r.caseSensitive&&(u.sensitive=r.caseSensitive);var d={path:c,regex:Z(c,u),components:r.components||{default:r.component},instances:{},name:l,parent:s,matchAs:o,redirect:r.redirect,beforeEnter:r.beforeEnter,meta:r.meta||{},props:null==r.props?{}:r.components?r.props:{default:r.props}};r.children&&r.children.forEach((function(r){var s=o?A(o+"/"+r.path):void 0;n(e,t,i,r,d,s)}));t[d.path]||(e.push(d.path),t[d.path]=d);if(void 0!==r.alias)for(var m=Array.isArray(r.alias)?r.alias:[r.alias],p=0;p<m.length;++p){0;var h={path:m[p],children:r.children};n(e,t,i,h,s,d.path||"/")}l&&(i[l]||(i[l]=d))}(r,s,o,n)}));for(var a=0,l=r.length;a<l;a++)"*"===r[a]&&(r.push(r.splice(a,1)[0]),l--,a--);return{pathList:r,pathMap:s,nameMap:o}}function Z(n,e){return _(n,[],e)}function J(n,e){var t=G(n),i=t.pathList,r=t.pathMap,s=t.nameMap;function o(n,t,o){var a=U(n,t,!1,e),u=a.name;if(u){var c=s[u];if(!c)return l(null,a);var d=c.regex.keys.filter((function(n){return!n.optional})).map((function(n){return n.name}));if("object"!=typeof a.params&&(a.params={}),t&&"object"==typeof t.params)for(var m in t.params)!(m in a.params)&&d.indexOf(m)>-1&&(a.params[m]=t.params[m]);return a.path=$(c.path,a.params),l(c,a,o)}if(a.path){a.params={};for(var p=0;p<i.length;p++){var h=i[p],f=r[h];if(X(f.regex,a.path,a.params))return l(f,a,o)}}return l(null,a)}function a(n,t){var i=n.redirect,r="function"==typeof i?i(g(n,t,null,e)):i;if("string"==typeof r&&(r={path:r}),!r||"object"!=typeof r)return l(null,t);var a=r,u=a.name,c=a.path,d=t.query,m=t.hash,p=t.params;if(d=a.hasOwnProperty("query")?a.query:d,m=a.hasOwnProperty("hash")?a.hash:m,p=a.hasOwnProperty("params")?a.params:p,u){s[u];return o({_normalized:!0,name:u,query:d,hash:m,params:p},void 0,t)}if(c){var h=function(n,e){return k(n,e.parent?e.parent.path:"/",!0)}(c,n);return o({_normalized:!0,path:$(h,p),query:d,hash:m},void 0,t)}return l(null,t)}function l(n,t,i){return n&&n.redirect?a(n,i||t):n&&n.matchAs?function(n,e,t){var i=o({_normalized:!0,path:$(t,e.params)});if(i){var r=i.matched,s=r[r.length-1];return e.params=i.params,l(s,e)}return l(null,e)}(0,t,n.matchAs):g(n,t,i,e)}return{match:o,addRoutes:function(n){G(n,i,r,s)}}}function X(n,e,t){var i=e.match(n);if(!i)return!1;if(!t)return!0;for(var r=1,s=i.length;r<s;++r){var o=n.keys[r-1],a="string"==typeof i[r]?decodeURIComponent(i[r]):i[r];o&&(t[o.name||"pathMatch"]=a)}return!0}var Y=Q&&window.performance&&window.performance.now?window.performance:Date;function nn(){return Y.now().toFixed(3)}var en=nn();function tn(){return en}function rn(n){return en=n}var sn=Object.create(null);function on(){var n=window.location.protocol+"//"+window.location.host,e=window.location.href.replace(n,"");window.history.replaceState({key:tn()},"",e),window.addEventListener("popstate",(function(n){ln(),n.state&&n.state.key&&rn(n.state.key)}))}function an(n,e,t,i){if(n.app){var r=n.options.scrollBehavior;r&&n.app.$nextTick((function(){var s=function(){var n=tn();if(n)return sn[n]}(),o=r.call(n,e,t,i?s:null);o&&("function"==typeof o.then?o.then((function(n){pn(n,s)})).catch((function(n){0})):pn(o,s))}))}}function ln(){var n=tn();n&&(sn[n]={x:window.pageXOffset,y:window.pageYOffset})}function un(n){return dn(n.x)||dn(n.y)}function cn(n){return{x:dn(n.x)?n.x:window.pageXOffset,y:dn(n.y)?n.y:window.pageYOffset}}function dn(n){return"number"==typeof n}var mn=/^#\d/;function pn(n,e){var t,i="object"==typeof n;if(i&&"string"==typeof n.selector){var r=mn.test(n.selector)?document.getElementById(n.selector.slice(1)):document.querySelector(n.selector);if(r){var s=n.offset&&"object"==typeof n.offset?n.offset:{};e=function(n,e){var t=document.documentElement.getBoundingClientRect(),i=n.getBoundingClientRect();return{x:i.left-t.left-e.x,y:i.top-t.top-e.y}}(r,s={x:dn((t=s).x)?t.x:0,y:dn(t.y)?t.y:0})}else un(n)&&(e=cn(n))}else i&&un(n)&&(e=cn(n));e&&window.scrollTo(e.x,e.y)}var hn,fn=Q&&((-1===(hn=window.navigator.userAgent).indexOf("Android 2.")&&-1===hn.indexOf("Android 4.0")||-1===hn.indexOf("Mobile Safari")||-1!==hn.indexOf("Chrome")||-1!==hn.indexOf("Windows Phone"))&&window.history&&"pushState"in window.history);function gn(n,e){ln();var t=window.history;try{e?t.replaceState({key:tn()},"",n):t.pushState({key:rn(nn())},"",n)}catch(t){window.location[e?"replace":"assign"](n)}}function vn(n){gn(n,!0)}function bn(n,e,t){var i=function(r){r>=n.length?t():n[r]?e(n[r],(function(){i(r+1)})):i(r+1)};i(0)}function xn(n){return function(e,t,i){var s=!1,o=0,a=null;wn(n,(function(n,e,t,l){if("function"==typeof n&&void 0===n.cid){s=!0,o++;var u,c=kn((function(e){var r;((r=e).__esModule||yn&&"Module"===r[Symbol.toStringTag])&&(e=e.default),n.resolved="function"==typeof e?e:H.extend(e),t.components[l]=e,--o<=0&&i()})),d=kn((function(n){var e="Failed to resolve async component "+l+": "+n;a||(a=r(n)?n:new Error(e),i(a))}));try{u=n(c,d)}catch(n){d(n)}if(u)if("function"==typeof u.then)u.then(c,d);else{var m=u.component;m&&"function"==typeof m.then&&m.then(c,d)}}})),s||i()}}function wn(n,e){return En(n.map((function(n){return Object.keys(n.components).map((function(t){return e(n.components[t],n.instances[t],n,t)}))})))}function En(n){return Array.prototype.concat.apply([],n)}var yn="function"==typeof Symbol&&"symbol"==typeof Symbol.toStringTag;function kn(n){var e=!1;return function(){for(var t=[],i=arguments.length;i--;)t[i]=arguments[i];if(!e)return e=!0,n.apply(this,t)}}var An=function(n){function e(e){n.call(this),this.name=this._name="NavigationDuplicated",this.message='Navigating to current location ("'+e.fullPath+'") is not allowed',Object.defineProperty(this,"stack",{value:(new n).stack,writable:!0,configurable:!0})}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e}(Error);An._name="NavigationDuplicated";var jn=function(n,e){this.router=n,this.base=function(n){if(!n)if(Q){var e=document.querySelector("base");n=(n=e&&e.getAttribute("href")||"/").replace(/^https?:\/\/[^\/]+/,"")}else n="/";"/"!==n.charAt(0)&&(n="/"+n);return n.replace(/\/$/,"")}(e),this.current=b,this.pending=null,this.ready=!1,this.readyCbs=[],this.readyErrorCbs=[],this.errorCbs=[]};function _n(n,e,t,i){var r=wn(n,(function(n,i,r,s){var o=function(n,e){"function"!=typeof n&&(n=H.extend(n));return n.options[e]}(n,e);if(o)return Array.isArray(o)?o.map((function(n){return t(n,i,r,s)})):t(o,i,r,s)}));return En(i?r.reverse():r)}function Nn(n,e){if(e)return function(){return n.apply(e,arguments)}}jn.prototype.listen=function(n){this.cb=n},jn.prototype.onReady=function(n,e){this.ready?n():(this.readyCbs.push(n),e&&this.readyErrorCbs.push(e))},jn.prototype.onError=function(n){this.errorCbs.push(n)},jn.prototype.transitionTo=function(n,e,t){var i=this,r=this.router.match(n,this.current);this.confirmTransition(r,(function(){i.updateRoute(r),e&&e(r),i.ensureURL(),i.ready||(i.ready=!0,i.readyCbs.forEach((function(n){n(r)})))}),(function(n){t&&t(n),n&&!i.ready&&(i.ready=!0,i.readyErrorCbs.forEach((function(e){e(n)})))}))},jn.prototype.confirmTransition=function(n,e,t){var i=this,o=this.current,a=function(n){!s(An,n)&&r(n)&&(i.errorCbs.length?i.errorCbs.forEach((function(e){e(n)})):console.error(n)),t&&t(n)};if(E(n,o)&&n.matched.length===o.matched.length)return this.ensureURL(),a(new An(n));var l=function(n,e){var t,i=Math.max(n.length,e.length);for(t=0;t<i&&n[t]===e[t];t++);return{updated:e.slice(0,t),activated:e.slice(t),deactivated:n.slice(t)}}(this.current.matched,n.matched),u=l.updated,c=l.deactivated,d=l.activated,m=[].concat(function(n){return _n(n,"beforeRouteLeave",Nn,!0)}(c),this.router.beforeHooks,function(n){return _n(n,"beforeRouteUpdate",Nn)}(u),d.map((function(n){return n.beforeEnter})),xn(d));this.pending=n;var p=function(e,t){if(i.pending!==n)return a();try{e(n,o,(function(n){!1===n||r(n)?(i.ensureURL(!0),a(n)):"string"==typeof n||"object"==typeof n&&("string"==typeof n.path||"string"==typeof n.name)?(a(),"object"==typeof n&&n.replace?i.replace(n):i.push(n)):t(n)}))}catch(n){a(n)}};bn(m,p,(function(){var t=[];bn(function(n,e,t){return _n(n,"beforeRouteEnter",(function(n,i,r,s){return function(n,e,t,i,r){return function(s,o,a){return n(s,o,(function(n){"function"==typeof n&&i.push((function(){!function n(e,t,i,r){t[i]&&!t[i]._isBeingDestroyed?e(t[i]):r()&&setTimeout((function(){n(e,t,i,r)}),16)}(n,e.instances,t,r)})),a(n)}))}}(n,r,s,e,t)}))}(d,t,(function(){return i.current===n})).concat(i.router.resolveHooks),p,(function(){if(i.pending!==n)return a();i.pending=null,e(n),i.router.app&&i.router.app.$nextTick((function(){t.forEach((function(n){n()}))}))}))}))},jn.prototype.updateRoute=function(n){var e=this.current;this.current=n,this.cb&&this.cb(n),this.router.afterHooks.forEach((function(t){t&&t(n,e)}))};var On=function(n){function e(e,t){var i=this;n.call(this,e,t);var r=e.options.scrollBehavior,s=fn&&r;s&&on();var o=Bn(this.base);window.addEventListener("popstate",(function(n){var t=i.current,r=Bn(i.base);i.current===b&&r===o||i.transitionTo(r,(function(n){s&&an(e,n,t,!0)}))}))}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.go=function(n){window.history.go(n)},e.prototype.push=function(n,e,t){var i=this,r=this.current;this.transitionTo(n,(function(n){gn(A(i.base+n.fullPath)),an(i.router,n,r,!1),e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var i=this,r=this.current;this.transitionTo(n,(function(n){vn(A(i.base+n.fullPath)),an(i.router,n,r,!1),e&&e(n)}),t)},e.prototype.ensureURL=function(n){if(Bn(this.base)!==this.current.fullPath){var e=A(this.base+this.current.fullPath);n?gn(e):vn(e)}},e.prototype.getCurrentLocation=function(){return Bn(this.base)},e}(jn);function Bn(n){var e=decodeURI(window.location.pathname);return n&&0===e.indexOf(n)&&(e=e.slice(n.length)),(e||"/")+window.location.search+window.location.hash}var Sn=function(n){function e(e,t,i){n.call(this,e,t),i&&function(n){var e=Bn(n);if(!/^\/#/.test(e))return window.location.replace(A(n+"/#"+e)),!0}(this.base)||In()}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.setupListeners=function(){var n=this,e=this.router.options.scrollBehavior,t=fn&&e;t&&on(),window.addEventListener(fn?"popstate":"hashchange",(function(){var e=n.current;In()&&n.transitionTo(Ln(),(function(i){t&&an(n.router,i,e,!0),fn||Dn(i.fullPath)}))}))},e.prototype.push=function(n,e,t){var i=this,r=this.current;this.transitionTo(n,(function(n){Tn(n.fullPath),an(i.router,n,r,!1),e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var i=this,r=this.current;this.transitionTo(n,(function(n){Dn(n.fullPath),an(i.router,n,r,!1),e&&e(n)}),t)},e.prototype.go=function(n){window.history.go(n)},e.prototype.ensureURL=function(n){var e=this.current.fullPath;Ln()!==e&&(n?Tn(e):Dn(e))},e.prototype.getCurrentLocation=function(){return Ln()},e}(jn);function In(){var n=Ln();return"/"===n.charAt(0)||(Dn("/"+n),!1)}function Ln(){var n=window.location.href,e=n.indexOf("#");if(e<0)return"";var t=(n=n.slice(e+1)).indexOf("?");if(t<0){var i=n.indexOf("#");n=i>-1?decodeURI(n.slice(0,i))+n.slice(i):decodeURI(n)}else t>-1&&(n=decodeURI(n.slice(0,t))+n.slice(t));return n}function Cn(n){var e=window.location.href,t=e.indexOf("#");return(t>=0?e.slice(0,t):e)+"#"+n}function Tn(n){fn?gn(Cn(n)):window.location.hash=n}function Dn(n){fn?vn(Cn(n)):window.location.replace(Cn(n))}var qn=function(n){function e(e,t){n.call(this,e,t),this.stack=[],this.index=-1}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.push=function(n,e,t){var i=this;this.transitionTo(n,(function(n){i.stack=i.stack.slice(0,i.index+1).concat(n),i.index++,e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var i=this;this.transitionTo(n,(function(n){i.stack=i.stack.slice(0,i.index).concat(n),e&&e(n)}),t)},e.prototype.go=function(n){var e=this,t=this.index+n;if(!(t<0||t>=this.stack.length)){var i=this.stack[t];this.confirmTransition(i,(function(){e.index=t,e.updateRoute(i)}),(function(n){s(An,n)&&(e.index=t)}))}},e.prototype.getCurrentLocation=function(){var n=this.stack[this.stack.length-1];return n?n.fullPath:"/"},e.prototype.ensureURL=function(){},e}(jn),Pn=function(n){void 0===n&&(n={}),this.app=null,this.apps=[],this.options=n,this.beforeHooks=[],this.resolveHooks=[],this.afterHooks=[],this.matcher=J(n.routes||[],this);var e=n.mode||"hash";switch(this.fallback="history"===e&&!fn&&!1!==n.fallback,this.fallback&&(e="hash"),Q||(e="abstract"),this.mode=e,e){case"history":this.history=new On(this,n.base);break;case"hash":this.history=new Sn(this,n.base,this.fallback);break;case"abstract":this.history=new qn(this,n.base);break;default:0}},Mn={currentRoute:{configurable:!0}};function Fn(n,e){return n.push(e),function(){var t=n.indexOf(e);t>-1&&n.splice(t,1)}}Pn.prototype.match=function(n,e,t){return this.matcher.match(n,e,t)},Mn.currentRoute.get=function(){return this.history&&this.history.current},Pn.prototype.init=function(n){var e=this;if(this.apps.push(n),n.$once("hook:destroyed",(function(){var t=e.apps.indexOf(n);t>-1&&e.apps.splice(t,1),e.app===n&&(e.app=e.apps[0]||null)})),!this.app){this.app=n;var t=this.history;if(t instanceof On)t.transitionTo(t.getCurrentLocation());else if(t instanceof Sn){var i=function(){t.setupListeners()};t.transitionTo(t.getCurrentLocation(),i,i)}t.listen((function(n){e.apps.forEach((function(e){e._route=n}))}))}},Pn.prototype.beforeEach=function(n){return Fn(this.beforeHooks,n)},Pn.prototype.beforeResolve=function(n){return Fn(this.resolveHooks,n)},Pn.prototype.afterEach=function(n){return Fn(this.afterHooks,n)},Pn.prototype.onReady=function(n,e){this.history.onReady(n,e)},Pn.prototype.onError=function(n){this.history.onError(n)},Pn.prototype.push=function(n,e,t){var i=this;if(!e&&!t&&"undefined"!=typeof Promise)return new Promise((function(e,t){i.history.push(n,e,t)}));this.history.push(n,e,t)},Pn.prototype.replace=function(n,e,t){var i=this;if(!e&&!t&&"undefined"!=typeof Promise)return new Promise((function(e,t){i.history.replace(n,e,t)}));this.history.replace(n,e,t)},Pn.prototype.go=function(n){this.history.go(n)},Pn.prototype.back=function(){this.go(-1)},Pn.prototype.forward=function(){this.go(1)},Pn.prototype.getMatchedComponents=function(n){var e=n?n.matched?n:this.resolve(n).route:this.currentRoute;return e?[].concat.apply([],e.matched.map((function(n){return Object.keys(n.components).map((function(e){return n.components[e]}))}))):[]},Pn.prototype.resolve=function(n,e,t){var i=U(n,e=e||this.history.current,t,this),r=this.match(i,e),s=r.redirectedFrom||r.fullPath;return{location:i,route:r,href:function(n,e,t){var i="hash"===t?"#"+e:e;return n?A(n+"/"+i):i}(this.history.base,s,this.mode),normalizedTo:i,resolved:r}},Pn.prototype.addRoutes=function(n){this.matcher.addRoutes(n),this.history.current!==b&&this.history.transitionTo(this.history.getCurrentLocation())},Object.defineProperties(Pn.prototype,Mn),Pn.install=function n(e){if(!n.installed||H!==e){n.installed=!0,H=e;var t=function(n){return void 0!==n},i=function(n,e){var i=n.$options._parentVnode;t(i)&&t(i=i.data)&&t(i=i.registerRouteInstance)&&i(n,e)};e.mixin({beforeCreate:function(){t(this.$options.router)?(this._routerRoot=this,this._router=this.$options.router,this._router.init(this),e.util.defineReactive(this,"_route",this._router.history.current)):this._routerRoot=this.$parent&&this.$parent._routerRoot||this,i(this,this)},destroyed:function(){i(this)}}),Object.defineProperty(e.prototype,"$router",{get:function(){return this._routerRoot._router}}),Object.defineProperty(e.prototype,"$route",{get:function(){return this._routerRoot._route}}),e.component("RouterView",a),e.component("RouterLink",W);var r=e.config.optionMergeStrategies;r.beforeRouteEnter=r.beforeRouteLeave=r.beforeRouteUpdate=r.created}},Pn.version="3.1.3",Q&&window.Vue&&window.Vue.use(Pn);var zn=Pn;var Rn=t(0),$n={created(){this.$ssrContext&&(this.$ssrContext.title=this.$title,this.$ssrContext.lang=this.$lang,this.$ssrContext.description=this.$page.description||this.$description)},mounted(){this.currentMetaTags=new Set,this.updateMeta()},methods:{updateMeta(){document.title=this.$title,document.documentElement.lang=this.$lang;const n=this.$page.frontmatter.meta||[],e=n.slice(0);0===n.filter(n=>"description"===n.name).length&&e.push({name:"description",content:this.$description});const t=document.querySelectorAll('meta[name="description"]');t.length&&t.forEach(n=>this.currentMetaTags.add(n)),this.currentMetaTags=new Set(Un(e,this.currentMetaTags))}},watch:{$page(){this.updateMeta()}},beforeDestroy(){Un(null,this.currentMetaTags)}};function Un(n,e){if(e&&[...e].forEach(n=>{document.head.removeChild(n)}),n)return n.map(n=>{const e=document.createElement("meta");return Object.keys(n).forEach(t=>{e.setAttribute(t,n[t])}),document.head.appendChild(e),e})}var Hn=t(84),Vn={mounted(){window.addEventListener("scroll",this.onScroll)},methods:{onScroll:t.n(Hn)()((function(){this.setActiveHash()}),300),setActiveHash(){const n=[].slice.call(document.querySelectorAll(".sidebar-link")),e=[].slice.call(document.querySelectorAll(".header-anchor")).filter(e=>n.some(n=>n.hash===e.hash)),t=Math.max(window.pageYOffset,document.documentElement.scrollTop,document.body.scrollTop),i=Math.max(document.documentElement.scrollHeight,document.body.scrollHeight),r=window.innerHeight+t;for(let n=0;n<e.length;n++){const s=e[n],o=e[n+1],a=0===n&&0===t||t>=s.parentElement.offsetTop+10&&(!o||t<o.parentElement.offsetTop-10),l=decodeURIComponent(this.$route.hash);if(a&&l!==decodeURIComponent(s.hash)){const t=s;if(r===i)for(let t=n+1;t<e.length;t++)if(l===decodeURIComponent(e[t].hash))return;return this.$vuepress.$set("disableScrollBehavior",!0),void this.$router.replace(decodeURIComponent(t.hash),()=>{this.$nextTick(()=>{this.$vuepress.$set("disableScrollBehavior",!1)})})}}}},beforeDestroy(){window.removeEventListener("scroll",this.onScroll)}},Wn=(t(110),Object.assign||function(n){for(var e=1;e<arguments.length;e++){var t=arguments[e];for(var i in t)Object.prototype.hasOwnProperty.call(t,i)&&(n[i]=t[i])}return n}),Kn=function(n){return"IMG"===n.tagName},Qn=function(n){return n&&1===n.nodeType},Gn=function(n){return".svg"===(n.currentSrc||n.src).substr(-4).toLowerCase()},Zn=function(n){try{return Array.isArray(n)?n.filter(Kn):function(n){return NodeList.prototype.isPrototypeOf(n)}(n)?[].slice.call(n).filter(Kn):Qn(n)?[n].filter(Kn):"string"==typeof n?[].slice.call(document.querySelectorAll(n)).filter(Kn):[]}catch(n){throw new TypeError("The provided selector is invalid.\nExpects a CSS selector, a Node element, a NodeList or an array.\nSee: https://github.com/francoischalifour/medium-zoom")}},Jn=function(n){var e=document.createElement("div");return e.classList.add("medium-zoom-overlay"),e.style.background=n,e},Xn=function(n){var e=n.getBoundingClientRect(),t=e.top,i=e.left,r=e.width,s=e.height,o=n.cloneNode(),a=window.pageYOffset||document.documentElement.scrollTop||document.body.scrollTop||0,l=window.pageXOffset||document.documentElement.scrollLeft||document.body.scrollLeft||0;return o.removeAttribute("id"),o.style.position="absolute",o.style.top=t+a+"px",o.style.left=i+l+"px",o.style.width=r+"px",o.style.height=s+"px",o.style.transform="",o},Yn=function(n,e){var t=Wn({bubbles:!1,cancelable:!1,detail:void 0},e);if("function"==typeof window.CustomEvent)return new CustomEvent(n,t);var i=document.createEvent("CustomEvent");return i.initCustomEvent(n,t.bubbles,t.cancelable,t.detail),i};!function(n,e){void 0===e&&(e={});var t=e.insertAt;if(n&&"undefined"!=typeof document){var i=document.head||document.getElementsByTagName("head")[0],r=document.createElement("style");r.type="text/css","top"===t&&i.firstChild?i.insertBefore(r,i.firstChild):i.appendChild(r),r.styleSheet?r.styleSheet.cssText=n:r.appendChild(document.createTextNode(n))}}(".medium-zoom-overlay{position:fixed;top:0;right:0;bottom:0;left:0;opacity:0;transition:opacity .3s;will-change:opacity}.medium-zoom--opened .medium-zoom-overlay{cursor:pointer;cursor:zoom-out;opacity:1}.medium-zoom-image{cursor:pointer;cursor:zoom-in;transition:transform .3s cubic-bezier(.2,0,.2,1)!important}.medium-zoom-image--hidden{visibility:hidden}.medium-zoom-image--opened{position:relative;cursor:pointer;cursor:zoom-out;will-change:transform}");var ne=function n(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},i=window.Promise||function(n){function e(){}n(e,e)},r=function(n){var e=n.target;e!==j?-1!==x.indexOf(e)&&f({target:e}):h()},s=function(){if(!E&&A.original){var n=window.pageYOffset||document.documentElement.scrollTop||document.body.scrollTop||0;Math.abs(y-n)>k.scrollOffset&&setTimeout(h,150)}},o=function(n){var e=n.key||n.keyCode;"Escape"!==e&&"Esc"!==e&&27!==e||h()},a=function(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},e=n;if(n.background&&(j.style.background=n.background),n.container&&n.container instanceof Object&&(e.container=Wn({},k.container,n.container)),n.template){var t=Qn(n.template)?n.template:document.querySelector(n.template);e.template=t}return k=Wn({},k,e),x.forEach((function(n){n.dispatchEvent(Yn("medium-zoom:update",{detail:{zoom:_}}))})),_},l=function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return n(Wn({},k,e))},u=function(){for(var n=arguments.length,e=Array(n),t=0;t<n;t++)e[t]=arguments[t];var i=e.reduce((function(n,e){return[].concat(n,Zn(e))}),[]);return i.filter((function(n){return-1===x.indexOf(n)})).forEach((function(n){x.push(n),n.classList.add("medium-zoom-image")})),w.forEach((function(n){var e=n.type,t=n.listener,r=n.options;i.forEach((function(n){n.addEventListener(e,t,r)}))})),_},c=function(){for(var n=arguments.length,e=Array(n),t=0;t<n;t++)e[t]=arguments[t];A.zoomed&&h();var i=e.length>0?e.reduce((function(n,e){return[].concat(n,Zn(e))}),[]):x;return i.forEach((function(n){n.classList.remove("medium-zoom-image"),n.dispatchEvent(Yn("medium-zoom:detach",{detail:{zoom:_}}))})),x=x.filter((function(n){return-1===i.indexOf(n)})),_},d=function(n,e){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};return x.forEach((function(i){i.addEventListener("medium-zoom:"+n,e,t)})),w.push({type:"medium-zoom:"+n,listener:e,options:t}),_},m=function(n,e){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};return x.forEach((function(i){i.removeEventListener("medium-zoom:"+n,e,t)})),w=w.filter((function(t){return!(t.type==="medium-zoom:"+n&&t.listener.toString()===e.toString())})),_},p=function(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},e=n.target,t=function(){var n={width:document.documentElement.clientWidth,height:document.documentElement.clientHeight,left:0,top:0,right:0,bottom:0},e=void 0,t=void 0;if(k.container)if(k.container instanceof Object)e=(n=Wn({},n,k.container)).width-n.left-n.right-2*k.margin,t=n.height-n.top-n.bottom-2*k.margin;else{var i=(Qn(k.container)?k.container:document.querySelector(k.container)).getBoundingClientRect(),r=i.width,s=i.height,o=i.left,a=i.top;n=Wn({},n,{width:r,height:s,left:o,top:a})}e=e||n.width-2*k.margin,t=t||n.height-2*k.margin;var l=A.zoomedHd||A.original,u=Gn(l)?e:l.naturalWidth||e,c=Gn(l)?t:l.naturalHeight||t,d=l.getBoundingClientRect(),m=d.top,p=d.left,h=d.width,f=d.height,g=Math.min(u,e)/h,v=Math.min(c,t)/f,b=Math.min(g,v),x="scale("+b+") translate3d("+((e-h)/2-p+k.margin+n.left)/b+"px, "+((t-f)/2-m+k.margin+n.top)/b+"px, 0)";A.zoomed.style.transform=x,A.zoomedHd&&(A.zoomedHd.style.transform=x)};return new i((function(n){if(e&&-1===x.indexOf(e))n(_);else{if(A.zoomed)n(_);else{if(e)A.original=e;else{if(!(x.length>0))return void n(_);var i=x;A.original=i[0]}if(A.original.dispatchEvent(Yn("medium-zoom:open",{detail:{zoom:_}})),y=window.pageYOffset||document.documentElement.scrollTop||document.body.scrollTop||0,E=!0,A.zoomed=Xn(A.original),document.body.appendChild(j),k.template){var r=Qn(k.template)?k.template:document.querySelector(k.template);A.template=document.createElement("div"),A.template.appendChild(r.content.cloneNode(!0)),document.body.appendChild(A.template)}if(document.body.appendChild(A.zoomed),window.requestAnimationFrame((function(){document.body.classList.add("medium-zoom--opened")})),A.original.classList.add("medium-zoom-image--hidden"),A.zoomed.classList.add("medium-zoom-image--opened"),A.zoomed.addEventListener("click",h),A.zoomed.addEventListener("transitionend",(function e(){E=!1,A.zoomed.removeEventListener("transitionend",e),A.original.dispatchEvent(Yn("medium-zoom:opened",{detail:{zoom:_}})),n(_)})),A.original.getAttribute("data-zoom-src")){A.zoomedHd=A.zoomed.cloneNode(),A.zoomedHd.removeAttribute("srcset"),A.zoomedHd.removeAttribute("sizes"),A.zoomedHd.src=A.zoomed.getAttribute("data-zoom-src"),A.zoomedHd.onerror=function(){clearInterval(s),console.warn("Unable to reach the zoom image target "+A.zoomedHd.src),A.zoomedHd=null,t()};var s=setInterval((function(){A.zoomedHd.complete&&(clearInterval(s),A.zoomedHd.classList.add("medium-zoom-image--opened"),A.zoomedHd.addEventListener("click",h),document.body.appendChild(A.zoomedHd),t())}),10)}else if(A.original.hasAttribute("srcset")){A.zoomedHd=A.zoomed.cloneNode(),A.zoomedHd.removeAttribute("sizes");var o=A.zoomedHd.addEventListener("load",(function(){A.zoomedHd.removeEventListener("load",o),A.zoomedHd.classList.add("medium-zoom-image--opened"),A.zoomedHd.addEventListener("click",h),document.body.appendChild(A.zoomedHd),t()}))}else t()}}}))},h=function(){return new i((function(n){if(!E&&A.original){E=!0,document.body.classList.remove("medium-zoom--opened"),A.zoomed.style.transform="",A.zoomedHd&&(A.zoomedHd.style.transform=""),A.template&&(A.template.style.transition="opacity 150ms",A.template.style.opacity=0),A.original.dispatchEvent(Yn("medium-zoom:close",{detail:{zoom:_}})),A.zoomed.addEventListener("transitionend",(function e(){A.original.classList.remove("medium-zoom-image--hidden"),document.body.removeChild(A.zoomed),A.zoomedHd&&document.body.removeChild(A.zoomedHd),document.body.removeChild(j),A.zoomed.classList.remove("medium-zoom-image--opened"),A.template&&document.body.removeChild(A.template),E=!1,A.zoomed.removeEventListener("transitionend",e),A.original.dispatchEvent(Yn("medium-zoom:closed",{detail:{zoom:_}})),A.original=null,A.zoomed=null,A.zoomedHd=null,A.template=null,n(_)}))}else n(_)}))},f=function(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},e=n.target;return A.original?h():p({target:e})},g=function(){return k},v=function(){return x},b=function(){return A.original},x=[],w=[],E=!1,y=0,k=t,A={original:null,zoomed:null,zoomedHd:null,template:null};"[object Object]"===Object.prototype.toString.call(e)?k=e:(e||"string"==typeof e)&&u(e),k=Wn({margin:0,background:"#fff",scrollOffset:40,container:null,template:null},k);var j=Jn(k.background);document.addEventListener("click",r),document.addEventListener("keyup",o),document.addEventListener("scroll",s),window.addEventListener("resize",h);var _={open:p,close:h,toggle:f,update:a,clone:l,attach:u,detach:c,on:d,off:m,getOptions:g,getImages:v,getZoomedImage:b};return _},ee={data:()=>({zoom:null}),mounted(){this.updateZoom()},updated(){this.updateZoom()},methods:{updateZoom(){setTimeout(()=>{this.zoom&&this.zoom.detach(),this.zoom=ne(".theme-reco-content :not(a) > img",void 0)},1e3)}}},te=t(36),ie=t.n(te),re={mounted(){ie.a.configure({showSpinner:!1}),this.$router.beforeEach((n,e,t)=>{n.path===e.path||i.a.component(n.name)||ie.a.start(),t()}),this.$router.afterEach(()=>{ie.a.done(),this.isSidebarOpen=!1})}};const se=".theme-reco-content :not(a) > img",oe=JSON.parse('{"margin":24,"background":"#182529","scrollOffset":0}'),ae=Number("1000");class le{constructor(){this.instance=null}update(n=se){"undefined"!=typeof window&&(null===this.instance?this.instance=ne(n,oe):(this.instance.detach(),this.instance.attach(n)))}updateDelay(n=se,e=ae){setTimeout(()=>this.update(n),e)}}t(111);var ue=[$n,Vn,ee,re,{watch:{"$page.path"(){void 0!==this.$vuepress.mediumZoom&&this.$vuepress.mediumZoom.updateDelay()}},mounted(){this.$vuepress.mediumZoom=new le,this.$vuepress.mediumZoom.updateDelay()}}],ce={methods:{getLayout:function(){if(this.$page.path){var n=this.$page.frontmatter.layout;return n&&(this.$vuepress.getLayoutAsyncComponent(n)||this.$vuepress.getVueComponent(n))?n:"Layout"}return"NotFound"}},computed:{layout:function(){var n=this.getLayout();return Object(Rn.i)("layout",n),i.a.component(n)}}},de=t(2),me=Object(de.a)(ce,(function(){var n=this.$createElement;return(this._self._c||n)(this.layout,{tag:"component"})}),[],!1,null,null,null).exports;Object(Rn.g)(me,"mixins",ue);const pe=[{name:"v-50a4e6f6",path:"/",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-50a4e6f6").then(t)}},{path:"/index.html",redirect:"/"},{name:"v-872b1f36",path:"/views/%E4%B8%AD%E7%AD%89/0002-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0.html",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-872b1f36").then(t)}},{path:"/views/中等/0002-两数相加.html",redirect:"/views/%E4%B8%AD%E7%AD%89/0002-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0.html"},{name:"v-51a0a422",path:"/views/%E4%B8%AD%E7%AD%89/0003-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2.html",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-51a0a422").then(t)}},{path:"/views/中等/0003-无重复字符的最长子串.html",redirect:"/views/%E4%B8%AD%E7%AD%89/0003-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2.html"},{name:"v-7541876e",path:"/views/%E4%B8%AD%E7%AD%89/0019-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9.html",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-7541876e").then(t)}},{path:"/views/中等/0019-删除链表的倒数第N个节点.html",redirect:"/views/%E4%B8%AD%E7%AD%89/0019-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9.html"},{name:"v-082f848c",path:"/views/%E4%B8%AD%E7%AD%89/0017-%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88.html",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-082f848c").then(t)}},{path:"/views/中等/0017-电话号码的字母组合.html",redirect:"/views/%E4%B8%AD%E7%AD%89/0017-%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88.html"},{name:"v-4779f67f",path:"/views/%E4%B8%AD%E7%AD%89/0011-%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8.html",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-4779f67f").then(t)}},{path:"/views/中等/0011-盛最多水的容器.html",redirect:"/views/%E4%B8%AD%E7%AD%89/0011-%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8.html"},{name:"v-69743892",path:"/views/%E4%B8%AD%E7%AD%89/0034-%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE.html",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-69743892").then(t)}},{path:"/views/中等/0034-在排序数组中查找元素的第一个和最后一个位置.html",redirect:"/views/%E4%B8%AD%E7%AD%89/0034-%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE.html"},{name:"v-40896626",path:"/views/%E4%B8%AD%E7%AD%89/0039-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C.html",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-40896626").then(t)}},{path:"/views/中等/0039-组合总和.html",redirect:"/views/%E4%B8%AD%E7%AD%89/0039-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C.html"},{name:"v-2b081e4c",path:"/views/%E4%B8%AD%E7%AD%89/0024-%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9.html",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-2b081e4c").then(t)}},{path:"/views/中等/0024-两两交换链表中的节点.html",redirect:"/views/%E4%B8%AD%E7%AD%89/0024-%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9.html"},{name:"v-29c9103a",path:"/views/%E4%B8%AD%E7%AD%89/0015-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C.html",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-29c9103a").then(t)}},{path:"/views/中等/0015-三数之和.html",redirect:"/views/%E4%B8%AD%E7%AD%89/0015-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C.html"},{name:"v-1efc4839",path:"/views/%E4%B8%AD%E7%AD%89/0040-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C%20II.html",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-1efc4839").then(t)}},{path:"/views/中等/0040-组合总和 II.html",redirect:"/views/%E4%B8%AD%E7%AD%89/0040-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C%20II.html"},{name:"v-4ed2f72c",path:"/views/%E4%B8%AD%E7%AD%89/0046-%E5%85%A8%E6%8E%92%E5%88%97.html",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-4ed2f72c").then(t)}},{path:"/views/中等/0046-全排列.html",redirect:"/views/%E4%B8%AD%E7%AD%89/0046-%E5%85%A8%E6%8E%92%E5%88%97.html"},{name:"v-46d8099a",path:"/views/%E4%B8%AD%E7%AD%89/0047-%E5%85%A8%E6%8E%92%E5%88%97%20II.html",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-46d8099a").then(t)}},{path:"/views/中等/0047-全排列 II.html",redirect:"/views/%E4%B8%AD%E7%AD%89/0047-%E5%85%A8%E6%8E%92%E5%88%97%20II.html"},{name:"v-27f937b5",path:"/views/%E4%B8%AD%E7%AD%89/0022-%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90.html",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-27f937b5").then(t)}},{path:"/views/中等/0022-括号生成.html",redirect:"/views/%E4%B8%AD%E7%AD%89/0022-%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90.html"},{name:"v-662329a2",path:"/views/%E4%B8%AD%E7%AD%89/0062-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84.html",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-662329a2").then(t)}},{path:"/views/中等/0062-不同路径.html",redirect:"/views/%E4%B8%AD%E7%AD%89/0062-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84.html"},{name:"v-37e48825",path:"/views/%E4%B8%AD%E7%AD%89/0049-%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D%E5%88%86%E7%BB%84.html",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-37e48825").then(t)}},{path:"/views/中等/0049-字母异位词分组.html",redirect:"/views/%E4%B8%AD%E7%AD%89/0049-%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D%E5%88%86%E7%BB%84.html"},{name:"v-4b70cbd6",path:"/views/%E4%B8%AD%E7%AD%89/0064-%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C.html",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-4b70cbd6").then(t)}},{path:"/views/中等/0064-最小路径和.html",redirect:"/views/%E4%B8%AD%E7%AD%89/0064-%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C.html"},{name:"v-92619eec",path:"/views/%E4%B8%AD%E7%AD%89/0075-%E9%A2%9C%E8%89%B2%E5%88%86%E7%B1%BB.html",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-92619eec").then(t)}},{path:"/views/中等/0075-颜色分类.html",redirect:"/views/%E4%B8%AD%E7%AD%89/0075-%E9%A2%9C%E8%89%B2%E5%88%86%E7%B1%BB.html"},{name:"v-0e1774ab",path:"/views/%E4%B8%AD%E7%AD%89/0063-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84%20II.html",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-0e1774ab").then(t)}},{path:"/views/中等/0063-不同路径 II.html",redirect:"/views/%E4%B8%AD%E7%AD%89/0063-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84%20II.html"},{name:"v-7c92bd0a",path:"/views/%E4%B8%AD%E7%AD%89/0078-%E5%AD%90%E9%9B%86.html",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-7c92bd0a").then(t)}},{path:"/views/中等/0078-子集.html",redirect:"/views/%E4%B8%AD%E7%AD%89/0078-%E5%AD%90%E9%9B%86.html"},{name:"v-4ec67454",path:"/views/%E4%B8%AD%E7%AD%89/0077-%E7%BB%84%E5%90%88.html",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-4ec67454").then(t)}},{path:"/views/中等/0077-组合.html",redirect:"/views/%E4%B8%AD%E7%AD%89/0077-%E7%BB%84%E5%90%88.html"},{name:"v-67f0bc42",path:"/views/%E4%B8%AD%E7%AD%89/0079-%E5%8D%95%E8%AF%8D%E6%90%9C%E7%B4%A2.html",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-67f0bc42").then(t)}},{path:"/views/中等/0079-单词搜索.html",redirect:"/views/%E4%B8%AD%E7%AD%89/0079-%E5%8D%95%E8%AF%8D%E6%90%9C%E7%B4%A2.html"},{name:"v-69c9e716",path:"/views/%E4%B8%AD%E7%AD%89/0080-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9%20II.html",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-69c9e716").then(t)}},{path:"/views/中等/0080-删除排序数组中的重复项 II.html",redirect:"/views/%E4%B8%AD%E7%AD%89/0080-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9%20II.html"},{name:"v-09fa2471",path:"/views/%E4%B8%AD%E7%AD%89/0086-%E5%88%86%E9%9A%94%E9%93%BE%E8%A1%A8.html",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-09fa2471").then(t)}},{path:"/views/中等/0086-分隔链表.html",redirect:"/views/%E4%B8%AD%E7%AD%89/0086-%E5%88%86%E9%9A%94%E9%93%BE%E8%A1%A8.html"},{name:"v-a45a98cc",path:"/views/%E4%B8%AD%E7%AD%89/0050-Pow(x,%20n).html",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-a45a98cc").then(t)}},{path:"/views/中等/0050-Pow(x, n).html",redirect:"/views/%E4%B8%AD%E7%AD%89/0050-Pow(x,%20n).html"},{name:"v-636b4c6e",path:"/views/%E4%B8%AD%E7%AD%89/0090-%E5%AD%90%E9%9B%86%20II.html",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-636b4c6e").then(t)}},{path:"/views/中等/0090-子集 II.html",redirect:"/views/%E4%B8%AD%E7%AD%89/0090-%E5%AD%90%E9%9B%86%20II.html"},{name:"v-4cbecd9d",path:"/views/%E4%B8%AD%E7%AD%89/0094-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86.html",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-4cbecd9d").then(t)}},{path:"/views/中等/0094-二叉树的中序遍历.html",redirect:"/views/%E4%B8%AD%E7%AD%89/0094-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86.html"},{name:"v-3bb3d58a",path:"/views/%E4%B8%AD%E7%AD%89/0091-%E8%A7%A3%E7%A0%81%E6%96%B9%E6%B3%95.html",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-3bb3d58a").then(t)}},{path:"/views/中等/0091-解码方法.html",redirect:"/views/%E4%B8%AD%E7%AD%89/0091-%E8%A7%A3%E7%A0%81%E6%96%B9%E6%B3%95.html"},{name:"v-70fe855a",path:"/views/%E4%B8%AD%E7%AD%89/0092-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8%20II.html",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-70fe855a").then(t)}},{path:"/views/中等/0092-反转链表 II.html",redirect:"/views/%E4%B8%AD%E7%AD%89/0092-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8%20II.html"},{name:"v-7dcfc1d7",path:"/views/%E4%B8%AD%E7%AD%89/0093-%E5%A4%8D%E5%8E%9FIP%E5%9C%B0%E5%9D%80.html",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-7dcfc1d7").then(t)}},{path:"/views/中等/0093-复原IP地址.html",redirect:"/views/%E4%B8%AD%E7%AD%89/0093-%E5%A4%8D%E5%8E%9FIP%E5%9C%B0%E5%9D%80.html"},{name:"v-78c30bf4",path:"/views/%E4%B8%AD%E7%AD%89/0098-%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.html",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-78c30bf4").then(t)}},{path:"/views/中等/0098-验证二叉搜索树.html",redirect:"/views/%E4%B8%AD%E7%AD%89/0098-%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.html"},{name:"v-08021f6f",path:"/views/%E4%B8%AD%E7%AD%89/0102-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86.html",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-08021f6f").then(t)}},{path:"/views/中等/0102-二叉树的层次遍历.html",redirect:"/views/%E4%B8%AD%E7%AD%89/0102-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86.html"},{name:"v-4fb1a763",path:"/views/%E4%B8%AD%E7%AD%89/0113-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C%20II.html",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-4fb1a763").then(t)}},{path:"/views/中等/0113-路径总和 II.html",redirect:"/views/%E4%B8%AD%E7%AD%89/0113-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C%20II.html"},{name:"v-b7e2d1be",path:"/views/%E4%B8%AD%E7%AD%89/0103-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%94%AF%E9%BD%BF%E5%BD%A2%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86.html",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-b7e2d1be").then(t)}},{path:"/views/中等/0103-二叉树的锯齿形层次遍历.html",redirect:"/views/%E4%B8%AD%E7%AD%89/0103-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%94%AF%E9%BD%BF%E5%BD%A2%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86.html"},{name:"v-4aeac5ec",path:"/views/%E4%B8%AD%E7%AD%89/0120-%E4%B8%89%E8%A7%92%E5%BD%A2%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C.html",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-4aeac5ec").then(t)}},{path:"/views/中等/0120-三角形最小路径和.html",redirect:"/views/%E4%B8%AD%E7%AD%89/0120-%E4%B8%89%E8%A7%92%E5%BD%A2%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C.html"},{name:"v-94273df0",path:"/views/%E4%B8%AD%E7%AD%89/0129-%E6%B1%82%E6%A0%B9%E5%88%B0%E5%8F%B6%E5%AD%90%E8%8A%82%E7%82%B9%E6%95%B0%E5%AD%97%E4%B9%8B%E5%92%8C.html",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-94273df0").then(t)}},{path:"/views/中等/0129-求根到叶子节点数字之和.html",redirect:"/views/%E4%B8%AD%E7%AD%89/0129-%E6%B1%82%E6%A0%B9%E5%88%B0%E5%8F%B6%E5%AD%90%E8%8A%82%E7%82%B9%E6%95%B0%E5%AD%97%E4%B9%8B%E5%92%8C.html"},{name:"v-6fab22e5",path:"/views/%E4%B8%AD%E7%AD%89/0150-%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC.html",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-6fab22e5").then(t)}},{path:"/views/中等/0150-逆波兰表达式求值.html",redirect:"/views/%E4%B8%AD%E7%AD%89/0150-%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC.html"},{name:"v-6ba46688",path:"/views/%E4%B8%AD%E7%AD%89/0200-%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F.html",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-6ba46688").then(t)}},{path:"/views/中等/0200-岛屿数量.html",redirect:"/views/%E4%B8%AD%E7%AD%89/0200-%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F.html"},{name:"v-2a6bb239",path:"/views/%E4%B8%AD%E7%AD%89/0208-%E5%AE%9E%E7%8E%B0%20Trie%20(%E5%89%8D%E7%BC%80%E6%A0%91).html",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-2a6bb239").then(t)}},{path:"/views/中等/0208-实现 Trie (前缀树).html",redirect:"/views/%E4%B8%AD%E7%AD%89/0208-%E5%AE%9E%E7%8E%B0%20Trie%20(%E5%89%8D%E7%BC%80%E6%A0%91).html"},{name:"v-78dbd082",path:"/views/%E4%B8%AD%E7%AD%89/0209-%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84.html",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-78dbd082").then(t)}},{path:"/views/中等/0209-长度最小的子数组.html",redirect:"/views/%E4%B8%AD%E7%AD%89/0209-%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84.html"},{name:"v-172d1308",path:"/views/%E4%B8%AD%E7%AD%89/0144-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86.html",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-172d1308").then(t)}},{path:"/views/中等/0144-二叉树的前序遍历.html",redirect:"/views/%E4%B8%AD%E7%AD%89/0144-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86.html"},{name:"v-f54f2200",path:"/views/%E4%B8%AD%E7%AD%89/0211-%E6%B7%BB%E5%8A%A0%E4%B8%8E%E6%90%9C%E7%B4%A2%E5%8D%95%E8%AF%8D%20-%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1.html",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-f54f2200").then(t)}},{path:"/views/中等/0211-添加与搜索单词 - 数据结构设计.html",redirect:"/views/%E4%B8%AD%E7%AD%89/0211-%E6%B7%BB%E5%8A%A0%E4%B8%8E%E6%90%9C%E7%B4%A2%E5%8D%95%E8%AF%8D%20-%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1.html"},{name:"v-7d3d3b3c",path:"/views/%E4%B8%AD%E7%AD%89/0213-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D%20II.html",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-7d3d3b3c").then(t)}},{path:"/views/中等/0213-打家劫舍 II.html",redirect:"/views/%E4%B8%AD%E7%AD%89/0213-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D%20II.html"},{name:"v-5cfb85d7",path:"/views/%E4%B8%AD%E7%AD%89/0215-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACK%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0.html",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-5cfb85d7").then(t)}},{path:"/views/中等/0215-数组中的第K个最大元素.html",redirect:"/views/%E4%B8%AD%E7%AD%89/0215-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACK%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0.html"},{name:"v-3e57534e",path:"/views/%E4%B8%AD%E7%AD%89/0216-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C%20III.html",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-3e57534e").then(t)}},{path:"/views/中等/0216-组合总和 III.html",redirect:"/views/%E4%B8%AD%E7%AD%89/0216-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C%20III.html"},{name:"v-0c1dc4cd",path:"/views/%E4%B8%AD%E7%AD%89/0220-%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0%20III.html",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-0c1dc4cd").then(t)}},{path:"/views/中等/0220-存在重复元素 III.html",redirect:"/views/%E4%B8%AD%E7%AD%89/0220-%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0%20III.html"},{name:"v-239b7bef",path:"/views/%E4%B8%AD%E7%AD%89/0230-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%AC%ACK%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0.html",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-239b7bef").then(t)}},{path:"/views/中等/0230-二叉搜索树中第K小的元素.html",redirect:"/views/%E4%B8%AD%E7%AD%89/0230-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%AC%ACK%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0.html"},{name:"v-a8cd2084",path:"/views/%E4%B8%AD%E7%AD%89/0307-%E5%8C%BA%E5%9F%9F%E5%92%8C%E6%A3%80%E7%B4%A2%20-%20%E6%95%B0%E7%BB%84%E5%8F%AF%E4%BF%AE%E6%94%B9.html",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-a8cd2084").then(t)}},{path:"/views/中等/0307-区域和检索 - 数组可修改.html",redirect:"/views/%E4%B8%AD%E7%AD%89/0307-%E5%8C%BA%E5%9F%9F%E5%92%8C%E6%A3%80%E7%B4%A2%20-%20%E6%95%B0%E7%BB%84%E5%8F%AF%E4%BF%AE%E6%94%B9.html"},{name:"v-39824ad2",path:"/views/%E4%B8%AD%E7%AD%89/0279-%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0.html",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-39824ad2").then(t)}},{path:"/views/中等/0279-完全平方数.html",redirect:"/views/%E4%B8%AD%E7%AD%89/0279-%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0.html"},{name:"v-49ca1f81",path:"/views/%E4%B8%AD%E7%AD%89/0240-%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5%20II.html",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-49ca1f81").then(t)}},{path:"/views/中等/0240-搜索二维矩阵 II.html",redirect:"/views/%E4%B8%AD%E7%AD%89/0240-%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5%20II.html"},{name:"v-4f2683df",path:"/views/%E4%B8%AD%E7%AD%89/0300-%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97.html",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-4f2683df").then(t)}},{path:"/views/中等/0300-最长上升子序列.html",redirect:"/views/%E4%B8%AD%E7%AD%89/0300-%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97.html"},{name:"v-59e03967",path:"/views/%E4%B8%AD%E7%AD%89/0322-%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2.html",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-59e03967").then(t)}},{path:"/views/中等/0322-零钱兑换.html",redirect:"/views/%E4%B8%AD%E7%AD%89/0322-%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2.html"},{name:"v-36ec1cda",path:"/views/%E4%B8%AD%E7%AD%89/0309-%E6%9C%80%E4%BD%B3%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E6%97%B6%E6%9C%BA%E5%90%AB%E5%86%B7%E5%86%BB%E6%9C%9F.html",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-36ec1cda").then(t)}},{path:"/views/中等/0309-最佳买卖股票时机含冷冻期.html",redirect:"/views/%E4%B8%AD%E7%AD%89/0309-%E6%9C%80%E4%BD%B3%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E6%97%B6%E6%9C%BA%E5%90%AB%E5%86%B7%E5%86%BB%E6%9C%9F.html"},{name:"v-0d191fb0",path:"/views/%E4%B8%AD%E7%AD%89/0337-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D%20III.html",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-0d191fb0").then(t)}},{path:"/views/中等/0337-打家劫舍 III.html",redirect:"/views/%E4%B8%AD%E7%AD%89/0337-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D%20III.html"},{name:"v-4772a9c6",path:"/views/%E4%B8%AD%E7%AD%89/0343-%E6%95%B4%E6%95%B0%E6%8B%86%E5%88%86.html",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-4772a9c6").then(t)}},{path:"/views/中等/0343-整数拆分.html",redirect:"/views/%E4%B8%AD%E7%AD%89/0343-%E6%95%B4%E6%95%B0%E6%8B%86%E5%88%86.html"},{name:"v-a45ead70",path:"/views/%E4%B8%AD%E7%AD%89/0347-%E5%89%8D%20K%20%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0.html",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-a45ead70").then(t)}},{path:"/views/中等/0347-前 K 个高频元素.html",redirect:"/views/%E4%B8%AD%E7%AD%89/0347-%E5%89%8D%20K%20%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0.html"},{name:"v-fedf490e",path:"/views/%E4%B8%AD%E7%AD%89/0377-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C%20%E2%85%A3.html",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-fedf490e").then(t)}},{path:"/views/中等/0377-组合总和 Ⅳ.html",redirect:"/views/%E4%B8%AD%E7%AD%89/0377-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C%20%E2%85%A3.html"},{name:"v-b2977cb0",path:"/views/%E4%B8%AD%E7%AD%89/0416-%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86.html",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-b2977cb0").then(t)}},{path:"/views/中等/0416-分割等和子集.html",redirect:"/views/%E4%B8%AD%E7%AD%89/0416-%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86.html"},{name:"v-4b6669ef",path:"/views/%E4%B8%AD%E7%AD%89/0435-%E6%97%A0%E9%87%8D%E5%8F%A0%E5%8C%BA%E9%97%B4.html",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-4b6669ef").then(t)}},{path:"/views/中等/0435-无重叠区间.html",redirect:"/views/%E4%B8%AD%E7%AD%89/0435-%E6%97%A0%E9%87%8D%E5%8F%A0%E5%8C%BA%E9%97%B4.html"},{name:"v-64e21c1e",path:"/views/%E4%B8%AD%E7%AD%89/0450-%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9.html",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-64e21c1e").then(t)}},{path:"/views/中等/0450-删除二叉搜索树中的节点.html",redirect:"/views/%E4%B8%AD%E7%AD%89/0450-%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9.html"},{name:"v-2f5ba20c",path:"/views/%E4%B8%AD%E7%AD%89/0438-%E6%89%BE%E5%88%B0%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E6%89%80%E6%9C%89%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D.html",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-2f5ba20c").then(t)}},{path:"/views/中等/0438-找到字符串中所有字母异位词.html",redirect:"/views/%E4%B8%AD%E7%AD%89/0438-%E6%89%BE%E5%88%B0%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E6%89%80%E6%9C%89%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D.html"},{name:"v-4f4e8ede",path:"/views/%E4%B8%AD%E7%AD%89/0451-%E6%A0%B9%E6%8D%AE%E5%AD%97%E7%AC%A6%E5%87%BA%E7%8E%B0%E9%A2%91%E7%8E%87%E6%8E%92%E5%BA%8F.html",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-4f4e8ede").then(t)}},{path:"/views/中等/0451-根据字符出现频率排序.html",redirect:"/views/%E4%B8%AD%E7%AD%89/0451-%E6%A0%B9%E6%8D%AE%E5%AD%97%E7%AC%A6%E5%87%BA%E7%8E%B0%E9%A2%91%E7%8E%87%E6%8E%92%E5%BA%8F.html"},{name:"v-9b996c72",path:"/views/%E4%B8%AD%E7%AD%89/0454-%E5%9B%9B%E6%95%B0%E7%9B%B8%E5%8A%A0%20II.html",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-9b996c72").then(t)}},{path:"/views/中等/0454-四数相加 II.html",redirect:"/views/%E4%B8%AD%E7%AD%89/0454-%E5%9B%9B%E6%95%B0%E7%9B%B8%E5%8A%A0%20II.html"},{name:"v-237c778e",path:"/views/%E4%B8%AD%E7%AD%89/%E5%89%91%E6%8C%87%20Offer%2004-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE.html",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-237c778e").then(t)}},{path:"/views/中等/剑指 Offer 04-二维数组中的查找.html",redirect:"/views/%E4%B8%AD%E7%AD%89/%E5%89%91%E6%8C%87%20Offer%2004-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE.html"},{name:"v-25ece19a",path:"/views/%E5%9B%B0%E9%9A%BE/0023-%E5%90%88%E5%B9%B6K%E4%B8%AA%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8.html",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-25ece19a").then(t)}},{path:"/views/困难/0023-合并K个排序链表.html",redirect:"/views/%E5%9B%B0%E9%9A%BE/0023-%E5%90%88%E5%B9%B6K%E4%B8%AA%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8.html"},{name:"v-0677f7bb",path:"/views/%E5%9B%B0%E9%9A%BE/0051-N%E7%9A%87%E5%90%8E.html",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-0677f7bb").then(t)}},{path:"/views/困难/0051-N皇后.html",redirect:"/views/%E5%9B%B0%E9%9A%BE/0051-N%E7%9A%87%E5%90%8E.html"},{name:"v-b27509c4",path:"/views/%E5%9B%B0%E9%9A%BE/0145-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86.html",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-b27509c4").then(t)}},{path:"/views/困难/0145-二叉树的后序遍历.html",redirect:"/views/%E5%9B%B0%E9%9A%BE/0145-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86.html"},{name:"v-7016069a",path:"/views/%E5%9B%B0%E9%9A%BE/0282-%E7%BB%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B7%BB%E5%8A%A0%E8%BF%90%E7%AE%97%E7%AC%A6.html",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-7016069a").then(t)}},{path:"/views/困难/0282-给表达式添加运算符.html",redirect:"/views/%E5%9B%B0%E9%9A%BE/0282-%E7%BB%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B7%BB%E5%8A%A0%E8%BF%90%E7%AE%97%E7%AC%A6.html"},{name:"v-0a7ef002",path:"/views/%E7%AE%80%E5%8D%95/0001-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C.html",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-0a7ef002").then(t)}},{path:"/views/简单/0001-两数之和.html",redirect:"/views/%E7%AE%80%E5%8D%95/0001-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C.html"},{name:"v-f20421d4",path:"/views/%E7%AE%80%E5%8D%95/0007-%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC.html",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-f20421d4").then(t)}},{path:"/views/简单/0007-整数反转.html",redirect:"/views/%E7%AE%80%E5%8D%95/0007-%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC.html"},{name:"v-1146fde9",path:"/views/%E7%AE%80%E5%8D%95/0009-%E5%9B%9E%E6%96%87%E6%95%B0.html",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-1146fde9").then(t)}},{path:"/views/简单/0009-回文数.html",redirect:"/views/%E7%AE%80%E5%8D%95/0009-%E5%9B%9E%E6%96%87%E6%95%B0.html"},{name:"v-d999d50a",path:"/views/%E7%AE%80%E5%8D%95/0014-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80.html",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-d999d50a").then(t)}},{path:"/views/简单/0014-最长公共前缀.html",redirect:"/views/%E7%AE%80%E5%8D%95/0014-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80.html"},{name:"v-72c7019a",path:"/views/%E7%AE%80%E5%8D%95/0013-%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%95%B4%E6%95%B0.html",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-72c7019a").then(t)}},{path:"/views/简单/0013-罗马数字转整数.html",redirect:"/views/%E7%AE%80%E5%8D%95/0013-%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%95%B4%E6%95%B0.html"},{name:"v-0aae0649",path:"/views/%E7%AE%80%E5%8D%95/0021-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8.html",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-0aae0649").then(t)}},{path:"/views/简单/0021-合并两个有序链表.html",redirect:"/views/%E7%AE%80%E5%8D%95/0021-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8.html"},{name:"v-78f01504",path:"/views/%E7%AE%80%E5%8D%95/0026-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9.html",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-78f01504").then(t)}},{path:"/views/简单/0026-删除排序数组中的重复项.html",redirect:"/views/%E7%AE%80%E5%8D%95/0026-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9.html"},{name:"v-7cecf4db",path:"/views/%E7%AE%80%E5%8D%95/0035-%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE.html",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-7cecf4db").then(t)}},{path:"/views/简单/0035-搜索插入位置.html",redirect:"/views/%E7%AE%80%E5%8D%95/0035-%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE.html"},{name:"v-dd4bf7e4",path:"/views/%E7%AE%80%E5%8D%95/0020-%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7.html",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-dd4bf7e4").then(t)}},{path:"/views/简单/0020-有效的括号.html",redirect:"/views/%E7%AE%80%E5%8D%95/0020-%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7.html"},{name:"v-3caa00fc",path:"/views/%E7%AE%80%E5%8D%95/0027-%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0.html",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-3caa00fc").then(t)}},{path:"/views/简单/0027-移除元素.html",redirect:"/views/%E7%AE%80%E5%8D%95/0027-%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0.html"},{name:"v-22fe62f0",path:"/views/%E7%AE%80%E5%8D%95/0028-%E5%AE%9E%E7%8E%B0%20strStr().html",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-22fe62f0").then(t)}},{path:"/views/简单/0028-实现 strStr().html",redirect:"/views/%E7%AE%80%E5%8D%95/0028-%E5%AE%9E%E7%8E%B0%20strStr().html"},{name:"v-964e1e2e",path:"/views/%E7%AE%80%E5%8D%95/0067-%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%B1%82%E5%92%8C.html",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-964e1e2e").then(t)}},{path:"/views/简单/0067-二进制求和.html",redirect:"/views/%E7%AE%80%E5%8D%95/0067-%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%B1%82%E5%92%8C.html"},{name:"v-eab508ce",path:"/views/%E7%AE%80%E5%8D%95/0058-%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E5%8D%95%E8%AF%8D%E7%9A%84%E9%95%BF%E5%BA%A6.html",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-eab508ce").then(t)}},{path:"/views/简单/0058-最后一个单词的长度.html",redirect:"/views/%E7%AE%80%E5%8D%95/0058-%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E5%8D%95%E8%AF%8D%E7%9A%84%E9%95%BF%E5%BA%A6.html"},{name:"v-86ef19d0",path:"/views/%E7%AE%80%E5%8D%95/0053-%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C.html",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-86ef19d0").then(t)}},{path:"/views/简单/0053-最大子序和.html",redirect:"/views/%E7%AE%80%E5%8D%95/0053-%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C.html"},{name:"v-08aa0349",path:"/views/%E7%AE%80%E5%8D%95/0066-%E5%8A%A0%E4%B8%80.html",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-08aa0349").then(t)}},{path:"/views/简单/0066-加一.html",redirect:"/views/%E7%AE%80%E5%8D%95/0066-%E5%8A%A0%E4%B8%80.html"},{name:"v-f3ca02fe",path:"/views/%E7%AE%80%E5%8D%95/0083-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0.html",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-f3ca02fe").then(t)}},{path:"/views/简单/0083-删除排序链表中的重复元素.html",redirect:"/views/%E7%AE%80%E5%8D%95/0083-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0.html"},{name:"v-31ede314",path:"/views/%E7%AE%80%E5%8D%95/0069-x%20%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9.html",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-31ede314").then(t)}},{path:"/views/简单/0069-x 的平方根.html",redirect:"/views/%E7%AE%80%E5%8D%95/0069-x%20%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9.html"},{name:"v-49990e49",path:"/views/%E7%AE%80%E5%8D%95/0070-%E7%88%AC%E6%A5%BC%E6%A2%AF.html",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-49990e49").then(t)}},{path:"/views/简单/0070-爬楼梯.html",redirect:"/views/%E7%AE%80%E5%8D%95/0070-%E7%88%AC%E6%A5%BC%E6%A2%AF.html"},{name:"v-0e59c80c",path:"/views/%E7%AE%80%E5%8D%95/0100-%E7%9B%B8%E5%90%8C%E7%9A%84%E6%A0%91.html",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-0e59c80c").then(t)}},{path:"/views/简单/0100-相同的树.html",redirect:"/views/%E7%AE%80%E5%8D%95/0100-%E7%9B%B8%E5%90%8C%E7%9A%84%E6%A0%91.html"},{name:"v-ccf835da",path:"/views/%E7%AE%80%E5%8D%95/0088-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84.html",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-ccf835da").then(t)}},{path:"/views/简单/0088-合并两个有序数组.html",redirect:"/views/%E7%AE%80%E5%8D%95/0088-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84.html"},{name:"v-cb8dcbd0",path:"/views/%E7%AE%80%E5%8D%95/0101-%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91.html",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-cb8dcbd0").then(t)}},{path:"/views/简单/0101-对称二叉树.html",redirect:"/views/%E7%AE%80%E5%8D%95/0101-%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91.html"},{name:"v-1f930831",path:"/views/%E7%AE%80%E5%8D%95/0107-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86%20II.html",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-1f930831").then(t)}},{path:"/views/简单/0107-二叉树的层次遍历 II.html",redirect:"/views/%E7%AE%80%E5%8D%95/0107-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86%20II.html"},{name:"v-8f131bfc",path:"/views/%E7%AE%80%E5%8D%95/0110-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91.html",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-8f131bfc").then(t)}},{path:"/views/简单/0110-平衡二叉树.html",redirect:"/views/%E7%AE%80%E5%8D%95/0110-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91.html"},{name:"v-9e31a4c2",path:"/views/%E7%AE%80%E5%8D%95/0104-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6.html",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-9e31a4c2").then(t)}},{path:"/views/简单/0104-二叉树的最大深度.html",redirect:"/views/%E7%AE%80%E5%8D%95/0104-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6.html"},{name:"v-41f9c21d",path:"/views/%E7%AE%80%E5%8D%95/0108-%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.html",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-41f9c21d").then(t)}},{path:"/views/简单/0108-将有序数组转换为二叉搜索树.html",redirect:"/views/%E7%AE%80%E5%8D%95/0108-%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.html"},{name:"v-7727e773",path:"/views/%E7%AE%80%E5%8D%95/0112-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C.html",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-7727e773").then(t)}},{path:"/views/简单/0112-路径总和.html",redirect:"/views/%E7%AE%80%E5%8D%95/0112-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C.html"},{name:"v-9c035a4c",path:"/views/%E7%AE%80%E5%8D%95/0118-%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92.html",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-9c035a4c").then(t)}},{path:"/views/简单/0118-杨辉三角.html",redirect:"/views/%E7%AE%80%E5%8D%95/0118-%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92.html"},{name:"v-c37cfd5c",path:"/views/%E7%AE%80%E5%8D%95/0111-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6.html",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-c37cfd5c").then(t)}},{path:"/views/简单/0111-二叉树的最小深度.html",redirect:"/views/%E7%AE%80%E5%8D%95/0111-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6.html"},{name:"v-3d43ded6",path:"/views/%E7%AE%80%E5%8D%95/0121-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA.html",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-3d43ded6").then(t)}},{path:"/views/简单/0121-买卖股票的最佳时机.html",redirect:"/views/%E7%AE%80%E5%8D%95/0121-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA.html"},{name:"v-a3978ed0",path:"/views/%E7%AE%80%E5%8D%95/0125-%E9%AA%8C%E8%AF%81%E5%9B%9E%E6%96%87%E4%B8%B2.html",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-a3978ed0").then(t)}},{path:"/views/简单/0125-验证回文串.html",redirect:"/views/%E7%AE%80%E5%8D%95/0125-%E9%AA%8C%E8%AF%81%E5%9B%9E%E6%96%87%E4%B8%B2.html"},{name:"v-0bb21a4d",path:"/views/%E7%AE%80%E5%8D%95/0119-%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92%20II.html",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-0bb21a4d").then(t)}},{path:"/views/简单/0119-杨辉三角 II.html",redirect:"/views/%E7%AE%80%E5%8D%95/0119-%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92%20II.html"},{name:"v-0cf96847",path:"/views/%E7%AE%80%E5%8D%95/0136-%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97.html",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-0cf96847").then(t)}},{path:"/views/简单/0136-只出现一次的数字.html",redirect:"/views/%E7%AE%80%E5%8D%95/0136-%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97.html"},{name:"v-1676ace0",path:"/views/%E7%AE%80%E5%8D%95/0167-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C%20II%20-%20%E8%BE%93%E5%85%A5%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84.html",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-1676ace0").then(t)}},{path:"/views/简单/0167-两数之和 II - 输入有序数组.html",redirect:"/views/%E7%AE%80%E5%8D%95/0167-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C%20II%20-%20%E8%BE%93%E5%85%A5%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84.html"},{name:"v-fa980d7a",path:"/views/%E7%AE%80%E5%8D%95/0168-Excel%E8%A1%A8%E5%88%97%E5%90%8D%E7%A7%B0.html",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-fa980d7a").then(t)}},{path:"/views/简单/0168-Excel表列名称.html",redirect:"/views/%E7%AE%80%E5%8D%95/0168-Excel%E8%A1%A8%E5%88%97%E5%90%8D%E7%A7%B0.html"},{name:"v-35262026",path:"/views/%E7%AE%80%E5%8D%95/0155-%E6%9C%80%E5%B0%8F%E6%A0%88.html",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-35262026").then(t)}},{path:"/views/简单/0155-最小栈.html",redirect:"/views/%E7%AE%80%E5%8D%95/0155-%E6%9C%80%E5%B0%8F%E6%A0%88.html"},{name:"v-17a4fc23",path:"/views/%E7%AE%80%E5%8D%95/0160-%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8.html",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-17a4fc23").then(t)}},{path:"/views/简单/0160-相交链表.html",redirect:"/views/%E7%AE%80%E5%8D%95/0160-%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8.html"},{name:"v-6f1770fa",path:"/views/%E7%AE%80%E5%8D%95/0169-%E5%A4%9A%E6%95%B0%E5%85%83%E7%B4%A0.html",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-6f1770fa").then(t)}},{path:"/views/简单/0169-多数元素.html",redirect:"/views/%E7%AE%80%E5%8D%95/0169-%E5%A4%9A%E6%95%B0%E5%85%83%E7%B4%A0.html"},{name:"v-58dab6f5",path:"/views/%E7%AE%80%E5%8D%95/0171-Excel%E8%A1%A8%E5%88%97%E5%BA%8F%E5%8F%B7.html",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-58dab6f5").then(t)}},{path:"/views/简单/0171-Excel表列序号.html",redirect:"/views/%E7%AE%80%E5%8D%95/0171-Excel%E8%A1%A8%E5%88%97%E5%BA%8F%E5%8F%B7.html"},{name:"v-896f1fde",path:"/views/%E7%AE%80%E5%8D%95/0141-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8.html",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-896f1fde").then(t)}},{path:"/views/简单/0141-环形链表.html",redirect:"/views/%E7%AE%80%E5%8D%95/0141-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8.html"},{name:"v-683b2412",path:"/views/%E7%AE%80%E5%8D%95/0189-%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84.html",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-683b2412").then(t)}},{path:"/views/简单/0189-旋转数组.html",redirect:"/views/%E7%AE%80%E5%8D%95/0189-%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84.html"},{name:"v-0d83ecdc",path:"/views/%E7%AE%80%E5%8D%95/0198-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D.html",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-0d83ecdc").then(t)}},{path:"/views/简单/0198-打家劫舍.html",redirect:"/views/%E7%AE%80%E5%8D%95/0198-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D.html"},{name:"v-a44527a2",path:"/views/%E7%AE%80%E5%8D%95/0202-%E5%BF%AB%E4%B9%90%E6%95%B0.html",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-a44527a2").then(t)}},{path:"/views/简单/0202-快乐数.html",redirect:"/views/%E7%AE%80%E5%8D%95/0202-%E5%BF%AB%E4%B9%90%E6%95%B0.html"},{name:"v-1b66e8d5",path:"/views/%E7%AE%80%E5%8D%95/0203-%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0.html",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-1b66e8d5").then(t)}},{path:"/views/简单/0203-移除链表元素.html",redirect:"/views/%E7%AE%80%E5%8D%95/0203-%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0.html"},{name:"v-1b5e2caa",path:"/views/%E7%AE%80%E5%8D%95/0204-%E8%AE%A1%E6%95%B0%E8%B4%A8%E6%95%B0.html",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-1b5e2caa").then(t)}},{path:"/views/简单/0204-计数质数.html",redirect:"/views/%E7%AE%80%E5%8D%95/0204-%E8%AE%A1%E6%95%B0%E8%B4%A8%E6%95%B0.html"},{name:"v-f3fd332e",path:"/views/%E7%AE%80%E5%8D%95/0206-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8.html",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-f3fd332e").then(t)}},{path:"/views/简单/0206-反转链表.html",redirect:"/views/%E7%AE%80%E5%8D%95/0206-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8.html"},{name:"v-c12cd844",path:"/views/%E7%AE%80%E5%8D%95/0205-%E5%90%8C%E6%9E%84%E5%AD%97%E7%AC%A6%E4%B8%B2.html",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-c12cd844").then(t)}},{path:"/views/简单/0205-同构字符串.html",redirect:"/views/%E7%AE%80%E5%8D%95/0205-%E5%90%8C%E6%9E%84%E5%AD%97%E7%AC%A6%E4%B8%B2.html"},{name:"v-695ff01c",path:"/views/%E7%AE%80%E5%8D%95/0172-%E9%98%B6%E4%B9%98%E5%90%8E%E7%9A%84%E9%9B%B6.html",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-695ff01c").then(t)}},{path:"/views/简单/0172-阶乘后的零.html",redirect:"/views/%E7%AE%80%E5%8D%95/0172-%E9%98%B6%E4%B9%98%E5%90%8E%E7%9A%84%E9%9B%B6.html"},{name:"v-386f1cf4",path:"/views/%E7%AE%80%E5%8D%95/0219-%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0%20II.html",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-386f1cf4").then(t)}},{path:"/views/简单/0219-存在重复元素 II.html",redirect:"/views/%E7%AE%80%E5%8D%95/0219-%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0%20II.html"},{name:"v-6a1a8aca",path:"/views/%E7%AE%80%E5%8D%95/0226-%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91.html",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-6a1a8aca").then(t)}},{path:"/views/简单/0226-翻转二叉树.html",redirect:"/views/%E7%AE%80%E5%8D%95/0226-%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91.html"},{name:"v-3febb966",path:"/views/%E7%AE%80%E5%8D%95/0217-%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0.html",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-3febb966").then(t)}},{path:"/views/简单/0217-存在重复元素.html",redirect:"/views/%E7%AE%80%E5%8D%95/0217-%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0.html"},{name:"v-eacea4c0",path:"/views/%E7%AE%80%E5%8D%95/0235-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88.html",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-eacea4c0").then(t)}},{path:"/views/简单/0235-二叉搜索树的最近公共祖先.html",redirect:"/views/%E7%AE%80%E5%8D%95/0235-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88.html"},{name:"v-0e89010e",path:"/views/%E7%AE%80%E5%8D%95/0242-%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D.html",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-0e89010e").then(t)}},{path:"/views/简单/0242-有效的字母异位词.html",redirect:"/views/%E7%AE%80%E5%8D%95/0242-%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D.html"},{name:"v-371682cc",path:"/views/%E7%AE%80%E5%8D%95/0237-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9.html",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-371682cc").then(t)}},{path:"/views/简单/0237-删除链表中的节点.html",redirect:"/views/%E7%AE%80%E5%8D%95/0237-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9.html"},{name:"v-812258f8",path:"/views/%E7%AE%80%E5%8D%95/0257-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84.html",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-812258f8").then(t)}},{path:"/views/简单/0257-二叉树的所有路径.html",redirect:"/views/%E7%AE%80%E5%8D%95/0257-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84.html"},{name:"v-35ed2a6a",path:"/views/%E7%AE%80%E5%8D%95/0268-%E7%BC%BA%E5%A4%B1%E6%95%B0%E5%AD%97.html",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-35ed2a6a").then(t)}},{path:"/views/简单/0268-缺失数字.html",redirect:"/views/%E7%AE%80%E5%8D%95/0268-%E7%BC%BA%E5%A4%B1%E6%95%B0%E5%AD%97.html"},{name:"v-b9ae42f8",path:"/views/%E7%AE%80%E5%8D%95/0278-%E7%AC%AC%E4%B8%80%E4%B8%AA%E9%94%99%E8%AF%AF%E7%9A%84%E7%89%88%E6%9C%AC.html",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-b9ae42f8").then(t)}},{path:"/views/简单/0278-第一个错误的版本.html",redirect:"/views/%E7%AE%80%E5%8D%95/0278-%E7%AC%AC%E4%B8%80%E4%B8%AA%E9%94%99%E8%AF%AF%E7%9A%84%E7%89%88%E6%9C%AC.html"},{name:"v-2f53649e",path:"/views/%E7%AE%80%E5%8D%95/0283-%E7%A7%BB%E5%8A%A8%E9%9B%B6.html",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-2f53649e").then(t)}},{path:"/views/简单/0283-移动零.html",redirect:"/views/%E7%AE%80%E5%8D%95/0283-%E7%A7%BB%E5%8A%A8%E9%9B%B6.html"},{name:"v-3f69c3c2",path:"/views/%E7%AE%80%E5%8D%95/0290-%E5%8D%95%E8%AF%8D%E8%A7%84%E5%BE%8B.html",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-3f69c3c2").then(t)}},{path:"/views/简单/0290-单词规律.html",redirect:"/views/%E7%AE%80%E5%8D%95/0290-%E5%8D%95%E8%AF%8D%E8%A7%84%E5%BE%8B.html"},{name:"v-b8b51226",path:"/views/%E7%AE%80%E5%8D%95/0303-%E5%8C%BA%E5%9F%9F%E5%92%8C%E6%A3%80%E7%B4%A2%20-%20%E6%95%B0%E7%BB%84%E4%B8%8D%E5%8F%AF%E5%8F%98.html",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-b8b51226").then(t)}},{path:"/views/简单/0303-区域和检索 - 数组不可变.html",redirect:"/views/%E7%AE%80%E5%8D%95/0303-%E5%8C%BA%E5%9F%9F%E5%92%8C%E6%A3%80%E7%B4%A2%20-%20%E6%95%B0%E7%BB%84%E4%B8%8D%E5%8F%AF%E5%8F%98.html"},{name:"v-72faf49f",path:"/views/%E7%AE%80%E5%8D%95/0344-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2.html",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-72faf49f").then(t)}},{path:"/views/简单/0344-反转字符串.html",redirect:"/views/%E7%AE%80%E5%8D%95/0344-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2.html"},{name:"v-f36f62ca",path:"/views/%E7%AE%80%E5%8D%95/0345-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%85%83%E9%9F%B3%E5%AD%97%E6%AF%8D.html",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-f36f62ca").then(t)}},{path:"/views/简单/0345-反转字符串中的元音字母.html",redirect:"/views/%E7%AE%80%E5%8D%95/0345-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%85%83%E9%9F%B3%E5%AD%97%E6%AF%8D.html"},{name:"v-24aef886",path:"/views/%E7%AE%80%E5%8D%95/0349-%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86.html",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-24aef886").then(t)}},{path:"/views/简单/0349-两个数组的交集.html",redirect:"/views/%E7%AE%80%E5%8D%95/0349-%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86.html"},{name:"v-33b19a42",path:"/views/%E7%AE%80%E5%8D%95/0350-%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86%20II.html",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-33b19a42").then(t)}},{path:"/views/简单/0350-两个数组的交集 II.html",redirect:"/views/%E7%AE%80%E5%8D%95/0350-%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86%20II.html"},{name:"v-57525a9a",path:"/views/%E7%AE%80%E5%8D%95/0387-%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%94%AF%E4%B8%80%E5%AD%97%E7%AC%A6.html",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-57525a9a").then(t)}},{path:"/views/简单/0387-字符串中的第一个唯一字符.html",redirect:"/views/%E7%AE%80%E5%8D%95/0387-%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%94%AF%E4%B8%80%E5%AD%97%E7%AC%A6.html"},{name:"v-861ad970",path:"/views/%E7%AE%80%E5%8D%95/0404-%E5%B7%A6%E5%8F%B6%E5%AD%90%E4%B9%8B%E5%92%8C.html",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-861ad970").then(t)}},{path:"/views/简单/0404-左叶子之和.html",redirect:"/views/%E7%AE%80%E5%8D%95/0404-%E5%B7%A6%E5%8F%B6%E5%AD%90%E4%B9%8B%E5%92%8C.html"},{name:"v-9549f80c",path:"/views/%E7%AE%80%E5%8D%95/0374-%E7%8C%9C%E6%95%B0%E5%AD%97%E5%A4%A7%E5%B0%8F.html",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-9549f80c").then(t)}},{path:"/views/简单/0374-猜数字大小.html",redirect:"/views/%E7%AE%80%E5%8D%95/0374-%E7%8C%9C%E6%95%B0%E5%AD%97%E5%A4%A7%E5%B0%8F.html"},{name:"v-c89f9d26",path:"/views/%E7%AE%80%E5%8D%95/0367-%E6%9C%89%E6%95%88%E7%9A%84%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0.html",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-c89f9d26").then(t)}},{path:"/views/简单/0367-有效的完全平方数.html",redirect:"/views/%E7%AE%80%E5%8D%95/0367-%E6%9C%89%E6%95%88%E7%9A%84%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0.html"},{name:"v-4a51aa00",path:"/views/%E7%AE%80%E5%8D%95/0434-%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%8D%95%E8%AF%8D%E6%95%B0.html",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-4a51aa00").then(t)}},{path:"/views/简单/0434-字符串中的单词数.html",redirect:"/views/%E7%AE%80%E5%8D%95/0434-%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%8D%95%E8%AF%8D%E6%95%B0.html"},{name:"v-0d795ffd",path:"/views/%E7%AE%80%E5%8D%95/0447-%E5%9B%9E%E6%97%8B%E9%95%96%E7%9A%84%E6%95%B0%E9%87%8F.html",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-0d795ffd").then(t)}},{path:"/views/简单/0447-回旋镖的数量.html",redirect:"/views/%E7%AE%80%E5%8D%95/0447-%E5%9B%9E%E6%97%8B%E9%95%96%E7%9A%84%E6%95%B0%E9%87%8F.html"},{name:"v-16b46357",path:"/views/%E7%AE%80%E5%8D%95/0455-%E5%88%86%E5%8F%91%E9%A5%BC%E5%B9%B2.html",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-16b46357").then(t)}},{path:"/views/简单/0455-分发饼干.html",redirect:"/views/%E7%AE%80%E5%8D%95/0455-%E5%88%86%E5%8F%91%E9%A5%BC%E5%B9%B2.html"},{name:"v-fa0e71a0",path:"/views/%E7%AE%80%E5%8D%95/0437-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C%20III.html",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-fa0e71a0").then(t)}},{path:"/views/简单/0437-路径总和 III.html",redirect:"/views/%E7%AE%80%E5%8D%95/0437-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C%20III.html"},{name:"v-487d573a",path:"/views/%E7%AE%80%E5%8D%95/0476-%E6%95%B0%E5%AD%97%E7%9A%84%E8%A1%A5%E6%95%B0.html",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-487d573a").then(t)}},{path:"/views/简单/0476-数字的补数.html",redirect:"/views/%E7%AE%80%E5%8D%95/0476-%E6%95%B0%E5%AD%97%E7%9A%84%E8%A1%A5%E6%95%B0.html"},{name:"v-55c55936",path:"/views/%E7%AE%80%E5%8D%95/0485-%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD1%E7%9A%84%E4%B8%AA%E6%95%B0.html",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-55c55936").then(t)}},{path:"/views/简单/0485-最大连续1的个数.html",redirect:"/views/%E7%AE%80%E5%8D%95/0485-%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD1%E7%9A%84%E4%B8%AA%E6%95%B0.html"},{name:"v-25479726",path:"/views/%E7%AE%80%E5%8D%95/0561-%E6%95%B0%E7%BB%84%E6%8B%86%E5%88%86%20I.html",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-25479726").then(t)}},{path:"/views/简单/0561-数组拆分 I.html",redirect:"/views/%E7%AE%80%E5%8D%95/0561-%E6%95%B0%E7%BB%84%E6%8B%86%E5%88%86%20I.html"},{name:"v-3529fb88",path:"/views/%E7%AE%80%E5%8D%95/0566-%E9%87%8D%E5%A1%91%E7%9F%A9%E9%98%B5.html",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-3529fb88").then(t)}},{path:"/views/简单/0566-重塑矩阵.html",redirect:"/views/%E7%AE%80%E5%8D%95/0566-%E9%87%8D%E5%A1%91%E7%9F%A9%E9%98%B5.html"},{name:"v-17bb9e2d",path:"/views/%E7%AE%80%E5%8D%95/0617-%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91.html",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-17bb9e2d").then(t)}},{path:"/views/简单/0617-合并二叉树.html",redirect:"/views/%E7%AE%80%E5%8D%95/0617-%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91.html"},{name:"v-9df561a4",path:"/views/%E7%AE%80%E5%8D%95/0633-%E5%B9%B3%E6%96%B9%E6%95%B0%E4%B9%8B%E5%92%8C.html",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-9df561a4").then(t)}},{path:"/views/简单/0633-平方数之和.html",redirect:"/views/%E7%AE%80%E5%8D%95/0633-%E5%B9%B3%E6%96%B9%E6%95%B0%E4%B9%8B%E5%92%8C.html"},{name:"v-54968448",path:"/views/%E7%AE%80%E5%8D%95/0643-%E5%AD%90%E6%95%B0%E7%BB%84%E6%9C%80%E5%A4%A7%E5%B9%B3%E5%9D%87%E6%95%B0%20I.html",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-54968448").then(t)}},{path:"/views/简单/0643-子数组最大平均数 I.html",redirect:"/views/%E7%AE%80%E5%8D%95/0643-%E5%AD%90%E6%95%B0%E7%BB%84%E6%9C%80%E5%A4%A7%E5%B9%B3%E5%9D%87%E6%95%B0%20I.html"},{name:"v-78bc8af7",path:"/views/%E7%AE%80%E5%8D%95/0448-%E6%89%BE%E5%88%B0%E6%89%80%E6%9C%89%E6%95%B0%E7%BB%84%E4%B8%AD%E6%B6%88%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97.html",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-78bc8af7").then(t)}},{path:"/views/简单/0448-找到所有数组中消失的数字.html",redirect:"/views/%E7%AE%80%E5%8D%95/0448-%E6%89%BE%E5%88%B0%E6%89%80%E6%9C%89%E6%95%B0%E7%BB%84%E4%B8%AD%E6%B6%88%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97.html"},{name:"v-6384368a",path:"/views/%E7%AE%80%E5%8D%95/0637-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%B9%B3%E5%9D%87%E5%80%BC.html",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-6384368a").then(t)}},{path:"/views/简单/0637-二叉树的层平均值.html",redirect:"/views/%E7%AE%80%E5%8D%95/0637-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%B9%B3%E5%9D%87%E5%80%BC.html"},{name:"v-21d82b43",path:"/views/%E7%AE%80%E5%8D%95/0724-%E5%AF%BB%E6%89%BE%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E5%BF%83%E7%B4%A2%E5%BC%95.html",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-21d82b43").then(t)}},{path:"/views/简单/0724-寻找数组的中心索引.html",redirect:"/views/%E7%AE%80%E5%8D%95/0724-%E5%AF%BB%E6%89%BE%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E5%BF%83%E7%B4%A2%E5%BC%95.html"},{name:"v-2fc6e32b",path:"/views/%E7%AE%80%E5%8D%95/0728-%E8%87%AA%E9%99%A4%E6%95%B0.html",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-2fc6e32b").then(t)}},{path:"/views/简单/0728-自除数.html",redirect:"/views/%E7%AE%80%E5%8D%95/0728-%E8%87%AA%E9%99%A4%E6%95%B0.html"},{name:"v-22e5cd39",path:"/views/%E7%AE%80%E5%8D%95/0704-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.html",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-22e5cd39").then(t)}},{path:"/views/简单/0704-二分查找.html",redirect:"/views/%E7%AE%80%E5%8D%95/0704-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.html"},{name:"v-4f4bf9f6",path:"/views/%E7%AE%80%E5%8D%95/0746-%E4%BD%BF%E7%94%A8%E6%9C%80%E5%B0%8F%E8%8A%B1%E8%B4%B9%E7%88%AC%E6%A5%BC%E6%A2%AF.html",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-4f4bf9f6").then(t)}},{path:"/views/简单/0746-使用最小花费爬楼梯.html",redirect:"/views/%E7%AE%80%E5%8D%95/0746-%E4%BD%BF%E7%94%A8%E6%9C%80%E5%B0%8F%E8%8A%B1%E8%B4%B9%E7%88%AC%E6%A5%BC%E6%A2%AF.html"},{name:"v-c9f395f0",path:"/views/%E7%AE%80%E5%8D%95/0496-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0%20I.html",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-c9f395f0").then(t)}},{path:"/views/简单/0496-下一个更大元素 I.html",redirect:"/views/%E7%AE%80%E5%8D%95/0496-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0%20I.html"},{name:"v-6a8c0a12",path:"/views/%E7%AE%80%E5%8D%95/0832-%E7%BF%BB%E8%BD%AC%E5%9B%BE%E5%83%8F.html",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-6a8c0a12").then(t)}},{path:"/views/简单/0832-翻转图像.html",redirect:"/views/%E7%AE%80%E5%8D%95/0832-%E7%BF%BB%E8%BD%AC%E5%9B%BE%E5%83%8F.html"},{name:"v-2d78303e",path:"/views/%E7%AE%80%E5%8D%95/0771-%E5%AE%9D%E7%9F%B3%E4%B8%8E%E7%9F%B3%E5%A4%B4.html",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-2d78303e").then(t)}},{path:"/views/简单/0771-宝石与石头.html",redirect:"/views/%E7%AE%80%E5%8D%95/0771-%E5%AE%9D%E7%9F%B3%E4%B8%8E%E7%9F%B3%E5%A4%B4.html"},{name:"v-e1b467a8",path:"/views/%E7%AE%80%E5%8D%95/0682-%E6%A3%92%E7%90%83%E6%AF%94%E8%B5%9B.html",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-e1b467a8").then(t)}},{path:"/views/简单/0682-棒球比赛.html",redirect:"/views/%E7%AE%80%E5%8D%95/0682-%E6%A3%92%E7%90%83%E6%AF%94%E8%B5%9B.html"},{name:"v-0b39ac5e",path:"/views/%E7%AE%80%E5%8D%95/0852-%E5%B1%B1%E8%84%89%E6%95%B0%E7%BB%84%E7%9A%84%E5%B3%B0%E9%A1%B6%E7%B4%A2%E5%BC%95.html",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-0b39ac5e").then(t)}},{path:"/views/简单/0852-山脉数组的峰顶索引.html",redirect:"/views/%E7%AE%80%E5%8D%95/0852-%E5%B1%B1%E8%84%89%E6%95%B0%E7%BB%84%E7%9A%84%E5%B3%B0%E9%A1%B6%E7%B4%A2%E5%BC%95.html"},{name:"v-536bbb82",path:"/views/%E7%AE%80%E5%8D%95/0929-%E7%8B%AC%E7%89%B9%E7%9A%84%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6%E5%9C%B0%E5%9D%80.html",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-536bbb82").then(t)}},{path:"/views/简单/0929-独特的电子邮件地址.html",redirect:"/views/%E7%AE%80%E5%8D%95/0929-%E7%8B%AC%E7%89%B9%E7%9A%84%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6%E5%9C%B0%E5%9D%80.html"},{name:"v-75e2436c",path:"/views/%E7%AE%80%E5%8D%95/0941-%E6%9C%89%E6%95%88%E7%9A%84%E5%B1%B1%E8%84%89%E6%95%B0%E7%BB%84.html",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-75e2436c").then(t)}},{path:"/views/简单/0941-有效的山脉数组.html",redirect:"/views/%E7%AE%80%E5%8D%95/0941-%E6%9C%89%E6%95%88%E7%9A%84%E5%B1%B1%E8%84%89%E6%95%B0%E7%BB%84.html"},{name:"v-6d5a9f28",path:"/views/%E7%AE%80%E5%8D%95/1051-%E9%AB%98%E5%BA%A6%E6%A3%80%E6%9F%A5%E5%99%A8.html",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-6d5a9f28").then(t)}},{path:"/views/简单/1051-高度检查器.html",redirect:"/views/%E7%AE%80%E5%8D%95/1051-%E9%AB%98%E5%BA%A6%E6%A3%80%E6%9F%A5%E5%99%A8.html"},{name:"v-638027b4",path:"/views/%E7%AE%80%E5%8D%95/0876-%E9%93%BE%E8%A1%A8%E7%9A%84%E4%B8%AD%E9%97%B4%E7%BB%93%E7%82%B9.html",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-638027b4").then(t)}},{path:"/views/简单/0876-链表的中间结点.html",redirect:"/views/%E7%AE%80%E5%8D%95/0876-%E9%93%BE%E8%A1%A8%E7%9A%84%E4%B8%AD%E9%97%B4%E7%BB%93%E7%82%B9.html"},{name:"v-d3e8a800",path:"/views/%E7%AE%80%E5%8D%95/1033-%E7%A7%BB%E5%8A%A8%E7%9F%B3%E5%AD%90%E7%9B%B4%E5%88%B0%E8%BF%9E%E7%BB%AD.html",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-d3e8a800").then(t)}},{path:"/views/简单/1033-移动石子直到连续.html",redirect:"/views/%E7%AE%80%E5%8D%95/1033-%E7%A7%BB%E5%8A%A8%E7%9F%B3%E5%AD%90%E7%9B%B4%E5%88%B0%E8%BF%9E%E7%BB%AD.html"},{name:"v-5bdc57ee",path:"/views/%E7%AE%80%E5%8D%95/0844-%E6%AF%94%E8%BE%83%E5%90%AB%E9%80%80%E6%A0%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2.html",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-5bdc57ee").then(t)}},{path:"/views/简单/0844-比较含退格的字符串.html",redirect:"/views/%E7%AE%80%E5%8D%95/0844-%E6%AF%94%E8%BE%83%E5%90%AB%E9%80%80%E6%A0%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2.html"},{name:"v-493516c6",path:"/views/%E7%AE%80%E5%8D%95/1266-%E8%AE%BF%E9%97%AE%E6%89%80%E6%9C%89%E7%82%B9%E7%9A%84%E6%9C%80%E5%B0%8F%E6%97%B6%E9%97%B4.html",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-493516c6").then(t)}},{path:"/views/简单/1266-访问所有点的最小时间.html",redirect:"/views/%E7%AE%80%E5%8D%95/1266-%E8%AE%BF%E9%97%AE%E6%89%80%E6%9C%89%E7%82%B9%E7%9A%84%E6%9C%80%E5%B0%8F%E6%97%B6%E9%97%B4.html"},{name:"v-2bbe7c80",path:"/views/%E7%AE%80%E5%8D%95/1252-%E5%A5%87%E6%95%B0%E5%80%BC%E5%8D%95%E5%85%83%E6%A0%BC%E7%9A%84%E6%95%B0%E7%9B%AE.html",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-2bbe7c80").then(t)}},{path:"/views/简单/1252-奇数值单元格的数目.html",redirect:"/views/%E7%AE%80%E5%8D%95/1252-%E5%A5%87%E6%95%B0%E5%80%BC%E5%8D%95%E5%85%83%E6%A0%BC%E7%9A%84%E6%95%B0%E7%9B%AE.html"},{name:"v-71aae79a",path:"/views/%E7%AE%80%E5%8D%95/1295-%E7%BB%9F%E8%AE%A1%E4%BD%8D%E6%95%B0%E4%B8%BA%E5%81%B6%E6%95%B0%E7%9A%84%E6%95%B0%E5%AD%97.html",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-71aae79a").then(t)}},{path:"/views/简单/1295-统计位数为偶数的数字.html",redirect:"/views/%E7%AE%80%E5%8D%95/1295-%E7%BB%9F%E8%AE%A1%E4%BD%8D%E6%95%B0%E4%B8%BA%E5%81%B6%E6%95%B0%E7%9A%84%E6%95%B0%E5%AD%97.html"},{name:"v-a8e7c0ea",path:"/views/%E7%AE%80%E5%8D%95/1304-%E5%92%8C%E4%B8%BA%E9%9B%B6%E7%9A%84N%E4%B8%AA%E5%94%AF%E4%B8%80%E6%95%B4%E6%95%B0.html",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-a8e7c0ea").then(t)}},{path:"/views/简单/1304-和为零的N个唯一整数.html",redirect:"/views/%E7%AE%80%E5%8D%95/1304-%E5%92%8C%E4%B8%BA%E9%9B%B6%E7%9A%84N%E4%B8%AA%E5%94%AF%E4%B8%80%E6%95%B4%E6%95%B0.html"},{name:"v-0aece9fa",path:"/views/%E7%AE%80%E5%8D%95/1299-%E5%B0%86%E6%AF%8F%E4%B8%AA%E5%85%83%E7%B4%A0%E6%9B%BF%E6%8D%A2%E4%B8%BA%E5%8F%B3%E4%BE%A7%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0.html",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-0aece9fa").then(t)}},{path:"/views/简单/1299-将每个元素替换为右侧最大元素.html",redirect:"/views/%E7%AE%80%E5%8D%95/1299-%E5%B0%86%E6%AF%8F%E4%B8%AA%E5%85%83%E7%B4%A0%E6%9B%BF%E6%8D%A2%E4%B8%BA%E5%8F%B3%E4%BE%A7%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0.html"},{name:"v-c077fb86",path:"/views/%E7%AE%80%E5%8D%95/1313-%E8%A7%A3%E5%8E%8B%E7%BC%A9%E7%BC%96%E7%A0%81%E5%88%97%E8%A1%A8.html",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-c077fb86").then(t)}},{path:"/views/简单/1313-解压缩编码列表.html",redirect:"/views/%E7%AE%80%E5%8D%95/1313-%E8%A7%A3%E5%8E%8B%E7%BC%A9%E7%BC%96%E7%A0%81%E5%88%97%E8%A1%A8.html"},{name:"v-3f33cfdc",path:"/views/%E7%AE%80%E5%8D%95/1365-%E6%9C%89%E5%A4%9A%E5%B0%91%E5%B0%8F%E4%BA%8E%E5%BD%93%E5%89%8D%E6%95%B0%E5%AD%97%E7%9A%84%E6%95%B0%E5%AD%97.html",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-3f33cfdc").then(t)}},{path:"/views/简单/1365-有多少小于当前数字的数字.html",redirect:"/views/%E7%AE%80%E5%8D%95/1365-%E6%9C%89%E5%A4%9A%E5%B0%91%E5%B0%8F%E4%BA%8E%E5%BD%93%E5%89%8D%E6%95%B0%E5%AD%97%E7%9A%84%E6%95%B0%E5%AD%97.html"},{name:"v-622c1825",path:"/views/%E7%AE%80%E5%8D%95/%E5%89%91%E6%8C%87%20Offer%2003-%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97.html",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-622c1825").then(t)}},{path:"/views/简单/剑指 Offer 03-数组中重复的数字.html",redirect:"/views/%E7%AE%80%E5%8D%95/%E5%89%91%E6%8C%87%20Offer%2003-%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97.html"},{name:"v-1bff81f9",path:"/views/%E7%AE%80%E5%8D%95/%E5%89%91%E6%8C%87%20Offer%2005-%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC.html",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-1bff81f9").then(t)}},{path:"/views/简单/剑指 Offer 05-替换空格.html",redirect:"/views/%E7%AE%80%E5%8D%95/%E5%89%91%E6%8C%87%20Offer%2005-%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC.html"},{name:"v-1f24f964",path:"/views/%E7%AE%80%E5%8D%95/%E5%89%91%E6%8C%87%20Offer%2006-%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8.html",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-1f24f964").then(t)}},{path:"/views/简单/剑指 Offer 06-从尾到头打印链表.html",redirect:"/views/%E7%AE%80%E5%8D%95/%E5%89%91%E6%8C%87%20Offer%2006-%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8.html"},{name:"v-0e65eec4",path:"/views/%E7%AE%80%E5%8D%95/%E5%89%91%E6%8C%87%20Offer%2009-%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97.html",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-0e65eec4").then(t)}},{path:"/views/简单/剑指 Offer 09-用两个栈实现队列.html",redirect:"/views/%E7%AE%80%E5%8D%95/%E5%89%91%E6%8C%87%20Offer%2009-%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97.html"},{name:"v-559cfd35",path:"/views/%E7%AE%80%E5%8D%95/%E5%89%91%E6%8C%87%20Offer%2010-%20I-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97.html",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-559cfd35").then(t)}},{path:"/views/简单/剑指 Offer 10- I-斐波那契数列.html",redirect:"/views/%E7%AE%80%E5%8D%95/%E5%89%91%E6%8C%87%20Offer%2010-%20I-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97.html"},{name:"v-64944eae",path:"/views/%E7%AE%80%E5%8D%95/%E5%89%91%E6%8C%87%20Offer%2010-%20II-%E9%9D%92%E8%9B%99%E8%B7%B3%E5%8F%B0%E9%98%B6%E9%97%AE%E9%A2%98.html",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-64944eae").then(t)}},{path:"/views/简单/剑指 Offer 10- II-青蛙跳台阶问题.html",redirect:"/views/%E7%AE%80%E5%8D%95/%E5%89%91%E6%8C%87%20Offer%2010-%20II-%E9%9D%92%E8%9B%99%E8%B7%B3%E5%8F%B0%E9%98%B6%E9%97%AE%E9%A2%98.html"},{name:"v-b1564aac",path:"/tag/",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Tags","v-b1564aac").then(t)},meta:{pid:"tags",id:"tags"}},{path:"/tag/index.html",redirect:"/tag/"},{name:"v-ef9325c4",path:"/categories/",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("FrontmatterKey","v-ef9325c4").then(t)},meta:{pid:"categories",id:"categories"}},{path:"/categories/index.html",redirect:"/categories/"},{name:"v-6319eb4e",path:"/timeline/",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("TimeLines","v-6319eb4e").then(t)},meta:{pid:"timeline",id:"timeline"}},{path:"/timeline/index.html",redirect:"/timeline/"},{name:"v-2ea6762e",path:"/tags/链表<Linked List>/",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Tag","v-2ea6762e").then(t)},meta:{pid:"tags",id:"链表<Linked List>"}},{path:"/tags/链表<Linked List>/index.html",redirect:"/tags/链表<Linked List>/"},{path:"/tags/%E9%93%BE%E8%A1%A8%3CLinked%20List%3E/",redirect:"/tags/链表<Linked List>/"},{name:"v-5b7e7d96",path:"/tags/数学<Math>/",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Tag","v-5b7e7d96").then(t)},meta:{pid:"tags",id:"数学<Math>"}},{path:"/tags/数学<Math>/index.html",redirect:"/tags/数学<Math>/"},{path:"/tags/%E6%95%B0%E5%AD%A6%3CMath%3E/",redirect:"/tags/数学<Math>/"},{name:"v-e9650e12",path:"/tags/哈希表<Hash Table>/",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Tag","v-e9650e12").then(t)},meta:{pid:"tags",id:"哈希表<Hash Table>"}},{path:"/tags/哈希表<Hash Table>/index.html",redirect:"/tags/哈希表<Hash Table>/"},{path:"/tags/%E5%93%88%E5%B8%8C%E8%A1%A8%3CHash%20Table%3E/",redirect:"/tags/哈希表<Hash Table>/"},{name:"v-27dacd33",path:"/tags/双指针<Two Pointers>/",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Tag","v-27dacd33").then(t)},meta:{pid:"tags",id:"双指针<Two Pointers>"}},{path:"/tags/双指针<Two Pointers>/index.html",redirect:"/tags/双指针<Two Pointers>/"},{path:"/tags/%E5%8F%8C%E6%8C%87%E9%92%88%3CTwo%20Pointers%3E/",redirect:"/tags/双指针<Two Pointers>/"},{name:"v-6b74076a",path:"/tags/字符串<String>/",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Tag","v-6b74076a").then(t)},meta:{pid:"tags",id:"字符串<String>"}},{path:"/tags/字符串<String>/index.html",redirect:"/tags/字符串<String>/"},{path:"/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%3CString%3E/",redirect:"/tags/字符串<String>/"},{name:"v-3ef1fb49",path:"/tags/Sliding Window/",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Tag","v-3ef1fb49").then(t)},meta:{pid:"tags",id:"Sliding Window"}},{path:"/tags/Sliding Window/index.html",redirect:"/tags/Sliding Window/"},{path:"/tags/Sliding%20Window/",redirect:"/tags/Sliding Window/"},{name:"v-67be4016",path:"/tags/回溯算法<Backtracking>/",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Tag","v-67be4016").then(t)},meta:{pid:"tags",id:"回溯算法<Backtracking>"}},{path:"/tags/回溯算法<Backtracking>/index.html",redirect:"/tags/回溯算法<Backtracking>/"},{path:"/tags/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%3CBacktracking%3E/",redirect:"/tags/回溯算法<Backtracking>/"},{name:"v-5279a3e8",path:"/tags/数组<Array>/",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Tag","v-5279a3e8").then(t)},meta:{pid:"tags",id:"数组<Array>"}},{path:"/tags/数组<Array>/index.html",redirect:"/tags/数组<Array>/"},{path:"/tags/%E6%95%B0%E7%BB%84%3CArray%3E/",redirect:"/tags/数组<Array>/"},{name:"v-40d1debc",path:"/tags/二分查找<Binary Search>/",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Tag","v-40d1debc").then(t)},meta:{pid:"tags",id:"二分查找<Binary Search>"}},{path:"/tags/二分查找<Binary Search>/index.html",redirect:"/tags/二分查找<Binary Search>/"},{path:"/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%3CBinary%20Search%3E/",redirect:"/tags/二分查找<Binary Search>/"},{name:"v-76883238",path:"/tags/递归<Recursion>/",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Tag","v-76883238").then(t)},meta:{pid:"tags",id:"递归<Recursion>"}},{path:"/tags/递归<Recursion>/index.html",redirect:"/tags/递归<Recursion>/"},{path:"/tags/%E9%80%92%E5%BD%92%3CRecursion%3E/",redirect:"/tags/递归<Recursion>/"},{name:"v-7d6a3d86",path:"/tags/动态规划<Dynamic Programming>/",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Tag","v-7d6a3d86").then(t)},meta:{pid:"tags",id:"动态规划<Dynamic Programming>"}},{path:"/tags/动态规划<Dynamic Programming>/index.html",redirect:"/tags/动态规划<Dynamic Programming>/"},{path:"/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%3CDynamic%20Programming%3E/",redirect:"/tags/动态规划<Dynamic Programming>/"},{name:"v-ab77a8b0",path:"/tags/排序<Sort>/",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Tag","v-ab77a8b0").then(t)},meta:{pid:"tags",id:"排序<Sort>"}},{path:"/tags/排序<Sort>/index.html",redirect:"/tags/排序<Sort>/"},{path:"/tags/%E6%8E%92%E5%BA%8F%3CSort%3E/",redirect:"/tags/排序<Sort>/"},{name:"v-356594fd",path:"/tags/位运算<Bit Manipulation>/",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Tag","v-356594fd").then(t)},meta:{pid:"tags",id:"位运算<Bit Manipulation>"}},{path:"/tags/位运算<Bit Manipulation>/index.html",redirect:"/tags/位运算<Bit Manipulation>/"},{path:"/tags/%E4%BD%8D%E8%BF%90%E7%AE%97%3CBit%20Manipulation%3E/",redirect:"/tags/位运算<Bit Manipulation>/"},{name:"v-dd24ce1e",path:"/tags/栈<Stack>/",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Tag","v-dd24ce1e").then(t)},meta:{pid:"tags",id:"栈<Stack>"}},{path:"/tags/栈<Stack>/index.html",redirect:"/tags/栈<Stack>/"},{path:"/tags/%E6%A0%88%3CStack%3E/",redirect:"/tags/栈<Stack>/"},{name:"v-28f11726",path:"/tags/树<Tree>/",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Tag","v-28f11726").then(t)},meta:{pid:"tags",id:"树<Tree>"}},{path:"/tags/树<Tree>/index.html",redirect:"/tags/树<Tree>/"},{path:"/tags/%E6%A0%91%3CTree%3E/",redirect:"/tags/树<Tree>/"},{name:"v-45a392fa",path:"/tags/深度优先搜索<Depth-first Search>/",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Tag","v-45a392fa").then(t)},meta:{pid:"tags",id:"深度优先搜索<Depth-first Search>"}},{path:"/tags/深度优先搜索<Depth-first Search>/index.html",redirect:"/tags/深度优先搜索<Depth-first Search>/"},{path:"/tags/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%3CDepth-first%20Search%3E/",redirect:"/tags/深度优先搜索<Depth-first Search>/"},{name:"v-6aeae2cc",path:"/tags/广度优先搜索<Breadth-first Search>/",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Tag","v-6aeae2cc").then(t)},meta:{pid:"tags",id:"广度优先搜索<Breadth-first Search>"}},{path:"/tags/广度优先搜索<Breadth-first Search>/index.html",redirect:"/tags/广度优先搜索<Breadth-first Search>/"},{path:"/tags/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%3CBreadth-first%20Search%3E/",redirect:"/tags/广度优先搜索<Breadth-first Search>/"},{name:"v-196d7d58",path:"/tags/并查集<Union Find>/",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Tag","v-196d7d58").then(t)},meta:{pid:"tags",id:"并查集<Union Find>"}},{path:"/tags/并查集<Union Find>/index.html",redirect:"/tags/并查集<Union Find>/"},{path:"/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86%3CUnion%20Find%3E/",redirect:"/tags/并查集<Union Find>/"},{name:"v-2f716bfd",path:"/tags/设计<Design>/",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Tag","v-2f716bfd").then(t)},meta:{pid:"tags",id:"设计<Design>"}},{path:"/tags/设计<Design>/index.html",redirect:"/tags/设计<Design>/"},{path:"/tags/%E8%AE%BE%E8%AE%A1%3CDesign%3E/",redirect:"/tags/设计<Design>/"},{name:"v-c1d120b2",path:"/tags/字典树<Trie>/",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Tag","v-c1d120b2").then(t)},meta:{pid:"tags",id:"字典树<Trie>"}},{path:"/tags/字典树<Trie>/index.html",redirect:"/tags/字典树<Trie>/"},{path:"/tags/%E5%AD%97%E5%85%B8%E6%A0%91%3CTrie%3E/",redirect:"/tags/字典树<Trie>/"},{name:"v-6b196c14",path:"/tags/堆<Heap>/",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Tag","v-6b196c14").then(t)},meta:{pid:"tags",id:"堆<Heap>"}},{path:"/tags/堆<Heap>/index.html",redirect:"/tags/堆<Heap>/"},{path:"/tags/%E5%A0%86%3CHeap%3E/",redirect:"/tags/堆<Heap>/"},{name:"v-56974274",path:"/tags/分治算法<Divide and Conquer>/",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Tag","v-56974274").then(t)},meta:{pid:"tags",id:"分治算法<Divide and Conquer>"}},{path:"/tags/分治算法<Divide and Conquer>/index.html",redirect:"/tags/分治算法<Divide and Conquer>/"},{path:"/tags/%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95%3CDivide%20and%20Conquer%3E/",redirect:"/tags/分治算法<Divide and Conquer>/"},{name:"v-34755e6a",path:"/tags/Ordered Map/",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Tag","v-34755e6a").then(t)},meta:{pid:"tags",id:"Ordered Map"}},{path:"/tags/Ordered Map/index.html",redirect:"/tags/Ordered Map/"},{path:"/tags/Ordered%20Map/",redirect:"/tags/Ordered Map/"},{name:"v-537ba684",path:"/tags/树状数组<Binary Indexed Tree>/",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Tag","v-537ba684").then(t)},meta:{pid:"tags",id:"树状数组<Binary Indexed Tree>"}},{path:"/tags/树状数组<Binary Indexed Tree>/index.html",redirect:"/tags/树状数组<Binary Indexed Tree>/"},{path:"/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%3CBinary%20Indexed%20Tree%3E/",redirect:"/tags/树状数组<Binary Indexed Tree>/"},{name:"v-2074af06",path:"/tags/线段树<Segment Tree>/",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Tag","v-2074af06").then(t)},meta:{pid:"tags",id:"线段树<Segment Tree>"}},{path:"/tags/线段树<Segment Tree>/index.html",redirect:"/tags/线段树<Segment Tree>/"},{path:"/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91%3CSegment%20Tree%3E/",redirect:"/tags/线段树<Segment Tree>/"},{name:"v-7b83e294",path:"/tags/贪心算法<Greedy>/",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Tag","v-7b83e294").then(t)},meta:{pid:"tags",id:"贪心算法<Greedy>"}},{path:"/tags/贪心算法<Greedy>/index.html",redirect:"/tags/贪心算法<Greedy>/"},{path:"/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%3CGreedy%3E/",redirect:"/tags/贪心算法<Greedy>/"},{name:"v-0914131e",path:"/tags/脑筋急转弯<Brainteaser>/",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Tag","v-0914131e").then(t)},meta:{pid:"tags",id:"脑筋急转弯<Brainteaser>"}},{path:"/tags/脑筋急转弯<Brainteaser>/index.html",redirect:"/tags/脑筋急转弯<Brainteaser>/"},{path:"/tags/%E8%84%91%E7%AD%8B%E6%80%A5%E8%BD%AC%E5%BC%AF%3CBrainteaser%3E/",redirect:"/tags/脑筋急转弯<Brainteaser>/"},{name:"v-24a5d056",path:"/tags/几何<Geometry>/",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Tag","v-24a5d056").then(t)},meta:{pid:"tags",id:"几何<Geometry>"}},{path:"/tags/几何<Geometry>/index.html",redirect:"/tags/几何<Geometry>/"},{path:"/tags/%E5%87%A0%E4%BD%95%3CGeometry%3E/",redirect:"/tags/几何<Geometry>/"},{name:"v-abbdcbc6",path:"/categories/中等/",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Category","v-abbdcbc6").then(t)},meta:{pid:"categories",id:"中等"}},{path:"/categories/中等/index.html",redirect:"/categories/中等/"},{path:"/categories/%E4%B8%AD%E7%AD%89/",redirect:"/categories/中等/"},{name:"v-66f980d2",path:"/categories/困难/",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Category","v-66f980d2").then(t)},meta:{pid:"categories",id:"困难"}},{path:"/categories/困难/index.html",redirect:"/categories/困难/"},{path:"/categories/%E5%9B%B0%E9%9A%BE/",redirect:"/categories/困难/"},{name:"v-17686912",path:"/categories/简单/",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Category","v-17686912").then(t)},meta:{pid:"categories",id:"简单"}},{path:"/categories/简单/index.html",redirect:"/categories/简单/"},{path:"/categories/%E7%AE%80%E5%8D%95/",redirect:"/categories/简单/"},{name:"v-003aa8b4",path:"/tags/链表<Linked List>/page/2/",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-003aa8b4").then(t)},meta:{pid:"tags",id:"链表<Linked List>"}},{path:"/tags/链表<Linked List>/page/2/index.html",redirect:"/tags/链表<Linked List>/page/2/"},{path:"/tags/%E9%93%BE%E8%A1%A8%3CLinked%20List%3E/page/2/",redirect:"/tags/链表<Linked List>/page/2/"},{name:"v-3a4c7ee8",path:"/tags/数学<Math>/page/2/",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-3a4c7ee8").then(t)},meta:{pid:"tags",id:"数学<Math>"}},{path:"/tags/数学<Math>/page/2/index.html",redirect:"/tags/数学<Math>/page/2/"},{path:"/tags/%E6%95%B0%E5%AD%A6%3CMath%3E/page/2/",redirect:"/tags/数学<Math>/page/2/"},{name:"v-2b77e8e6",path:"/tags/哈希表<Hash Table>/page/2/",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-2b77e8e6").then(t)},meta:{pid:"tags",id:"哈希表<Hash Table>"}},{path:"/tags/哈希表<Hash Table>/page/2/index.html",redirect:"/tags/哈希表<Hash Table>/page/2/"},{path:"/tags/%E5%93%88%E5%B8%8C%E8%A1%A8%3CHash%20Table%3E/page/2/",redirect:"/tags/哈希表<Hash Table>/page/2/"},{name:"v-2b77e905",path:"/tags/哈希表<Hash Table>/page/3/",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-2b77e905").then(t)},meta:{pid:"tags",id:"哈希表<Hash Table>"}},{path:"/tags/哈希表<Hash Table>/page/3/index.html",redirect:"/tags/哈希表<Hash Table>/page/3/"},{path:"/tags/%E5%93%88%E5%B8%8C%E8%A1%A8%3CHash%20Table%3E/page/3/",redirect:"/tags/哈希表<Hash Table>/page/3/"},{name:"v-01ca992a",path:"/tags/双指针<Two Pointers>/page/2/",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-01ca992a").then(t)},meta:{pid:"tags",id:"双指针<Two Pointers>"}},{path:"/tags/双指针<Two Pointers>/page/2/index.html",redirect:"/tags/双指针<Two Pointers>/page/2/"},{path:"/tags/%E5%8F%8C%E6%8C%87%E9%92%88%3CTwo%20Pointers%3E/page/2/",redirect:"/tags/双指针<Two Pointers>/page/2/"},{name:"v-01ca9949",path:"/tags/双指针<Two Pointers>/page/3/",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-01ca9949").then(t)},meta:{pid:"tags",id:"双指针<Two Pointers>"}},{path:"/tags/双指针<Two Pointers>/page/3/index.html",redirect:"/tags/双指针<Two Pointers>/page/3/"},{path:"/tags/%E5%8F%8C%E6%8C%87%E9%92%88%3CTwo%20Pointers%3E/page/3/",redirect:"/tags/双指针<Two Pointers>/page/3/"},{name:"v-154e81dc",path:"/tags/字符串<String>/page/2/",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-154e81dc").then(t)},meta:{pid:"tags",id:"字符串<String>"}},{path:"/tags/字符串<String>/page/2/index.html",redirect:"/tags/字符串<String>/page/2/"},{path:"/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%3CString%3E/page/2/",redirect:"/tags/字符串<String>/page/2/"},{name:"v-0f2db0e7",path:"/tags/回溯算法<Backtracking>/page/2/",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-0f2db0e7").then(t)},meta:{pid:"tags",id:"回溯算法<Backtracking>"}},{path:"/tags/回溯算法<Backtracking>/page/2/index.html",redirect:"/tags/回溯算法<Backtracking>/page/2/"},{path:"/tags/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%3CBacktracking%3E/page/2/",redirect:"/tags/回溯算法<Backtracking>/page/2/"},{name:"v-11b88656",path:"/tags/数组<Array>/page/2/",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-11b88656").then(t)},meta:{pid:"tags",id:"数组<Array>"}},{path:"/tags/数组<Array>/page/2/index.html",redirect:"/tags/数组<Array>/page/2/"},{path:"/tags/%E6%95%B0%E7%BB%84%3CArray%3E/page/2/",redirect:"/tags/数组<Array>/page/2/"},{name:"v-11b88618",path:"/tags/数组<Array>/page/3/",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-11b88618").then(t)},meta:{pid:"tags",id:"数组<Array>"}},{path:"/tags/数组<Array>/page/3/index.html",redirect:"/tags/数组<Array>/page/3/"},{path:"/tags/%E6%95%B0%E7%BB%84%3CArray%3E/page/3/",redirect:"/tags/数组<Array>/page/3/"},{name:"v-11b885da",path:"/tags/数组<Array>/page/4/",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-11b885da").then(t)},meta:{pid:"tags",id:"数组<Array>"}},{path:"/tags/数组<Array>/page/4/index.html",redirect:"/tags/数组<Array>/page/4/"},{path:"/tags/%E6%95%B0%E7%BB%84%3CArray%3E/page/4/",redirect:"/tags/数组<Array>/page/4/"},{name:"v-11b8859c",path:"/tags/数组<Array>/page/5/",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-11b8859c").then(t)},meta:{pid:"tags",id:"数组<Array>"}},{path:"/tags/数组<Array>/page/5/index.html",redirect:"/tags/数组<Array>/page/5/"},{path:"/tags/%E6%95%B0%E7%BB%84%3CArray%3E/page/5/",redirect:"/tags/数组<Array>/page/5/"},{name:"v-11b8855e",path:"/tags/数组<Array>/page/6/",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-11b8855e").then(t)},meta:{pid:"tags",id:"数组<Array>"}},{path:"/tags/数组<Array>/page/6/index.html",redirect:"/tags/数组<Array>/page/6/"},{path:"/tags/%E6%95%B0%E7%BB%84%3CArray%3E/page/6/",redirect:"/tags/数组<Array>/page/6/"},{name:"v-7f2128fe",path:"/tags/二分查找<Binary Search>/page/2/",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-7f2128fe").then(t)},meta:{pid:"tags",id:"二分查找<Binary Search>"}},{path:"/tags/二分查找<Binary Search>/page/2/index.html",redirect:"/tags/二分查找<Binary Search>/page/2/"},{path:"/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%3CBinary%20Search%3E/page/2/",redirect:"/tags/二分查找<Binary Search>/page/2/"},{name:"v-deb07440",path:"/tags/动态规划<Dynamic Programming>/page/2/",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-deb07440").then(t)},meta:{pid:"tags",id:"动态规划<Dynamic Programming>"}},{path:"/tags/动态规划<Dynamic Programming>/page/2/index.html",redirect:"/tags/动态规划<Dynamic Programming>/page/2/"},{path:"/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%3CDynamic%20Programming%3E/page/2/",redirect:"/tags/动态规划<Dynamic Programming>/page/2/"},{name:"v-90a688a8",path:"/tags/栈<Stack>/page/2/",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-90a688a8").then(t)},meta:{pid:"tags",id:"栈<Stack>"}},{path:"/tags/栈<Stack>/page/2/index.html",redirect:"/tags/栈<Stack>/page/2/"},{path:"/tags/%E6%A0%88%3CStack%3E/page/2/",redirect:"/tags/栈<Stack>/page/2/"},{name:"v-71e83cb0",path:"/tags/树<Tree>/page/2/",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-71e83cb0").then(t)},meta:{pid:"tags",id:"树<Tree>"}},{path:"/tags/树<Tree>/page/2/index.html",redirect:"/tags/树<Tree>/page/2/"},{path:"/tags/%E6%A0%91%3CTree%3E/page/2/",redirect:"/tags/树<Tree>/page/2/"},{name:"v-71e83ccf",path:"/tags/树<Tree>/page/3/",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-71e83ccf").then(t)},meta:{pid:"tags",id:"树<Tree>"}},{path:"/tags/树<Tree>/page/3/index.html",redirect:"/tags/树<Tree>/page/3/"},{path:"/tags/%E6%A0%91%3CTree%3E/page/3/",redirect:"/tags/树<Tree>/page/3/"},{name:"v-0add15da",path:"/tags/深度优先搜索<Depth-first Search>/page/2/",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-0add15da").then(t)},meta:{pid:"tags",id:"深度优先搜索<Depth-first Search>"}},{path:"/tags/深度优先搜索<Depth-first Search>/page/2/index.html",redirect:"/tags/深度优先搜索<Depth-first Search>/page/2/"},{path:"/tags/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%3CDepth-first%20Search%3E/page/2/",redirect:"/tags/深度优先搜索<Depth-first Search>/page/2/"},{name:"v-51e9d100",path:"/categories/中等/page/2/",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-51e9d100").then(t)},meta:{pid:"categories",id:"中等"}},{path:"/categories/中等/page/2/index.html",redirect:"/categories/中等/page/2/"},{path:"/categories/%E4%B8%AD%E7%AD%89/page/2/",redirect:"/categories/中等/page/2/"},{name:"v-51e9d11f",path:"/categories/中等/page/3/",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-51e9d11f").then(t)},meta:{pid:"categories",id:"中等"}},{path:"/categories/中等/page/3/index.html",redirect:"/categories/中等/page/3/"},{path:"/categories/%E4%B8%AD%E7%AD%89/page/3/",redirect:"/categories/中等/page/3/"},{name:"v-51e9d13e",path:"/categories/中等/page/4/",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-51e9d13e").then(t)},meta:{pid:"categories",id:"中等"}},{path:"/categories/中等/page/4/index.html",redirect:"/categories/中等/page/4/"},{path:"/categories/%E4%B8%AD%E7%AD%89/page/4/",redirect:"/categories/中等/page/4/"},{name:"v-51e9d15d",path:"/categories/中等/page/5/",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-51e9d15d").then(t)},meta:{pid:"categories",id:"中等"}},{path:"/categories/中等/page/5/index.html",redirect:"/categories/中等/page/5/"},{path:"/categories/%E4%B8%AD%E7%AD%89/page/5/",redirect:"/categories/中等/page/5/"},{name:"v-51e9d17c",path:"/categories/中等/page/6/",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-51e9d17c").then(t)},meta:{pid:"categories",id:"中等"}},{path:"/categories/中等/page/6/index.html",redirect:"/categories/中等/page/6/"},{path:"/categories/%E4%B8%AD%E7%AD%89/page/6/",redirect:"/categories/中等/page/6/"},{name:"v-51e9d19b",path:"/categories/中等/page/7/",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-51e9d19b").then(t)},meta:{pid:"categories",id:"中等"}},{path:"/categories/中等/page/7/index.html",redirect:"/categories/中等/page/7/"},{path:"/categories/%E4%B8%AD%E7%AD%89/page/7/",redirect:"/categories/中等/page/7/"},{name:"v-59afc666",path:"/categories/简单/page/2/",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-59afc666").then(t)},meta:{pid:"categories",id:"简单"}},{path:"/categories/简单/page/2/index.html",redirect:"/categories/简单/page/2/"},{path:"/categories/%E7%AE%80%E5%8D%95/page/2/",redirect:"/categories/简单/page/2/"},{name:"v-59afc685",path:"/categories/简单/page/3/",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-59afc685").then(t)},meta:{pid:"categories",id:"简单"}},{path:"/categories/简单/page/3/index.html",redirect:"/categories/简单/page/3/"},{path:"/categories/%E7%AE%80%E5%8D%95/page/3/",redirect:"/categories/简单/page/3/"},{name:"v-59afc6a4",path:"/categories/简单/page/4/",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-59afc6a4").then(t)},meta:{pid:"categories",id:"简单"}},{path:"/categories/简单/page/4/index.html",redirect:"/categories/简单/page/4/"},{path:"/categories/%E7%AE%80%E5%8D%95/page/4/",redirect:"/categories/简单/page/4/"},{name:"v-59afc6c3",path:"/categories/简单/page/5/",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-59afc6c3").then(t)},meta:{pid:"categories",id:"简单"}},{path:"/categories/简单/page/5/index.html",redirect:"/categories/简单/page/5/"},{path:"/categories/%E7%AE%80%E5%8D%95/page/5/",redirect:"/categories/简单/page/5/"},{name:"v-59afc6e2",path:"/categories/简单/page/6/",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-59afc6e2").then(t)},meta:{pid:"categories",id:"简单"}},{path:"/categories/简单/page/6/index.html",redirect:"/categories/简单/page/6/"},{path:"/categories/%E7%AE%80%E5%8D%95/page/6/",redirect:"/categories/简单/page/6/"},{name:"v-59afc701",path:"/categories/简单/page/7/",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-59afc701").then(t)},meta:{pid:"categories",id:"简单"}},{path:"/categories/简单/page/7/index.html",redirect:"/categories/简单/page/7/"},{path:"/categories/%E7%AE%80%E5%8D%95/page/7/",redirect:"/categories/简单/page/7/"},{name:"v-59afc720",path:"/categories/简单/page/8/",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-59afc720").then(t)},meta:{pid:"categories",id:"简单"}},{path:"/categories/简单/page/8/index.html",redirect:"/categories/简单/page/8/"},{path:"/categories/%E7%AE%80%E5%8D%95/page/8/",redirect:"/categories/简单/page/8/"},{name:"v-59afc73f",path:"/categories/简单/page/9/",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-59afc73f").then(t)},meta:{pid:"categories",id:"简单"}},{path:"/categories/简单/page/9/index.html",redirect:"/categories/简单/page/9/"},{path:"/categories/%E7%AE%80%E5%8D%95/page/9/",redirect:"/categories/简单/page/9/"},{name:"v-476dfa32",path:"/categories/简单/page/10/",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-476dfa32").then(t)},meta:{pid:"categories",id:"简单"}},{path:"/categories/简单/page/10/index.html",redirect:"/categories/简单/page/10/"},{path:"/categories/%E7%AE%80%E5%8D%95/page/10/",redirect:"/categories/简单/page/10/"},{name:"v-476df9f4",path:"/categories/简单/page/11/",component:me,beforeEnter:(n,e,t)=>{Object(Rn.a)("Layout","v-476df9f4").then(t)},meta:{pid:"categories",id:"简单"}},{path:"/categories/简单/page/11/index.html",redirect:"/categories/简单/page/11/"},{path:"/categories/%E7%AE%80%E5%8D%95/page/11/",redirect:"/categories/简单/page/11/"},{path:"*",component:me}],he={title:"LCViewer",description:"我的最新的LeetCode提交信息",base:"/",pages:[{title:"Home",frontmatter:{home:!0,bgImage:"images/background.jpg",faceImage:"images/head.png"},regularPath:"/",relativePath:"README.md",key:"v-50a4e6f6",path:"/",lastUpdated:"4/11/2021, 4:03:15 PM",headersStr:null,content:"",contentLowercase:""},{title:"2-两数相加(Add Two Numbers)",frontmatter:{title:"2-两数相加(Add Two Numbers)",date:"2018-04-19T00:00:00.000Z",categories:["中等"],tags:["链表<Linked List>","数学<Math>"]},regularPath:"/views/%E4%B8%AD%E7%AD%89/0002-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0.html",relativePath:"views/中等/0002-两数相加.md",key:"v-872b1f36",path:"/views/%E4%B8%AD%E7%AD%89/0002-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0.html",headers:[{level:2,title:"中文题目",slug:"中文题目",charIndex:2},{level:2,title:"通过代码",slug:"通过代码",charIndex:213},{level:2,title:"官方题解",slug:"官方题解",charIndex:2839},{level:2,title:"提交历史",slug:"提交历史",charIndex:5165},{level:2,title:"统计信息",slug:"统计信息",charIndex:5788},{level:2,title:"相似题目",slug:"相似题目",charIndex:5824}],lastUpdated:"4/11/2021, 1:15:21 PM",headersStr:"中文题目 通过代码 官方题解 提交历史 统计信息 相似题目",content:'# 中文题目\n给出两个非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照逆序的方式存储的，并且它们的每个节点只能存储一位数字。\n\n如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。\n\n您可以假设除了数字 0 之外，这两个数都不会以 0 开头。\n\n示例：\n\n输入：(2 -> 4 -> 3) + (5 -> 6 -> 4)\n输出：7 -> 0 -> 8\n原因：342 + 465 = 807\n\n\n# 通过代码\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\nimport java.util.LinkedList;\n\nclass Solution {\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\n          ListNode listNode=new ListNode(0);\n           ListNode head=listNode;\n           int temp=0;\n           while (l1!=null || l2!=null||temp!=0){\n               int sum=(l1!=null?l1.val:0)+(l2!=null?l2.val:0)+temp;\n               temp=sum/10;\n               listNode.next=new ListNode(sum%10);\n               listNode=listNode.next;\n               l1=(l1!=null?l1.next:l1);\n               l2=(l2!=null?l2.next:l2);\n           }\n           return head.next;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\nimport java.util.LinkedList;\n\nclass Solution {\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\n         ListNode listNode=new ListNode(0);\n            if (l1==null && l2==null){\n                return listNode;\n            }\n            LinkedList<Integer> a=new LinkedList<>();\n            LinkedList<Integer> b=new LinkedList<>();\n            while (l1!=null){\n                a.add(l1.val);\n                l1=l1.next;\n            }\n            while (l2!=null){\n                b.add(l2.val);\n                l2=l2.next;\n            }\n            int temp=0;\n            int total=0;\n            ListNode head=listNode;\n            LinkedList<Integer> c=new LinkedList<>();\n            while (a.size()!=0 && b.size()!=0){\n                total=a.peekFirst()+b.peekFirst()+temp;\n                c.add((total)%10);\n                temp=total/10;\n                a.removeFirst();\n                b.removeFirst();\n            }\n            while (a.size()!=0){\n                total=a.removeFirst()+temp;\n                c.add((total)%10);\n                temp=total/10;\n            }\n            while (b.size()!=0){\n                total=b.removeFirst()+temp;\n                c.add((total)%10);\n                temp=total/10;\n            }\n        if (temp!=0){\n                c.add(temp);\n            }\n            while (c.size()!=0){\n                listNode.next=new ListNode(c.removeFirst());\n                listNode=listNode.next;\n            }\n            return head.next;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n# 官方题解\n# 方法：初等数学\n思路\n\n我们使用变量来跟踪进位，并从包含最低有效位的表头开始模拟逐位相加的过程。\n\n{:align="center"}\n\n图1，对两数相加方法的可视化: 342+465=807342 + 465 = 807342+465=807，每个结点都包含一个数字，并且数字按位逆序存储。{:align="center"}\n\n算法\n\n就像你在纸上计算两个数字的和那样，我们首先从最低有效位也就是列表 l1l1l1 和 l2l2l2 的表头开始相加。由于每位数字都应当处于 0…90 \\ldots 90…9 的范围内，我们计算两个数字的和时可能会出现 “溢出”。例如，5+7=125 + 7 = 125+7=12。在这种情况下，我们会将当前位的数值设置为 222，并将进位 carry=1carry = 1carry=1 带入下一次迭代。进位 carrycarrycarry 必定是 000 或 111，这是因为两个数字相加（考虑到进位）可能出现的最大和为 9+9+1=199 + 9 + 1 = 199+9+1=19。\n\n伪代码如下：\n\n * 将当前结点初始化为返回列表的哑结点。\n * 将进位 carrycarrycarry 初始化为 000。\n * 将 ppp 和 qqq 分别初始化为列表 l1l1l1 和 l2l2l2 的头部。\n * 遍历列表 l1l1l1 和 l2l2l2 直至到达它们的尾端。 * 将 xxx 设为结点 ppp 的值。如果 ppp 已经到达 l1l1l1 的末尾，则将其值设置为 000。\n    * 将 yyy 设为结点 qqq 的值。如果 qqq 已经到达 l2l2l2 的末尾，则将其值设置为 000。\n    * 设定 sum=x+y+carrysum = x + y + carrysum=x+y+carry。\n    * 更新进位的值，carry=sum/10carry = sum / 10carry=sum/10。\n    * 创建一个数值为 (summod10)(sum \\bmod 10)(summod10) 的新结点，并将其设置为当前结点的下一个结点，然后将当前结点前进到下一个结点。\n    * 同时，将 ppp 和 qqq 前进到下一个结点。\n   \n   \n * 检查 carry=1carry = 1carry=1 是否成立，如果成立，则向返回列表追加一个含有数字 111 的新结点。\n * 返回哑结点的下一个结点。\n\n请注意，我们使用哑结点来简化代码。如果没有哑结点，则必须编写额外的条件语句来初始化表头的值。\n\n请特别注意以下情况：\n\n测试用例说明l1=[0,1]l1=[0,1]l1=[0,1]，l2=[0,1,2]l2=[0,1,2]l2=[0,1,2]当一个列表比另一个列表长时l1=[]l1=[]l1=[]，l2=[0,1]l2=[0,1]l2=[0,1]当一个列表为空时，即出现空列表l1=[9,9]l1=[9,9]l1=[9,9]，l2=[1]l2=[1]l2=[1]求和运算最后可能出现额外的进位，这一点很容易被遗忘{:align="center"}\n\npublic ListNode addTwoNumbers(ListNode l1, ListNode l2) {\n    ListNode dummyHead = new ListNode(0);\n    ListNode p = l1, q = l2, curr = dummyHead;\n    int carry = 0;\n    while (p != null || q != null) {\n        int x = (p != null) ? p.val : 0;\n        int y = (q != null) ? q.val : 0;\n        int sum = carry + x + y;\n        carry = sum / 10;\n        curr.next = new ListNode(sum % 10);\n        curr = curr.next;\n        if (p != null) p = p.next;\n        if (q != null) q = q.next;\n    }\n    if (carry > 0) {\n        curr.next = new ListNode(carry);\n    }\n    return dummyHead.next;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n复杂度分析\n\n * 时间复杂度：O(max⁡(m,n))O(\\max(m, n))O(max(m,n))，假设 mmm 和 nnn 分别表示 l1l1l1 和 l2l2l2 的长度，上面的算法最多重复 max⁡(m,n)\\max(m, n)max(m,n) 次。\n   \n   \n * 空间复杂度：O(max⁡(m,n))O(\\max(m, n))O(max(m,n))， 新列表的长度最多为 max⁡(m,n)+1\\max(m,n) + 1max(m,n)+1。\n   \n   \n\n拓展\n\n如果链表中的数字不是按逆序存储的呢？例如：\n\n(3→4→2)+(4→6→5)=8→0→7(3 \\to 4 \\to 2) + (4 \\to 6 \\to 5) = 8 \\to 0 \\to 7(3→4→2)+(4→6→5)=8→0→7\n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-04-19 10:11:07Accepted [https://leetcode-cn.com//submissions/detail/1463461/]51 ms5.75%N/Ajava2018-04-19 09:43:44Accepted [https://leetcode-cn.com//submissions/detail/1462190/]52 ms5.75%N/Ajava2018-04-19 09:40:38Wrong Answer [https://leetcode-cn.com//submissions/detail/1462040/]N/AN/AN/Ajava2018-04-18 23:50:18Wrong Answer [https://leetcode-cn.com//submissions/detail/1454800/]N/AN/AN/Ajava2018-04-18 23:49:01Wrong Answer [https://leetcode-cn.com//submissions/detail/1454751/]N/AN/AN/Ajava2018-04-18 23:48:28Wrong Answer [https://leetcode-cn.com//submissions/detail/1454728/]N/AN/AN/Ajava# 统计信息\n通过次数提交次数AC比率30393183519336.4%# 相似题目\n题目难度字符串相乘 [https://leetcode-cn.com/problems/multiply-strings/]中等二进制求和 [https://leetcode-cn.com/problems/add-binary/]简单两整数之和 [https://leetcode-cn.com/problems/sum-of-two-integers/]简单字符串相加 [https://leetcode-cn.com/problems/add-strings/]简单两数相加 II [https://leetcode-cn.com/problems/add-two-numbers-ii/]中等数组形式的整数加法 [https://leetcode-cn.com/problems/add-to-array-form-of-integer/]简单',contentLowercase:'# 中文题目\n给出两个非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照逆序的方式存储的，并且它们的每个节点只能存储一位数字。\n\n如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。\n\n您可以假设除了数字 0 之外，这两个数都不会以 0 开头。\n\n示例：\n\n输入：(2 -> 4 -> 3) + (5 -> 6 -> 4)\n输出：7 -> 0 -> 8\n原因：342 + 465 = 807\n\n\n# 通过代码\n/**\n * definition for singly-linked list.\n * public class listnode {\n *     int val;\n *     listnode next;\n *     listnode(int x) { val = x; }\n * }\n */\nimport java.util.linkedlist;\n\nclass solution {\n    public listnode addtwonumbers(listnode l1, listnode l2) {\n          listnode listnode=new listnode(0);\n           listnode head=listnode;\n           int temp=0;\n           while (l1!=null || l2!=null||temp!=0){\n               int sum=(l1!=null?l1.val:0)+(l2!=null?l2.val:0)+temp;\n               temp=sum/10;\n               listnode.next=new listnode(sum%10);\n               listnode=listnode.next;\n               l1=(l1!=null?l1.next:l1);\n               l2=(l2!=null?l2.next:l2);\n           }\n           return head.next;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n/**\n * definition for singly-linked list.\n * public class listnode {\n *     int val;\n *     listnode next;\n *     listnode(int x) { val = x; }\n * }\n */\nimport java.util.linkedlist;\n\nclass solution {\n    public listnode addtwonumbers(listnode l1, listnode l2) {\n         listnode listnode=new listnode(0);\n            if (l1==null && l2==null){\n                return listnode;\n            }\n            linkedlist<integer> a=new linkedlist<>();\n            linkedlist<integer> b=new linkedlist<>();\n            while (l1!=null){\n                a.add(l1.val);\n                l1=l1.next;\n            }\n            while (l2!=null){\n                b.add(l2.val);\n                l2=l2.next;\n            }\n            int temp=0;\n            int total=0;\n            listnode head=listnode;\n            linkedlist<integer> c=new linkedlist<>();\n            while (a.size()!=0 && b.size()!=0){\n                total=a.peekfirst()+b.peekfirst()+temp;\n                c.add((total)%10);\n                temp=total/10;\n                a.removefirst();\n                b.removefirst();\n            }\n            while (a.size()!=0){\n                total=a.removefirst()+temp;\n                c.add((total)%10);\n                temp=total/10;\n            }\n            while (b.size()!=0){\n                total=b.removefirst()+temp;\n                c.add((total)%10);\n                temp=total/10;\n            }\n        if (temp!=0){\n                c.add(temp);\n            }\n            while (c.size()!=0){\n                listnode.next=new listnode(c.removefirst());\n                listnode=listnode.next;\n            }\n            return head.next;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n# 官方题解\n# 方法：初等数学\n思路\n\n我们使用变量来跟踪进位，并从包含最低有效位的表头开始模拟逐位相加的过程。\n\n{:align="center"}\n\n图1，对两数相加方法的可视化: 342+465=807342 + 465 = 807342+465=807，每个结点都包含一个数字，并且数字按位逆序存储。{:align="center"}\n\n算法\n\n就像你在纸上计算两个数字的和那样，我们首先从最低有效位也就是列表 l1l1l1 和 l2l2l2 的表头开始相加。由于每位数字都应当处于 0…90 \\ldots 90…9 的范围内，我们计算两个数字的和时可能会出现 “溢出”。例如，5+7=125 + 7 = 125+7=12。在这种情况下，我们会将当前位的数值设置为 222，并将进位 carry=1carry = 1carry=1 带入下一次迭代。进位 carrycarrycarry 必定是 000 或 111，这是因为两个数字相加（考虑到进位）可能出现的最大和为 9+9+1=199 + 9 + 1 = 199+9+1=19。\n\n伪代码如下：\n\n * 将当前结点初始化为返回列表的哑结点。\n * 将进位 carrycarrycarry 初始化为 000。\n * 将 ppp 和 qqq 分别初始化为列表 l1l1l1 和 l2l2l2 的头部。\n * 遍历列表 l1l1l1 和 l2l2l2 直至到达它们的尾端。 * 将 xxx 设为结点 ppp 的值。如果 ppp 已经到达 l1l1l1 的末尾，则将其值设置为 000。\n    * 将 yyy 设为结点 qqq 的值。如果 qqq 已经到达 l2l2l2 的末尾，则将其值设置为 000。\n    * 设定 sum=x+y+carrysum = x + y + carrysum=x+y+carry。\n    * 更新进位的值，carry=sum/10carry = sum / 10carry=sum/10。\n    * 创建一个数值为 (summod10)(sum \\bmod 10)(summod10) 的新结点，并将其设置为当前结点的下一个结点，然后将当前结点前进到下一个结点。\n    * 同时，将 ppp 和 qqq 前进到下一个结点。\n   \n   \n * 检查 carry=1carry = 1carry=1 是否成立，如果成立，则向返回列表追加一个含有数字 111 的新结点。\n * 返回哑结点的下一个结点。\n\n请注意，我们使用哑结点来简化代码。如果没有哑结点，则必须编写额外的条件语句来初始化表头的值。\n\n请特别注意以下情况：\n\n测试用例说明l1=[0,1]l1=[0,1]l1=[0,1]，l2=[0,1,2]l2=[0,1,2]l2=[0,1,2]当一个列表比另一个列表长时l1=[]l1=[]l1=[]，l2=[0,1]l2=[0,1]l2=[0,1]当一个列表为空时，即出现空列表l1=[9,9]l1=[9,9]l1=[9,9]，l2=[1]l2=[1]l2=[1]求和运算最后可能出现额外的进位，这一点很容易被遗忘{:align="center"}\n\npublic listnode addtwonumbers(listnode l1, listnode l2) {\n    listnode dummyhead = new listnode(0);\n    listnode p = l1, q = l2, curr = dummyhead;\n    int carry = 0;\n    while (p != null || q != null) {\n        int x = (p != null) ? p.val : 0;\n        int y = (q != null) ? q.val : 0;\n        int sum = carry + x + y;\n        carry = sum / 10;\n        curr.next = new listnode(sum % 10);\n        curr = curr.next;\n        if (p != null) p = p.next;\n        if (q != null) q = q.next;\n    }\n    if (carry > 0) {\n        curr.next = new listnode(carry);\n    }\n    return dummyhead.next;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n复杂度分析\n\n * 时间复杂度：o(max⁡(m,n))o(\\max(m, n))o(max(m,n))，假设 mmm 和 nnn 分别表示 l1l1l1 和 l2l2l2 的长度，上面的算法最多重复 max⁡(m,n)\\max(m, n)max(m,n) 次。\n   \n   \n * 空间复杂度：o(max⁡(m,n))o(\\max(m, n))o(max(m,n))， 新列表的长度最多为 max⁡(m,n)+1\\max(m,n) + 1max(m,n)+1。\n   \n   \n\n拓展\n\n如果链表中的数字不是按逆序存储的呢？例如：\n\n(3→4→2)+(4→6→5)=8→0→7(3 \\to 4 \\to 2) + (4 \\to 6 \\to 5) = 8 \\to 0 \\to 7(3→4→2)+(4→6→5)=8→0→7\n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-04-19 10:11:07accepted [https://leetcode-cn.com//submissions/detail/1463461/]51 ms5.75%n/ajava2018-04-19 09:43:44accepted [https://leetcode-cn.com//submissions/detail/1462190/]52 ms5.75%n/ajava2018-04-19 09:40:38wrong answer [https://leetcode-cn.com//submissions/detail/1462040/]n/an/an/ajava2018-04-18 23:50:18wrong answer [https://leetcode-cn.com//submissions/detail/1454800/]n/an/an/ajava2018-04-18 23:49:01wrong answer [https://leetcode-cn.com//submissions/detail/1454751/]n/an/an/ajava2018-04-18 23:48:28wrong answer [https://leetcode-cn.com//submissions/detail/1454728/]n/an/an/ajava# 统计信息\n通过次数提交次数ac比率30393183519336.4%# 相似题目\n题目难度字符串相乘 [https://leetcode-cn.com/problems/multiply-strings/]中等二进制求和 [https://leetcode-cn.com/problems/add-binary/]简单两整数之和 [https://leetcode-cn.com/problems/sum-of-two-integers/]简单字符串相加 [https://leetcode-cn.com/problems/add-strings/]简单两数相加 ii [https://leetcode-cn.com/problems/add-two-numbers-ii/]中等数组形式的整数加法 [https://leetcode-cn.com/problems/add-to-array-form-of-integer/]简单'},{title:"3-无重复字符的最长子串(Longest Substring Without Repeating Characters)",frontmatter:{title:"3-无重复字符的最长子串(Longest Substring Without Repeating Characters)",date:"2018-05-22T00:00:00.000Z",categories:["中等"],tags:["哈希表<Hash Table>","双指针<Two Pointers>","字符串<String>","Sliding Window"]},regularPath:"/views/%E4%B8%AD%E7%AD%89/0003-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2.html",relativePath:"views/中等/0003-无重复字符的最长子串.md",key:"v-51a0a422",path:"/views/%E4%B8%AD%E7%AD%89/0003-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2.html",headers:[{level:2,title:"中文题目",slug:"中文题目",charIndex:2},{level:2,title:"通过代码",slug:"通过代码",charIndex:271},{level:2,title:"官方题解",slug:"官方题解",charIndex:1706},{level:2,title:"提交历史",slug:"提交历史",charIndex:6876},{level:2,title:"统计信息",slug:"统计信息",charIndex:7303},{level:2,title:"相似题目",slug:"相似题目",charIndex:7339}],lastUpdated:"4/11/2021, 1:15:21 PM",headersStr:"中文题目 通过代码 官方题解 提交历史 统计信息 相似题目",content:'# 中文题目\n给定一个字符串，请你找出其中不含有重复字符的最长子串的长度。\n\n示例 1:\n\n输入: "abcabcbb"\n输出: 3 \n解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。\n\n\n示例 2:\n\n输入: "bbbbb"\n输出: 1\n解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。\n\n\n示例 3:\n\n输入: "pwwkew"\n输出: 3\n解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。\n     请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。\n\n\n# 通过代码\nclass Solution {\n    public int lengthOfLongestSubstring(String s) {\n         if (s.length() == 0) {\n                return 0;\n            }\n            int max = 0;\n            HashMap<Character, Integer> map = new HashMap<>();\n//            hi为右指针，lo为左指针，扫描字符串\n            for (int hi = 0, lo = 0; hi < s.length(); hi++) {\n//                检测当前子串的右边的字符是或否在map中已经存在，如果存在的话，将左指针指向当前找到的相同字符的右侧\n                if (map.containsKey(s.charAt(hi))) {\n                  lo = Math.max(lo, map.get(s.charAt(hi)) + 1);\n                }\n                map.put(s.charAt(hi), hi);\n                max = Math.max(max, hi - lo + 1);\n            }\n            return max;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\nclass Solution {\n    public int lengthOfLongestSubstring(String s) {\n         if (s.length() == 0) {\n                return 0;\n            }\n            int max = 0;\n            HashMap<Character, Integer> map = new HashMap<>();\n//            hi为右指针，lo为左指针，扫描字符串\n            for (int hi = 0, lo = 0; hi < s.length(); hi++) {\n//                检测当前子串的右边的字符是或否在map中已经存在，如果存在的话，将左指针指向当前找到的相同字符的右侧\n                if (map.containsKey(s.charAt(hi))) {\n                  lo = Math.max(lo, map.get(s.charAt(hi)) + 1);\n                }\n                map.put(s.charAt(hi), hi);\n                max = Math.max(max, hi - lo + 1);\n            }\n            return max;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n# 官方题解\n# 方法一：暴力法\n题目更新后由于时间限制，会出现 TLE。\n\n思路\n\n逐个检查所有的子字符串，看它是否不含有重复的字符。\n\n算法\n\n假设我们有一个函数 boolean allUnique(String substring) ，如果子字符串中的字符都是唯一的，它会返回 true，否则会返回 false。 我们可以遍历给定字符串 s 的所有可能的子字符串并调用函数 allUnique。 如果事实证明返回值为 true，那么我们将会更新无重复字符子串的最大长度的答案。\n\n现在让我们填补缺少的部分：\n\n 1. 为了枚举给定字符串的所有子字符串，我们需要枚举它们开始和结束的索引。假设开始和结束的索引分别为 iii 和 jjj。那么我们有 0≤i<j≤n0 \\leq i \\lt j \\leq n0≤i<j≤n（这里的结束索引 jjj 是按惯例排除的）。因此，使用 iii 从 0 到 n−1n - 1n−1 以及 jjj 从 i+1i+1i+1 到 nnn 这两个嵌套的循环，我们可以枚举出 s 的所有子字符串。\n    \n    \n 2. 要检查一个字符串是否有重复字符，我们可以使用集合。我们遍历字符串中的所有字符，并将它们逐个放入 set 中。在放置一个字符之前，我们检查该集合是否已经包含它。如果包含，我们会返回 false。循环结束后，我们返回 true。\n    \n    \n\npublic class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        int n = s.length();\n        int ans = 0;\n        for (int i = 0; i < n; i++)\n            for (int j = i + 1; j <= n; j++)\n                if (allUnique(s, i, j)) ans = Math.max(ans, j - i);\n        return ans;\n    }\n\n    public boolean allUnique(String s, int start, int end) {\n        Set<Character> set = new HashSet<>();\n        for (int i = start; i < end; i++) {\n            Character ch = s.charAt(i);\n            if (set.contains(ch)) return false;\n            set.add(ch);\n        }\n        return true;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n复杂度分析\n\n * 时间复杂度：O(n3)O(n^3)O(n3) 。\n   \n   要验证索引范围在 [i,j)[i, j)[i,j) 内的字符是否都是唯一的，我们需要检查该范围中的所有字符。 因此，它将花费 O(j−i)O(j - i)O(j−i) 的时间。\n   \n   对于给定的 i，对于所有 j∈[i+1,n]j \\in [i+1, n]j∈[i+1,n] 所耗费的时间总和为：\n   \n   ∑i+1nO(j−i)\\sum_{i+1}^{n}O(j - i)i+1∑n​O(j−i)\n   \n   因此，执行所有步骤耗去的时间总和为：\n   \n   O(∑i=0n−1(∑j=i+1n(j−i)))=O(∑i=0n−1(1+n−i)(n−i)2)=O(n3)O\\left(\\sum_{i = 0}^{n - 1}\\left(\\sum_{j = i + 1}^{n}(j - i)\\right)\\right) = O\\left(\\sum_{i = 0}^{n - 1}\\frac{(1 + n - i)(n - i)}{2}\\right) = O(n^3)O(i=0∑n−1​(j=i+1∑n​(j−i)))=O(i=0∑n−1​2(1+n−i)(n−i)​)=O(n3)\n   \n   \n * 空间复杂度：O(min(n,m))O(min(n, m))O(min(n,m))，我们需要 O(k)O(k)O(k) 的空间来检查子字符串中是否有重复字符，其中 kkk 表示 Set 的大小。而 Set 的大小取决于字符串 nnn 的大小以及字符集/字母 mmm 的大小。\n   \n   \n\n\n\n\n# 方法二：滑动窗口\n算法\n\n暴力法非常简单，但它太慢了。那么我们该如何优化它呢？\n\n在暴力法中，我们会反复检查一个子字符串是否含有有重复的字符，但这是没有必要的。如果从索引 iii 到 j−1j - 1j−1 之间的子字符串 sijs_{ij}sij​ 已经被检查为没有重复字符。我们只需要检查 s[j]s[j]s[j] 对应的字符是否已经存在于子字符串 sijs_{ij}sij​ 中。\n\n要检查一个字符是否已经在子字符串中，我们可以检查整个子字符串，这将产生一个复杂度为 O(n2)O(n^2)O(n2) 的算法，但我们可以做得更好。\n\n通过使用 HashSet 作为滑动窗口，我们可以用 O(1)O(1)O(1) 的时间来完成对字符是否在当前的子字符串中的检查。\n\n滑动窗口是数组/字符串问题中常用的抽象概念。 窗口通常是在数组/字符串中由开始和结束索引定义的一系列元素的集合，即 [i,j)[i, j)[i,j)（左闭，右开）。而滑动窗口是可以将两个边界向某一方向“滑动”的窗口。例如，我们将 [i,j)[i, j)[i,j) 向右滑动 111 个元素，则它将变为 [i+1,j+1)[i+1, j+1)[i+1,j+1)（左闭，右开）。\n\n回到我们的问题，我们使用 HashSet 将字符存储在当前窗口 [i,j)[i, j)[i,j)（最初 j=ij = ij=i）中。 然后我们向右侧滑动索引 jjj，如果它不在 HashSet 中，我们会继续滑动 jjj。直到 s[j] 已经存在于 HashSet 中。此时，我们找到的没有重复字符的最长子字符串将会以索引 iii 开头。如果我们对所有的 iii 这样做，就可以得到答案。\n\npublic class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        int n = s.length();\n        Set<Character> set = new HashSet<>();\n        int ans = 0, i = 0, j = 0;\n        while (i < n && j < n) {\n            // try to extend the range [i, j]\n            if (!set.contains(s.charAt(j))){\n                set.add(s.charAt(j++));\n                ans = Math.max(ans, j - i);\n            }\n            else {\n                set.remove(s.charAt(i++));\n            }\n        }\n        return ans;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n复杂度分析\n\n * 时间复杂度：O(2n)=O(n)O(2n) = O(n)O(2n)=O(n)，在最糟糕的情况下，每个字符将被 iii 和 jjj 访问两次。\n   \n   \n * 空间复杂度：O(min(m,n))O(min(m, n))O(min(m,n))，与之前的方法相同。滑动窗口法需要 O(k)O(k)O(k) 的空间，其中 kkk 表示 Set 的大小。而 Set 的大小取决于字符串 nnn 的大小以及字符集 / 字母 mmm 的大小。\n   \n   \n\n\n\n\n# 方法三：优化的滑动窗口\n上述的方法最多需要执行 2n 个步骤。事实上，它可以被进一步优化为仅需要 n 个步骤。我们可以定义字符到索引的映射，而不是使用集合来判断一个字符是否存在。 当我们找到重复的字符时，我们可以立即跳过该窗口。\n\n也就是说，如果 s[j]s[j]s[j] 在 [i,j)[i, j)[i,j) 范围内有与 j′j\'j′ 重复的字符，我们不需要逐渐增加 iii 。 我们可以直接跳过 [i，j′][i，j\'][i，j′] 范围内的所有元素，并将 iii 变为 j′+1j\' + 1j′+1。\n\nJava（使用 HashMap）\n\npublic class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        int n = s.length(), ans = 0;\n        Map<Character, Integer> map = new HashMap<>(); // current index of character\n        // try to extend the range [i, j]\n        for (int j = 0, i = 0; j < n; j++) {\n            if (map.containsKey(s.charAt(j))) {\n                i = Math.max(map.get(s.charAt(j)), i);\n            }\n            ans = Math.max(ans, j - i + 1);\n            map.put(s.charAt(j), j + 1);\n        }\n        return ans;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\nJava（假设字符集为 ASCII 128）\n\n以前的我们都没有对字符串 s 所使用的字符集进行假设。\n\n当我们知道该字符集比较小的时侯，我们可以用一个整数数组作为直接访问表来替换 Map。\n\n常用的表如下所示：\n\n * int [26] 用于字母 ‘a’ - ‘z’ 或 ‘A’ - ‘Z’\n * int [128] 用于ASCII码\n * int [256] 用于扩展ASCII码\n\npublic class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        int n = s.length(), ans = 0;\n        int[] index = new int[128]; // current index of character\n        // try to extend the range [i, j]\n        for (int j = 0, i = 0; j < n; j++) {\n            i = Math.max(index[s.charAt(j)], i);\n            ans = Math.max(ans, j - i + 1);\n            index[s.charAt(j)] = j + 1;\n        }\n        return ans;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n复杂度分析\n\n * 时间复杂度：O(n)O(n)O(n)，索引 jjj 将会迭代 nnn 次。\n   \n   \n * 空间复杂度（HashMap）：O(min(m,n))O(min(m, n))O(min(m,n))，与之前的方法相同。\n   \n   \n * 空间复杂度（Table）：O(m)O(m)O(m)，mmm 是字符集的大小。\n   \n   \n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-05-22 23:49:22Accepted [https://leetcode-cn.com//submissions/detail/2514809/]50 ms22.71%N/Ajava2018-05-22 23:47:27Accepted [https://leetcode-cn.com//submissions/detail/2514733/]60 ms20.63%N/Ajava2018-05-22 23:42:07Wrong Answer [https://leetcode-cn.com//submissions/detail/2514508/]N/AN/AN/Ajava2018-05-22 23:26:40Wrong Answer [https://leetcode-cn.com//submissions/detail/2513752/]N/AN/AN/Ajava# 统计信息\n通过次数提交次数AC比率32481799785132.6%# 相似题目\n题目难度至多包含两个不同字符的最长子串 [https://leetcode-cn.com/problems/longest-substring-with-at-most-two-distinct-characters/]中等至多包含 K 个不同字符的最长子串 [https://leetcode-cn.com/problems/longest-substring-with-at-most-k-distinct-characters/]困难K 个不同整数的子数组 [https://leetcode-cn.com/problems/subarrays-with-k-different-integers/]困难',contentLowercase:'# 中文题目\n给定一个字符串，请你找出其中不含有重复字符的最长子串的长度。\n\n示例 1:\n\n输入: "abcabcbb"\n输出: 3 \n解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。\n\n\n示例 2:\n\n输入: "bbbbb"\n输出: 1\n解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。\n\n\n示例 3:\n\n输入: "pwwkew"\n输出: 3\n解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。\n     请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。\n\n\n# 通过代码\nclass solution {\n    public int lengthoflongestsubstring(string s) {\n         if (s.length() == 0) {\n                return 0;\n            }\n            int max = 0;\n            hashmap<character, integer> map = new hashmap<>();\n//            hi为右指针，lo为左指针，扫描字符串\n            for (int hi = 0, lo = 0; hi < s.length(); hi++) {\n//                检测当前子串的右边的字符是或否在map中已经存在，如果存在的话，将左指针指向当前找到的相同字符的右侧\n                if (map.containskey(s.charat(hi))) {\n                  lo = math.max(lo, map.get(s.charat(hi)) + 1);\n                }\n                map.put(s.charat(hi), hi);\n                max = math.max(max, hi - lo + 1);\n            }\n            return max;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\nclass solution {\n    public int lengthoflongestsubstring(string s) {\n         if (s.length() == 0) {\n                return 0;\n            }\n            int max = 0;\n            hashmap<character, integer> map = new hashmap<>();\n//            hi为右指针，lo为左指针，扫描字符串\n            for (int hi = 0, lo = 0; hi < s.length(); hi++) {\n//                检测当前子串的右边的字符是或否在map中已经存在，如果存在的话，将左指针指向当前找到的相同字符的右侧\n                if (map.containskey(s.charat(hi))) {\n                  lo = math.max(lo, map.get(s.charat(hi)) + 1);\n                }\n                map.put(s.charat(hi), hi);\n                max = math.max(max, hi - lo + 1);\n            }\n            return max;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n# 官方题解\n# 方法一：暴力法\n题目更新后由于时间限制，会出现 tle。\n\n思路\n\n逐个检查所有的子字符串，看它是否不含有重复的字符。\n\n算法\n\n假设我们有一个函数 boolean allunique(string substring) ，如果子字符串中的字符都是唯一的，它会返回 true，否则会返回 false。 我们可以遍历给定字符串 s 的所有可能的子字符串并调用函数 allunique。 如果事实证明返回值为 true，那么我们将会更新无重复字符子串的最大长度的答案。\n\n现在让我们填补缺少的部分：\n\n 1. 为了枚举给定字符串的所有子字符串，我们需要枚举它们开始和结束的索引。假设开始和结束的索引分别为 iii 和 jjj。那么我们有 0≤i<j≤n0 \\leq i \\lt j \\leq n0≤i<j≤n（这里的结束索引 jjj 是按惯例排除的）。因此，使用 iii 从 0 到 n−1n - 1n−1 以及 jjj 从 i+1i+1i+1 到 nnn 这两个嵌套的循环，我们可以枚举出 s 的所有子字符串。\n    \n    \n 2. 要检查一个字符串是否有重复字符，我们可以使用集合。我们遍历字符串中的所有字符，并将它们逐个放入 set 中。在放置一个字符之前，我们检查该集合是否已经包含它。如果包含，我们会返回 false。循环结束后，我们返回 true。\n    \n    \n\npublic class solution {\n    public int lengthoflongestsubstring(string s) {\n        int n = s.length();\n        int ans = 0;\n        for (int i = 0; i < n; i++)\n            for (int j = i + 1; j <= n; j++)\n                if (allunique(s, i, j)) ans = math.max(ans, j - i);\n        return ans;\n    }\n\n    public boolean allunique(string s, int start, int end) {\n        set<character> set = new hashset<>();\n        for (int i = start; i < end; i++) {\n            character ch = s.charat(i);\n            if (set.contains(ch)) return false;\n            set.add(ch);\n        }\n        return true;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n复杂度分析\n\n * 时间复杂度：o(n3)o(n^3)o(n3) 。\n   \n   要验证索引范围在 [i,j)[i, j)[i,j) 内的字符是否都是唯一的，我们需要检查该范围中的所有字符。 因此，它将花费 o(j−i)o(j - i)o(j−i) 的时间。\n   \n   对于给定的 i，对于所有 j∈[i+1,n]j \\in [i+1, n]j∈[i+1,n] 所耗费的时间总和为：\n   \n   ∑i+1no(j−i)\\sum_{i+1}^{n}o(j - i)i+1∑n​o(j−i)\n   \n   因此，执行所有步骤耗去的时间总和为：\n   \n   o(∑i=0n−1(∑j=i+1n(j−i)))=o(∑i=0n−1(1+n−i)(n−i)2)=o(n3)o\\left(\\sum_{i = 0}^{n - 1}\\left(\\sum_{j = i + 1}^{n}(j - i)\\right)\\right) = o\\left(\\sum_{i = 0}^{n - 1}\\frac{(1 + n - i)(n - i)}{2}\\right) = o(n^3)o(i=0∑n−1​(j=i+1∑n​(j−i)))=o(i=0∑n−1​2(1+n−i)(n−i)​)=o(n3)\n   \n   \n * 空间复杂度：o(min(n,m))o(min(n, m))o(min(n,m))，我们需要 o(k)o(k)o(k) 的空间来检查子字符串中是否有重复字符，其中 kkk 表示 set 的大小。而 set 的大小取决于字符串 nnn 的大小以及字符集/字母 mmm 的大小。\n   \n   \n\n\n\n\n# 方法二：滑动窗口\n算法\n\n暴力法非常简单，但它太慢了。那么我们该如何优化它呢？\n\n在暴力法中，我们会反复检查一个子字符串是否含有有重复的字符，但这是没有必要的。如果从索引 iii 到 j−1j - 1j−1 之间的子字符串 sijs_{ij}sij​ 已经被检查为没有重复字符。我们只需要检查 s[j]s[j]s[j] 对应的字符是否已经存在于子字符串 sijs_{ij}sij​ 中。\n\n要检查一个字符是否已经在子字符串中，我们可以检查整个子字符串，这将产生一个复杂度为 o(n2)o(n^2)o(n2) 的算法，但我们可以做得更好。\n\n通过使用 hashset 作为滑动窗口，我们可以用 o(1)o(1)o(1) 的时间来完成对字符是否在当前的子字符串中的检查。\n\n滑动窗口是数组/字符串问题中常用的抽象概念。 窗口通常是在数组/字符串中由开始和结束索引定义的一系列元素的集合，即 [i,j)[i, j)[i,j)（左闭，右开）。而滑动窗口是可以将两个边界向某一方向“滑动”的窗口。例如，我们将 [i,j)[i, j)[i,j) 向右滑动 111 个元素，则它将变为 [i+1,j+1)[i+1, j+1)[i+1,j+1)（左闭，右开）。\n\n回到我们的问题，我们使用 hashset 将字符存储在当前窗口 [i,j)[i, j)[i,j)（最初 j=ij = ij=i）中。 然后我们向右侧滑动索引 jjj，如果它不在 hashset 中，我们会继续滑动 jjj。直到 s[j] 已经存在于 hashset 中。此时，我们找到的没有重复字符的最长子字符串将会以索引 iii 开头。如果我们对所有的 iii 这样做，就可以得到答案。\n\npublic class solution {\n    public int lengthoflongestsubstring(string s) {\n        int n = s.length();\n        set<character> set = new hashset<>();\n        int ans = 0, i = 0, j = 0;\n        while (i < n && j < n) {\n            // try to extend the range [i, j]\n            if (!set.contains(s.charat(j))){\n                set.add(s.charat(j++));\n                ans = math.max(ans, j - i);\n            }\n            else {\n                set.remove(s.charat(i++));\n            }\n        }\n        return ans;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n复杂度分析\n\n * 时间复杂度：o(2n)=o(n)o(2n) = o(n)o(2n)=o(n)，在最糟糕的情况下，每个字符将被 iii 和 jjj 访问两次。\n   \n   \n * 空间复杂度：o(min(m,n))o(min(m, n))o(min(m,n))，与之前的方法相同。滑动窗口法需要 o(k)o(k)o(k) 的空间，其中 kkk 表示 set 的大小。而 set 的大小取决于字符串 nnn 的大小以及字符集 / 字母 mmm 的大小。\n   \n   \n\n\n\n\n# 方法三：优化的滑动窗口\n上述的方法最多需要执行 2n 个步骤。事实上，它可以被进一步优化为仅需要 n 个步骤。我们可以定义字符到索引的映射，而不是使用集合来判断一个字符是否存在。 当我们找到重复的字符时，我们可以立即跳过该窗口。\n\n也就是说，如果 s[j]s[j]s[j] 在 [i,j)[i, j)[i,j) 范围内有与 j′j\'j′ 重复的字符，我们不需要逐渐增加 iii 。 我们可以直接跳过 [i，j′][i，j\'][i，j′] 范围内的所有元素，并将 iii 变为 j′+1j\' + 1j′+1。\n\njava（使用 hashmap）\n\npublic class solution {\n    public int lengthoflongestsubstring(string s) {\n        int n = s.length(), ans = 0;\n        map<character, integer> map = new hashmap<>(); // current index of character\n        // try to extend the range [i, j]\n        for (int j = 0, i = 0; j < n; j++) {\n            if (map.containskey(s.charat(j))) {\n                i = math.max(map.get(s.charat(j)), i);\n            }\n            ans = math.max(ans, j - i + 1);\n            map.put(s.charat(j), j + 1);\n        }\n        return ans;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\njava（假设字符集为 ascii 128）\n\n以前的我们都没有对字符串 s 所使用的字符集进行假设。\n\n当我们知道该字符集比较小的时侯，我们可以用一个整数数组作为直接访问表来替换 map。\n\n常用的表如下所示：\n\n * int [26] 用于字母 ‘a’ - ‘z’ 或 ‘a’ - ‘z’\n * int [128] 用于ascii码\n * int [256] 用于扩展ascii码\n\npublic class solution {\n    public int lengthoflongestsubstring(string s) {\n        int n = s.length(), ans = 0;\n        int[] index = new int[128]; // current index of character\n        // try to extend the range [i, j]\n        for (int j = 0, i = 0; j < n; j++) {\n            i = math.max(index[s.charat(j)], i);\n            ans = math.max(ans, j - i + 1);\n            index[s.charat(j)] = j + 1;\n        }\n        return ans;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n复杂度分析\n\n * 时间复杂度：o(n)o(n)o(n)，索引 jjj 将会迭代 nnn 次。\n   \n   \n * 空间复杂度（hashmap）：o(min(m,n))o(min(m, n))o(min(m,n))，与之前的方法相同。\n   \n   \n * 空间复杂度（table）：o(m)o(m)o(m)，mmm 是字符集的大小。\n   \n   \n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-05-22 23:49:22accepted [https://leetcode-cn.com//submissions/detail/2514809/]50 ms22.71%n/ajava2018-05-22 23:47:27accepted [https://leetcode-cn.com//submissions/detail/2514733/]60 ms20.63%n/ajava2018-05-22 23:42:07wrong answer [https://leetcode-cn.com//submissions/detail/2514508/]n/an/an/ajava2018-05-22 23:26:40wrong answer [https://leetcode-cn.com//submissions/detail/2513752/]n/an/an/ajava# 统计信息\n通过次数提交次数ac比率32481799785132.6%# 相似题目\n题目难度至多包含两个不同字符的最长子串 [https://leetcode-cn.com/problems/longest-substring-with-at-most-two-distinct-characters/]中等至多包含 k 个不同字符的最长子串 [https://leetcode-cn.com/problems/longest-substring-with-at-most-k-distinct-characters/]困难k 个不同整数的子数组 [https://leetcode-cn.com/problems/subarrays-with-k-different-integers/]困难'},{title:"19-删除链表的倒数第N个节点(Remove Nth Node From End of List)",frontmatter:{title:"19-删除链表的倒数第N个节点(Remove Nth Node From End of List)",date:"2018-07-15T00:00:00.000Z",categories:["中等"],tags:["链表<Linked List>","双指针<Two Pointers>"]},regularPath:"/views/%E4%B8%AD%E7%AD%89/0019-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9.html",relativePath:"views/中等/0019-删除链表的倒数第N个节点.md",key:"v-7541876e",path:"/views/%E4%B8%AD%E7%AD%89/0019-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9.html",headers:[{level:2,title:"中文题目",slug:"中文题目",charIndex:2},{level:2,title:"通过代码",slug:"通过代码",charIndex:152},{level:2,title:"官方题解",slug:"官方题解",charIndex:853},{level:2,title:"提交历史",slug:"提交历史",charIndex:3004},{level:2,title:"统计信息",slug:"统计信息",charIndex:3133}],lastUpdated:"4/11/2021, 1:15:21 PM",headersStr:"中文题目 通过代码 官方题解 提交历史 统计信息",content:'# 中文题目\n给定一个链表，删除链表的倒数第n个节点，并且返回链表的头结点。\n\n示例：\n\n给定一个链表: 1->2->3->4->5, 和 n = 2.\n\n当删除了倒数第二个节点后，链表变为 1->2->3->5.\n\n\n说明：\n\n给定的 n保证是有效的。\n\n进阶：\n\n你能尝试使用一趟扫描实现吗？\n\n# 通过代码\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public ListNode removeNthFromEnd(ListNode head, int n) {\n        ListNode dummyHead=new ListNode(0);\n            dummyHead.next=head;\n            ListNode p=dummyHead;\n            ListNode q=dummyHead;\n            for (int i = 0; i < n+1; i++) {\n                q=q.next;\n            }\n            while (q!=null){\n                q=q.next;\n                p=p.next;\n            }\n            p.next=p.next.next;\n            return dummyHead.next; \n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n# 官方题解\n# 摘要\n本文适用于初学者。它介绍了以下内容：链表的遍历和删除其末尾的第 n 个元素。\n\n# 方法一：两次遍历算法\n思路\n\n我们注意到这个问题可以容易地简化成另一个问题：删除从列表开头数起的第 (L−n+1)(L - n + 1)(L−n+1) 个结点，其中 LLL 是列表的长度。只要我们找到列表的长度 LLL，这个问题就很容易解决。\n\n算法\n\n首先我们将添加一个哑结点作为辅助，该结点位于列表头部。哑结点用来简化某些极端情况，例如列表中只含有一个结点，或需要删除列表的头部。在第一次遍历中，我们找出列表的长度 LLL。然后设置一个指向哑结点的指针，并移动它遍历列表，直至它到达第 (L−n)(L - n)(L−n) 个结点那里。我们把第 (L−n)(L - n)(L−n) 个结点的 next 指针重新链接至第 (L−n+2)(L - n + 2)(L−n+2) 个结点，完成这个算法。\n\n{:width="360px"} {:align="center"}\n\n图 1. 删除列表中的第 L - n + 1 个元素{:align="center"}\n\npublic ListNode removeNthFromEnd(ListNode head, int n) {\n    ListNode dummy = new ListNode(0);\n    dummy.next = head;\n    int length  = 0;\n    ListNode first = head;\n    while (first != null) {\n        length++;\n        first = first.next;\n    }\n    length -= n;\n    first = dummy;\n    while (length > 0) {\n        length--;\n        first = first.next;\n    }\n    first.next = first.next.next;\n    return dummy.next;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n复杂度分析\n\n * 时间复杂度：O(L)O(L)O(L)，该算法对列表进行了两次遍历，首先计算了列表的长度 LLL 其次找到第 (L−n)(L - n)(L−n) 个结点。 操作执行了 2L−n2L-n2L−n 步，时间复杂度为 O(L)O(L)O(L)。\n   \n   \n * 空间复杂度：O(1)O(1)O(1)，我们只用了常量级的额外空间。\n   \n   \n\n\n\n\n# 方法二：一次遍历算法\n算法\n\n上述算法可以优化为只使用一次遍历。我们可以使用两个指针而不是一个指针。第一个指针从列表的开头向前移动 n+1n+1n+1 步，而第二个指针将从列表的开头出发。现在，这两个指针被 nnn 个结点分开。我们通过同时移动两个指针向前来保持这个恒定的间隔，直到第一个指针到达最后一个结点。此时第二个指针将指向从最后一个结点数起的第 nnn 个结点。我们重新链接第二个指针所引用的结点的 next 指针指向该结点的下下个结点。\n\n{:width="360px"} {:align="center"}\n\n图 2. 删除链表的倒数第 N 个元素{:align="center"}\n\npublic ListNode removeNthFromEnd(ListNode head, int n) {\n    ListNode dummy = new ListNode(0);\n    dummy.next = head;\n    ListNode first = dummy;\n    ListNode second = dummy;\n    // Advances first pointer so that the gap between first and second is n nodes apart\n    for (int i = 1; i <= n + 1; i++) {\n        first = first.next;\n    }\n    // Move first to the end, maintaining the gap\n    while (first != null) {\n        first = first.next;\n        second = second.next;\n    }\n    second.next = second.next.next;\n    return dummy.next;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n复杂度分析\n\n * 时间复杂度：O(L)O(L)O(L)，该算法对含有 LLL 个结点的列表进行了一次遍历。因此时间复杂度为 O(L)O(L)O(L)。\n   \n   \n * 空间复杂度：O(1)O(1)O(1)，我们只用了常量级的额外空间。\n   \n   \n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-07-15 22:32:27Accepted [https://leetcode-cn.com//submissions/detail/4216694/]13 ms57.45%N/Ajava# 统计信息\n通过次数提交次数AC比率11097129927237.1%',contentLowercase:'# 中文题目\n给定一个链表，删除链表的倒数第n个节点，并且返回链表的头结点。\n\n示例：\n\n给定一个链表: 1->2->3->4->5, 和 n = 2.\n\n当删除了倒数第二个节点后，链表变为 1->2->3->5.\n\n\n说明：\n\n给定的 n保证是有效的。\n\n进阶：\n\n你能尝试使用一趟扫描实现吗？\n\n# 通过代码\n/**\n * definition for singly-linked list.\n * public class listnode {\n *     int val;\n *     listnode next;\n *     listnode(int x) { val = x; }\n * }\n */\nclass solution {\n    public listnode removenthfromend(listnode head, int n) {\n        listnode dummyhead=new listnode(0);\n            dummyhead.next=head;\n            listnode p=dummyhead;\n            listnode q=dummyhead;\n            for (int i = 0; i < n+1; i++) {\n                q=q.next;\n            }\n            while (q!=null){\n                q=q.next;\n                p=p.next;\n            }\n            p.next=p.next.next;\n            return dummyhead.next; \n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n# 官方题解\n# 摘要\n本文适用于初学者。它介绍了以下内容：链表的遍历和删除其末尾的第 n 个元素。\n\n# 方法一：两次遍历算法\n思路\n\n我们注意到这个问题可以容易地简化成另一个问题：删除从列表开头数起的第 (l−n+1)(l - n + 1)(l−n+1) 个结点，其中 lll 是列表的长度。只要我们找到列表的长度 lll，这个问题就很容易解决。\n\n算法\n\n首先我们将添加一个哑结点作为辅助，该结点位于列表头部。哑结点用来简化某些极端情况，例如列表中只含有一个结点，或需要删除列表的头部。在第一次遍历中，我们找出列表的长度 lll。然后设置一个指向哑结点的指针，并移动它遍历列表，直至它到达第 (l−n)(l - n)(l−n) 个结点那里。我们把第 (l−n)(l - n)(l−n) 个结点的 next 指针重新链接至第 (l−n+2)(l - n + 2)(l−n+2) 个结点，完成这个算法。\n\n{:width="360px"} {:align="center"}\n\n图 1. 删除列表中的第 l - n + 1 个元素{:align="center"}\n\npublic listnode removenthfromend(listnode head, int n) {\n    listnode dummy = new listnode(0);\n    dummy.next = head;\n    int length  = 0;\n    listnode first = head;\n    while (first != null) {\n        length++;\n        first = first.next;\n    }\n    length -= n;\n    first = dummy;\n    while (length > 0) {\n        length--;\n        first = first.next;\n    }\n    first.next = first.next.next;\n    return dummy.next;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n复杂度分析\n\n * 时间复杂度：o(l)o(l)o(l)，该算法对列表进行了两次遍历，首先计算了列表的长度 lll 其次找到第 (l−n)(l - n)(l−n) 个结点。 操作执行了 2l−n2l-n2l−n 步，时间复杂度为 o(l)o(l)o(l)。\n   \n   \n * 空间复杂度：o(1)o(1)o(1)，我们只用了常量级的额外空间。\n   \n   \n\n\n\n\n# 方法二：一次遍历算法\n算法\n\n上述算法可以优化为只使用一次遍历。我们可以使用两个指针而不是一个指针。第一个指针从列表的开头向前移动 n+1n+1n+1 步，而第二个指针将从列表的开头出发。现在，这两个指针被 nnn 个结点分开。我们通过同时移动两个指针向前来保持这个恒定的间隔，直到第一个指针到达最后一个结点。此时第二个指针将指向从最后一个结点数起的第 nnn 个结点。我们重新链接第二个指针所引用的结点的 next 指针指向该结点的下下个结点。\n\n{:width="360px"} {:align="center"}\n\n图 2. 删除链表的倒数第 n 个元素{:align="center"}\n\npublic listnode removenthfromend(listnode head, int n) {\n    listnode dummy = new listnode(0);\n    dummy.next = head;\n    listnode first = dummy;\n    listnode second = dummy;\n    // advances first pointer so that the gap between first and second is n nodes apart\n    for (int i = 1; i <= n + 1; i++) {\n        first = first.next;\n    }\n    // move first to the end, maintaining the gap\n    while (first != null) {\n        first = first.next;\n        second = second.next;\n    }\n    second.next = second.next.next;\n    return dummy.next;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n复杂度分析\n\n * 时间复杂度：o(l)o(l)o(l)，该算法对含有 lll 个结点的列表进行了一次遍历。因此时间复杂度为 o(l)o(l)o(l)。\n   \n   \n * 空间复杂度：o(1)o(1)o(1)，我们只用了常量级的额外空间。\n   \n   \n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-07-15 22:32:27accepted [https://leetcode-cn.com//submissions/detail/4216694/]13 ms57.45%n/ajava# 统计信息\n通过次数提交次数ac比率11097129927237.1%'},{title:"17-电话号码的字母组合(Letter Combinations of a Phone Number)",frontmatter:{title:"17-电话号码的字母组合(Letter Combinations of a Phone Number)",date:"2018-07-18T00:00:00.000Z",categories:["中等"],tags:["字符串<String>","回溯算法<Backtracking>"]},regularPath:"/views/%E4%B8%AD%E7%AD%89/0017-%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88.html",relativePath:"views/中等/0017-电话号码的字母组合.md",key:"v-082f848c",path:"/views/%E4%B8%AD%E7%AD%89/0017-%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88.html",headers:[{level:2,title:"中文题目",slug:"中文题目",charIndex:2},{level:2,title:"通过代码",slug:"通过代码",charIndex:194},{level:2,title:"官方题解",slug:"官方题解",charIndex:1258},{level:2,title:"提交历史",slug:"提交历史",charIndex:4510},{level:2,title:"统计信息",slug:"统计信息",charIndex:4836},{level:2,title:"相似题目",slug:"相似题目",charIndex:4871}],lastUpdated:"4/11/2021, 1:15:21 PM",headersStr:"中文题目 通过代码 官方题解 提交历史 统计信息 相似题目",content:'# 中文题目\n给定一个仅包含数字2-9的字符串，返回所有它能表示的字母组合。\n\n给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。\n\n\n\n示例:\n\n输入："23"\n输出：["ad", "ae", "af", "bd", "be", "bf", "cd", "ce", "cf"].\n\n\n说明:\n尽管上面的答案是按字典序排列的，但是你可以任意选择答案输出的顺序。\n\n# 通过代码\nclass Solution {\n  final String[] letterMap={\n               " ",\n                "",\n                "abc",\n                "def",\n                "ghi",\n                "jkl",\n                "mno",\n                "pqrs",\n                "tuv",\n                "wxyz"\n        };\n        List<String> res=new LinkedList<>();\n        public List<String> letterCombinations(String digits) {\n            if (digits.equals("")){\n                return res;\n            }\n            findCombination(digits,0,"");\n            return res;\n        }\n\n        public void findCombination(String digits,int index,String s){\n            if (index==digits.length()){\n                res.add(s);\n                return;\n            }\n\n            char c=digits.charAt(index);\n            String letters=letterMap[c-\'0\'];\n            for (int i = 0; i < letters.length(); i++) {\n                findCombination(digits,index+1,s+letters.charAt(i));\n            }\n        }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n# 官方题解\n# 方法：回溯\n回溯是一种通过穷举所有可能情况来找到所有解的算法。如果一个候选解最后被发现并不是可行解，回溯算法会舍弃它，并在前面的一些步骤做出一些修改，并重新尝试找到可行解。\n\n给出如下回溯函数 backtrack(combination, next_digits) ，它将一个目前已经产生的组合 combination 和接下来准备要输入的数字 next_digits 作为参数。\n\n如果没有更多的数字需要被输入，那意味着当前的组合已经产生好了。 如果还有数字需要被输入： 遍历下一个数字所对应的所有映射的字母。 将当前的字母添加到组合最后，也就是 combination = combination + letter 。 重复这个过程，输入剩下的数字： backtrack(combination + letter, next_digits[1:]) 。\n\n<,,,,,,,,,,,,,>\n\nclass Solution {\n  Map<String, String> phone = new HashMap<String, String>() {{\n    put("2", "abc");\n    put("3", "def");\n    put("4", "ghi");\n    put("5", "jkl");\n    put("6", "mno");\n    put("7", "pqrs");\n    put("8", "tuv");\n    put("9", "wxyz");\n  }};\n\n  List<String> output = new ArrayList<String>();\n\n  public void backtrack(String combination, String next_digits) {\n    // if there is no more digits to check\n    if (next_digits.length() == 0) {\n      // the combination is done\n      output.add(combination);\n    }\n    // if there are still digits to check\n    else {\n      // iterate over all letters which map \n      // the next available digit\n      String digit = next_digits.substring(0, 1);\n      String letters = phone.get(digit);\n      for (int i = 0; i < letters.length(); i++) {\n        String letter = phone.get(digit).substring(i, i + 1);\n        // append the current letter to the combination\n        // and proceed to the next digits\n        backtrack(combination + letter, next_digits.substring(1));\n      }\n    }\n  }\n\n  public List<String> letterCombinations(String digits) {\n    if (digits.length() != 0)\n      backtrack("", digits);\n    return output;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\nclass Solution:\n    def letterCombinations(self, digits):\n        """\n        :type digits: str\n        :rtype: List[str]\n        """\n        phone = {\'2\': [\'a\', \'b\', \'c\'],\n                 \'3\': [\'d\', \'e\', \'f\'],\n                 \'4\': [\'g\', \'h\', \'i\'],\n                 \'5\': [\'j\', \'k\', \'l\'],\n                 \'6\': [\'m\', \'n\', \'o\'],\n                 \'7\': [\'p\', \'q\', \'r\', \'s\'],\n                 \'8\': [\'t\', \'u\', \'v\'],\n                 \'9\': [\'w\', \'x\', \'y\', \'z\']}\n                \n        def backtrack(combination, next_digits):\n            # if there is no more digits to check\n            if len(next_digits) == 0:\n                # the combination is done\n                output.append(combination)\n            # if there are still digits to check\n            else:\n                # iterate over all letters which map \n                # the next available digit\n                for letter in phone[next_digits[0]]:\n                    # append the current letter to the combination\n                    # and proceed to the next digits\n                    backtrack(combination + letter, next_digits[1:])\n                    \n        output = []\n        if digits:\n            backtrack("", digits)\n        return output\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n复杂度分析\n\n * 时间复杂度： O(3N×4M)O(3^N \\times 4^M)O(3N×4M) ，其中 N 是输入数字中对应 3 个字母的数目（比方说 2，3，4，5，6，8）， M 是输入数字中对应 4 个字母的数目（比方说 7，9），N+M 是输入数字的总数。\n   \n   \n * 空间复杂度：O(3N×4M)O(3^N \\times 4^M)O(3N×4M) ，这是因为需要保存 3N×4M3^N \\times 4^M3N×4M 个结果。\n   \n   \n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-07-18 20:41:03Accepted [https://leetcode-cn.com//submissions/detail/4345053/]3 ms5.71%N/Ajava2018-07-18 20:38:28Wrong Answer [https://leetcode-cn.com//submissions/detail/4344941/]N/AN/AN/Ajava2018-07-18 20:36:00Runtime Error [https://leetcode-cn.com//submissions/detail/4344811/]N/AN/AN/Ajava# 统计信息\n通过次数提交次数AC比率7030813500152.1%# 相似题目\n题目难度括号生成 [https://leetcode-cn.com/problems/generate-parentheses/]中等组合总和 [https://leetcode-cn.com/problems/combination-sum/]中等二进制手表 [https://leetcode-cn.com/problems/binary-watch/]简单',contentLowercase:'# 中文题目\n给定一个仅包含数字2-9的字符串，返回所有它能表示的字母组合。\n\n给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。\n\n\n\n示例:\n\n输入："23"\n输出：["ad", "ae", "af", "bd", "be", "bf", "cd", "ce", "cf"].\n\n\n说明:\n尽管上面的答案是按字典序排列的，但是你可以任意选择答案输出的顺序。\n\n# 通过代码\nclass solution {\n  final string[] lettermap={\n               " ",\n                "",\n                "abc",\n                "def",\n                "ghi",\n                "jkl",\n                "mno",\n                "pqrs",\n                "tuv",\n                "wxyz"\n        };\n        list<string> res=new linkedlist<>();\n        public list<string> lettercombinations(string digits) {\n            if (digits.equals("")){\n                return res;\n            }\n            findcombination(digits,0,"");\n            return res;\n        }\n\n        public void findcombination(string digits,int index,string s){\n            if (index==digits.length()){\n                res.add(s);\n                return;\n            }\n\n            char c=digits.charat(index);\n            string letters=lettermap[c-\'0\'];\n            for (int i = 0; i < letters.length(); i++) {\n                findcombination(digits,index+1,s+letters.charat(i));\n            }\n        }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n# 官方题解\n# 方法：回溯\n回溯是一种通过穷举所有可能情况来找到所有解的算法。如果一个候选解最后被发现并不是可行解，回溯算法会舍弃它，并在前面的一些步骤做出一些修改，并重新尝试找到可行解。\n\n给出如下回溯函数 backtrack(combination, next_digits) ，它将一个目前已经产生的组合 combination 和接下来准备要输入的数字 next_digits 作为参数。\n\n如果没有更多的数字需要被输入，那意味着当前的组合已经产生好了。 如果还有数字需要被输入： 遍历下一个数字所对应的所有映射的字母。 将当前的字母添加到组合最后，也就是 combination = combination + letter 。 重复这个过程，输入剩下的数字： backtrack(combination + letter, next_digits[1:]) 。\n\n<,,,,,,,,,,,,,>\n\nclass solution {\n  map<string, string> phone = new hashmap<string, string>() {{\n    put("2", "abc");\n    put("3", "def");\n    put("4", "ghi");\n    put("5", "jkl");\n    put("6", "mno");\n    put("7", "pqrs");\n    put("8", "tuv");\n    put("9", "wxyz");\n  }};\n\n  list<string> output = new arraylist<string>();\n\n  public void backtrack(string combination, string next_digits) {\n    // if there is no more digits to check\n    if (next_digits.length() == 0) {\n      // the combination is done\n      output.add(combination);\n    }\n    // if there are still digits to check\n    else {\n      // iterate over all letters which map \n      // the next available digit\n      string digit = next_digits.substring(0, 1);\n      string letters = phone.get(digit);\n      for (int i = 0; i < letters.length(); i++) {\n        string letter = phone.get(digit).substring(i, i + 1);\n        // append the current letter to the combination\n        // and proceed to the next digits\n        backtrack(combination + letter, next_digits.substring(1));\n      }\n    }\n  }\n\n  public list<string> lettercombinations(string digits) {\n    if (digits.length() != 0)\n      backtrack("", digits);\n    return output;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\nclass solution:\n    def lettercombinations(self, digits):\n        """\n        :type digits: str\n        :rtype: list[str]\n        """\n        phone = {\'2\': [\'a\', \'b\', \'c\'],\n                 \'3\': [\'d\', \'e\', \'f\'],\n                 \'4\': [\'g\', \'h\', \'i\'],\n                 \'5\': [\'j\', \'k\', \'l\'],\n                 \'6\': [\'m\', \'n\', \'o\'],\n                 \'7\': [\'p\', \'q\', \'r\', \'s\'],\n                 \'8\': [\'t\', \'u\', \'v\'],\n                 \'9\': [\'w\', \'x\', \'y\', \'z\']}\n                \n        def backtrack(combination, next_digits):\n            # if there is no more digits to check\n            if len(next_digits) == 0:\n                # the combination is done\n                output.append(combination)\n            # if there are still digits to check\n            else:\n                # iterate over all letters which map \n                # the next available digit\n                for letter in phone[next_digits[0]]:\n                    # append the current letter to the combination\n                    # and proceed to the next digits\n                    backtrack(combination + letter, next_digits[1:])\n                    \n        output = []\n        if digits:\n            backtrack("", digits)\n        return output\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n复杂度分析\n\n * 时间复杂度： o(3n×4m)o(3^n \\times 4^m)o(3n×4m) ，其中 n 是输入数字中对应 3 个字母的数目（比方说 2，3，4，5，6，8）， m 是输入数字中对应 4 个字母的数目（比方说 7，9），n+m 是输入数字的总数。\n   \n   \n * 空间复杂度：o(3n×4m)o(3^n \\times 4^m)o(3n×4m) ，这是因为需要保存 3n×4m3^n \\times 4^m3n×4m 个结果。\n   \n   \n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-07-18 20:41:03accepted [https://leetcode-cn.com//submissions/detail/4345053/]3 ms5.71%n/ajava2018-07-18 20:38:28wrong answer [https://leetcode-cn.com//submissions/detail/4344941/]n/an/an/ajava2018-07-18 20:36:00runtime error [https://leetcode-cn.com//submissions/detail/4344811/]n/an/an/ajava# 统计信息\n通过次数提交次数ac比率7030813500152.1%# 相似题目\n题目难度括号生成 [https://leetcode-cn.com/problems/generate-parentheses/]中等组合总和 [https://leetcode-cn.com/problems/combination-sum/]中等二进制手表 [https://leetcode-cn.com/problems/binary-watch/]简单'},{title:"11-盛最多水的容器(Container With Most Water)",frontmatter:{title:"11-盛最多水的容器(Container With Most Water)",date:"2021-04-14T00:00:00.000Z",categories:["中等"],tags:["数组<Array>","双指针<Two Pointers>"]},regularPath:"/views/%E4%B8%AD%E7%AD%89/0011-%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8.html",relativePath:"views/中等/0011-盛最多水的容器.md",key:"v-4779f67f",path:"/views/%E4%B8%AD%E7%AD%89/0011-%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8.html",headers:[{level:2,title:"中文题目",slug:"中文题目",charIndex:2},{level:2,title:"通过代码",slug:"通过代码",charIndex:406},{level:2,title:"我的笔记",slug:"我的笔记",charIndex:2212},{level:2,title:"高赞题解",slug:"高赞题解",charIndex:2234},{level:2,title:"提交历史",slug:"提交历史",charIndex:4312},{level:2,title:"统计信息",slug:"统计信息",charIndex:4750},{level:2,title:"相似题目",slug:"相似题目",charIndex:4786}],lastUpdated:"4/11/2021, 1:15:21 PM",headersStr:"中文题目 通过代码 我的笔记 高赞题解 提交历史 统计信息 相似题目",content:"# 中文题目\n给你 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点(i, ai) 。在坐标内画 n 条垂直线，垂直线 i的两个端点分别为(i, ai) 和 (i, 0) 。找出其中的两条线，使得它们与x轴共同构成的容器可以容纳最多的水。\n\n说明：你不能倾斜容器。\n\n\n\n示例 1：\n\n\n\n\n输入：[1,8,6,2,5,4,8,3,7]\n输出：49 \n解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。\n\n示例 2：\n\n\n输入：height = [1,1]\n输出：1\n\n\n示例 3：\n\n\n输入：height = [4,3,2,1,4]\n输出：16\n\n\n示例 4：\n\n\n输入：height = [1,2,1]\n输出：2\n\n\n\n\n提示：\n\n * n = height.length\n * 2 4\n * 0 4\n\n# 通过代码\n    class Solution {\n        public int maxArea(int[] height) {\n            // 头尾指针，当那个的竖坐标的值小的时候，就向中间靠近一个\n            // 因为只有竖坐标在不断变大的时候，横坐标变小，才能使面积变大\n            int start = 0;\n            int end = height.length - 1;\n            int maxArea = 0;\n            while (start < end) {\n                maxArea = Math.max(maxArea, (end - start) * Math.min(height[start], height[end]));\n                if (height[start] < height[end]) {\n                    start++;\n                } else {\n                    end--;\n                }\n            }\n            return maxArea;\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n    class Solution {\n        public int maxArea(int[] height) {\n            // 头尾指针，当那个的竖坐标的值小的时候，就向中间靠近一个\n            // 因为只有竖坐标在不断变大的时候，横坐标变小，才能使面积变大\n            int start = 0;\n            int end = height.length - 1;\n            int maxArea = 0;\n            while (start < end) {\n                maxArea = Math.max(maxArea, (end - start) * Math.min(height[start], height[end]));\n                if (height[start] < height[end]) {\n                    start++;\n                } else {\n                    end--;\n                }\n            }\n            return maxArea;\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\nclass Solution {\n    public int maxArea(int[] height) {\n        int left = 0;\n            int right = height.length - 1;\n            int maxArea = 0;\n            while (left < right) {\n                maxArea = Math.max(maxArea, Math.min(height[left], height[right]) * (right - left));\n                if (height[left] < height[right]) {\n                    left++;\n                } else {\n                    right--;\n                }\n            }\n            return maxArea;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n# 我的笔记\n双指针，前后往中间进行遍历\n\n# 高赞题解\n# 思路：\n * 算法流程： 设置双指针 iii,jjj 分别位于容器壁两端，根据规则移动指针（后续说明），并且更新面积最大值 res，直到 i == j 时返回 res。\n   \n   \n * 指针移动规则与证明： 每次选定围成水槽两板高度 h[i]h[i]h[i],h[j]h[j]h[j] 中的短板，向中间收窄 111 格。以下证明：\n   \n    * 设每一状态下水槽面积为 S(i,j)S(i, j)S(i,j),(0<=i<j<n)(0 <= i < j < n)(0<=i<j<n)，由于水槽的实际高度由两板中的短板决定，则可得面积公式 S(i,j)=min(h[i],h[j])×(j−i)S(i, j) = min(h[i], h[j]) × (j - i)S(i,j)=min(h[i],h[j])×(j−i)。\n    * 在每一个状态下，无论长板或短板收窄 111 格，都会导致水槽 底边宽度 −1-1−1： * 若向内移动短板，水槽的短板 min(h[i],h[j])min(h[i], h[j])min(h[i],h[j]) 可能变大，因此水槽面积 S(i,j)S(i, j)S(i,j) 可能增大。\n       * 若向内移动长板，水槽的短板 min(h[i],h[j])min(h[i], h[j])min(h[i],h[j]) 不变或变小，下个水槽的面积一定小于当前水槽面积。\n      \n      \n    * 因此，向内收窄短板可以获取面积最大值。换个角度理解： * 若不指定移动规则，所有移动出现的 S(i,j)S(i, j)S(i,j) 的状态数为 C(n,2)C(n, 2)C(n,2)，即暴力枚举出所有状态。\n       * 在状态 S(i,j)S(i, j)S(i,j) 下向内移动短板至 S(i+1,j)S(i + 1, j)S(i+1,j)（假设 h[i]<h[j]h[i] < h[j]h[i]<h[j] ），则相当于消去了 S(i,j−1),S(i,j−2),...,S(i,i+1){S(i, j - 1), S(i, j - 2), ... , S(i, i + 1)}S(i,j−1),S(i,j−2),...,S(i,i+1) 状态集合。而所有消去状态的面积一定 <=S(i,j)<= S(i, j)<=S(i,j)： * 短板高度：相比 S(i,j)S(i, j)S(i,j) 相同或更短（<=h[i]<= h[i]<=h[i]）；\n          * 底边宽度：相比 S(i,j)S(i, j)S(i,j) 更短。\n         \n         \n       * 因此所有消去的状态的面积都 <S(i,j)< S(i, j)<S(i,j)。通俗的讲，我们每次向内移动短板，所有的消去状态都不会导致丢失面积最大值 。\n      \n      \n   \n   \n * 复杂度分析：\n   \n    * 时间复杂度 O(N)O(N)O(N)，双指针遍历一次底边宽度 NNN 。\n    * 空间复杂度 O(1)O(1)O(1)，指针使用常数额外空间。\n   \n   \n\n<,,,,,,,>\n\n# 代码：\nclass Solution:\n    def maxArea(self, height: List[int]) -> int:\n        i, j, res = 0, len(height) - 1, 0\n        while i < j:\n            if height[i] < height[j]:\n                res = max(res, height[i] * (j - i))\n                i += 1\n            else:\n                res = max(res, height[j] * (j - i))\n                j -= 1\n        return res\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\nclass Solution {\n    public int maxArea(int[] height) {\n        int i = 0, j = height.length - 1, res = 0;\n        while(i < j){\n            res = height[i] < height[j] ? \n                Math.max(res, (j - i) * height[i++]): \n                Math.max(res, (j - i) * height[j--]); \n        }\n        return res;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2021-04-14 21:39:56Accepted [https://leetcode-cn.com//submissions/detail/167933305/]5 ms100.0%52 MBjava2021-04-14 21:31:29Time Limit Exceeded [https://leetcode-cn.com//submissions/detail/167928558/]N/AN/AN/Ajava2018-05-21 17:45:53Accepted [https://leetcode-cn.com//submissions/detail/2471702/]9 ms100.0%N/Ajava2018-05-21 17:43:51Wrong Answer [https://leetcode-cn.com//submissions/detail/2471556/]N/AN/AN/Ajava# 统计信息\n通过次数提交次数AC比率41578064645864.3%# 相似题目\n题目难度接雨水 [https://leetcode-cn.com/problems/trapping-rain-water/]困难",contentLowercase:"# 中文题目\n给你 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点(i, ai) 。在坐标内画 n 条垂直线，垂直线 i的两个端点分别为(i, ai) 和 (i, 0) 。找出其中的两条线，使得它们与x轴共同构成的容器可以容纳最多的水。\n\n说明：你不能倾斜容器。\n\n\n\n示例 1：\n\n\n\n\n输入：[1,8,6,2,5,4,8,3,7]\n输出：49 \n解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。\n\n示例 2：\n\n\n输入：height = [1,1]\n输出：1\n\n\n示例 3：\n\n\n输入：height = [4,3,2,1,4]\n输出：16\n\n\n示例 4：\n\n\n输入：height = [1,2,1]\n输出：2\n\n\n\n\n提示：\n\n * n = height.length\n * 2 4\n * 0 4\n\n# 通过代码\n    class solution {\n        public int maxarea(int[] height) {\n            // 头尾指针，当那个的竖坐标的值小的时候，就向中间靠近一个\n            // 因为只有竖坐标在不断变大的时候，横坐标变小，才能使面积变大\n            int start = 0;\n            int end = height.length - 1;\n            int maxarea = 0;\n            while (start < end) {\n                maxarea = math.max(maxarea, (end - start) * math.min(height[start], height[end]));\n                if (height[start] < height[end]) {\n                    start++;\n                } else {\n                    end--;\n                }\n            }\n            return maxarea;\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n    class solution {\n        public int maxarea(int[] height) {\n            // 头尾指针，当那个的竖坐标的值小的时候，就向中间靠近一个\n            // 因为只有竖坐标在不断变大的时候，横坐标变小，才能使面积变大\n            int start = 0;\n            int end = height.length - 1;\n            int maxarea = 0;\n            while (start < end) {\n                maxarea = math.max(maxarea, (end - start) * math.min(height[start], height[end]));\n                if (height[start] < height[end]) {\n                    start++;\n                } else {\n                    end--;\n                }\n            }\n            return maxarea;\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\nclass solution {\n    public int maxarea(int[] height) {\n        int left = 0;\n            int right = height.length - 1;\n            int maxarea = 0;\n            while (left < right) {\n                maxarea = math.max(maxarea, math.min(height[left], height[right]) * (right - left));\n                if (height[left] < height[right]) {\n                    left++;\n                } else {\n                    right--;\n                }\n            }\n            return maxarea;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n# 我的笔记\n双指针，前后往中间进行遍历\n\n# 高赞题解\n# 思路：\n * 算法流程： 设置双指针 iii,jjj 分别位于容器壁两端，根据规则移动指针（后续说明），并且更新面积最大值 res，直到 i == j 时返回 res。\n   \n   \n * 指针移动规则与证明： 每次选定围成水槽两板高度 h[i]h[i]h[i],h[j]h[j]h[j] 中的短板，向中间收窄 111 格。以下证明：\n   \n    * 设每一状态下水槽面积为 s(i,j)s(i, j)s(i,j),(0<=i<j<n)(0 <= i < j < n)(0<=i<j<n)，由于水槽的实际高度由两板中的短板决定，则可得面积公式 s(i,j)=min(h[i],h[j])×(j−i)s(i, j) = min(h[i], h[j]) × (j - i)s(i,j)=min(h[i],h[j])×(j−i)。\n    * 在每一个状态下，无论长板或短板收窄 111 格，都会导致水槽 底边宽度 −1-1−1： * 若向内移动短板，水槽的短板 min(h[i],h[j])min(h[i], h[j])min(h[i],h[j]) 可能变大，因此水槽面积 s(i,j)s(i, j)s(i,j) 可能增大。\n       * 若向内移动长板，水槽的短板 min(h[i],h[j])min(h[i], h[j])min(h[i],h[j]) 不变或变小，下个水槽的面积一定小于当前水槽面积。\n      \n      \n    * 因此，向内收窄短板可以获取面积最大值。换个角度理解： * 若不指定移动规则，所有移动出现的 s(i,j)s(i, j)s(i,j) 的状态数为 c(n,2)c(n, 2)c(n,2)，即暴力枚举出所有状态。\n       * 在状态 s(i,j)s(i, j)s(i,j) 下向内移动短板至 s(i+1,j)s(i + 1, j)s(i+1,j)（假设 h[i]<h[j]h[i] < h[j]h[i]<h[j] ），则相当于消去了 s(i,j−1),s(i,j−2),...,s(i,i+1){s(i, j - 1), s(i, j - 2), ... , s(i, i + 1)}s(i,j−1),s(i,j−2),...,s(i,i+1) 状态集合。而所有消去状态的面积一定 <=s(i,j)<= s(i, j)<=s(i,j)： * 短板高度：相比 s(i,j)s(i, j)s(i,j) 相同或更短（<=h[i]<= h[i]<=h[i]）；\n          * 底边宽度：相比 s(i,j)s(i, j)s(i,j) 更短。\n         \n         \n       * 因此所有消去的状态的面积都 <s(i,j)< s(i, j)<s(i,j)。通俗的讲，我们每次向内移动短板，所有的消去状态都不会导致丢失面积最大值 。\n      \n      \n   \n   \n * 复杂度分析：\n   \n    * 时间复杂度 o(n)o(n)o(n)，双指针遍历一次底边宽度 nnn 。\n    * 空间复杂度 o(1)o(1)o(1)，指针使用常数额外空间。\n   \n   \n\n<,,,,,,,>\n\n# 代码：\nclass solution:\n    def maxarea(self, height: list[int]) -> int:\n        i, j, res = 0, len(height) - 1, 0\n        while i < j:\n            if height[i] < height[j]:\n                res = max(res, height[i] * (j - i))\n                i += 1\n            else:\n                res = max(res, height[j] * (j - i))\n                j -= 1\n        return res\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\nclass solution {\n    public int maxarea(int[] height) {\n        int i = 0, j = height.length - 1, res = 0;\n        while(i < j){\n            res = height[i] < height[j] ? \n                math.max(res, (j - i) * height[i++]): \n                math.max(res, (j - i) * height[j--]); \n        }\n        return res;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2021-04-14 21:39:56accepted [https://leetcode-cn.com//submissions/detail/167933305/]5 ms100.0%52 mbjava2021-04-14 21:31:29time limit exceeded [https://leetcode-cn.com//submissions/detail/167928558/]n/an/an/ajava2018-05-21 17:45:53accepted [https://leetcode-cn.com//submissions/detail/2471702/]9 ms100.0%n/ajava2018-05-21 17:43:51wrong answer [https://leetcode-cn.com//submissions/detail/2471556/]n/an/an/ajava# 统计信息\n通过次数提交次数ac比率41578064645864.3%# 相似题目\n题目难度接雨水 [https://leetcode-cn.com/problems/trapping-rain-water/]困难"},{title:"34-在排序数组中查找元素的第一个和最后一个位置(Find First and Last Position of Element in Sorted Array)",frontmatter:{title:"34-在排序数组中查找元素的第一个和最后一个位置(Find First and Last Position of Element in Sorted Array)",date:"2021-05-23T00:00:00.000Z",categories:["中等"],tags:["数组<Array>","二分查找<Binary Search>"]},regularPath:"/views/%E4%B8%AD%E7%AD%89/0034-%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE.html",relativePath:"views/中等/0034-在排序数组中查找元素的第一个和最后一个位置.md",key:"v-69743892",path:"/views/%E4%B8%AD%E7%AD%89/0034-%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE.html",headers:[{level:2,title:"中文题目",slug:"中文题目",charIndex:2},{level:2,title:"通过代码",slug:"通过代码",charIndex:350},{level:2,title:"高赞题解",slug:"高赞题解",charIndex:2152},{level:2,title:"第 1 部分：查找 target 出现的第 1 个位置",slug:"第-1-部分：查找-target-出现的第-1-个位置",charIndex:2777},{level:2,title:"第 2 部分：查找 target 出现的最后 1 个位置",slug:"第-2-部分：查找-target-出现的最后-1-个位置",charIndex:4641},{level:2,title:"完整代码 1（其实就是把上面的三个代码拼凑出来）",slug:"完整代码-1（其实就是把上面的三个代码拼凑出来）",charIndex:5952},{level:2,title:"完整代码 2",slug:"完整代码-2",charIndex:10417},{level:2,title:"提交历史",slug:"提交历史",charIndex:14387},{level:2,title:"统计信息",slug:"统计信息",charIndex:14941},{level:2,title:"相似题目",slug:"相似题目",charIndex:14977}],headersStr:"中文题目 通过代码 高赞题解 第 1 部分：查找 target 出现的第 1 个位置 第 2 部分：查找 target 出现的最后 1 个位置 完整代码 1（其实就是把上面的三个代码拼凑出来） 完整代码 2 提交历史 统计信息 相似题目",content:"# 中文题目\n给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。\n\n如果数组中不存在目标值 target，返回[-1, -1]。\n\n进阶：\n\n * 你可以设计并实现时间复杂度为O(log n)的算法解决此问题吗？\n\n\n\n示例 1：\n\n\n输入：nums = [5,7,7,8,8,10], target = 8\n输出：[3,4]\n\n示例 2：\n\n\n输入：nums = [5,7,7,8,8,10], target = 6\n输出：[-1,-1]\n\n示例 3：\n\n\n输入：nums = [], target = 0\n输出：[-1,-1]\n\n\n\n提示：\n\n * 0 5\n * -1099\n * nums是一个非递减数组\n * -1099\n\n# 通过代码\nclass Solution {\n        public int[] searchRange(int[] nums, int target) {\n            int[] res = {-1, -1};\n            if (nums.length == 0) {\n                return res;\n            }\n            int left = findLeftPos(nums, target);\n            int right = findRightPos(nums, target);\n            //判断一下找到的值是否和目标值相等\n            if (left <= right && nums[left] == target) {\n                res[0] = left;\n            }\n            //需满足右边界大于等于左边界\n            if (right >= left && nums[right] == target) {\n                res[1] = right;\n            }\n            return res;\n        }\n\n        private int findRightPos(int[] nums, int target) {\n            int left = 0;\n            int right = nums.length - 1;\n            int mid;\n            while (left <= right) {\n                mid = left + (right - left) / 2;\n                // 如果左边的值一直小于等于目标值的话，就左哨兵往右移，找右边界\n                if (nums[mid] <= target) {\n                    left = mid + 1;\n                }\n                if (nums[mid] > target) {\n                    right = mid - 1;\n                }\n            }\n            return right;\n        }\n\n        private int findLeftPos(int[] nums, int target) {\n            int left = 0;\n            int right = nums.length - 1;\n            int mid;\n            while (left <= right) {\n                mid = left + (right - left) / 2;\n                if (nums[mid] < target) {\n                    left = mid + 1;\n                }\n                // 如果右边的值一直大于等于目标值的话，就左哨兵往左移，找左边界\n                if (nums[mid] >= target) {\n                    right = mid - 1;\n                }\n            }\n            return left;\n        }\n    }\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n# 高赞题解\n二分查找在通常的资料里会介绍几种模板的写法，但我并不推荐通过模板学习算法的方式。我相信写算法没有那么模板，设计算法的人一定是通过了深入的思考，才设计出一个个精妙的算法和数据结构。\n\n请大家一定不要去记忆所谓的二分查找模板，一题一个模板，相当于没有模板。\n\n# 二分查找的三种写法\n二分查找通常有以下几种写法，区别主要在于 while 里面，\n\n形式结论与建议while (left <= right)简单问题用，在循环体里能找到答案以后退出。while (left < right)复杂问题用，把答案留到退出循环以后，再判断。是解决二分问题的利器，尤其在边界问题用，这种方式考虑细节最少，但是需要一定练习才能灵活运用。while (left + 1 < right)不建议，本质上和 while (left <= right) 写法一样，盲目套这个所谓的最无脑模板，反而学不会二分。其实理解这三种写法并不难。关键在于掌握：退出循环的时候，left 和 right 的位置关系。只需要掌握一种写法就可以了。\n\n# LeetCode 第 34 题采用 while(left <= right)\n本篇题解采用 while(left <= right) 这种二分查找的写法，并分析如何在循环体里设置 left 和 right，和应该返回 left 和 right，即怎样思考边界问题。只要逻辑是完备，并且足够细心，写对二分查找问题并不困难。\n\n# 第 1 部分：查找 target 出现的第 1 个位置\n二分查找的基本用法是在一个有序数组里查找目标元素，具体是看区间中间元素的值 nums[mid] 与 target 的大小关系。\n\n * 如果等于，就可以直接返回；\n * 如果严格大于，就往右边查找；\n * 如果严格小于，就往左边查找。\n\n就这 333 种情况，先判断等于，然后再判断大于还是小于，符合人们正常的思维。\n\n具体到当前「力扣」第 34 题，由于一个元素出现多次，在具体分类讨论的时候，就有一点细微差别。\n\n（如果嫌下面文字多，可以直接看代码，都有注释。）\n\n * 如果当前看到的元素 恰好等于 target，那么当前元素有可能是 target 出现的第 111 个位置，由于我们要找第 111 个位置，此时我们应该向左边继续查找；\n * 如果当前看到的元素 严格大于 target，那么当前元素一定不是要找的 target 出现的第 111 个位置，第 111 个位置肯定出现在 mid 的 左边 ，因此就需要在 [left, mid] 区间里继续查找；\n * 如果当前看到的元素 严格小于 target，那么当前元素一定不是要找的 target 出现的第 111 个位置，第 111 个位置肯定出现在 mid 的 右边 ，因此就需要在 [mid + 1, right] 区间里继续查找。\n\n代码 1：\n\nprivate int findFirstPosition(int[] nums, int target) {\n    int left = 0;\n    int right = nums.length - 1;\n\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n\n        if (nums[mid] == target) {\n            // ① 不可以直接返回，应该继续向左边找，即 [left..mid - 1] 区间里找\n            right = mid - 1;\n        } else if (nums[mid] < target) {\n            // 应该继续向右边找，即 [mid + 1, right] 区间里找\n            left = mid + 1;\n        } else {\n            // 此时 nums[mid] > target，应该继续向左边找，即 [left..mid - 1] 区间里找\n            right = mid - 1;\n        }\n    }\n\n    // 此时 left 和 right 的位置关系是 [right, left]，注意上面的 ①，此时 left 才是第 1 次元素出现的位置\n    // 因此还需要特别做一次判断\n    if (left != nums.length && nums[left] == target) {\n        return left;\n    }\n    return -1;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n解释：\n\n * 第 111 次出现的位置和最后 111 次出现的位置肯定都在数组里。因此，初始化的时候 left = 0 、 right = nums.length - 1；\n * nums[mid] == target 的时候，在 [left, mid - 1] 区间里找，有没有可能 nums[mid] 就是第 111 次出现的位置，有可能，但不要紧，退出循环的时候 right 指针在左，left 在右。如果数组里存在 target，那么 left 一定位于 target 出现的第 111 个位置，请看下图。\n\n\n\n还有一种特殊情况，当要查找的目标元素不存在的时，分两种情况：（1）target 很大，（2）target 很小：\n\n * target 很大，还是上面的例子\n\n\n\n * target 很小，还是上面的例子\n\n\n\n以上特殊例子，解释了为什么在 while (left <= right) 退出循环以后，需要单独判断 left 是否越界，以及判断 nums[left] 是不是目标元素的原因。\n\n# 第 2 部分：查找 target 出现的最后 1 个位置\n可以直接看注释。\n\n代码 2：\n\nprivate int findLastPosition(int[] nums, int target) {\n    int left = 0;\n    int right = nums.length - 1;\n\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n\n        if (nums[mid] == target) {\n            // 只有这里不一样：不可以直接返回，应该继续向右边找，即 [mid + 1, right] 区间里找\n            left = mid + 1;\n        } else if (nums[mid] < target) {\n            // 应该继续向右边找，即 [mid + 1, right] 区间里找\n            left = mid + 1;\n        } else {\n            // 此时 nums[mid] > target，应该继续向左边找，即 [left, mid - 1] 区间里找\n            right = mid - 1;\n        }\n    }\n    // 由于 findFirstPosition 方法可以返回是否找到，这里无需单独再做判断\n    return right;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n为什么返回 right 解释如下图：\n\n\n\n这里注意：无需讨论不存在的情况。这是因为先执行了 findFirstPosition() 方法，这个方法如果返回 −1-1−1，显然我们就知道数组里不存在目标元素，可以直接返回 [-1, -1]。\n\n接下来，我们补上主调方法：\n\n代码 3：\n\npublic int[] searchRange(int[] nums, int target) {\n    if (nums.length == 0) {\n        return new int[]{-1, -1};\n    }\n    int firstPosition = findFirstPosition(nums, target);\n    // 如果第 1 次出现的位置都找不到，肯定不存在最后 1 次出现的位置\n    if (firstPosition == -1) {\n        return new int[]{-1, -1};\n    }\n    int lastPosition = findLastPosition(nums, target);\n    return new int[]{firstPosition, lastPosition};\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n完整代码如下：\n\n# 完整代码 1（其实就是把上面的三个代码拼凑出来）\n代码 4：\n\npublic class Solution {\n\n    public int[] searchRange(int[] nums, int target) {\n        if (nums.length == 0) {\n            return new int[]{-1, -1};\n        }\n        int firstPosition = findFirstPosition(nums, target);\n        if (firstPosition == -1) {\n            return new int[]{-1, -1};\n        }\n        int lastPosition = findLastPosition(nums, target);\n        return new int[]{firstPosition, lastPosition};\n    }\n\n\n    private int findFirstPosition(int[] nums, int target) {\n        int left = 0;\n        int right = nums.length - 1;\n\n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n            if (nums[mid] == target) {\n                // ① 不可以直接返回，应该继续向左边找，即 [left, mid - 1] 区间里找\n                right = mid - 1;\n            } else if (nums[mid] < target) {\n                // 应该继续向右边找，即 [mid + 1, right] 区间里找\n                left = mid + 1;\n            } else {\n                // 此时 nums[mid] > target，应该继续向左边找，即 [left, mid - 1] 区间里找\n                right = mid - 1;\n            }\n        }\n\n        // 此时 left 和 right 的位置关系是 [right, left]，注意上面的 ①，此时 left 才是第 1 次元素出现的位置\n        // 因此还需要特别做一次判断\n        if (left != nums.length && nums[left] == target) {\n            return left;\n        }\n        return -1;\n    }\n\n    private int findLastPosition(int[] nums, int target) {\n        int left = 0;\n        int right = nums.length - 1;\n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n            if (nums[mid] == target) {\n                // 只有这里不一样：不可以直接返回，应该继续向右边找，即 [mid + 1, right] 区间里找\n                left = mid + 1;\n            } else if (nums[mid] < target) {\n                // 应该继续向右边找，即 [mid + 1, right] 区间里找\n                left = mid + 1;\n            } else {\n                // 此时 nums[mid] > target，应该继续向左边找，即 [left, mid - 1] 区间里找\n                right = mid - 1;\n            }\n        }\n        // 由于 findFirstPosition 方法可以返回是否找到，这里无需单独再做判断\n        return right;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<int> searchRange(vector<int> &nums, int target) {\n        if (nums.empty()) {\n            return vector<int>{-1, -1};\n        }\n\n        int firstPosition = findFirstPosition(nums, target);\n        // 如果第 1 次出现的位置都找不到，肯定不存在最后 1 次出现的位置\n        if (firstPosition == -1) {\n            return vector<int>{-1, -1};\n        }\n        int lastPosition = findLastPosition(nums, target);\n        return vector<int>{firstPosition, lastPosition};\n    }\n\nprivate:\n    int findFirstPosition(vector<int> &nums, int target) {\n        int left = 0;\n        int right = nums.size() - 1;\n\n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n            if (nums[mid] == target) {\n                // ① 不可以直接返回，应该继续向左边找，即 [left, mid - 1] 区间里找\n                right = mid - 1;\n            } else if (nums[mid] < target) {\n                // 应该继续向右边找，即 [mid + 1, right] 区间里找\n                left = mid + 1;\n            } else {\n                // 此时 nums[mid] > target，应该继续向左边找，即 [left, mid - 1] 区间里找\n                right = mid - 1;\n            }\n        }\n\n        // 此时 left 和 right 的位置关系是 [right, left]，注意上面的 ①，此时 left 才是第 1 次元素出现的位置\n        // 因此还需要特别做一次判断\n        if (left != nums.size() && nums[left] == target) {\n            return left;\n        }\n        return -1;\n    }\n\n    int findLastPosition(vector<int> &nums, int target) {\n        int left = 0;\n        int right = nums.size() - 1;\n\n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n            if (nums[mid] == target) {\n                // 只有这里不一样：不可以直接返回，应该继续向右边找，即 [mid + 1, right] 区间里找\n                left = mid + 1;\n            } else if (nums[mid] < target) {\n                // 应该继续向右边找，即 [mid + 1, right] 区间里找\n                left = mid + 1;\n            } else {\n                // 此时 nums[mid] > target，应该继续向左边找，即 [left, mid - 1] 区间里找\n                right = mid - 1;\n            }\n        }\n        // 由于 findFirstPosition 方法可以返回是否找到，这里无需单独再做判断\n        return right;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n# 完整代码 2\n应评论区网友要求，写了一个不利用 findFirstPosition() 结果的版本，和「完整代码 1」没有本质上的区别。\n\n不利用 findFirstPosition() 的结果写 findLastPosition()。这里要注意，findLastPosition() 的逻辑当 left == right 的之后再执行下去，看 findLastPosition() 里面的逻辑，找到相等以后 left = mid + 1; 所以 left 右移一位，退出循环以后 right 在左，left 在右。因此 right 才是 target 最后一次出现的位置。但是要注意分支逻辑中有 right = mid - 1;，因此 right 有可能等于 -1 。所以退出循环以后要判断的逻辑是：\n\nif (right != -1 && nums[right] == target) {\n    return right;\n}\n\n\n1\n2\n3\n完整代码如下：\n\n代码 5：\n\nimport java.util.Arrays;\n\npublic class Solution {\n\n    public int[] searchRange(int[] nums, int target) {\n        if (nums.length == 0) {\n            return new int[]{-1, -1};\n        }\n        int firstPosition = findFirstPosition(nums, target);\n        int lastPosition = findLastPosition(nums, target);\n        return new int[]{firstPosition, lastPosition};\n    }\n\n\n    private int findFirstPosition(int[] nums, int target) {\n        int left = 0;\n        int right = nums.length - 1;\n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n\n            if (nums[mid] == target) {\n                // ① 不可以直接返回，应该继续向左边找，即 [left, mid - 1] 区间里找\n                right = mid - 1;\n            } else if (nums[mid] < target) {\n                // 应该继续向右边找，即 [mid + 1, right] 区间里找\n                left = mid + 1;\n            } else {\n                // 此时 nums[mid] > target，应该继续向左边找，即 [left, mid - 1] 区间里找\n                right = mid - 1;\n            }\n        }\n\n        // 此时 left 和 right 的位置关系是 [right, left]，注意上面的 ①，此时 left 才是第 1 次元素出现的位置\n        // 因此还需要特别做一次判断\n        if (left != nums.length && nums[left] == target) {\n            return left;\n        }\n        return -1;\n    }\n\n\n    private int findLastPosition(int[] nums, int target) {\n        int left = 0;\n        int right = nums.length - 1;\n\n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n            if (nums[mid] == target) {\n                // 只有这里不一样：不可以直接返回，应该继续向右边找，即 [mid + 1, right] 区间里找\n                left = mid + 1;\n            } else if (nums[mid] < target) {\n                // 应该继续向右边找，即 [mid + 1, right] 区间里找\n                left = mid + 1;\n            } else {\n                // 此时 nums[mid] > target，应该继续向左边找，即 [left, mid - 1] 区间里找\n                right = mid - 1;\n            }\n        }\n\n        if (right != -1 && nums[right] == target) {\n            return right;\n        }\n        return -1;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n# while(left < right) 写法的好处在于退出循环的时候 left 与 right 的重合\n至于 while(left < right) 的写法，建议大家参考本题的 题解 [https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/solution/si-lu-hen-jian-dan-xi-jie-fei-mo-gui-de-er-fen-cha/] 和第 35 题 高赞题解 [https://leetcode-cn.com/problems/search-insert-position/solution/te-bie-hao-yong-de-er-fen-cha-fa-fa-mo-ban-python-/]，我平常也多用 while(left < right) 的写法去思考复杂问题，确实可以少考虑很多细节，把思考的精力用于求解问题上。\n\n# while(left <= right) 与 while(left < right) 写法的区别\n这一部分也来自评论区网友的提问，我的理解如下：\n\n首先抓住它们最主要的特征：\n\n * while(left <= right) 在退出循环的时候 left = right + 1，即 right 在左，left 在右；\n * while(left < right) 在退出循环的时候，有 left == right 成立。\n\n我的经验是 left <= right 用在简单的二分问题中，如果题目要我们找的数的性质很简单，可以用这种写法，在循环体里找到了就退出。\n\n在一些复杂问题中，例如找一些边界的值（就比如当前这个问题），用 while(left < right) 其实是更简单的，把要找的数留到最后，在退出循环以后做判断。我觉得最重要的原因是退出循环以后有 left == right 成立，这种思考问题的方式不容易出错。\n\nwhile(left < right) 写法难点在于理解：初学的时候很难理解出现死循环的原因。特别是很难理解分支的取法决定中间数的取法。不过通过练习和调试，把这一关过了，相信解决一些难度较大的额额分查找问题就相对容易了。建议大家尝试使用 while(left < right) 的方式去解决一些较困难的问题。\n\n# while (left + 1 < right) 的写法\n一些资料上号称这是最无脑的写法，但是我有一些不同的意见：\n\n * 首先 while (left + 1 < right) 这种写法就很奇怪；\n * 其次，这种写法在设置边界的时候屏蔽了细节，全部写成 left = mid 和 right = mid，没有加 1 减 1，这一点虽然号称是优点，但我觉得是缺点，加 1 减 1 完全可以分析出来，屏蔽这个细节不能算是优点；\n * 退出循环的时候必须针对 left 和 right 编写逻辑，这是一个负担，增加了出错的可能；\n * 如果拿这种写法做当前这道题（LeetCode 第 34 题），就会发现代码很不好写。\n\n# 总结\n算法不能靠模板来学习，应该先理解思想，然后通过练习和思考巩固，这样在面对新问题的时候才不至于被一些边界和死循环给绕晕。\n\n# 提交历史\n提交时间提交结果标记状态我的注释执行时间战胜比例内存消耗语言2021-05-23 18:16:42Accepted [https://leetcode-cn.com/submissions/detail/180138860/]🚩边界情况的判断0 ms100.0%41.4 MBjava2021-05-23 18:15:05Runtime Error [https://leetcode-cn.com/submissions/detail/180138580/]N/AN/AN/Ajava2021-05-23 17:50:19Runtime Error [https://leetcode-cn.com/submissions/detail/180133108/]N/AN/AN/Ajava2021-05-23 17:48:25Runtime Error [https://leetcode-cn.com/submissions/detail/180132590/]N/AN/AN/Ajava2021-05-23 17:47:46Runtime Error [https://leetcode-cn.com/submissions/detail/180132422/]N/AN/AN/Ajava# 统计信息\n通过次数提交次数AC比率25680260477042.5%# 相似题目\n题目难度第一个错误的版本 [https://leetcode-cn.com/problems/first-bad-version/]简单",contentLowercase:"# 中文题目\n给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。\n\n如果数组中不存在目标值 target，返回[-1, -1]。\n\n进阶：\n\n * 你可以设计并实现时间复杂度为o(log n)的算法解决此问题吗？\n\n\n\n示例 1：\n\n\n输入：nums = [5,7,7,8,8,10], target = 8\n输出：[3,4]\n\n示例 2：\n\n\n输入：nums = [5,7,7,8,8,10], target = 6\n输出：[-1,-1]\n\n示例 3：\n\n\n输入：nums = [], target = 0\n输出：[-1,-1]\n\n\n\n提示：\n\n * 0 5\n * -1099\n * nums是一个非递减数组\n * -1099\n\n# 通过代码\nclass solution {\n        public int[] searchrange(int[] nums, int target) {\n            int[] res = {-1, -1};\n            if (nums.length == 0) {\n                return res;\n            }\n            int left = findleftpos(nums, target);\n            int right = findrightpos(nums, target);\n            //判断一下找到的值是否和目标值相等\n            if (left <= right && nums[left] == target) {\n                res[0] = left;\n            }\n            //需满足右边界大于等于左边界\n            if (right >= left && nums[right] == target) {\n                res[1] = right;\n            }\n            return res;\n        }\n\n        private int findrightpos(int[] nums, int target) {\n            int left = 0;\n            int right = nums.length - 1;\n            int mid;\n            while (left <= right) {\n                mid = left + (right - left) / 2;\n                // 如果左边的值一直小于等于目标值的话，就左哨兵往右移，找右边界\n                if (nums[mid] <= target) {\n                    left = mid + 1;\n                }\n                if (nums[mid] > target) {\n                    right = mid - 1;\n                }\n            }\n            return right;\n        }\n\n        private int findleftpos(int[] nums, int target) {\n            int left = 0;\n            int right = nums.length - 1;\n            int mid;\n            while (left <= right) {\n                mid = left + (right - left) / 2;\n                if (nums[mid] < target) {\n                    left = mid + 1;\n                }\n                // 如果右边的值一直大于等于目标值的话，就左哨兵往左移，找左边界\n                if (nums[mid] >= target) {\n                    right = mid - 1;\n                }\n            }\n            return left;\n        }\n    }\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n# 高赞题解\n二分查找在通常的资料里会介绍几种模板的写法，但我并不推荐通过模板学习算法的方式。我相信写算法没有那么模板，设计算法的人一定是通过了深入的思考，才设计出一个个精妙的算法和数据结构。\n\n请大家一定不要去记忆所谓的二分查找模板，一题一个模板，相当于没有模板。\n\n# 二分查找的三种写法\n二分查找通常有以下几种写法，区别主要在于 while 里面，\n\n形式结论与建议while (left <= right)简单问题用，在循环体里能找到答案以后退出。while (left < right)复杂问题用，把答案留到退出循环以后，再判断。是解决二分问题的利器，尤其在边界问题用，这种方式考虑细节最少，但是需要一定练习才能灵活运用。while (left + 1 < right)不建议，本质上和 while (left <= right) 写法一样，盲目套这个所谓的最无脑模板，反而学不会二分。其实理解这三种写法并不难。关键在于掌握：退出循环的时候，left 和 right 的位置关系。只需要掌握一种写法就可以了。\n\n# leetcode 第 34 题采用 while(left <= right)\n本篇题解采用 while(left <= right) 这种二分查找的写法，并分析如何在循环体里设置 left 和 right，和应该返回 left 和 right，即怎样思考边界问题。只要逻辑是完备，并且足够细心，写对二分查找问题并不困难。\n\n# 第 1 部分：查找 target 出现的第 1 个位置\n二分查找的基本用法是在一个有序数组里查找目标元素，具体是看区间中间元素的值 nums[mid] 与 target 的大小关系。\n\n * 如果等于，就可以直接返回；\n * 如果严格大于，就往右边查找；\n * 如果严格小于，就往左边查找。\n\n就这 333 种情况，先判断等于，然后再判断大于还是小于，符合人们正常的思维。\n\n具体到当前「力扣」第 34 题，由于一个元素出现多次，在具体分类讨论的时候，就有一点细微差别。\n\n（如果嫌下面文字多，可以直接看代码，都有注释。）\n\n * 如果当前看到的元素 恰好等于 target，那么当前元素有可能是 target 出现的第 111 个位置，由于我们要找第 111 个位置，此时我们应该向左边继续查找；\n * 如果当前看到的元素 严格大于 target，那么当前元素一定不是要找的 target 出现的第 111 个位置，第 111 个位置肯定出现在 mid 的 左边 ，因此就需要在 [left, mid] 区间里继续查找；\n * 如果当前看到的元素 严格小于 target，那么当前元素一定不是要找的 target 出现的第 111 个位置，第 111 个位置肯定出现在 mid 的 右边 ，因此就需要在 [mid + 1, right] 区间里继续查找。\n\n代码 1：\n\nprivate int findfirstposition(int[] nums, int target) {\n    int left = 0;\n    int right = nums.length - 1;\n\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n\n        if (nums[mid] == target) {\n            // ① 不可以直接返回，应该继续向左边找，即 [left..mid - 1] 区间里找\n            right = mid - 1;\n        } else if (nums[mid] < target) {\n            // 应该继续向右边找，即 [mid + 1, right] 区间里找\n            left = mid + 1;\n        } else {\n            // 此时 nums[mid] > target，应该继续向左边找，即 [left..mid - 1] 区间里找\n            right = mid - 1;\n        }\n    }\n\n    // 此时 left 和 right 的位置关系是 [right, left]，注意上面的 ①，此时 left 才是第 1 次元素出现的位置\n    // 因此还需要特别做一次判断\n    if (left != nums.length && nums[left] == target) {\n        return left;\n    }\n    return -1;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n解释：\n\n * 第 111 次出现的位置和最后 111 次出现的位置肯定都在数组里。因此，初始化的时候 left = 0 、 right = nums.length - 1；\n * nums[mid] == target 的时候，在 [left, mid - 1] 区间里找，有没有可能 nums[mid] 就是第 111 次出现的位置，有可能，但不要紧，退出循环的时候 right 指针在左，left 在右。如果数组里存在 target，那么 left 一定位于 target 出现的第 111 个位置，请看下图。\n\n\n\n还有一种特殊情况，当要查找的目标元素不存在的时，分两种情况：（1）target 很大，（2）target 很小：\n\n * target 很大，还是上面的例子\n\n\n\n * target 很小，还是上面的例子\n\n\n\n以上特殊例子，解释了为什么在 while (left <= right) 退出循环以后，需要单独判断 left 是否越界，以及判断 nums[left] 是不是目标元素的原因。\n\n# 第 2 部分：查找 target 出现的最后 1 个位置\n可以直接看注释。\n\n代码 2：\n\nprivate int findlastposition(int[] nums, int target) {\n    int left = 0;\n    int right = nums.length - 1;\n\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n\n        if (nums[mid] == target) {\n            // 只有这里不一样：不可以直接返回，应该继续向右边找，即 [mid + 1, right] 区间里找\n            left = mid + 1;\n        } else if (nums[mid] < target) {\n            // 应该继续向右边找，即 [mid + 1, right] 区间里找\n            left = mid + 1;\n        } else {\n            // 此时 nums[mid] > target，应该继续向左边找，即 [left, mid - 1] 区间里找\n            right = mid - 1;\n        }\n    }\n    // 由于 findfirstposition 方法可以返回是否找到，这里无需单独再做判断\n    return right;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n为什么返回 right 解释如下图：\n\n\n\n这里注意：无需讨论不存在的情况。这是因为先执行了 findfirstposition() 方法，这个方法如果返回 −1-1−1，显然我们就知道数组里不存在目标元素，可以直接返回 [-1, -1]。\n\n接下来，我们补上主调方法：\n\n代码 3：\n\npublic int[] searchrange(int[] nums, int target) {\n    if (nums.length == 0) {\n        return new int[]{-1, -1};\n    }\n    int firstposition = findfirstposition(nums, target);\n    // 如果第 1 次出现的位置都找不到，肯定不存在最后 1 次出现的位置\n    if (firstposition == -1) {\n        return new int[]{-1, -1};\n    }\n    int lastposition = findlastposition(nums, target);\n    return new int[]{firstposition, lastposition};\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n完整代码如下：\n\n# 完整代码 1（其实就是把上面的三个代码拼凑出来）\n代码 4：\n\npublic class solution {\n\n    public int[] searchrange(int[] nums, int target) {\n        if (nums.length == 0) {\n            return new int[]{-1, -1};\n        }\n        int firstposition = findfirstposition(nums, target);\n        if (firstposition == -1) {\n            return new int[]{-1, -1};\n        }\n        int lastposition = findlastposition(nums, target);\n        return new int[]{firstposition, lastposition};\n    }\n\n\n    private int findfirstposition(int[] nums, int target) {\n        int left = 0;\n        int right = nums.length - 1;\n\n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n            if (nums[mid] == target) {\n                // ① 不可以直接返回，应该继续向左边找，即 [left, mid - 1] 区间里找\n                right = mid - 1;\n            } else if (nums[mid] < target) {\n                // 应该继续向右边找，即 [mid + 1, right] 区间里找\n                left = mid + 1;\n            } else {\n                // 此时 nums[mid] > target，应该继续向左边找，即 [left, mid - 1] 区间里找\n                right = mid - 1;\n            }\n        }\n\n        // 此时 left 和 right 的位置关系是 [right, left]，注意上面的 ①，此时 left 才是第 1 次元素出现的位置\n        // 因此还需要特别做一次判断\n        if (left != nums.length && nums[left] == target) {\n            return left;\n        }\n        return -1;\n    }\n\n    private int findlastposition(int[] nums, int target) {\n        int left = 0;\n        int right = nums.length - 1;\n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n            if (nums[mid] == target) {\n                // 只有这里不一样：不可以直接返回，应该继续向右边找，即 [mid + 1, right] 区间里找\n                left = mid + 1;\n            } else if (nums[mid] < target) {\n                // 应该继续向右边找，即 [mid + 1, right] 区间里找\n                left = mid + 1;\n            } else {\n                // 此时 nums[mid] > target，应该继续向左边找，即 [left, mid - 1] 区间里找\n                right = mid - 1;\n            }\n        }\n        // 由于 findfirstposition 方法可以返回是否找到，这里无需单独再做判断\n        return right;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass solution {\npublic:\n    vector<int> searchrange(vector<int> &nums, int target) {\n        if (nums.empty()) {\n            return vector<int>{-1, -1};\n        }\n\n        int firstposition = findfirstposition(nums, target);\n        // 如果第 1 次出现的位置都找不到，肯定不存在最后 1 次出现的位置\n        if (firstposition == -1) {\n            return vector<int>{-1, -1};\n        }\n        int lastposition = findlastposition(nums, target);\n        return vector<int>{firstposition, lastposition};\n    }\n\nprivate:\n    int findfirstposition(vector<int> &nums, int target) {\n        int left = 0;\n        int right = nums.size() - 1;\n\n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n            if (nums[mid] == target) {\n                // ① 不可以直接返回，应该继续向左边找，即 [left, mid - 1] 区间里找\n                right = mid - 1;\n            } else if (nums[mid] < target) {\n                // 应该继续向右边找，即 [mid + 1, right] 区间里找\n                left = mid + 1;\n            } else {\n                // 此时 nums[mid] > target，应该继续向左边找，即 [left, mid - 1] 区间里找\n                right = mid - 1;\n            }\n        }\n\n        // 此时 left 和 right 的位置关系是 [right, left]，注意上面的 ①，此时 left 才是第 1 次元素出现的位置\n        // 因此还需要特别做一次判断\n        if (left != nums.size() && nums[left] == target) {\n            return left;\n        }\n        return -1;\n    }\n\n    int findlastposition(vector<int> &nums, int target) {\n        int left = 0;\n        int right = nums.size() - 1;\n\n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n            if (nums[mid] == target) {\n                // 只有这里不一样：不可以直接返回，应该继续向右边找，即 [mid + 1, right] 区间里找\n                left = mid + 1;\n            } else if (nums[mid] < target) {\n                // 应该继续向右边找，即 [mid + 1, right] 区间里找\n                left = mid + 1;\n            } else {\n                // 此时 nums[mid] > target，应该继续向左边找，即 [left, mid - 1] 区间里找\n                right = mid - 1;\n            }\n        }\n        // 由于 findfirstposition 方法可以返回是否找到，这里无需单独再做判断\n        return right;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n# 完整代码 2\n应评论区网友要求，写了一个不利用 findfirstposition() 结果的版本，和「完整代码 1」没有本质上的区别。\n\n不利用 findfirstposition() 的结果写 findlastposition()。这里要注意，findlastposition() 的逻辑当 left == right 的之后再执行下去，看 findlastposition() 里面的逻辑，找到相等以后 left = mid + 1; 所以 left 右移一位，退出循环以后 right 在左，left 在右。因此 right 才是 target 最后一次出现的位置。但是要注意分支逻辑中有 right = mid - 1;，因此 right 有可能等于 -1 。所以退出循环以后要判断的逻辑是：\n\nif (right != -1 && nums[right] == target) {\n    return right;\n}\n\n\n1\n2\n3\n完整代码如下：\n\n代码 5：\n\nimport java.util.arrays;\n\npublic class solution {\n\n    public int[] searchrange(int[] nums, int target) {\n        if (nums.length == 0) {\n            return new int[]{-1, -1};\n        }\n        int firstposition = findfirstposition(nums, target);\n        int lastposition = findlastposition(nums, target);\n        return new int[]{firstposition, lastposition};\n    }\n\n\n    private int findfirstposition(int[] nums, int target) {\n        int left = 0;\n        int right = nums.length - 1;\n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n\n            if (nums[mid] == target) {\n                // ① 不可以直接返回，应该继续向左边找，即 [left, mid - 1] 区间里找\n                right = mid - 1;\n            } else if (nums[mid] < target) {\n                // 应该继续向右边找，即 [mid + 1, right] 区间里找\n                left = mid + 1;\n            } else {\n                // 此时 nums[mid] > target，应该继续向左边找，即 [left, mid - 1] 区间里找\n                right = mid - 1;\n            }\n        }\n\n        // 此时 left 和 right 的位置关系是 [right, left]，注意上面的 ①，此时 left 才是第 1 次元素出现的位置\n        // 因此还需要特别做一次判断\n        if (left != nums.length && nums[left] == target) {\n            return left;\n        }\n        return -1;\n    }\n\n\n    private int findlastposition(int[] nums, int target) {\n        int left = 0;\n        int right = nums.length - 1;\n\n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n            if (nums[mid] == target) {\n                // 只有这里不一样：不可以直接返回，应该继续向右边找，即 [mid + 1, right] 区间里找\n                left = mid + 1;\n            } else if (nums[mid] < target) {\n                // 应该继续向右边找，即 [mid + 1, right] 区间里找\n                left = mid + 1;\n            } else {\n                // 此时 nums[mid] > target，应该继续向左边找，即 [left, mid - 1] 区间里找\n                right = mid - 1;\n            }\n        }\n\n        if (right != -1 && nums[right] == target) {\n            return right;\n        }\n        return -1;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n# while(left < right) 写法的好处在于退出循环的时候 left 与 right 的重合\n至于 while(left < right) 的写法，建议大家参考本题的 题解 [https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/solution/si-lu-hen-jian-dan-xi-jie-fei-mo-gui-de-er-fen-cha/] 和第 35 题 高赞题解 [https://leetcode-cn.com/problems/search-insert-position/solution/te-bie-hao-yong-de-er-fen-cha-fa-fa-mo-ban-python-/]，我平常也多用 while(left < right) 的写法去思考复杂问题，确实可以少考虑很多细节，把思考的精力用于求解问题上。\n\n# while(left <= right) 与 while(left < right) 写法的区别\n这一部分也来自评论区网友的提问，我的理解如下：\n\n首先抓住它们最主要的特征：\n\n * while(left <= right) 在退出循环的时候 left = right + 1，即 right 在左，left 在右；\n * while(left < right) 在退出循环的时候，有 left == right 成立。\n\n我的经验是 left <= right 用在简单的二分问题中，如果题目要我们找的数的性质很简单，可以用这种写法，在循环体里找到了就退出。\n\n在一些复杂问题中，例如找一些边界的值（就比如当前这个问题），用 while(left < right) 其实是更简单的，把要找的数留到最后，在退出循环以后做判断。我觉得最重要的原因是退出循环以后有 left == right 成立，这种思考问题的方式不容易出错。\n\nwhile(left < right) 写法难点在于理解：初学的时候很难理解出现死循环的原因。特别是很难理解分支的取法决定中间数的取法。不过通过练习和调试，把这一关过了，相信解决一些难度较大的额额分查找问题就相对容易了。建议大家尝试使用 while(left < right) 的方式去解决一些较困难的问题。\n\n# while (left + 1 < right) 的写法\n一些资料上号称这是最无脑的写法，但是我有一些不同的意见：\n\n * 首先 while (left + 1 < right) 这种写法就很奇怪；\n * 其次，这种写法在设置边界的时候屏蔽了细节，全部写成 left = mid 和 right = mid，没有加 1 减 1，这一点虽然号称是优点，但我觉得是缺点，加 1 减 1 完全可以分析出来，屏蔽这个细节不能算是优点；\n * 退出循环的时候必须针对 left 和 right 编写逻辑，这是一个负担，增加了出错的可能；\n * 如果拿这种写法做当前这道题（leetcode 第 34 题），就会发现代码很不好写。\n\n# 总结\n算法不能靠模板来学习，应该先理解思想，然后通过练习和思考巩固，这样在面对新问题的时候才不至于被一些边界和死循环给绕晕。\n\n# 提交历史\n提交时间提交结果标记状态我的注释执行时间战胜比例内存消耗语言2021-05-23 18:16:42accepted [https://leetcode-cn.com/submissions/detail/180138860/]🚩边界情况的判断0 ms100.0%41.4 mbjava2021-05-23 18:15:05runtime error [https://leetcode-cn.com/submissions/detail/180138580/]n/an/an/ajava2021-05-23 17:50:19runtime error [https://leetcode-cn.com/submissions/detail/180133108/]n/an/an/ajava2021-05-23 17:48:25runtime error [https://leetcode-cn.com/submissions/detail/180132590/]n/an/an/ajava2021-05-23 17:47:46runtime error [https://leetcode-cn.com/submissions/detail/180132422/]n/an/an/ajava# 统计信息\n通过次数提交次数ac比率25680260477042.5%# 相似题目\n题目难度第一个错误的版本 [https://leetcode-cn.com/problems/first-bad-version/]简单"},{title:"39-组合总和(Combination Sum)",frontmatter:{title:"39-组合总和(Combination Sum)",date:"2018-09-11T00:00:00.000Z",categories:["中等"],tags:["数组<Array>","回溯算法<Backtracking>"]},regularPath:"/views/%E4%B8%AD%E7%AD%89/0039-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C.html",relativePath:"views/中等/0039-组合总和.md",key:"v-40896626",path:"/views/%E4%B8%AD%E7%AD%89/0039-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C.html",headers:[{level:2,title:"中文题目",slug:"中文题目",charIndex:2},{level:2,title:"通过代码",slug:"通过代码",charIndex:317},{level:2,title:"高赞题解",slug:"高赞题解",charIndex:2542},{level:2,title:"提交历史",slug:"提交历史",charIndex:10478},{level:2,title:"统计信息",slug:"统计信息",charIndex:11107},{level:2,title:"相似题目",slug:"相似题目",charIndex:11141}],lastUpdated:"4/11/2021, 1:15:21 PM",headersStr:"中文题目 通过代码 高赞题解 提交历史 统计信息 相似题目",content:"# 中文题目\n给定一个无重复元素的数组candidates和一个目标数target，找出candidates中所有可以使数字和为target的组合。\n\ncandidates中的数字可以无限制重复被选取。\n\n说明：\n\n * 所有数字（包括target）都是正整数。\n * 解集不能包含重复的组合。\n\n示例 1:\n\n输入: candidates = [2,3,6,7], target = 7,\n所求解集为:\n[\n  [7],\n  [2,2,3]\n]\n\n\n示例 2:\n\n输入: candidates = [2,3,5], target = 8,\n所求解集为:\n[\n  [2,2,2,2],\n  [2,3,3],\n  [3,5]\n]\n\n# 通过代码\nclass Solution {\n     public List<List<Integer>> combinationSum(int[] candidates, int target) {\n            List<List<Integer>> res=new LinkedList<List<Integer>>();\n            if (candidates==null || candidates.length==0){\n                return res;\n            }\n            LinkedList<Integer> list=new LinkedList<Integer>();\n            Arrays.sort(candidates);\n//            对于这种存在顺序的，可以把其实位置放在一起递归\n            dfs(candidates,list,res,target,0);\n            return res;\n        }\n\n        private void dfs(int[] candidates,  LinkedList<Integer> list, List<List<Integer>> res, int target,int start) {\n            if (target==0){\n                res.add(new LinkedList<Integer>(list));\n                return;\n            }\n            for (int i = start; i < candidates.length; i++) {\n                if (candidates[i]<=target){\n                    list.addLast(candidates[i]);\n                    dfs(candidates,list,res,target-candidates[i],i);\n                    list.removeLast();\n                }\n            }\n        }\n\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\nclass Solution {\n     public List<List<Integer>> combinationSum(int[] candidates, int target) {\n            List<List<Integer>> res=new LinkedList<List<Integer>>();\n            if (candidates==null || candidates.length==0){\n                return res;\n            }\n            LinkedList<Integer> list=new LinkedList<Integer>();\n            Arrays.sort(candidates);\n//            对于这种存在顺序的，可以把其实位置放在一起递归\n            dfs(candidates,list,res,target,0);\n            return res;\n        }\n\n        private void dfs(int[] candidates,  LinkedList<Integer> list, List<List<Integer>> res, int target,int start) {\n            if (target==0){\n                res.add(new LinkedList<Integer>(list));\n                return;\n            }\n            for (int i = start; i < candidates.length; i++) {\n                if (candidates[i]<=target){\n                    list.addLast(candidates[i]);\n                    dfs(candidates,list,res,target-candidates[i],i);\n                    list.removeLast();\n                }\n            }\n        }\n\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n# 高赞题解\n# 解题思路：\n做搜索、回溯问题的套路是画图，代码其实就是根据画出的树形图写出来的。\n\n那么如何画图呢？\n\n * 根据题目中的用例，画一个图，因为是搜索，因此呈现的是一个树形结构图，并且在这个树形结构中会体现出递归结构。\n * 根据题目中的用例，比对自己画图的结果和题目的结果的差异，如果一样，说明我们的分析没有错；如果不一样，说明我们的分析有误，一定有哪一个环节漏掉了或者分析错误，根据找到的问题调整算法。\n\n下面我具体说一下，本来想展示草稿的，奈何本人画的图太难看，还是用软件画图给大家看吧。\n\n针对示例 1：\n\n> 输入: candidates = [2, 3, 6, 7]，target = 7，所求解集为: [[7], [2, 2, 3]]\n\n\n一开始我画的图是这样的：\n\n思路：以 target = 7 为根结点，每一个分支做减法。减到 000 或者负数的时候，剪枝。其中，减到 000 的时候结算，这里 “结算” 的意思是添加到结果集。\n\n{:width=600} {:align=center}\n\n我把其中文字的部分去掉了，这样大家看得清楚一点：\n\n{:width=600} {:align=center}\n\n说明：\n\n1、一个蓝色正方形表示的是 “尝试将这个数到数组 candidates 中找组合”，那么怎么找呢？挨个减掉那些数就可以了。\n\n2、在减的过程中，会得到 000 和负数，也就是被我标红色和粉色的结点：\n\n * 得到 000 是我们喜欢的，从 000 这一点向根结点走的路径（很可能只走过一条边，也算一个路径），就是一个组合，在这一点要做一次结算（把根结点到 000 所经过的路径，加入结果集）。\n   \n   \n * 得到负数就说明这条路走不通，没有必要再走下去了。\n   \n   \n\n总结一下：在减的过程中，得到 000 或者负数，就没有必要再走下去，所以这两种情况就分别表示成为叶子结点。此时递归结束，然后要发生回溯。\n\n画出图以后，我看了一下，我这张图画出的结果有 444 个 000，对应的路径是 [[2, 2, 3], [2, 3, 2], [3, 2, 2], [7]]，而示例中的解集只有 [[7], [2, 2, 3]]，很显然，我的分析出现了问题。问题是很显然的，我的结果集出现了重复。重复的原因是\n\n> 后面分支的更深层的边出现了前面分支低层的边的值。\n\n\n限于我的表达能力有限，大伙意会这句话就可以了，看一看重复的叶子结点 000 的路径，想一想重复的原因，或许你会比我说得更清楚更好。\n\n但是这个问题也不难解决，把候选数组排个序就好了（想一下，结果数组排个序是不是也可以去重），后面选取的数不能比前面选的数还要小，即 “更深层的边上的数值不能比它上层的边上的数值小”，按照这种策略，剪枝就可以去掉重复的组合。\n\n{:width=600} {:align=center}\n\n# 参考代码：\n这里感谢 @rmokerone [/u/rmokerone] 提供的 C++ 代码实现。\n\nfrom typing import List\n\n\nclass Solution:\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\n        size = len(candidates)\n        if size == 0:\n            return []\n\n        # 剪枝的前提是数组元素排序\n        # 深度深的边不能比深度浅的边还小\n        # 要排序的理由：1、前面用过的数后面不能再用；2、下一层边上的数不能小于上一层边上的数。\n        candidates.sort()\n        # 在遍历的过程中记录路径，一般而言它是一个栈\n        path = []\n        res = []\n        # 注意要传入 size ，在 range 中， size 取不到\n        self.__dfs(candidates, 0, size, path, res, target)\n        return res\n\n    def __dfs(self, candidates, begin, size, path, res, target):\n        # 先写递归终止的情况\n        if target == 0:\n            # Python 中可变对象是引用传递，因此需要将当前 path 里的值拷贝出来\n            # 或者使用 path.copy()\n            res.append(path[:])\n\n        for index in range(begin, size):\n            residue = target - candidates[index]\n            // “剪枝”操作，不必递归到下一层，并且后面的分支也不必执行\n            if residue < 0:\n                break\n            path.append(candidates[index])\n            # 因为下一层不能比上一层还小，起始索引还从 index 开始\n            self.__dfs(candidates, index, size, path, res, residue)\n            path.pop()\n\n\nif __name__ == '__main__':\n    candidates = [2, 3, 6, 7]\n    target = 7\n    solution = Solution()\n    result = solution.combinationSum(candidates, target)\n    print(result)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Stack;\n\npublic class Solution {\n\n    private List<List<Integer>> res = new ArrayList<>();\n    private int[] candidates;\n    private int len;\n\n    private void findCombinationSum(int residue, int start, Stack<Integer> pre) {\n        if (residue == 0) {\n            // Java 中可变对象是引用传递，因此需要将当前 path 里的值拷贝出来\n            res.add(new ArrayList<>(pre));\n            return;\n        }\n        // 优化添加的代码2：在循环的时候做判断，尽量避免系统栈的深度\n        // residue - candidates[i] 表示下一轮的剩余，如果下一轮的剩余都小于 0 ，就没有必要进行后面的循环了\n        // 这一点基于原始数组是排序数组的前提，因为如果计算后面的剩余，只会越来越小\n        for (int i = start; i < len && residue - candidates[i] >= 0; i++) {\n            pre.add(candidates[i]);\n            // 【关键】因为元素可以重复使用，这里递归传递下去的是 i 而不是 i + 1\n            findCombinationSum(residue - candidates[i], i, pre);\n            pre.pop();\n        }\n    }\n\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\n        int len = candidates.length;\n        if (len == 0) {\n            return res;\n        }\n        // 优化添加的代码1：先对数组排序，可以提前终止判断\n        Arrays.sort(candidates);\n        this.len = len;\n        this.candidates = candidates;\n        findCombinationSum(target, 0, new Stack<>());\n        return res;\n    }\n\n    public static void main(String[] args) {\n        int[] candidates = {2, 3, 6, 7};\n        int target = 7;\n        Solution solution = new Solution();\n        List<List<Integer>> combinationSum = solution.combinationSum(candidates, target);\n        System.out.println(combinationSum);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n// author:rmokerone\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\nprivate:\n    vector<int> candidates;\n    vector<vector<int>> res;\n    vector<int> path;\npublic:\n    void DFS(int start, int target) {\n        if (target == 0) {\n            res.push_back(path);\n            return;\n        }\n        for (int i = start;\n             i < candidates.size() && target - candidates[i] >= 0; i++) {\n            path.push_back(candidates[i]);\n            DFS(i, target - candidates[i]);\n            path.pop_back();\n        }\n    }\n\n    vector<vector<int>> combinationSum(vector<int> &candidates, int target) {\n        std::sort(candidates.begin(), candidates.end());\n        this->candidates = candidates;\n        DFS(0, target);\n\n        return res;\n    }\n\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n补充：事实上，不排序也是可以的，只要保证按顺序读取，也可以通过测试用例，我个人还是觉得排序更好一些，这样“剪枝”工作可以更彻底一些。\n\n# 参考代码：\n如果没有事先将数组 nums 排序，剪枝操作就没有办法执行，虽然可以得到正确结果，但搜索时间更长。\n\nfrom typing import List\n\n\n# 不排序的写法，只有遇到减到负数的时候剪枝\n\nclass Solution:\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\n        size = len(candidates)\n        if size == 0:\n            return []\n\n        res = []\n        self.__dfs(candidates, size, 0, [], target, res)\n        return res\n\n    def __dfs(self, candidates, size, start, path, residue, res):\n        if residue < 0:\n            return\n        if residue == 0:\n            res.append(path[:])\n            return\n\n        for index in range(start, size):\n            path.append(candidates[index])\n            # 注意：因为数字可以无限制重复被选取，因此起始位置还是自己\n            self.__dfs(candidates, size, index, path, residue - candidates[index], res)\n            path.pop()\n\n\nif __name__ == '__main__':\n    candidates = [2, 3, 6, 7]\n    target = 7\n    solution = Solution()\n    result = solution.combinationSum(candidates, target)\n    print(result)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Stack;\n\npublic class Solution {\n\n    private List<List<Integer>> res = new ArrayList<>();\n    private int[] candidates;\n    private int len;\n\n    private void findCombinationSum(int residue, int start, Stack<Integer> pre) {\n        if (residue < 0) {\n            return;\n        }\n        if (residue == 0) {\n            res.add(new ArrayList<>(pre));\n            return;\n        }\n        for (int i = start; i < len; i++) {\n            pre.add(candidates[i]);\n            findCombinationSum(residue - candidates[i], i, pre);\n            pre.pop();\n        }\n    }\n\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\n        int len = candidates.length;\n        if (len == 0) {\n            return res;\n        }\n        this.len = len;\n        this.candidates = candidates;\n        findCombinationSum(target, 0, new Stack<>());\n        return res;\n    }\n\n    public static void main(String[] args) {\n        int[] candidates = {2, 3, 6, 7};\n        int target = 7;\n        Solution3 solution = new Solution3();\n        List<List<Integer>> combinationSum = solution.combinationSum(candidates, target);\n        System.out.println(combinationSum);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n附注：这道题我用的是减法，有兴趣的朋友还可以使用加法，加到 target 的时候结算，超过 target 的时候剪枝。\n\n做完这题的朋友，不妨做一下 LeetCode 第 40 题：组合问题 II。\n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-09-11 22:55:39Accepted [https://leetcode-cn.com//submissions/detail/6937983/]21 ms13.19%N/Ajava2018-09-11 22:55:25Accepted [https://leetcode-cn.com//submissions/detail/6937965/]21 ms13.19%N/Ajava2018-09-11 22:37:35Compile Error [https://leetcode-cn.com//submissions/detail/6936573/]N/AN/AN/Ajava2018-09-11 21:53:20Compile Error [https://leetcode-cn.com//submissions/detail/6933901/]N/AN/AN/Ajava2018-09-11 21:25:53Compile Error [https://leetcode-cn.com//submissions/detail/6932252/]N/AN/AN/Ajava2018-09-11 21:21:51Compile Error [https://leetcode-cn.com//submissions/detail/6932053/]N/AN/AN/Ajava# 统计信息\n通过次数提交次数AC比率568518363168.0%# 相似题目\n题目难度电话号码的字母组合 [https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/]中等组合总和 II [https://leetcode-cn.com/problems/combination-sum-ii/]中等组合 [https://leetcode-cn.com/problems/combinations/]中等组合总和 III [https://leetcode-cn.com/problems/combination-sum-iii/]中等因子的组合 [https://leetcode-cn.com/problems/factor-combinations/]中等组合总和 Ⅳ [https://leetcode-cn.com/problems/combination-sum-iv/]中等",contentLowercase:"# 中文题目\n给定一个无重复元素的数组candidates和一个目标数target，找出candidates中所有可以使数字和为target的组合。\n\ncandidates中的数字可以无限制重复被选取。\n\n说明：\n\n * 所有数字（包括target）都是正整数。\n * 解集不能包含重复的组合。\n\n示例 1:\n\n输入: candidates = [2,3,6,7], target = 7,\n所求解集为:\n[\n  [7],\n  [2,2,3]\n]\n\n\n示例 2:\n\n输入: candidates = [2,3,5], target = 8,\n所求解集为:\n[\n  [2,2,2,2],\n  [2,3,3],\n  [3,5]\n]\n\n# 通过代码\nclass solution {\n     public list<list<integer>> combinationsum(int[] candidates, int target) {\n            list<list<integer>> res=new linkedlist<list<integer>>();\n            if (candidates==null || candidates.length==0){\n                return res;\n            }\n            linkedlist<integer> list=new linkedlist<integer>();\n            arrays.sort(candidates);\n//            对于这种存在顺序的，可以把其实位置放在一起递归\n            dfs(candidates,list,res,target,0);\n            return res;\n        }\n\n        private void dfs(int[] candidates,  linkedlist<integer> list, list<list<integer>> res, int target,int start) {\n            if (target==0){\n                res.add(new linkedlist<integer>(list));\n                return;\n            }\n            for (int i = start; i < candidates.length; i++) {\n                if (candidates[i]<=target){\n                    list.addlast(candidates[i]);\n                    dfs(candidates,list,res,target-candidates[i],i);\n                    list.removelast();\n                }\n            }\n        }\n\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\nclass solution {\n     public list<list<integer>> combinationsum(int[] candidates, int target) {\n            list<list<integer>> res=new linkedlist<list<integer>>();\n            if (candidates==null || candidates.length==0){\n                return res;\n            }\n            linkedlist<integer> list=new linkedlist<integer>();\n            arrays.sort(candidates);\n//            对于这种存在顺序的，可以把其实位置放在一起递归\n            dfs(candidates,list,res,target,0);\n            return res;\n        }\n\n        private void dfs(int[] candidates,  linkedlist<integer> list, list<list<integer>> res, int target,int start) {\n            if (target==0){\n                res.add(new linkedlist<integer>(list));\n                return;\n            }\n            for (int i = start; i < candidates.length; i++) {\n                if (candidates[i]<=target){\n                    list.addlast(candidates[i]);\n                    dfs(candidates,list,res,target-candidates[i],i);\n                    list.removelast();\n                }\n            }\n        }\n\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n# 高赞题解\n# 解题思路：\n做搜索、回溯问题的套路是画图，代码其实就是根据画出的树形图写出来的。\n\n那么如何画图呢？\n\n * 根据题目中的用例，画一个图，因为是搜索，因此呈现的是一个树形结构图，并且在这个树形结构中会体现出递归结构。\n * 根据题目中的用例，比对自己画图的结果和题目的结果的差异，如果一样，说明我们的分析没有错；如果不一样，说明我们的分析有误，一定有哪一个环节漏掉了或者分析错误，根据找到的问题调整算法。\n\n下面我具体说一下，本来想展示草稿的，奈何本人画的图太难看，还是用软件画图给大家看吧。\n\n针对示例 1：\n\n> 输入: candidates = [2, 3, 6, 7]，target = 7，所求解集为: [[7], [2, 2, 3]]\n\n\n一开始我画的图是这样的：\n\n思路：以 target = 7 为根结点，每一个分支做减法。减到 000 或者负数的时候，剪枝。其中，减到 000 的时候结算，这里 “结算” 的意思是添加到结果集。\n\n{:width=600} {:align=center}\n\n我把其中文字的部分去掉了，这样大家看得清楚一点：\n\n{:width=600} {:align=center}\n\n说明：\n\n1、一个蓝色正方形表示的是 “尝试将这个数到数组 candidates 中找组合”，那么怎么找呢？挨个减掉那些数就可以了。\n\n2、在减的过程中，会得到 000 和负数，也就是被我标红色和粉色的结点：\n\n * 得到 000 是我们喜欢的，从 000 这一点向根结点走的路径（很可能只走过一条边，也算一个路径），就是一个组合，在这一点要做一次结算（把根结点到 000 所经过的路径，加入结果集）。\n   \n   \n * 得到负数就说明这条路走不通，没有必要再走下去了。\n   \n   \n\n总结一下：在减的过程中，得到 000 或者负数，就没有必要再走下去，所以这两种情况就分别表示成为叶子结点。此时递归结束，然后要发生回溯。\n\n画出图以后，我看了一下，我这张图画出的结果有 444 个 000，对应的路径是 [[2, 2, 3], [2, 3, 2], [3, 2, 2], [7]]，而示例中的解集只有 [[7], [2, 2, 3]]，很显然，我的分析出现了问题。问题是很显然的，我的结果集出现了重复。重复的原因是\n\n> 后面分支的更深层的边出现了前面分支低层的边的值。\n\n\n限于我的表达能力有限，大伙意会这句话就可以了，看一看重复的叶子结点 000 的路径，想一想重复的原因，或许你会比我说得更清楚更好。\n\n但是这个问题也不难解决，把候选数组排个序就好了（想一下，结果数组排个序是不是也可以去重），后面选取的数不能比前面选的数还要小，即 “更深层的边上的数值不能比它上层的边上的数值小”，按照这种策略，剪枝就可以去掉重复的组合。\n\n{:width=600} {:align=center}\n\n# 参考代码：\n这里感谢 @rmokerone [/u/rmokerone] 提供的 c++ 代码实现。\n\nfrom typing import list\n\n\nclass solution:\n    def combinationsum(self, candidates: list[int], target: int) -> list[list[int]]:\n        size = len(candidates)\n        if size == 0:\n            return []\n\n        # 剪枝的前提是数组元素排序\n        # 深度深的边不能比深度浅的边还小\n        # 要排序的理由：1、前面用过的数后面不能再用；2、下一层边上的数不能小于上一层边上的数。\n        candidates.sort()\n        # 在遍历的过程中记录路径，一般而言它是一个栈\n        path = []\n        res = []\n        # 注意要传入 size ，在 range 中， size 取不到\n        self.__dfs(candidates, 0, size, path, res, target)\n        return res\n\n    def __dfs(self, candidates, begin, size, path, res, target):\n        # 先写递归终止的情况\n        if target == 0:\n            # python 中可变对象是引用传递，因此需要将当前 path 里的值拷贝出来\n            # 或者使用 path.copy()\n            res.append(path[:])\n\n        for index in range(begin, size):\n            residue = target - candidates[index]\n            // “剪枝”操作，不必递归到下一层，并且后面的分支也不必执行\n            if residue < 0:\n                break\n            path.append(candidates[index])\n            # 因为下一层不能比上一层还小，起始索引还从 index 开始\n            self.__dfs(candidates, index, size, path, res, residue)\n            path.pop()\n\n\nif __name__ == '__main__':\n    candidates = [2, 3, 6, 7]\n    target = 7\n    solution = solution()\n    result = solution.combinationsum(candidates, target)\n    print(result)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\nimport java.util.arraylist;\nimport java.util.arrays;\nimport java.util.list;\nimport java.util.stack;\n\npublic class solution {\n\n    private list<list<integer>> res = new arraylist<>();\n    private int[] candidates;\n    private int len;\n\n    private void findcombinationsum(int residue, int start, stack<integer> pre) {\n        if (residue == 0) {\n            // java 中可变对象是引用传递，因此需要将当前 path 里的值拷贝出来\n            res.add(new arraylist<>(pre));\n            return;\n        }\n        // 优化添加的代码2：在循环的时候做判断，尽量避免系统栈的深度\n        // residue - candidates[i] 表示下一轮的剩余，如果下一轮的剩余都小于 0 ，就没有必要进行后面的循环了\n        // 这一点基于原始数组是排序数组的前提，因为如果计算后面的剩余，只会越来越小\n        for (int i = start; i < len && residue - candidates[i] >= 0; i++) {\n            pre.add(candidates[i]);\n            // 【关键】因为元素可以重复使用，这里递归传递下去的是 i 而不是 i + 1\n            findcombinationsum(residue - candidates[i], i, pre);\n            pre.pop();\n        }\n    }\n\n    public list<list<integer>> combinationsum(int[] candidates, int target) {\n        int len = candidates.length;\n        if (len == 0) {\n            return res;\n        }\n        // 优化添加的代码1：先对数组排序，可以提前终止判断\n        arrays.sort(candidates);\n        this.len = len;\n        this.candidates = candidates;\n        findcombinationsum(target, 0, new stack<>());\n        return res;\n    }\n\n    public static void main(string[] args) {\n        int[] candidates = {2, 3, 6, 7};\n        int target = 7;\n        solution solution = new solution();\n        list<list<integer>> combinationsum = solution.combinationsum(candidates, target);\n        system.out.println(combinationsum);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n// author:rmokerone\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass solution {\nprivate:\n    vector<int> candidates;\n    vector<vector<int>> res;\n    vector<int> path;\npublic:\n    void dfs(int start, int target) {\n        if (target == 0) {\n            res.push_back(path);\n            return;\n        }\n        for (int i = start;\n             i < candidates.size() && target - candidates[i] >= 0; i++) {\n            path.push_back(candidates[i]);\n            dfs(i, target - candidates[i]);\n            path.pop_back();\n        }\n    }\n\n    vector<vector<int>> combinationsum(vector<int> &candidates, int target) {\n        std::sort(candidates.begin(), candidates.end());\n        this->candidates = candidates;\n        dfs(0, target);\n\n        return res;\n    }\n\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n补充：事实上，不排序也是可以的，只要保证按顺序读取，也可以通过测试用例，我个人还是觉得排序更好一些，这样“剪枝”工作可以更彻底一些。\n\n# 参考代码：\n如果没有事先将数组 nums 排序，剪枝操作就没有办法执行，虽然可以得到正确结果，但搜索时间更长。\n\nfrom typing import list\n\n\n# 不排序的写法，只有遇到减到负数的时候剪枝\n\nclass solution:\n    def combinationsum(self, candidates: list[int], target: int) -> list[list[int]]:\n        size = len(candidates)\n        if size == 0:\n            return []\n\n        res = []\n        self.__dfs(candidates, size, 0, [], target, res)\n        return res\n\n    def __dfs(self, candidates, size, start, path, residue, res):\n        if residue < 0:\n            return\n        if residue == 0:\n            res.append(path[:])\n            return\n\n        for index in range(start, size):\n            path.append(candidates[index])\n            # 注意：因为数字可以无限制重复被选取，因此起始位置还是自己\n            self.__dfs(candidates, size, index, path, residue - candidates[index], res)\n            path.pop()\n\n\nif __name__ == '__main__':\n    candidates = [2, 3, 6, 7]\n    target = 7\n    solution = solution()\n    result = solution.combinationsum(candidates, target)\n    print(result)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\nimport java.util.arraylist;\nimport java.util.arrays;\nimport java.util.list;\nimport java.util.stack;\n\npublic class solution {\n\n    private list<list<integer>> res = new arraylist<>();\n    private int[] candidates;\n    private int len;\n\n    private void findcombinationsum(int residue, int start, stack<integer> pre) {\n        if (residue < 0) {\n            return;\n        }\n        if (residue == 0) {\n            res.add(new arraylist<>(pre));\n            return;\n        }\n        for (int i = start; i < len; i++) {\n            pre.add(candidates[i]);\n            findcombinationsum(residue - candidates[i], i, pre);\n            pre.pop();\n        }\n    }\n\n    public list<list<integer>> combinationsum(int[] candidates, int target) {\n        int len = candidates.length;\n        if (len == 0) {\n            return res;\n        }\n        this.len = len;\n        this.candidates = candidates;\n        findcombinationsum(target, 0, new stack<>());\n        return res;\n    }\n\n    public static void main(string[] args) {\n        int[] candidates = {2, 3, 6, 7};\n        int target = 7;\n        solution3 solution = new solution3();\n        list<list<integer>> combinationsum = solution.combinationsum(candidates, target);\n        system.out.println(combinationsum);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n附注：这道题我用的是减法，有兴趣的朋友还可以使用加法，加到 target 的时候结算，超过 target 的时候剪枝。\n\n做完这题的朋友，不妨做一下 leetcode 第 40 题：组合问题 ii。\n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-09-11 22:55:39accepted [https://leetcode-cn.com//submissions/detail/6937983/]21 ms13.19%n/ajava2018-09-11 22:55:25accepted [https://leetcode-cn.com//submissions/detail/6937965/]21 ms13.19%n/ajava2018-09-11 22:37:35compile error [https://leetcode-cn.com//submissions/detail/6936573/]n/an/an/ajava2018-09-11 21:53:20compile error [https://leetcode-cn.com//submissions/detail/6933901/]n/an/an/ajava2018-09-11 21:25:53compile error [https://leetcode-cn.com//submissions/detail/6932252/]n/an/an/ajava2018-09-11 21:21:51compile error [https://leetcode-cn.com//submissions/detail/6932053/]n/an/an/ajava# 统计信息\n通过次数提交次数ac比率568518363168.0%# 相似题目\n题目难度电话号码的字母组合 [https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/]中等组合总和 ii [https://leetcode-cn.com/problems/combination-sum-ii/]中等组合 [https://leetcode-cn.com/problems/combinations/]中等组合总和 iii [https://leetcode-cn.com/problems/combination-sum-iii/]中等因子的组合 [https://leetcode-cn.com/problems/factor-combinations/]中等组合总和 ⅳ [https://leetcode-cn.com/problems/combination-sum-iv/]中等"},{title:"24-两两交换链表中的节点(Swap Nodes in Pairs)",frontmatter:{title:"24-两两交换链表中的节点(Swap Nodes in Pairs)",date:"2021-04-11T00:00:00.000Z",categories:["中等"],tags:["递归<Recursion>","链表<Linked List>"]},regularPath:"/views/%E4%B8%AD%E7%AD%89/0024-%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9.html",relativePath:"views/中等/0024-两两交换链表中的节点.md",key:"v-2b081e4c",path:"/views/%E4%B8%AD%E7%AD%89/0024-%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9.html",headers:[{level:2,title:"中文题目",slug:"中文题目",charIndex:2},{level:2,title:"通过代码",slug:"通过代码",charIndex:263},{level:2,title:"高赞题解",slug:"高赞题解",charIndex:2791},{level:3,title:"解题思路",slug:"解题思路",charIndex:2798},{level:3,title:"代码",slug:"代码",charIndex:265},{level:3,title:"画解",slug:"画解",charIndex:4046},{level:2,title:"提交历史",slug:"提交历史",charIndex:4173},{level:2,title:"统计信息",slug:"统计信息",charIndex:4508},{level:2,title:"相似题目",slug:"相似题目",charIndex:4544}],lastUpdated:"4/11/2021, 1:15:21 PM",headersStr:"中文题目 通过代码 高赞题解 解题思路 代码 画解 提交历史 统计信息 相似题目",content:'# 中文题目\n给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。\n\n你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。\n\n\n\n示例 1：\n\n\n输入：head = [1,2,3,4]\n输出：[2,1,4,3]\n\n\n示例 2：\n\n\n输入：head = []\n输出：[]\n\n\n示例 3：\n\n\n输入：head = [1]\n输出：[1]\n\n\n\n\n提示：\n\n * 链表中节点的数目在范围 [0, 100] 内\n * 0 \n\n\n\n进阶：你能在不修改链表节点值的情况下解决这个问题吗?（也就是说，仅修改节点本身。）\n\n# 通过代码\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n        public ListNode swapPairs(ListNode head) {\n            if (head == null) {\n                return null;\n            }\n            if (head.next == null) {\n                return head;\n            }\n            // 暂存头节点\n            ListNode tmpHead = new ListNode(0);\n            // 临时头节点\n            tmpHead.next = head;\n            ListNode head1 = tmpHead;\n            // 临时节点1\n            ListNode tmp1 = head;\n            // 临时节点2\n            ListNode tmp2 = head.next;\n            while (tmp1 != null && tmp2 != null) {\n                // 进行交换\n                head1.next = tmp2;\n                tmp1.next = tmp2.next;\n                tmp2.next = tmp1;\n\n                // 重设tmp1与tmp2顺序\n                tmp1 = head1.next;\n                tmp2 = head1.next.next;\n\n\n                // tmp1向后移动两位\n                tmp1 = tmp1.next.next;\n                // 偶数个数时，退出\n                if (tmp1 == null) {\n                    break;\n                }\n                // tmp2向后移2位\n                tmp2 = tmp2.next.next;\n                // 奇数个数时，推出\n                if (tmp2 == null) {\n                    break;\n                }\n\n                \n                //头指针后移两位\n                head1 = head1.next.next;\n            }\n            return tmpHead.next;\n        }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n         ListNode dummyHead=new ListNode(0);\n            dummyHead.next=head;\n            ListNode p=dummyHead;\n            while (p.next!=null && p.next.next!=null){\n                ListNode node1=p.next;\n                ListNode node2=node1.next;\n                ListNode next=node2.next;\n                node2.next=node1;\n                node1.next=next;\n                p.next=node2;\n                //                现在node1指向的是偏后的那个节点\n                p=node1;\n            }\n            return dummyHead.next;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n# 高赞题解\n# 解题思路\n * 标签：链表\n * 本题的递归和非递归解法其实原理类似，都是更新每两个点的链表形态完成整个链表的调整\n * 其中递归解法可以作为典型的递归解决思路进行讲解\n\n递归写法要观察本级递归的解决过程，形成抽象模型，因为递归本质就是不断重复相同的事情。而不是去思考完整的调用栈，一级又一级，无从下手。如图所示，我们应该关注一级调用小单元的情况，也就是单个f(x)。\n\n{:width="300px"} {:align="center"}\n\n其中我们应该关心的主要有三点：\n\n 1. 返回值\n 2. 调用单元做了什么\n 3. 终止条件\n\n在本题中：\n\n 1. 返回值：交换完成的子链表\n 2. 调用单元：设需要交换的两个点为 head 和 next，head 连接后面交换完成的子链表，next 连接 head，完成交换\n 3. 终止条件：head 为空指针或者 next 为空指针，也就是当前无节点或者只有一个节点，无法进行交换\n\n# 代码\n递归解法\n\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        if(head == null || head.next == null){\n            return head;\n        }\n        ListNode next = head.next;\n        head.next = swapPairs(next.next);\n        next.next = head;\n        return next;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n非递归解法\n\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        ListNode pre = new ListNode(0);\n        pre.next = head;\n        ListNode temp = pre;\n        while(temp.next != null && temp.next.next != null) {\n            ListNode start = temp.next;\n            ListNode end = temp.next.next;\n            temp.next = end;\n            start.next = end.next;\n            end.next = start;\n            temp = start;\n        }\n        return pre.next;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n# 画解\n<,,,,,>\n\n想看大鹏画解更多高频面试题，欢迎阅读大鹏的 LeetBook：《画解剑指 Offer 》 [https://leetcode-cn.com/leetbook/detail/illustrate-lcof/]，O(∩_∩)O\n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2021-04-11 19:41:08Accepted [https://leetcode-cn.com//submissions/detail/166579674/]0 ms100.0%36.1 MBjava2021-04-11 19:39:35Compile Error [https://leetcode-cn.com//submissions/detail/166579305/]N/AN/AN/Ajava2018-07-15 22:07:05Accepted [https://leetcode-cn.com//submissions/detail/4215557/]4 ms100.0%N/Ajava# 统计信息\n通过次数提交次数AC比率24535835334669.4%# 相似题目\n题目难度K 个一组翻转链表 [https://leetcode-cn.com/problems/reverse-nodes-in-k-group/]困难',contentLowercase:'# 中文题目\n给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。\n\n你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。\n\n\n\n示例 1：\n\n\n输入：head = [1,2,3,4]\n输出：[2,1,4,3]\n\n\n示例 2：\n\n\n输入：head = []\n输出：[]\n\n\n示例 3：\n\n\n输入：head = [1]\n输出：[1]\n\n\n\n\n提示：\n\n * 链表中节点的数目在范围 [0, 100] 内\n * 0 \n\n\n\n进阶：你能在不修改链表节点值的情况下解决这个问题吗?（也就是说，仅修改节点本身。）\n\n# 通过代码\n/**\n * definition for singly-linked list.\n * public class listnode {\n *     int val;\n *     listnode next;\n *     listnode() {}\n *     listnode(int val) { this.val = val; }\n *     listnode(int val, listnode next) { this.val = val; this.next = next; }\n * }\n */\nclass solution {\n        public listnode swappairs(listnode head) {\n            if (head == null) {\n                return null;\n            }\n            if (head.next == null) {\n                return head;\n            }\n            // 暂存头节点\n            listnode tmphead = new listnode(0);\n            // 临时头节点\n            tmphead.next = head;\n            listnode head1 = tmphead;\n            // 临时节点1\n            listnode tmp1 = head;\n            // 临时节点2\n            listnode tmp2 = head.next;\n            while (tmp1 != null && tmp2 != null) {\n                // 进行交换\n                head1.next = tmp2;\n                tmp1.next = tmp2.next;\n                tmp2.next = tmp1;\n\n                // 重设tmp1与tmp2顺序\n                tmp1 = head1.next;\n                tmp2 = head1.next.next;\n\n\n                // tmp1向后移动两位\n                tmp1 = tmp1.next.next;\n                // 偶数个数时，退出\n                if (tmp1 == null) {\n                    break;\n                }\n                // tmp2向后移2位\n                tmp2 = tmp2.next.next;\n                // 奇数个数时，推出\n                if (tmp2 == null) {\n                    break;\n                }\n\n                \n                //头指针后移两位\n                head1 = head1.next.next;\n            }\n            return tmphead.next;\n        }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n/**\n * definition for singly-linked list.\n * public class listnode {\n *     int val;\n *     listnode next;\n *     listnode(int x) { val = x; }\n * }\n */\nclass solution {\n    public listnode swappairs(listnode head) {\n         listnode dummyhead=new listnode(0);\n            dummyhead.next=head;\n            listnode p=dummyhead;\n            while (p.next!=null && p.next.next!=null){\n                listnode node1=p.next;\n                listnode node2=node1.next;\n                listnode next=node2.next;\n                node2.next=node1;\n                node1.next=next;\n                p.next=node2;\n                //                现在node1指向的是偏后的那个节点\n                p=node1;\n            }\n            return dummyhead.next;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n# 高赞题解\n# 解题思路\n * 标签：链表\n * 本题的递归和非递归解法其实原理类似，都是更新每两个点的链表形态完成整个链表的调整\n * 其中递归解法可以作为典型的递归解决思路进行讲解\n\n递归写法要观察本级递归的解决过程，形成抽象模型，因为递归本质就是不断重复相同的事情。而不是去思考完整的调用栈，一级又一级，无从下手。如图所示，我们应该关注一级调用小单元的情况，也就是单个f(x)。\n\n{:width="300px"} {:align="center"}\n\n其中我们应该关心的主要有三点：\n\n 1. 返回值\n 2. 调用单元做了什么\n 3. 终止条件\n\n在本题中：\n\n 1. 返回值：交换完成的子链表\n 2. 调用单元：设需要交换的两个点为 head 和 next，head 连接后面交换完成的子链表，next 连接 head，完成交换\n 3. 终止条件：head 为空指针或者 next 为空指针，也就是当前无节点或者只有一个节点，无法进行交换\n\n# 代码\n递归解法\n\nclass solution {\n    public listnode swappairs(listnode head) {\n        if(head == null || head.next == null){\n            return head;\n        }\n        listnode next = head.next;\n        head.next = swappairs(next.next);\n        next.next = head;\n        return next;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n非递归解法\n\nclass solution {\n    public listnode swappairs(listnode head) {\n        listnode pre = new listnode(0);\n        pre.next = head;\n        listnode temp = pre;\n        while(temp.next != null && temp.next.next != null) {\n            listnode start = temp.next;\n            listnode end = temp.next.next;\n            temp.next = end;\n            start.next = end.next;\n            end.next = start;\n            temp = start;\n        }\n        return pre.next;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n# 画解\n<,,,,,>\n\n想看大鹏画解更多高频面试题，欢迎阅读大鹏的 leetbook：《画解剑指 offer 》 [https://leetcode-cn.com/leetbook/detail/illustrate-lcof/]，o(∩_∩)o\n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2021-04-11 19:41:08accepted [https://leetcode-cn.com//submissions/detail/166579674/]0 ms100.0%36.1 mbjava2021-04-11 19:39:35compile error [https://leetcode-cn.com//submissions/detail/166579305/]n/an/an/ajava2018-07-15 22:07:05accepted [https://leetcode-cn.com//submissions/detail/4215557/]4 ms100.0%n/ajava# 统计信息\n通过次数提交次数ac比率24535835334669.4%# 相似题目\n题目难度k 个一组翻转链表 [https://leetcode-cn.com/problems/reverse-nodes-in-k-group/]困难'},{title:"15-三数之和(3Sum)",frontmatter:{title:"15-三数之和(3Sum)",date:"2021-04-15T00:00:00.000Z",categories:["中等"],tags:["数组<Array>","双指针<Two Pointers>"]},regularPath:"/views/%E4%B8%AD%E7%AD%89/0015-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C.html",relativePath:"views/中等/0015-三数之和.md",key:"v-29c9103a",path:"/views/%E4%B8%AD%E7%AD%89/0015-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C.html",headers:[{level:2,title:"中文题目",slug:"中文题目",charIndex:2},{level:2,title:"通过代码",slug:"通过代码",charIndex:257},{level:2,title:"我的笔记",slug:"我的笔记",charIndex:11921},{level:2,title:"高赞题解",slug:"高赞题解",charIndex:11963},{level:3,title:"排序 + 双指针",slug:"排序-双指针",charIndex:11970},{level:3,title:"算法流程：",slug:"算法流程：",charIndex:11998},{level:3,title:"复杂度分析",slug:"复杂度分析",charIndex:12528},{level:2,title:"提交历史",slug:"提交历史",charIndex:13774},{level:2,title:"统计信息",slug:"统计信息",charIndex:14613},{level:2,title:"相似题目",slug:"相似题目",charIndex:14650}],lastUpdated:"4/11/2021, 1:15:21 PM",headersStr:"中文题目 通过代码 我的笔记 高赞题解 排序 + 双指针 算法流程： 复杂度分析 提交历史 统计信息 相似题目",content:"# 中文题目\n给你一个包含 n 个整数的数组nums，判断nums中是否存在三个元素 a，b，c ，使得a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。\n\n注意：答案中不可以包含重复的三元组。\n\n\n\n示例 1：\n\n\n输入：nums = [-1,0,1,2,-1,-4]\n输出：[[-1,-1,2],[-1,0,1]]\n\n\n示例 2：\n\n\n输入：nums = []\n输出：[]\n\n\n示例 3：\n\n\n输入：nums = [0]\n输出：[]\n\n\n\n\n提示：\n\n * 0 \n * -105 5\n\n# 通过代码\n    class Solution {\n        public List<List<Integer>> threeSum(int[] nums) {\n            // 如果长度小于3则不存在结果\n            if (nums.length < 3 ){\n                return new ArrayList<>();\n            }\n            // 双指针，j从i+1往后，k从后往前\n            int j,k;\n            List<List<Integer>> result=new ArrayList<>();\n            // 先对数组进行排序\n            Arrays.sort(nums);\n            // 如果nums[i]>0则，nums[j]nums[k]都大于0,直接返回\n            for (int i = 0; i < nums.length-2 && nums[i]<=0; i++) {\n                // j从i+1开始\n                j=i+1;\n                // k从末尾开始\n                k=nums.length-1;\n                // 去重，i\n                if (i>0 && nums[i]==nums[i-1]){\n                    continue;\n                }\n                while (j<k){\n                    if (nums[i]+nums[j]+nums[k]<0){\n                        // 结果小于0，i往后移\n                        j++;\n                    }else if (nums[i]+nums[j]+nums[k]>0){\n                        // 结果大于0，k往前移\n                        k--;\n                    }else {\n                        // 找到结果\n                        List<Integer> tempRes=new ArrayList<>(3);\n                        tempRes.add(nums[i]);\n                        tempRes.add(nums[j]);\n                        tempRes.add(nums[k]);\n                        result.add(tempRes);\n                        // 找到结果后，两个指针同时往中间移\n                        j++;\n                        k--;\n                        // 去重j\n                        while (j<k && nums[j]==nums[j-1]){\n                            j++;\n                        }\n                        // 去重k\n                        while (j<k && nums[k]==nums[k+1]){\n                            k--;\n                        }\n                    }\n\n                }\n            }\n            return result;\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\nclass Solution {\n    public List<List<Integer>> threeSum(int[] nums) {\n        List<List<Integer>> lists = new LinkedList<>();\n\n            HashMap<Integer, Integer> map = new HashMap<>();\n            if (null == nums || nums.length == 0) {\n                return lists;\n            }\n            for (int i = 0; i < nums.length; i++) {\n                if (map.containsKey(nums[i])) {\n                    map.put(nums[i], (map.get(nums[i])) + 1);\n                } else {\n                    map.put(nums[i], 1);\n                }\n            }\n\n            if (map.containsKey(0) &&map.get(0) >= 3) {\n                lists.add(Arrays.asList(0, 0, 0));\n            }\n\n            Arrays.sort(nums);\n\n            for (int i = 1, j = 1; i < nums.length; i++) {\n                if (nums[i] != nums[i - 1]) {\n                    nums[j] = nums[i];\n                    j++;\n                }\n            }\n            for (int i = 0; i < map.size(); i++) {\n                for (int j = i + 1; j < map.size(); j++) {\n                    if (nums[i] * 2 + nums[j] == 0 && map.get(nums[i]) >= 2) {\n                        lists.add(Arrays.asList(nums[i], nums[i], nums[j]));\n                    }\n\n                    if (nums[i] + nums[j] * 2 == 0 && map.get(nums[j]) >= 2) {\n                        lists.add(Arrays.asList(nums[i], nums[j], nums[j]));\n                    }\n\n                    int c = 0 - nums[i] - nums[j];\n                    if (c > nums[j] && map.containsKey(c)) {\n                        lists.add(Arrays.asList(nums[i], nums[j], c));\n                    }\n                }\n            }\n            return lists;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\nimport java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.List;\nclass Solution {\n    public List<List<Integer>> threeSum(int[] nums) {\n        Arrays.sort(nums);\n            List<List<Integer>> res = new LinkedList<>();\n            for (int i = 0; i < nums.length - 2; i++) {\n                if (i == 0 || (i > 0 && nums[i] != nums[i - 1])) {\n                    int lo = i + 1, hi = nums.length - 1, sum = 0 - nums[i];\n                    while (lo < hi) {\n                        if (nums[lo] + nums[hi] == sum) {\n                            res.add(Arrays.asList(nums[i], nums[lo], nums[hi]));\n                            while (lo < hi && nums[lo] == nums[lo + 1]) {\n                                lo++;\n                            }\n                            while (lo < hi && nums[hi] == nums[hi - 1]) {\n                                hi--;\n                            }\n                            lo++;\n                            hi--;\n                        } else if (nums[lo] + nums[hi] < sum) {\n                            lo++;\n                        } else {\n                            hi--;\n                        }\n                    }\n                }\n            }\n            return res;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n    class Solution {\n        public List<List<Integer>> threeSum(int[] nums) {\n            // 如果长度小于3则不存在结果\n            if (nums.length < 3 ){\n                return new ArrayList<>();\n            }\n            // 双指针，j从i+1往后，k从后往前\n            int j,k;\n            List<List<Integer>> result=new ArrayList<>();\n            // 先对数组进行排序\n            Arrays.sort(nums);\n            // 如果nums[i]>0则，nums[j]nums[k]都大于0,直接返回\n            for (int i = 0; i < nums.length-2 && nums[i]<=0; i++) {\n                // j从i+1开始\n                j=i+1;\n                // k从末尾开始\n                k=nums.length-1;\n                // 去重，i\n                if (i>0 && nums[i]==nums[i-1]){\n                    continue;\n                }\n                while (j<k){\n                    if (nums[i]+nums[j]+nums[k]<0){\n                        // 结果小于0，i往后移\n                        j++;\n                    }else if (nums[i]+nums[j]+nums[k]>0){\n                        // 结果大于0，k往前移\n                        k--;\n                    }else {\n                        // 找到结果\n                        List<Integer> tempRes=new ArrayList<>(3);\n                        tempRes.add(nums[i]);\n                        tempRes.add(nums[j]);\n                        tempRes.add(nums[k]);\n                        result.add(tempRes);\n                        // 找到结果后，两个指针同时往中间移\n                        j++;\n                        k--;\n                        // 去重j\n                        while (j<k && nums[j]==nums[j-1]){\n                            j++;\n                        }\n                        // 去重k\n                        while (j<k && nums[k]==nums[k+1]){\n                            k--;\n                        }\n                    }\n\n                }\n            }\n            return result;\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\nclass Solution {\n    public List<List<Integer>> threeSum(int[] nums) {\n        List<List<Integer>> lists = new LinkedList<>();\n\n            HashMap<Integer, Integer> map = new HashMap<>();\n            if (null == nums || nums.length == 0) {\n                return lists;\n            }\n            for (int i = 0; i < nums.length; i++) {\n                if (map.containsKey(nums[i])) {\n                    map.put(nums[i], (map.get(nums[i])) + 1);\n                } else {\n                    map.put(nums[i], 1);\n                }\n            }\n\n            if (map.containsKey(0) &&map.get(0) >= 3) {\n                lists.add(Arrays.asList(0, 0, 0));\n            }\n\n            Arrays.sort(nums);\n\n            for (int i = 1, j = 1; i < nums.length; i++) {\n                if (nums[i] != nums[i - 1]) {\n                    nums[j] = nums[i];\n                    j++;\n                }\n            }\n            for (int i = 0; i < map.size(); i++) {\n                for (int j = i + 1; j < map.size(); j++) {\n                    if (nums[i] * 2 + nums[j] == 0 && map.get(nums[i]) >= 2) {\n                        lists.add(Arrays.asList(nums[i], nums[i], nums[j]));\n                    }\n\n                    if (nums[i] + nums[j] * 2 == 0 && map.get(nums[j]) >= 2) {\n                        lists.add(Arrays.asList(nums[i], nums[j], nums[j]));\n                    }\n\n                    int c = 0 - nums[i] - nums[j];\n                    if (c > nums[j] && map.containsKey(c)) {\n                        lists.add(Arrays.asList(nums[i], nums[j], c));\n                    }\n                }\n            }\n            return lists;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\nclass Solution {\n    public List<List<Integer>> threeSum(int[] nums) {\n        //            先对数组进行排序\n            Arrays.sort(nums);\n            List<List<Integer>> res = new LinkedList<>();\n//            从0到n-2进行循环操作\n            for (int i = 0; i < nums.length - 2; i++) {\n//                要对当前的元素是第一个还是之后的元素做一个判断，一确定是否有排序后前后的元素是否相等\n                if (i == 0 || (i > 0 && nums[i] != nums[i - 1])) {\n//                    然后在[i+1,nums.length-1]区间进行查找符合的条件的元素\n                    int lo = i + 1, hi = nums.length - 1, sum = 0 - nums[i];\n                    while (lo < hi) {\n//                        满足条件\n                        if (nums[lo] + nums[hi] == sum) {\n//                            添加到res\n                            res.add(Arrays.asList(nums[i], nums[lo], nums[hi]));\n//                            如果nums[lo]之后的元素和它相等，跳过，同理nums[hi]也是\n                            while (lo < hi && nums[lo] == nums[lo + 1]) {\n                                lo++;\n                            }\n                            while (lo < hi && nums[hi] == nums[hi - 1]) {\n                                hi--;\n                            }\n                            lo++;\n                            hi--;\n                        } else if (nums[lo] + nums[hi] < sum) {\n                            lo++;\n                        } else {\n                            hi--;\n                        }\n                    }\n                }\n            }\n            return res;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\nimport java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.List;\nclass Solution {\n    public List<List<Integer>> threeSum(int[] nums) {\n        Arrays.sort(nums);\n            List<List<Integer>> res = new LinkedList<>();\n            for (int i = 0; i < nums.length - 2; i++) {\n                if (i == 0 || (i > 0 && nums[i] != nums[i - 1])) {\n                    int lo = i + 1, hi = nums.length - 1, sum = 0 - nums[i];\n                    while (lo < hi) {\n                        if (nums[lo] + nums[hi] == sum) {\n                            res.add(Arrays.asList(nums[i], nums[lo], nums[hi]));\n                            while (lo < hi && nums[lo] == nums[lo + 1]) {\n                                lo++;\n                            }\n                            while (lo < hi && nums[hi] == nums[hi - 1]) {\n                                hi--;\n                            }\n                            lo++;\n                            hi--;\n                        } else if (nums[lo] + nums[hi] < sum) {\n                            lo++;\n                        } else {\n                            hi--;\n                        }\n                    }\n                }\n            }\n            return res;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n# 我的笔记\n采用双指针，固定最前面的元素，然后后面两个前后移动，注意结果的去重\n\n# 高赞题解\n# 排序 + 双指针\n本题的难点在于如何去除重复解。\n\n# 算法流程：\n 1. 特判，对于数组长度 nnn，如果数组为 nullnullnull 或者数组长度小于 333，返回 [][][]。\n 2. 对数组进行排序。\n 3. 遍历排序后数组： * 若 nums[i]>0nums[i]>0nums[i]>0：因为已经排序好，所以后面不可能有三个数加和等于 000，直接返回结果。\n     * 对于重复元素：跳过，避免出现重复解\n     * 令左指针 L=i+1L=i+1L=i+1，右指针 R=n−1R=n-1R=n−1，当 L<RL<RL<R 时，执行循环： * 当 nums[i]+nums[L]+nums[R]==0nums[i]+nums[L]+nums[R]==0nums[i]+nums[L]+nums[R]==0，执行循环，判断左界和右界是否和下一位置重复，去除重复解。并同时将 L,RL,RL,R 移到下一位置，寻找新的解\n        * 若和大于 000，说明 nums[R]nums[R]nums[R] 太大，RRR 左移\n        * 若和小于 000，说明 nums[L]nums[L]nums[L] 太小，LLL 右移\n       \n       \n    \n    \n\n# 复杂度分析\n * 时间复杂度：O(n2)O\\left(n^{2}\\right)O(n2)，数组排序 O(Nlog⁡N)O(N \\log N)O(NlogN)，遍历数组 O(n)O\\left(n\\right)O(n)，双指针遍历 O(n)O\\left(n\\right)O(n)，总体 O(Nlog⁡N)+O(n)∗O(n)O(N \\log N)+O\\left(n\\right)*O\\left(n\\right)O(NlogN)+O(n)∗O(n)，O(n2)O\\left(n^{2}\\right)O(n2)\n * 空间复杂度：O(1)O(1)O(1)\n\nclass Solution:\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\n        \n        n=len(nums)\n        res=[]\n        if(not nums or n<3):\n            return []\n        nums.sort()\n        res=[]\n        for i in range(n):\n            if(nums[i]>0):\n                return res\n            if(i>0 and nums[i]==nums[i-1]):\n                continue\n            L=i+1\n            R=n-1\n            while(L<R):\n                if(nums[i]+nums[L]+nums[R]==0):\n                    res.append([nums[i],nums[L],nums[R]])\n                    while(L<R and nums[L]==nums[L+1]):\n                        L=L+1\n                    while(L<R and nums[R]==nums[R-1]):\n                        R=R-1\n                    L=L+1\n                    R=R-1\n                elif(nums[i]+nums[L]+nums[R]>0):\n                    R=R-1\n                else:\n                    L=L+1\n        return res\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2021-04-15 20:53:16Accepted [https://leetcode-cn.com//submissions/detail/168311551/]22 ms100.0%42.3 MBjava2021-04-15 20:51:47Runtime Error [https://leetcode-cn.com//submissions/detail/168310850/]N/AN/AN/Ajava2021-04-15 20:47:52Wrong Answer [https://leetcode-cn.com//submissions/detail/168308878/]N/AN/AN/Ajava2018-09-02 15:55:42Accepted [https://leetcode-cn.com//submissions/detail/6423192/]220 ms100.0%N/Ajava2018-09-02 15:54:08Runtime Error [https://leetcode-cn.com//submissions/detail/6423116/]N/AN/AN/Ajava2018-09-02 15:52:57Runtime Error [https://leetcode-cn.com//submissions/detail/6423052/]N/AN/AN/Ajava2018-09-02 14:55:03Accepted [https://leetcode-cn.com//submissions/detail/6419128/]94 ms100.0%N/Ajava2018-06-06 23:09:15Accepted [https://leetcode-cn.com//submissions/detail/2973129/]85 ms100.0%N/Ajava# 统计信息\n通过次数提交次数AC比率483391152168031.8%# 相似题目\n题目难度两数之和 [https://leetcode-cn.com/problems/two-sum/]简单最接近的三数之和 [https://leetcode-cn.com/problems/3sum-closest/]中等四数之和 [https://leetcode-cn.com/problems/4sum/]中等较小的三数之和 [https://leetcode-cn.com/problems/3sum-smaller/]中等",contentLowercase:"# 中文题目\n给你一个包含 n 个整数的数组nums，判断nums中是否存在三个元素 a，b，c ，使得a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。\n\n注意：答案中不可以包含重复的三元组。\n\n\n\n示例 1：\n\n\n输入：nums = [-1,0,1,2,-1,-4]\n输出：[[-1,-1,2],[-1,0,1]]\n\n\n示例 2：\n\n\n输入：nums = []\n输出：[]\n\n\n示例 3：\n\n\n输入：nums = [0]\n输出：[]\n\n\n\n\n提示：\n\n * 0 \n * -105 5\n\n# 通过代码\n    class solution {\n        public list<list<integer>> threesum(int[] nums) {\n            // 如果长度小于3则不存在结果\n            if (nums.length < 3 ){\n                return new arraylist<>();\n            }\n            // 双指针，j从i+1往后，k从后往前\n            int j,k;\n            list<list<integer>> result=new arraylist<>();\n            // 先对数组进行排序\n            arrays.sort(nums);\n            // 如果nums[i]>0则，nums[j]nums[k]都大于0,直接返回\n            for (int i = 0; i < nums.length-2 && nums[i]<=0; i++) {\n                // j从i+1开始\n                j=i+1;\n                // k从末尾开始\n                k=nums.length-1;\n                // 去重，i\n                if (i>0 && nums[i]==nums[i-1]){\n                    continue;\n                }\n                while (j<k){\n                    if (nums[i]+nums[j]+nums[k]<0){\n                        // 结果小于0，i往后移\n                        j++;\n                    }else if (nums[i]+nums[j]+nums[k]>0){\n                        // 结果大于0，k往前移\n                        k--;\n                    }else {\n                        // 找到结果\n                        list<integer> tempres=new arraylist<>(3);\n                        tempres.add(nums[i]);\n                        tempres.add(nums[j]);\n                        tempres.add(nums[k]);\n                        result.add(tempres);\n                        // 找到结果后，两个指针同时往中间移\n                        j++;\n                        k--;\n                        // 去重j\n                        while (j<k && nums[j]==nums[j-1]){\n                            j++;\n                        }\n                        // 去重k\n                        while (j<k && nums[k]==nums[k+1]){\n                            k--;\n                        }\n                    }\n\n                }\n            }\n            return result;\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\nclass solution {\n    public list<list<integer>> threesum(int[] nums) {\n        list<list<integer>> lists = new linkedlist<>();\n\n            hashmap<integer, integer> map = new hashmap<>();\n            if (null == nums || nums.length == 0) {\n                return lists;\n            }\n            for (int i = 0; i < nums.length; i++) {\n                if (map.containskey(nums[i])) {\n                    map.put(nums[i], (map.get(nums[i])) + 1);\n                } else {\n                    map.put(nums[i], 1);\n                }\n            }\n\n            if (map.containskey(0) &&map.get(0) >= 3) {\n                lists.add(arrays.aslist(0, 0, 0));\n            }\n\n            arrays.sort(nums);\n\n            for (int i = 1, j = 1; i < nums.length; i++) {\n                if (nums[i] != nums[i - 1]) {\n                    nums[j] = nums[i];\n                    j++;\n                }\n            }\n            for (int i = 0; i < map.size(); i++) {\n                for (int j = i + 1; j < map.size(); j++) {\n                    if (nums[i] * 2 + nums[j] == 0 && map.get(nums[i]) >= 2) {\n                        lists.add(arrays.aslist(nums[i], nums[i], nums[j]));\n                    }\n\n                    if (nums[i] + nums[j] * 2 == 0 && map.get(nums[j]) >= 2) {\n                        lists.add(arrays.aslist(nums[i], nums[j], nums[j]));\n                    }\n\n                    int c = 0 - nums[i] - nums[j];\n                    if (c > nums[j] && map.containskey(c)) {\n                        lists.add(arrays.aslist(nums[i], nums[j], c));\n                    }\n                }\n            }\n            return lists;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\nimport java.util.arrays;\nimport java.util.linkedlist;\nimport java.util.list;\nclass solution {\n    public list<list<integer>> threesum(int[] nums) {\n        arrays.sort(nums);\n            list<list<integer>> res = new linkedlist<>();\n            for (int i = 0; i < nums.length - 2; i++) {\n                if (i == 0 || (i > 0 && nums[i] != nums[i - 1])) {\n                    int lo = i + 1, hi = nums.length - 1, sum = 0 - nums[i];\n                    while (lo < hi) {\n                        if (nums[lo] + nums[hi] == sum) {\n                            res.add(arrays.aslist(nums[i], nums[lo], nums[hi]));\n                            while (lo < hi && nums[lo] == nums[lo + 1]) {\n                                lo++;\n                            }\n                            while (lo < hi && nums[hi] == nums[hi - 1]) {\n                                hi--;\n                            }\n                            lo++;\n                            hi--;\n                        } else if (nums[lo] + nums[hi] < sum) {\n                            lo++;\n                        } else {\n                            hi--;\n                        }\n                    }\n                }\n            }\n            return res;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n    class solution {\n        public list<list<integer>> threesum(int[] nums) {\n            // 如果长度小于3则不存在结果\n            if (nums.length < 3 ){\n                return new arraylist<>();\n            }\n            // 双指针，j从i+1往后，k从后往前\n            int j,k;\n            list<list<integer>> result=new arraylist<>();\n            // 先对数组进行排序\n            arrays.sort(nums);\n            // 如果nums[i]>0则，nums[j]nums[k]都大于0,直接返回\n            for (int i = 0; i < nums.length-2 && nums[i]<=0; i++) {\n                // j从i+1开始\n                j=i+1;\n                // k从末尾开始\n                k=nums.length-1;\n                // 去重，i\n                if (i>0 && nums[i]==nums[i-1]){\n                    continue;\n                }\n                while (j<k){\n                    if (nums[i]+nums[j]+nums[k]<0){\n                        // 结果小于0，i往后移\n                        j++;\n                    }else if (nums[i]+nums[j]+nums[k]>0){\n                        // 结果大于0，k往前移\n                        k--;\n                    }else {\n                        // 找到结果\n                        list<integer> tempres=new arraylist<>(3);\n                        tempres.add(nums[i]);\n                        tempres.add(nums[j]);\n                        tempres.add(nums[k]);\n                        result.add(tempres);\n                        // 找到结果后，两个指针同时往中间移\n                        j++;\n                        k--;\n                        // 去重j\n                        while (j<k && nums[j]==nums[j-1]){\n                            j++;\n                        }\n                        // 去重k\n                        while (j<k && nums[k]==nums[k+1]){\n                            k--;\n                        }\n                    }\n\n                }\n            }\n            return result;\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\nclass solution {\n    public list<list<integer>> threesum(int[] nums) {\n        list<list<integer>> lists = new linkedlist<>();\n\n            hashmap<integer, integer> map = new hashmap<>();\n            if (null == nums || nums.length == 0) {\n                return lists;\n            }\n            for (int i = 0; i < nums.length; i++) {\n                if (map.containskey(nums[i])) {\n                    map.put(nums[i], (map.get(nums[i])) + 1);\n                } else {\n                    map.put(nums[i], 1);\n                }\n            }\n\n            if (map.containskey(0) &&map.get(0) >= 3) {\n                lists.add(arrays.aslist(0, 0, 0));\n            }\n\n            arrays.sort(nums);\n\n            for (int i = 1, j = 1; i < nums.length; i++) {\n                if (nums[i] != nums[i - 1]) {\n                    nums[j] = nums[i];\n                    j++;\n                }\n            }\n            for (int i = 0; i < map.size(); i++) {\n                for (int j = i + 1; j < map.size(); j++) {\n                    if (nums[i] * 2 + nums[j] == 0 && map.get(nums[i]) >= 2) {\n                        lists.add(arrays.aslist(nums[i], nums[i], nums[j]));\n                    }\n\n                    if (nums[i] + nums[j] * 2 == 0 && map.get(nums[j]) >= 2) {\n                        lists.add(arrays.aslist(nums[i], nums[j], nums[j]));\n                    }\n\n                    int c = 0 - nums[i] - nums[j];\n                    if (c > nums[j] && map.containskey(c)) {\n                        lists.add(arrays.aslist(nums[i], nums[j], c));\n                    }\n                }\n            }\n            return lists;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\nclass solution {\n    public list<list<integer>> threesum(int[] nums) {\n        //            先对数组进行排序\n            arrays.sort(nums);\n            list<list<integer>> res = new linkedlist<>();\n//            从0到n-2进行循环操作\n            for (int i = 0; i < nums.length - 2; i++) {\n//                要对当前的元素是第一个还是之后的元素做一个判断，一确定是否有排序后前后的元素是否相等\n                if (i == 0 || (i > 0 && nums[i] != nums[i - 1])) {\n//                    然后在[i+1,nums.length-1]区间进行查找符合的条件的元素\n                    int lo = i + 1, hi = nums.length - 1, sum = 0 - nums[i];\n                    while (lo < hi) {\n//                        满足条件\n                        if (nums[lo] + nums[hi] == sum) {\n//                            添加到res\n                            res.add(arrays.aslist(nums[i], nums[lo], nums[hi]));\n//                            如果nums[lo]之后的元素和它相等，跳过，同理nums[hi]也是\n                            while (lo < hi && nums[lo] == nums[lo + 1]) {\n                                lo++;\n                            }\n                            while (lo < hi && nums[hi] == nums[hi - 1]) {\n                                hi--;\n                            }\n                            lo++;\n                            hi--;\n                        } else if (nums[lo] + nums[hi] < sum) {\n                            lo++;\n                        } else {\n                            hi--;\n                        }\n                    }\n                }\n            }\n            return res;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\nimport java.util.arrays;\nimport java.util.linkedlist;\nimport java.util.list;\nclass solution {\n    public list<list<integer>> threesum(int[] nums) {\n        arrays.sort(nums);\n            list<list<integer>> res = new linkedlist<>();\n            for (int i = 0; i < nums.length - 2; i++) {\n                if (i == 0 || (i > 0 && nums[i] != nums[i - 1])) {\n                    int lo = i + 1, hi = nums.length - 1, sum = 0 - nums[i];\n                    while (lo < hi) {\n                        if (nums[lo] + nums[hi] == sum) {\n                            res.add(arrays.aslist(nums[i], nums[lo], nums[hi]));\n                            while (lo < hi && nums[lo] == nums[lo + 1]) {\n                                lo++;\n                            }\n                            while (lo < hi && nums[hi] == nums[hi - 1]) {\n                                hi--;\n                            }\n                            lo++;\n                            hi--;\n                        } else if (nums[lo] + nums[hi] < sum) {\n                            lo++;\n                        } else {\n                            hi--;\n                        }\n                    }\n                }\n            }\n            return res;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n# 我的笔记\n采用双指针，固定最前面的元素，然后后面两个前后移动，注意结果的去重\n\n# 高赞题解\n# 排序 + 双指针\n本题的难点在于如何去除重复解。\n\n# 算法流程：\n 1. 特判，对于数组长度 nnn，如果数组为 nullnullnull 或者数组长度小于 333，返回 [][][]。\n 2. 对数组进行排序。\n 3. 遍历排序后数组： * 若 nums[i]>0nums[i]>0nums[i]>0：因为已经排序好，所以后面不可能有三个数加和等于 000，直接返回结果。\n     * 对于重复元素：跳过，避免出现重复解\n     * 令左指针 l=i+1l=i+1l=i+1，右指针 r=n−1r=n-1r=n−1，当 l<rl<rl<r 时，执行循环： * 当 nums[i]+nums[l]+nums[r]==0nums[i]+nums[l]+nums[r]==0nums[i]+nums[l]+nums[r]==0，执行循环，判断左界和右界是否和下一位置重复，去除重复解。并同时将 l,rl,rl,r 移到下一位置，寻找新的解\n        * 若和大于 000，说明 nums[r]nums[r]nums[r] 太大，rrr 左移\n        * 若和小于 000，说明 nums[l]nums[l]nums[l] 太小，lll 右移\n       \n       \n    \n    \n\n# 复杂度分析\n * 时间复杂度：o(n2)o\\left(n^{2}\\right)o(n2)，数组排序 o(nlog⁡n)o(n \\log n)o(nlogn)，遍历数组 o(n)o\\left(n\\right)o(n)，双指针遍历 o(n)o\\left(n\\right)o(n)，总体 o(nlog⁡n)+o(n)∗o(n)o(n \\log n)+o\\left(n\\right)*o\\left(n\\right)o(nlogn)+o(n)∗o(n)，o(n2)o\\left(n^{2}\\right)o(n2)\n * 空间复杂度：o(1)o(1)o(1)\n\nclass solution:\n    def threesum(self, nums: list[int]) -> list[list[int]]:\n        \n        n=len(nums)\n        res=[]\n        if(not nums or n<3):\n            return []\n        nums.sort()\n        res=[]\n        for i in range(n):\n            if(nums[i]>0):\n                return res\n            if(i>0 and nums[i]==nums[i-1]):\n                continue\n            l=i+1\n            r=n-1\n            while(l<r):\n                if(nums[i]+nums[l]+nums[r]==0):\n                    res.append([nums[i],nums[l],nums[r]])\n                    while(l<r and nums[l]==nums[l+1]):\n                        l=l+1\n                    while(l<r and nums[r]==nums[r-1]):\n                        r=r-1\n                    l=l+1\n                    r=r-1\n                elif(nums[i]+nums[l]+nums[r]>0):\n                    r=r-1\n                else:\n                    l=l+1\n        return res\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2021-04-15 20:53:16accepted [https://leetcode-cn.com//submissions/detail/168311551/]22 ms100.0%42.3 mbjava2021-04-15 20:51:47runtime error [https://leetcode-cn.com//submissions/detail/168310850/]n/an/an/ajava2021-04-15 20:47:52wrong answer [https://leetcode-cn.com//submissions/detail/168308878/]n/an/an/ajava2018-09-02 15:55:42accepted [https://leetcode-cn.com//submissions/detail/6423192/]220 ms100.0%n/ajava2018-09-02 15:54:08runtime error [https://leetcode-cn.com//submissions/detail/6423116/]n/an/an/ajava2018-09-02 15:52:57runtime error [https://leetcode-cn.com//submissions/detail/6423052/]n/an/an/ajava2018-09-02 14:55:03accepted [https://leetcode-cn.com//submissions/detail/6419128/]94 ms100.0%n/ajava2018-06-06 23:09:15accepted [https://leetcode-cn.com//submissions/detail/2973129/]85 ms100.0%n/ajava# 统计信息\n通过次数提交次数ac比率483391152168031.8%# 相似题目\n题目难度两数之和 [https://leetcode-cn.com/problems/two-sum/]简单最接近的三数之和 [https://leetcode-cn.com/problems/3sum-closest/]中等四数之和 [https://leetcode-cn.com/problems/4sum/]中等较小的三数之和 [https://leetcode-cn.com/problems/3sum-smaller/]中等"},{title:"40-组合总和 II(Combination Sum II)",frontmatter:{title:"40-组合总和 II(Combination Sum II)",date:"2018-09-11T00:00:00.000Z",categories:["中等"],tags:["数组<Array>","回溯算法<Backtracking>"]},regularPath:"/views/%E4%B8%AD%E7%AD%89/0040-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C%20II.html",relativePath:"views/中等/0040-组合总和 II.md",key:"v-1efc4839",path:"/views/%E4%B8%AD%E7%AD%89/0040-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C%20II.html",headers:[{level:2,title:"中文题目",slug:"中文题目",charIndex:2},{level:2,title:"通过代码",slug:"通过代码",charIndex:336},{level:2,title:"高赞题解",slug:"高赞题解",charIndex:1569},{level:2,title:"提交历史",slug:"提交历史",charIndex:8712},{level:2,title:"统计信息",slug:"统计信息",charIndex:8840},{level:2,title:"相似题目",slug:"相似题目",charIndex:8874}],lastUpdated:"4/11/2021, 1:15:21 PM",headersStr:"中文题目 通过代码 高赞题解 提交历史 统计信息 相似题目",content:'# 中文题目\n给定一个数组candidates和一个目标数target，找出candidates中所有可以使数字和为target的组合。\n\ncandidates中的每个数字在每个组合中只能使用一次。\n\n说明：\n\n * 所有数字（包括目标数）都是正整数。\n * 解集不能包含重复的组合。\n\n示例 1:\n\n输入: candidates = [10,1,2,7,6,1,5], target = 8,\n所求解集为:\n[\n  [1, 7],\n  [1, 2, 5],\n  [2, 6],\n  [1, 1, 6]\n]\n\n\n示例 2:\n\n输入: candidates = [2,5,2,1,2], target = 5,\n所求解集为:\n[\n  [1,2,2],\n  [5]\n]\n\n# 通过代码\nclass Solution {\n   public List<List<Integer>> combinationSum2(int[] candidates, int target) {\n            List<List<Integer>> res=new LinkedList<List<Integer>>();\n            if (candidates==null || candidates.length==0){\n                return res;\n            }\n            LinkedList<Integer> list=new LinkedList<Integer>();\n            Arrays.sort(candidates);\n//            对于这种存在顺序的，可以把其实位置放在一起递归\n            dfs(candidates,list,res,target,0);\n            return res;\n        }\n\n        private void dfs(int[] candidates, LinkedList<Integer> list, List<List<Integer>> res, int target,int start) {\n            if (target==0){\n                res.add(new LinkedList<Integer>(list));\n                return;\n            }\n            for (int i = start; i < candidates.length; i++) {\n                if (i>start && candidates[i]==candidates[i-1]){\n                    continue;\n                }\n                if (candidates[i]<=target){\n                    list.addLast(candidates[i]);\n                    dfs(candidates,list,res,target-candidates[i],i+1);\n                    list.removeLast();\n                }\n            }\n        }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n# 高赞题解\n这道题与上一问的区别在于：\n\n * 第 39 题 [(https://leetcode-cn.com/problems/combination-sum/)]：candidates 中的数字可以无限制重复被选取。\n * 第 40 题：candidates 中的每个数字在每个组合中只能使用一次。\n\n编码的不同在于下一层递归的起始索引不一样。\n\n * 第 39 题：还从候选数组的当前索引值开始。\n * 第 40 题：从候选数组的当前索引值的下一位开始。\n\n相同之处：解集不能包含重复的组合。\n\n为了使得解集不包含重复的组合。我们想一想，如何去掉一个数组中重复的元素，除了使用哈希表以外，我们还可以先对数组升序排序，重复的元素一定不是排好序以后的第 1 个元素和相同元素的第 1 个元素。根据这个思想，我们先对数组升序排序是有必要的。候选数组有序，对于在递归树中发现重复分支，进而“剪枝”也是有效的。\n\n思路分析：\n\n这道题其实比上一问更简单，思路是：\n\n> 以 target 为根结点，依次减去数组中的数字，直到小于 000 或者等于 000，把等于 000 的结果记录到结果集中。\n\n\n当然你也可以以 000 为根结点，依次加上数组中的数字，直到大于 target 或者等于 target，把等于 target 的结果记录到结果集中。\n\n * “解集不能包含重复的组合”，就提示我们得对数组先排个序（“升序”或者“降序”均可，下面示例中均使用“升序”）。\n * “candidates 中的每个数字在每个组合中只能使用一次”，那就按照顺序依次减去数组中的元素，递归求解即可：遇到 000 就结算且回溯，遇到负数也回溯。\n * candidates 中的数字可以重复，可以借助「力扣」第 47 题：“全排列 II” [https://leetcode-cn.com/problems/permutations-ii/solution/hui-su-suan-fa-python-dai-ma-java-dai-ma-by-liwe-2/] 的思想，在搜索的过程中，找到可能发生重复结果的分支，把它剪去。\n\n（温馨提示：下面的幻灯片中，有几页上有较多的文字，可能需要您停留一下，可以点击右下角的后退 “|◀” 或者前进 “▶|” 按钮控制幻灯片的播放。）\n\n<,>\n\n参考代码 1：以 target 为根结点，依次减去数组中的数字，直到小于 000 或者等于 000，把等于 000 的结果记录到结果集中。\n\n感谢用户 @rmokerone 提供的 C++ 版本的参考代码。\n\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Deque;\nimport java.util.List;\n\npublic class Solution {\n\n    /**\n     * @param candidates 候选数组\n     * @param len\n     * @param begin      从候选数组的 begin 位置开始搜索\n     * @param residue    表示剩余，这个值一开始等于 target，基于题目中说明的"所有数字（包括目标数）都是正整数"这个条件\n     * @param path       从根结点到叶子结点的路径\n     * @param res\n     */\n    private void dfs(int[] candidates, int len, int begin, int residue, Deque<Integer> path, List<List<Integer>> res) {\n        if (residue == 0) {\n            res.add(new ArrayList<>(path));\n            return;\n        }\n        for (int i = begin; i < len; i++) {\n            // 大剪枝\n            if (residue - candidates[i] < 0) {\n                break;\n            }\n\n            // 小剪枝\n            if (i > begin && candidates[i] == candidates[i - 1]) {\n                continue;\n            }\n\n            path.addLast(candidates[i]);\n\n            // 因为元素不可以重复使用，这里递归传递下去的是 i + 1 而不是 i\n            dfs(candidates, len, i + 1, residue - candidates[i], path, res);\n\n            path.removeLast();\n        }\n    }\n\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\n        int len = candidates.length;\n        List<List<Integer>> res = new ArrayList<>();\n        if (len == 0) {\n            return res;\n        }\n\n        // 先将数组排序，这一步很关键\n        Arrays.sort(candidates);\n\n        Deque<Integer> path = new ArrayDeque<>(len);\n        dfs(candidates, len, 0, target, path, res);\n        return res;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\nfrom typing import List\n\n\nclass Solution:\n\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\n        def dfs(begin, path, residue):\n            if residue == 0:\n                res.append(path[:])\n                return\n\n            for index in range(begin, size):\n                if candidates[index] > residue:\n                    break\n\n                if index > begin and candidates[index - 1] == candidates[index]:\n                    continue\n\n                path.append(candidates[index])\n                dfs(index + 1, path, residue - candidates[index])\n                path.pop()\n\n        size = len(candidates)\n        if size == 0:\n            return []\n\n        candidates.sort()\n        res = []\n        dfs(0, [], target)\n        return res\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n// author:rmokerone\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\n\nprivate:\n    vector<int> candidates;\n    vector<vector<int>> res;\n    vector<int> path;\npublic:\n    void DFS(int start, int target) {\n        if (target == 0) {\n            res.push_back(path);\n            return;\n        }\n\n        for (int i = start; i < candidates.size() && target - candidates[i] >= 0; i++) {\n            if (i > start && candidates[i] == candidates[i - 1])\n                continue;\n            path.push_back(candidates[i]);\n            // 元素不可重复利用，使用下一个即i+1\n            DFS(i + 1, target - candidates[i]);\n            path.pop_back();\n        }\n    }\n\n    vector<vector<int>> combinationSum2(vector<int> &candidates, int target) {\n        sort(candidates.begin(), candidates.end());\n        this->candidates = candidates;\n        DFS(0, target);\n        return res;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n这里按照用户 @Aspire [/u/aspire-6] 提供的思路，给出从 000 开始，一个使用加法，搜索加到目标数的写法，“前提是排序（升序降序均可）”，然后“剪枝”的操作和上面一样。\n\n\n\n参考代码 2：以 000 为根结点，依次加上数组中的数字，直到大于 target 或者等于 target，把等于 target 的结果记录到结果集中。\n\n#include <iostream>\n#include <vector>\n#include <map>\n\nusing namespace std;\n\nclass Solution {\npublic:\n\n    vector<int> input;\n    int target;\n    vector<vector<int>> result;\n    vector<int> vc;\n\n    void dfs(int index, int sum) {\n        // index >= input.size() ，写成 index == input.size() 即可\n        // 因为每次都 + 1，在 index == input.size() 剪枝就可以了\n        if (sum >= target || index == input.size()) {\n            if (sum == target) {\n                result.push_back(vc);\n            }\n            return;\n        }\n        for (int i = index; i < input.size(); i++) {\n            if (input[i] > target) {\n                continue;\n            }\n\n            // 【我添加的代码在这里】：\n            // 1、i > index 表明剪枝的分支一定不是当前层的第 1 个分支\n            // 2、input[i - 1] == input[i] 表明当前选出来的数等于当前层前一个分支选出来的数\n            // 因为前一个分支的候选集合一定大于后一个分支的候选集合\n            // 故后面出现的分支中一定包含了前面分支出现的结果，因此剪枝\n            // “剪枝”的前提是排序，升序或者降序均可\n            if (i > index && input[i - 1] == input[i]) {\n                continue;\n            }\n\n            vc.push_back(input[i]);\n            sum += input[i];\n            dfs(i + 1, sum);\n            vc.pop_back();\n            sum -= input[i];\n        }\n    }\n\n    vector<vector<int>> combinationSum2(vector<int> &candidates, int target) {\n        // “剪枝”的前提是排序，升序或者降序均可\n        sort(candidates.begin(), candidates.end());\n        this->input = candidates;\n        this->target = target;\n        dfs(0, 0);\n        return result;\n    }\n};\n\n\nint main() {\n    cout << "LeetCode 第 40 题：组合问题 II" << endl;\n    Solution solution = Solution();\n\n    vector<int> candidates;\n    candidates.push_back(10);\n    candidates.push_back(1);\n    candidates.push_back(2);\n    candidates.push_back(7);\n    candidates.push_back(6);\n    candidates.push_back(1);\n    candidates.push_back(5);\n\n    int target = 8;\n    vector<vector<int>> res = solution.combinationSum2(candidates, target);\n    for (int i = 0; i < res.size(); ++i) {\n        for (int j = 0; j < res[i].size(); ++j) {\n            cout << res[i][j] << ",";\n        }\n        cout << "" << endl;\n    }\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-09-11 22:53:39Accepted [https://leetcode-cn.com//submissions/detail/6937819/]15 ms27.5%N/Ajava# 统计信息\n通过次数提交次数AC比率355235982959.4%# 相似题目\n题目难度组合总和 [https://leetcode-cn.com/problems/combination-sum/]中等',contentLowercase:'# 中文题目\n给定一个数组candidates和一个目标数target，找出candidates中所有可以使数字和为target的组合。\n\ncandidates中的每个数字在每个组合中只能使用一次。\n\n说明：\n\n * 所有数字（包括目标数）都是正整数。\n * 解集不能包含重复的组合。\n\n示例 1:\n\n输入: candidates = [10,1,2,7,6,1,5], target = 8,\n所求解集为:\n[\n  [1, 7],\n  [1, 2, 5],\n  [2, 6],\n  [1, 1, 6]\n]\n\n\n示例 2:\n\n输入: candidates = [2,5,2,1,2], target = 5,\n所求解集为:\n[\n  [1,2,2],\n  [5]\n]\n\n# 通过代码\nclass solution {\n   public list<list<integer>> combinationsum2(int[] candidates, int target) {\n            list<list<integer>> res=new linkedlist<list<integer>>();\n            if (candidates==null || candidates.length==0){\n                return res;\n            }\n            linkedlist<integer> list=new linkedlist<integer>();\n            arrays.sort(candidates);\n//            对于这种存在顺序的，可以把其实位置放在一起递归\n            dfs(candidates,list,res,target,0);\n            return res;\n        }\n\n        private void dfs(int[] candidates, linkedlist<integer> list, list<list<integer>> res, int target,int start) {\n            if (target==0){\n                res.add(new linkedlist<integer>(list));\n                return;\n            }\n            for (int i = start; i < candidates.length; i++) {\n                if (i>start && candidates[i]==candidates[i-1]){\n                    continue;\n                }\n                if (candidates[i]<=target){\n                    list.addlast(candidates[i]);\n                    dfs(candidates,list,res,target-candidates[i],i+1);\n                    list.removelast();\n                }\n            }\n        }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n# 高赞题解\n这道题与上一问的区别在于：\n\n * 第 39 题 [(https://leetcode-cn.com/problems/combination-sum/)]：candidates 中的数字可以无限制重复被选取。\n * 第 40 题：candidates 中的每个数字在每个组合中只能使用一次。\n\n编码的不同在于下一层递归的起始索引不一样。\n\n * 第 39 题：还从候选数组的当前索引值开始。\n * 第 40 题：从候选数组的当前索引值的下一位开始。\n\n相同之处：解集不能包含重复的组合。\n\n为了使得解集不包含重复的组合。我们想一想，如何去掉一个数组中重复的元素，除了使用哈希表以外，我们还可以先对数组升序排序，重复的元素一定不是排好序以后的第 1 个元素和相同元素的第 1 个元素。根据这个思想，我们先对数组升序排序是有必要的。候选数组有序，对于在递归树中发现重复分支，进而“剪枝”也是有效的。\n\n思路分析：\n\n这道题其实比上一问更简单，思路是：\n\n> 以 target 为根结点，依次减去数组中的数字，直到小于 000 或者等于 000，把等于 000 的结果记录到结果集中。\n\n\n当然你也可以以 000 为根结点，依次加上数组中的数字，直到大于 target 或者等于 target，把等于 target 的结果记录到结果集中。\n\n * “解集不能包含重复的组合”，就提示我们得对数组先排个序（“升序”或者“降序”均可，下面示例中均使用“升序”）。\n * “candidates 中的每个数字在每个组合中只能使用一次”，那就按照顺序依次减去数组中的元素，递归求解即可：遇到 000 就结算且回溯，遇到负数也回溯。\n * candidates 中的数字可以重复，可以借助「力扣」第 47 题：“全排列 ii” [https://leetcode-cn.com/problems/permutations-ii/solution/hui-su-suan-fa-python-dai-ma-java-dai-ma-by-liwe-2/] 的思想，在搜索的过程中，找到可能发生重复结果的分支，把它剪去。\n\n（温馨提示：下面的幻灯片中，有几页上有较多的文字，可能需要您停留一下，可以点击右下角的后退 “|◀” 或者前进 “▶|” 按钮控制幻灯片的播放。）\n\n<,>\n\n参考代码 1：以 target 为根结点，依次减去数组中的数字，直到小于 000 或者等于 000，把等于 000 的结果记录到结果集中。\n\n感谢用户 @rmokerone 提供的 c++ 版本的参考代码。\n\nimport java.util.arraydeque;\nimport java.util.arraylist;\nimport java.util.arrays;\nimport java.util.deque;\nimport java.util.list;\n\npublic class solution {\n\n    /**\n     * @param candidates 候选数组\n     * @param len\n     * @param begin      从候选数组的 begin 位置开始搜索\n     * @param residue    表示剩余，这个值一开始等于 target，基于题目中说明的"所有数字（包括目标数）都是正整数"这个条件\n     * @param path       从根结点到叶子结点的路径\n     * @param res\n     */\n    private void dfs(int[] candidates, int len, int begin, int residue, deque<integer> path, list<list<integer>> res) {\n        if (residue == 0) {\n            res.add(new arraylist<>(path));\n            return;\n        }\n        for (int i = begin; i < len; i++) {\n            // 大剪枝\n            if (residue - candidates[i] < 0) {\n                break;\n            }\n\n            // 小剪枝\n            if (i > begin && candidates[i] == candidates[i - 1]) {\n                continue;\n            }\n\n            path.addlast(candidates[i]);\n\n            // 因为元素不可以重复使用，这里递归传递下去的是 i + 1 而不是 i\n            dfs(candidates, len, i + 1, residue - candidates[i], path, res);\n\n            path.removelast();\n        }\n    }\n\n    public list<list<integer>> combinationsum2(int[] candidates, int target) {\n        int len = candidates.length;\n        list<list<integer>> res = new arraylist<>();\n        if (len == 0) {\n            return res;\n        }\n\n        // 先将数组排序，这一步很关键\n        arrays.sort(candidates);\n\n        deque<integer> path = new arraydeque<>(len);\n        dfs(candidates, len, 0, target, path, res);\n        return res;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\nfrom typing import list\n\n\nclass solution:\n\n    def combinationsum2(self, candidates: list[int], target: int) -> list[list[int]]:\n        def dfs(begin, path, residue):\n            if residue == 0:\n                res.append(path[:])\n                return\n\n            for index in range(begin, size):\n                if candidates[index] > residue:\n                    break\n\n                if index > begin and candidates[index - 1] == candidates[index]:\n                    continue\n\n                path.append(candidates[index])\n                dfs(index + 1, path, residue - candidates[index])\n                path.pop()\n\n        size = len(candidates)\n        if size == 0:\n            return []\n\n        candidates.sort()\n        res = []\n        dfs(0, [], target)\n        return res\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n// author:rmokerone\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass solution {\n\nprivate:\n    vector<int> candidates;\n    vector<vector<int>> res;\n    vector<int> path;\npublic:\n    void dfs(int start, int target) {\n        if (target == 0) {\n            res.push_back(path);\n            return;\n        }\n\n        for (int i = start; i < candidates.size() && target - candidates[i] >= 0; i++) {\n            if (i > start && candidates[i] == candidates[i - 1])\n                continue;\n            path.push_back(candidates[i]);\n            // 元素不可重复利用，使用下一个即i+1\n            dfs(i + 1, target - candidates[i]);\n            path.pop_back();\n        }\n    }\n\n    vector<vector<int>> combinationsum2(vector<int> &candidates, int target) {\n        sort(candidates.begin(), candidates.end());\n        this->candidates = candidates;\n        dfs(0, target);\n        return res;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n这里按照用户 @aspire [/u/aspire-6] 提供的思路，给出从 000 开始，一个使用加法，搜索加到目标数的写法，“前提是排序（升序降序均可）”，然后“剪枝”的操作和上面一样。\n\n\n\n参考代码 2：以 000 为根结点，依次加上数组中的数字，直到大于 target 或者等于 target，把等于 target 的结果记录到结果集中。\n\n#include <iostream>\n#include <vector>\n#include <map>\n\nusing namespace std;\n\nclass solution {\npublic:\n\n    vector<int> input;\n    int target;\n    vector<vector<int>> result;\n    vector<int> vc;\n\n    void dfs(int index, int sum) {\n        // index >= input.size() ，写成 index == input.size() 即可\n        // 因为每次都 + 1，在 index == input.size() 剪枝就可以了\n        if (sum >= target || index == input.size()) {\n            if (sum == target) {\n                result.push_back(vc);\n            }\n            return;\n        }\n        for (int i = index; i < input.size(); i++) {\n            if (input[i] > target) {\n                continue;\n            }\n\n            // 【我添加的代码在这里】：\n            // 1、i > index 表明剪枝的分支一定不是当前层的第 1 个分支\n            // 2、input[i - 1] == input[i] 表明当前选出来的数等于当前层前一个分支选出来的数\n            // 因为前一个分支的候选集合一定大于后一个分支的候选集合\n            // 故后面出现的分支中一定包含了前面分支出现的结果，因此剪枝\n            // “剪枝”的前提是排序，升序或者降序均可\n            if (i > index && input[i - 1] == input[i]) {\n                continue;\n            }\n\n            vc.push_back(input[i]);\n            sum += input[i];\n            dfs(i + 1, sum);\n            vc.pop_back();\n            sum -= input[i];\n        }\n    }\n\n    vector<vector<int>> combinationsum2(vector<int> &candidates, int target) {\n        // “剪枝”的前提是排序，升序或者降序均可\n        sort(candidates.begin(), candidates.end());\n        this->input = candidates;\n        this->target = target;\n        dfs(0, 0);\n        return result;\n    }\n};\n\n\nint main() {\n    cout << "leetcode 第 40 题：组合问题 ii" << endl;\n    solution solution = solution();\n\n    vector<int> candidates;\n    candidates.push_back(10);\n    candidates.push_back(1);\n    candidates.push_back(2);\n    candidates.push_back(7);\n    candidates.push_back(6);\n    candidates.push_back(1);\n    candidates.push_back(5);\n\n    int target = 8;\n    vector<vector<int>> res = solution.combinationsum2(candidates, target);\n    for (int i = 0; i < res.size(); ++i) {\n        for (int j = 0; j < res[i].size(); ++j) {\n            cout << res[i][j] << ",";\n        }\n        cout << "" << endl;\n    }\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-09-11 22:53:39accepted [https://leetcode-cn.com//submissions/detail/6937819/]15 ms27.5%n/ajava# 统计信息\n通过次数提交次数ac比率355235982959.4%# 相似题目\n题目难度组合总和 [https://leetcode-cn.com/problems/combination-sum/]中等'},{title:"46-全排列(Permutations)",frontmatter:{title:"46-全排列(Permutations)",date:"2018-07-19T00:00:00.000Z",categories:["中等"],tags:["回溯算法<Backtracking>"]},regularPath:"/views/%E4%B8%AD%E7%AD%89/0046-%E5%85%A8%E6%8E%92%E5%88%97.html",relativePath:"views/中等/0046-全排列.md",key:"v-4ed2f72c",path:"/views/%E4%B8%AD%E7%AD%89/0046-%E5%85%A8%E6%8E%92%E5%88%97.html",headers:[{level:2,title:"中文题目",slug:"中文题目",charIndex:2},{level:2,title:"通过代码",slug:"通过代码",charIndex:128},{level:2,title:"官方题解",slug:"官方题解",charIndex:1241},{level:2,title:"提交历史",slug:"提交历史",charIndex:4464},{level:2,title:"统计信息",slug:"统计信息",charIndex:4591},{level:2,title:"相似题目",slug:"相似题目",charIndex:4625}],lastUpdated:"4/11/2021, 1:15:21 PM",headersStr:"中文题目 通过代码 官方题解 提交历史 统计信息 相似题目",content:'# 中文题目\n给定一个没有重复数字的序列，返回其所有可能的全排列。\n\n示例:\n\n输入: [1,2,3]\n输出:\n[\n  [1,2,3],\n  [1,3,2],\n  [2,1,3],\n  [2,3,1],\n  [3,1,2],\n  [3,2,1]\n]\n\n# 通过代码\nclass Solution {\n   List<List<Integer>> res=new LinkedList<>();\n        boolean[] used;\n        void generatePermutation(int[] nums,int index,LinkedList<Integer> p){\n            if (index==nums.length){\n                LinkedList<Integer> temp=new LinkedList<>();\n                temp.addAll(p);\n                res.add(temp);\n                return;\n            }\n            for (int i = 0; i < nums.length; i++) {\n                if (!used[i]){\n                    p.addLast(nums[i]);\n                    used[i]=true;\n                    generatePermutation(nums,index+1,p);\n                    p.removeLast();\n                    used[i]=false;\n                }\n            }\n            return;\n        }\n\n        public List<List<Integer>> permute(int[] nums) {\n            if (nums.length==0){\n                return res;\n            }\n            used=new boolean[nums.length];\n            LinkedList<Integer> p=new LinkedList<>();\n            generatePermutation(nums,0,p);\n            return res;\n        }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n# 官方题解\n# 方法1：回溯法\n回溯法 [https://baike.baidu.com/item/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/9258495]是一种通过探索所有可能的候选解来找出所有的解的算法。如果候选解被确认 不是 一个解的话（或者至少不是 最后一个 解），回溯算法会通过在上一步进行一些变化抛弃该解，即 回溯 并且再次尝试。\n\n这里有一个回溯函数，使用第一个整数的索引作为参数 backtrack(first)。\n\n * 如果第一个整数有索引 n，意味着当前排列已完成。\n * 遍历索引 first 到索引 n - 1 的所有整数。Iterate over the integers from index first to index n - 1. * 在排列中放置第 i 个整数， 即 swap(nums[first], nums[i]).\n    * 继续生成从第 i 个整数开始的所有排列: backtrack(first + 1).\n    * 现在回溯，即通过 swap(nums[first], nums[i]) 还原.\n   \n   \n\n<,,,,,,,,,,,,,>\n\nclass Solution {\n  public void backtrack(int n,\n                        ArrayList<Integer> nums,\n                        List<List<Integer>> output,\n                        int first) {\n    // if all integers are used up\n    if (first == n)\n      output.add(new ArrayList<Integer>(nums));\n    for (int i = first; i < n; i++) {\n      // place i-th integer first \n      // in the current permutation\n      Collections.swap(nums, first, i);\n      // use next integers to complete the permutations\n      backtrack(n, nums, output, first + 1);\n      // backtrack\n      Collections.swap(nums, first, i);\n    }\n  }\n\n  public List<List<Integer>> permute(int[] nums) {\n    // init output list\n    List<List<Integer>> output = new LinkedList();\n\n    // convert nums into list since the output is a list of lists\n    ArrayList<Integer> nums_lst = new ArrayList<Integer>();\n    for (int num : nums)\n      nums_lst.add(num);\n\n    int n = nums.length;\n    backtrack(n, nums_lst, output, 0);\n    return output;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\nclass Solution:\n    def permute(self, nums):\n        """\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        """\n        def backtrack(first = 0):\n            # if all integers are used up\n            if first == n:  \n                output.append(nums[:])\n            for i in range(first, n):\n                # place i-th integer first \n                # in the current permutation\n                nums[first], nums[i] = nums[i], nums[first]\n                # use next integers to complete the permutations\n                backtrack(first + 1)\n                # backtrack\n                nums[first], nums[i] = nums[i], nums[first]\n        \n        n = len(nums)\n        output = []\n        backtrack()\n        return output\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n复杂性分析\n\n * 时间复杂度：O(∑k=1NP(N,k))\\mathcal{O}(\\sum_{k = 1}^{N}{P(N, k)})O(∑k=1N​P(N,k))， P(N,k)=N!(N−k)!=N(N−1)...(N−k+1)P(N, k) = \\frac{N!}{(N - k)!} = N (N - 1) ... (N - k + 1)P(N,k)=(N−k)!N!​=N(N−1)...(N−k+1)，该式被称作 n 的 k-排列，或者_部分排列_ [https://baike.baidu.com/item/%E6%8E%92%E5%88%97/7804523].\n\n为了简单起见，使 first+1=kfirst + 1 = kfirst+1=k. 这个公式很容易理解：对于每个 kkk (每个firstfirstfirst) 有 N(N−1)...(N−k+1)N(N - 1) ... (N - k + 1)N(N−1)...(N−k+1) 次操作， 且 kkk 的范围从 111 到 NNN (firstfirstfirst 从 000 到 N−1N - 1N−1).\n\n我们来做一个结果的粗略估计：N!≤∑k=1NN!(N−k)!=∑k=1NP(N,k)≤N×N!N! \\le \\sum_{k = 1}^{N}{\\frac{N!}{(N - k)!}} = \\sum_{k = 1}^{N}{P(N, k)} \\le N \\times N!N!≤∑k=1N​(N−k)!N!​=∑k=1N​P(N,k)≤N×N!, 即算法比 O(N×N!)\\mathcal{O}(N \\times N!)O(N×N!)更优 且 比 O(N!)\\mathcal{O}(N!)O(N!) 稍慢.\n\n * 空间复杂度：O(N!)\\mathcal{O}(N!)O(N!) 由于必须要保存N! 个解。\n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-07-19 23:14:19Accepted [https://leetcode-cn.com//submissions/detail/4398518/]7 ms6.09%N/Ajava# 统计信息\n通过次数提交次数AC比率701859535373.6%# 相似题目\n题目难度下一个排列 [https://leetcode-cn.com/problems/next-permutation/]中等全排列 II [https://leetcode-cn.com/problems/permutations-ii/]中等第k个排列 [https://leetcode-cn.com/problems/permutation-sequence/]中等组合 [https://leetcode-cn.com/problems/combinations/]中等',contentLowercase:'# 中文题目\n给定一个没有重复数字的序列，返回其所有可能的全排列。\n\n示例:\n\n输入: [1,2,3]\n输出:\n[\n  [1,2,3],\n  [1,3,2],\n  [2,1,3],\n  [2,3,1],\n  [3,1,2],\n  [3,2,1]\n]\n\n# 通过代码\nclass solution {\n   list<list<integer>> res=new linkedlist<>();\n        boolean[] used;\n        void generatepermutation(int[] nums,int index,linkedlist<integer> p){\n            if (index==nums.length){\n                linkedlist<integer> temp=new linkedlist<>();\n                temp.addall(p);\n                res.add(temp);\n                return;\n            }\n            for (int i = 0; i < nums.length; i++) {\n                if (!used[i]){\n                    p.addlast(nums[i]);\n                    used[i]=true;\n                    generatepermutation(nums,index+1,p);\n                    p.removelast();\n                    used[i]=false;\n                }\n            }\n            return;\n        }\n\n        public list<list<integer>> permute(int[] nums) {\n            if (nums.length==0){\n                return res;\n            }\n            used=new boolean[nums.length];\n            linkedlist<integer> p=new linkedlist<>();\n            generatepermutation(nums,0,p);\n            return res;\n        }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n# 官方题解\n# 方法1：回溯法\n回溯法 [https://baike.baidu.com/item/%e5%9b%9e%e6%ba%af%e7%ae%97%e6%b3%95/9258495]是一种通过探索所有可能的候选解来找出所有的解的算法。如果候选解被确认 不是 一个解的话（或者至少不是 最后一个 解），回溯算法会通过在上一步进行一些变化抛弃该解，即 回溯 并且再次尝试。\n\n这里有一个回溯函数，使用第一个整数的索引作为参数 backtrack(first)。\n\n * 如果第一个整数有索引 n，意味着当前排列已完成。\n * 遍历索引 first 到索引 n - 1 的所有整数。iterate over the integers from index first to index n - 1. * 在排列中放置第 i 个整数， 即 swap(nums[first], nums[i]).\n    * 继续生成从第 i 个整数开始的所有排列: backtrack(first + 1).\n    * 现在回溯，即通过 swap(nums[first], nums[i]) 还原.\n   \n   \n\n<,,,,,,,,,,,,,>\n\nclass solution {\n  public void backtrack(int n,\n                        arraylist<integer> nums,\n                        list<list<integer>> output,\n                        int first) {\n    // if all integers are used up\n    if (first == n)\n      output.add(new arraylist<integer>(nums));\n    for (int i = first; i < n; i++) {\n      // place i-th integer first \n      // in the current permutation\n      collections.swap(nums, first, i);\n      // use next integers to complete the permutations\n      backtrack(n, nums, output, first + 1);\n      // backtrack\n      collections.swap(nums, first, i);\n    }\n  }\n\n  public list<list<integer>> permute(int[] nums) {\n    // init output list\n    list<list<integer>> output = new linkedlist();\n\n    // convert nums into list since the output is a list of lists\n    arraylist<integer> nums_lst = new arraylist<integer>();\n    for (int num : nums)\n      nums_lst.add(num);\n\n    int n = nums.length;\n    backtrack(n, nums_lst, output, 0);\n    return output;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\nclass solution:\n    def permute(self, nums):\n        """\n        :type nums: list[int]\n        :rtype: list[list[int]]\n        """\n        def backtrack(first = 0):\n            # if all integers are used up\n            if first == n:  \n                output.append(nums[:])\n            for i in range(first, n):\n                # place i-th integer first \n                # in the current permutation\n                nums[first], nums[i] = nums[i], nums[first]\n                # use next integers to complete the permutations\n                backtrack(first + 1)\n                # backtrack\n                nums[first], nums[i] = nums[i], nums[first]\n        \n        n = len(nums)\n        output = []\n        backtrack()\n        return output\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n复杂性分析\n\n * 时间复杂度：o(∑k=1np(n,k))\\mathcal{o}(\\sum_{k = 1}^{n}{p(n, k)})o(∑k=1n​p(n,k))， p(n,k)=n!(n−k)!=n(n−1)...(n−k+1)p(n, k) = \\frac{n!}{(n - k)!} = n (n - 1) ... (n - k + 1)p(n,k)=(n−k)!n!​=n(n−1)...(n−k+1)，该式被称作 n 的 k-排列，或者_部分排列_ [https://baike.baidu.com/item/%e6%8e%92%e5%88%97/7804523].\n\n为了简单起见，使 first+1=kfirst + 1 = kfirst+1=k. 这个公式很容易理解：对于每个 kkk (每个firstfirstfirst) 有 n(n−1)...(n−k+1)n(n - 1) ... (n - k + 1)n(n−1)...(n−k+1) 次操作， 且 kkk 的范围从 111 到 nnn (firstfirstfirst 从 000 到 n−1n - 1n−1).\n\n我们来做一个结果的粗略估计：n!≤∑k=1nn!(n−k)!=∑k=1np(n,k)≤n×n!n! \\le \\sum_{k = 1}^{n}{\\frac{n!}{(n - k)!}} = \\sum_{k = 1}^{n}{p(n, k)} \\le n \\times n!n!≤∑k=1n​(n−k)!n!​=∑k=1n​p(n,k)≤n×n!, 即算法比 o(n×n!)\\mathcal{o}(n \\times n!)o(n×n!)更优 且 比 o(n!)\\mathcal{o}(n!)o(n!) 稍慢.\n\n * 空间复杂度：o(n!)\\mathcal{o}(n!)o(n!) 由于必须要保存n! 个解。\n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-07-19 23:14:19accepted [https://leetcode-cn.com//submissions/detail/4398518/]7 ms6.09%n/ajava# 统计信息\n通过次数提交次数ac比率701859535373.6%# 相似题目\n题目难度下一个排列 [https://leetcode-cn.com/problems/next-permutation/]中等全排列 ii [https://leetcode-cn.com/problems/permutations-ii/]中等第k个排列 [https://leetcode-cn.com/problems/permutation-sequence/]中等组合 [https://leetcode-cn.com/problems/combinations/]中等'},{title:"47-全排列 II(Permutations II)",frontmatter:{title:"47-全排列 II(Permutations II)",date:"2018-09-11T00:00:00.000Z",categories:["中等"],tags:["回溯算法<Backtracking>"]},regularPath:"/views/%E4%B8%AD%E7%AD%89/0047-%E5%85%A8%E6%8E%92%E5%88%97%20II.html",relativePath:"views/中等/0047-全排列 II.md",key:"v-46d8099a",path:"/views/%E4%B8%AD%E7%AD%89/0047-%E5%85%A8%E6%8E%92%E5%88%97%20II.html",headers:[{level:2,title:"中文题目",slug:"中文题目",charIndex:2},{level:2,title:"通过代码",slug:"通过代码",charIndex:96},{level:2,title:"高赞题解",slug:"高赞题解",charIndex:1753},{level:2,title:"提交历史",slug:"提交历史",charIndex:7400},{level:2,title:"统计信息",slug:"统计信息",charIndex:9027},{level:2,title:"相似题目",slug:"相似题目",charIndex:9061}],lastUpdated:"4/11/2021, 1:15:21 PM",headersStr:"中文题目 通过代码 高赞题解 提交历史 统计信息 相似题目",content:"# 中文题目\n给定一个可包含重复数字的序列，返回所有不重复的全排列。\n\n示例:\n\n输入: [1,1,2]\n输出:\n[\n  [1,1,2],\n  [1,2,1],\n  [2,1,1]\n]\n\n# 通过代码\nclass Solution {\n           public List<List<Integer>> permuteUnique(int[] nums) {\n            List<List<Integer>> res=new ArrayList<List<Integer>>();\n            if (nums==null || nums.length==0) {\n                return res;\n            }\n            boolean[] used=new boolean[nums.length];\n            List<Integer> list=new ArrayList<Integer>();\n            Arrays.sort(nums);\n            dfs(nums,used,list,res);\n            return res;\n\n        }\n\n        private void dfs(int[] nums, boolean[] used, List<Integer> list, List<List<Integer>> res) {\n            if (list.size()==nums.length){\n                res.add(new ArrayList<Integer>(list));\n                return;\n            }\n            for (int i = 0; i < nums.length; i++) {\n//                如果当前的元素已经添加过了\n                if (used[i]){\n                    continue;\n                }\n//                和前面的元素相同的，且当前不是在前面那个元素的递归栈上，故需要跳出\n//                考虑这种情况：\n//                       1     1    2\n//                      true false false\n//                上面这种情况是可以添加的\n//                       1      1    2\n//                        false  false false\n//                  上面这种情况在第二个一的时候，是不能添加的，因为前面已经添加过一次了\n                if (i>0 && nums[i]==nums[i-1] && !used[i-1]) {\n                    continue;\n                }\n                used[i]=true;\n                list.add(nums[i]);\n                dfs(nums,used,list,res);\n//                还原状态\n                used[i]=false;\n                list.remove(list.size()-1);\n            }\n        }\n    \n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n# 高赞题解\n思路分析：在一定会产生重复结果集的地方剪枝。\n\n这一题是在「力扣」第 46 题： “全排列” [https://leetcode-cn.com/problems/permutations/] 的基础上增加了“序列中的元素可重复”这一条件，但要求返回的结果又不能有重复元素。\n\n一个比较容易想到的办法是在结果集中去重。但是问题又来了，这些结果集的元素是一个又一个列表，对列表去重不像用哈希表对基本元素去重那样容易。\n\n如果实在要比较两个列表是否一样，一个很显然的办法就是分别排序，然后逐个比对。想到这里，其实思路就来了，既然要排序，我们可以在搜索之前就对候选数组排序，一旦发现这一支搜索下去可能搜索到重复元素，就停止搜索，这样结果集中不就没有重复元素了吗。\n\n\n\n产生重复结点的地方，正是图中标注了“剪刀”，且被绿色框框住的地方。\n\n大家也可以把第 2 个 1 加上 ' ，即 [1, 1', 2] 去想象这个搜索的过程。只要遇到起点一样，就有可能产生重复。这里还有一个很细节的地方：\n\n1、在图中 ② 处，搜索的数也和上一次一样，但是上一次的 1 还在使用中； 2、在图中 ① 处，搜索的数也和上一次一样，但是上一次的 1 刚刚被撤销，正是因为刚被撤销，下面的搜索中还会使用到，因此会产生重复，剪掉的就应该是这样的分支。\n\n代码实现方面，在第 46 题的基础上，要加上这样一段代码：\n\nif (i > 0 && nums[i] == nums[i - 1] && !used[i - 1]) {\n    continue;\n}\n\n\n1\n2\n3\n这段代码就能检测到标注为 ① 的两个结点，跳过它们。注意：这里 used[i - 1] 不加 !，测评也能通过。有兴趣的朋友可以想一想这是为什么。建议大家做这样几个对比实验：\n\n1、干脆就不写 !used[i - 1] 结果是什么样？ 2、写 used[i - 1] 结果是什么，代码又是怎样执行的。这里给的结论是：!used[i - 1] 这样的剪枝更彻底。附录会分析原因。\n\n参考代码 1：\n\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Deque;\nimport java.util.List;\n\npublic class Solution {\n\n    public List<List<Integer>> permuteUnique(int[] nums) {\n        int len = nums.length;\n        List<List<Integer>> res = new ArrayList<>();\n        if (len == 0) {\n            return res;\n        }\n\n        // 修改 1：排序（这里用升序），为了剪枝方便\n        Arrays.sort(nums);\n\n        boolean[] used = new boolean[len];\n        // 使用 Deque 是 Java 官方 Stack 类的建议\n        Deque<Integer> path = new ArrayDeque<>(len);\n        dfs(nums, len, 0, used, path, res);\n        return res;\n    }\n\n    private void dfs(int[] nums, int len, int depth, boolean[] used, Deque<Integer> stack, List<List<Integer>> res) {\n        if (depth == len) {\n            res.add(new ArrayList<>(stack));\n            return;\n        }\n        for (int i = 0; i < len; i++) {\n            if (!used[i]) {\n\n                // 修改 2：在 used[i - 1] 刚刚被撤销的时候剪枝，说明接下来会被选择，搜索一定会重复，故\"剪枝\"\n                if (i > 0 && nums[i - 1] == nums[i] && !used[i - 1]) {\n                    continue;\n                }\n\n                used[i] = true;\n                stack.addLast(nums[i]);\n                dfs(nums, len, depth + 1, used, stack, res);\n\n                // 回溯，撤销选择\n                stack.removeLast();\n                used[i] = false;\n            }\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\nfrom typing import List\n\n\nclass Solution:\n\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\n\n        def dfs(nums, size, depth, path, used, res):\n            if depth == size:\n                res.append(path.copy())\n                return\n            for i in range(size):\n                if not used[i]:\n\n                    if i > 0 and nums[i] == nums[i - 1] and not used[i - 1]:\n                        continue\n\n                    used[i] = True\n                    path.append(nums[i])\n                    dfs(nums, size, depth + 1, path, used, res)\n                    used[i] = False\n                    path.pop()\n\n        size = len(nums)\n        if size == 0:\n            return []\n\n        nums.sort()\n\n        used = [False] * len(nums)\n        res = []\n        dfs(nums, size, 0, [], used, res)\n        return res\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n想明白了上面这个思路，其实可以使用一个 pre 变量，记录上一次搜索的起点，只要起点一样就跳过这个分支，这种思路更加直接。感谢 @july 提供的思路。\n\n参考代码 2：\n\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Deque;\nimport java.util.List;\n\npublic class Solution {\n\n    public List<List<Integer>> permuteUnique(int[] nums) {\n        int len = nums.length;\n        List<List<Integer>> res = new ArrayList<>();\n        if (len == 0) {\n            return res;\n        }\n\n        // 修改 1：排序（升序或者降序都可以），为了剪枝方便\n        Arrays.sort(nums);\n\n        boolean[] used = new boolean[len];\n        // 使用 Deque 是 Java 官方 Stack 类的建议\n        Deque<Integer> path = new ArrayDeque<>(len);\n        dfs(nums, len, 0, used, path, res);\n        return res;\n    }\n\n    private void dfs(int[] nums, int len, int depth, boolean[] used, Deque<Integer> path, List<List<Integer>> res) {\n        if (depth == len) {\n            res.add(new ArrayList<>(path));\n            return;\n        }\n\n        // 这个 pre 值必须是整个数组中没有出现的，因此下边界 - 1 或者是上边界 + 1，均可\n        // 如果数组中有 int 类型的最大值或者最小值，可能会存在问题，好在这题里没有极端数据\n        int pre = nums[0] - 1;\n        for (int i = 0; i < len; ++i) {\n            if (!used[i] && pre != nums[i]) {\n                path.addLast(nums[i]);\n                used[i] = true;\n\n                dfs(nums, len, depth + 1, used, path, res);\n\n                used[i] = false;\n                path.removeLast();\n\n                pre = nums[i];\n            }\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n附录：分析写 used[i - 1] 代码正确，但是不推荐的原因。\n\n思路是分析一下此时数组 used 的值的状态即可：\n\n1、如果剪枝写的是：\n\nif (i > 0 && nums[i] == nums[i - 1] && !used[i - 1]) {\n    continue;\n}\n\n\n1\n2\n3\n那么，对于数组 [1, 1’, 1’’, 2]，回溯的过程如下：\n\n\n\n得到的全排列是：[[1, 1', 1'', 2], [1, 1', 2, 1''], [1, 2, 1', 1''], [2, 1, 1', 1'']]。特点是：1、1'、1'' 出现的顺序只能是 1、1'、1''。\n\n2、如果剪枝写的是：\n\nif (i > 0 && nums[i] == nums[i - 1] && used[i - 1]) {\n    continue;\n}\n\n\n1\n2\n3\n那么，对于数组 [1, 1’, 1’’, 2]，回溯的过程如下（因为过程稍显繁琐，所以没有画在一张图里）：\n\n（1）先选第 1 个数字，有 4 种取法。\n\n\n\n（2）对第 1 步的第 1 个分支，可以继续搜索，但是发现，没有搜索到合适的叶子结点。\n\n\n\n（3）对第 1 步的第 2 个分支，可以继续搜索，但是同样发现，没有搜索到合适的叶子结点。\n\n\n\n（4）对第 1 步的第 3 个分支，继续搜索发现搜索到合适的叶子结点。\n\n\n\n（5）对第 1 步的第 4 个分支，继续搜索发现搜索到合适的叶子结点。\n\n\n\n因此，used[i - 1] 前面加不加感叹号的区别仅在于保留的是相同元素的顺序索引，还是倒序索引。很明显，顺序索引（即使用 !used[i - 1] 作为剪枝判定条件得到）的递归树剪枝更彻底，思路也相对较自然。\n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-09-11 22:55:57Accepted [https://leetcode-cn.com//submissions/detail/6938010/]4 ms44.9%N/Ajava2018-09-11 21:54:21Compile Error [https://leetcode-cn.com//submissions/detail/6933952/]N/AN/AN/Ajava2018-09-11 21:53:32Compile Error [https://leetcode-cn.com//submissions/detail/6933914/]N/AN/AN/Ajava2018-09-11 21:17:36Compile Error [https://leetcode-cn.com//submissions/detail/6931800/]N/AN/AN/Ajava2018-09-11 21:01:53Compile Error [https://leetcode-cn.com//submissions/detail/6930874/]N/AN/AN/Ajava2018-09-11 21:00:41Compile Error [https://leetcode-cn.com//submissions/detail/6930810/]N/AN/AN/Ajava2018-09-11 21:00:14Compile Error [https://leetcode-cn.com//submissions/detail/6930779/]N/AN/AN/Ajava2018-09-11 20:58:31Compile Error [https://leetcode-cn.com//submissions/detail/6930700/]N/AN/AN/Ajava2018-09-11 20:58:09Compile Error [https://leetcode-cn.com//submissions/detail/6930684/]N/AN/AN/Ajava2018-09-11 20:57:05Compile Error [https://leetcode-cn.com//submissions/detail/6930624/]N/AN/AN/Ajava2018-09-11 20:54:59Compile Error [https://leetcode-cn.com//submissions/detail/6930514/]N/AN/AN/Ajava2018-09-11 20:52:35Compile Error [https://leetcode-cn.com//submissions/detail/6930376/]N/AN/AN/Ajava2018-09-11 20:52:14Compile Error [https://leetcode-cn.com//submissions/detail/6930364/]N/AN/AN/Ajava2018-09-11 20:51:48Compile Error [https://leetcode-cn.com//submissions/detail/6930330/]N/AN/AN/Ajava2018-09-11 20:51:39Compile Error [https://leetcode-cn.com//submissions/detail/6930321/]N/AN/AN/Ajava2018-09-11 20:51:06Compile Error [https://leetcode-cn.com//submissions/detail/6930293/]N/AN/AN/Ajava# 统计信息\n通过次数提交次数AC比率344096082456.6%# 相似题目\n题目难度下一个排列 [https://leetcode-cn.com/problems/next-permutation/]中等全排列 [https://leetcode-cn.com/problems/permutations/]中等回文排列 II [https://leetcode-cn.com/problems/palindrome-permutation-ii/]中等正方形数组的数目 [https://leetcode-cn.com/problems/number-of-squareful-arrays/]困难",contentLowercase:"# 中文题目\n给定一个可包含重复数字的序列，返回所有不重复的全排列。\n\n示例:\n\n输入: [1,1,2]\n输出:\n[\n  [1,1,2],\n  [1,2,1],\n  [2,1,1]\n]\n\n# 通过代码\nclass solution {\n           public list<list<integer>> permuteunique(int[] nums) {\n            list<list<integer>> res=new arraylist<list<integer>>();\n            if (nums==null || nums.length==0) {\n                return res;\n            }\n            boolean[] used=new boolean[nums.length];\n            list<integer> list=new arraylist<integer>();\n            arrays.sort(nums);\n            dfs(nums,used,list,res);\n            return res;\n\n        }\n\n        private void dfs(int[] nums, boolean[] used, list<integer> list, list<list<integer>> res) {\n            if (list.size()==nums.length){\n                res.add(new arraylist<integer>(list));\n                return;\n            }\n            for (int i = 0; i < nums.length; i++) {\n//                如果当前的元素已经添加过了\n                if (used[i]){\n                    continue;\n                }\n//                和前面的元素相同的，且当前不是在前面那个元素的递归栈上，故需要跳出\n//                考虑这种情况：\n//                       1     1    2\n//                      true false false\n//                上面这种情况是可以添加的\n//                       1      1    2\n//                        false  false false\n//                  上面这种情况在第二个一的时候，是不能添加的，因为前面已经添加过一次了\n                if (i>0 && nums[i]==nums[i-1] && !used[i-1]) {\n                    continue;\n                }\n                used[i]=true;\n                list.add(nums[i]);\n                dfs(nums,used,list,res);\n//                还原状态\n                used[i]=false;\n                list.remove(list.size()-1);\n            }\n        }\n    \n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n# 高赞题解\n思路分析：在一定会产生重复结果集的地方剪枝。\n\n这一题是在「力扣」第 46 题： “全排列” [https://leetcode-cn.com/problems/permutations/] 的基础上增加了“序列中的元素可重复”这一条件，但要求返回的结果又不能有重复元素。\n\n一个比较容易想到的办法是在结果集中去重。但是问题又来了，这些结果集的元素是一个又一个列表，对列表去重不像用哈希表对基本元素去重那样容易。\n\n如果实在要比较两个列表是否一样，一个很显然的办法就是分别排序，然后逐个比对。想到这里，其实思路就来了，既然要排序，我们可以在搜索之前就对候选数组排序，一旦发现这一支搜索下去可能搜索到重复元素，就停止搜索，这样结果集中不就没有重复元素了吗。\n\n\n\n产生重复结点的地方，正是图中标注了“剪刀”，且被绿色框框住的地方。\n\n大家也可以把第 2 个 1 加上 ' ，即 [1, 1', 2] 去想象这个搜索的过程。只要遇到起点一样，就有可能产生重复。这里还有一个很细节的地方：\n\n1、在图中 ② 处，搜索的数也和上一次一样，但是上一次的 1 还在使用中； 2、在图中 ① 处，搜索的数也和上一次一样，但是上一次的 1 刚刚被撤销，正是因为刚被撤销，下面的搜索中还会使用到，因此会产生重复，剪掉的就应该是这样的分支。\n\n代码实现方面，在第 46 题的基础上，要加上这样一段代码：\n\nif (i > 0 && nums[i] == nums[i - 1] && !used[i - 1]) {\n    continue;\n}\n\n\n1\n2\n3\n这段代码就能检测到标注为 ① 的两个结点，跳过它们。注意：这里 used[i - 1] 不加 !，测评也能通过。有兴趣的朋友可以想一想这是为什么。建议大家做这样几个对比实验：\n\n1、干脆就不写 !used[i - 1] 结果是什么样？ 2、写 used[i - 1] 结果是什么，代码又是怎样执行的。这里给的结论是：!used[i - 1] 这样的剪枝更彻底。附录会分析原因。\n\n参考代码 1：\n\nimport java.util.arraydeque;\nimport java.util.arraylist;\nimport java.util.arrays;\nimport java.util.deque;\nimport java.util.list;\n\npublic class solution {\n\n    public list<list<integer>> permuteunique(int[] nums) {\n        int len = nums.length;\n        list<list<integer>> res = new arraylist<>();\n        if (len == 0) {\n            return res;\n        }\n\n        // 修改 1：排序（这里用升序），为了剪枝方便\n        arrays.sort(nums);\n\n        boolean[] used = new boolean[len];\n        // 使用 deque 是 java 官方 stack 类的建议\n        deque<integer> path = new arraydeque<>(len);\n        dfs(nums, len, 0, used, path, res);\n        return res;\n    }\n\n    private void dfs(int[] nums, int len, int depth, boolean[] used, deque<integer> stack, list<list<integer>> res) {\n        if (depth == len) {\n            res.add(new arraylist<>(stack));\n            return;\n        }\n        for (int i = 0; i < len; i++) {\n            if (!used[i]) {\n\n                // 修改 2：在 used[i - 1] 刚刚被撤销的时候剪枝，说明接下来会被选择，搜索一定会重复，故\"剪枝\"\n                if (i > 0 && nums[i - 1] == nums[i] && !used[i - 1]) {\n                    continue;\n                }\n\n                used[i] = true;\n                stack.addlast(nums[i]);\n                dfs(nums, len, depth + 1, used, stack, res);\n\n                // 回溯，撤销选择\n                stack.removelast();\n                used[i] = false;\n            }\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\nfrom typing import list\n\n\nclass solution:\n\n    def permuteunique(self, nums: list[int]) -> list[list[int]]:\n\n        def dfs(nums, size, depth, path, used, res):\n            if depth == size:\n                res.append(path.copy())\n                return\n            for i in range(size):\n                if not used[i]:\n\n                    if i > 0 and nums[i] == nums[i - 1] and not used[i - 1]:\n                        continue\n\n                    used[i] = true\n                    path.append(nums[i])\n                    dfs(nums, size, depth + 1, path, used, res)\n                    used[i] = false\n                    path.pop()\n\n        size = len(nums)\n        if size == 0:\n            return []\n\n        nums.sort()\n\n        used = [false] * len(nums)\n        res = []\n        dfs(nums, size, 0, [], used, res)\n        return res\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n想明白了上面这个思路，其实可以使用一个 pre 变量，记录上一次搜索的起点，只要起点一样就跳过这个分支，这种思路更加直接。感谢 @july 提供的思路。\n\n参考代码 2：\n\nimport java.util.arraydeque;\nimport java.util.arraylist;\nimport java.util.arrays;\nimport java.util.deque;\nimport java.util.list;\n\npublic class solution {\n\n    public list<list<integer>> permuteunique(int[] nums) {\n        int len = nums.length;\n        list<list<integer>> res = new arraylist<>();\n        if (len == 0) {\n            return res;\n        }\n\n        // 修改 1：排序（升序或者降序都可以），为了剪枝方便\n        arrays.sort(nums);\n\n        boolean[] used = new boolean[len];\n        // 使用 deque 是 java 官方 stack 类的建议\n        deque<integer> path = new arraydeque<>(len);\n        dfs(nums, len, 0, used, path, res);\n        return res;\n    }\n\n    private void dfs(int[] nums, int len, int depth, boolean[] used, deque<integer> path, list<list<integer>> res) {\n        if (depth == len) {\n            res.add(new arraylist<>(path));\n            return;\n        }\n\n        // 这个 pre 值必须是整个数组中没有出现的，因此下边界 - 1 或者是上边界 + 1，均可\n        // 如果数组中有 int 类型的最大值或者最小值，可能会存在问题，好在这题里没有极端数据\n        int pre = nums[0] - 1;\n        for (int i = 0; i < len; ++i) {\n            if (!used[i] && pre != nums[i]) {\n                path.addlast(nums[i]);\n                used[i] = true;\n\n                dfs(nums, len, depth + 1, used, path, res);\n\n                used[i] = false;\n                path.removelast();\n\n                pre = nums[i];\n            }\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n附录：分析写 used[i - 1] 代码正确，但是不推荐的原因。\n\n思路是分析一下此时数组 used 的值的状态即可：\n\n1、如果剪枝写的是：\n\nif (i > 0 && nums[i] == nums[i - 1] && !used[i - 1]) {\n    continue;\n}\n\n\n1\n2\n3\n那么，对于数组 [1, 1’, 1’’, 2]，回溯的过程如下：\n\n\n\n得到的全排列是：[[1, 1', 1'', 2], [1, 1', 2, 1''], [1, 2, 1', 1''], [2, 1, 1', 1'']]。特点是：1、1'、1'' 出现的顺序只能是 1、1'、1''。\n\n2、如果剪枝写的是：\n\nif (i > 0 && nums[i] == nums[i - 1] && used[i - 1]) {\n    continue;\n}\n\n\n1\n2\n3\n那么，对于数组 [1, 1’, 1’’, 2]，回溯的过程如下（因为过程稍显繁琐，所以没有画在一张图里）：\n\n（1）先选第 1 个数字，有 4 种取法。\n\n\n\n（2）对第 1 步的第 1 个分支，可以继续搜索，但是发现，没有搜索到合适的叶子结点。\n\n\n\n（3）对第 1 步的第 2 个分支，可以继续搜索，但是同样发现，没有搜索到合适的叶子结点。\n\n\n\n（4）对第 1 步的第 3 个分支，继续搜索发现搜索到合适的叶子结点。\n\n\n\n（5）对第 1 步的第 4 个分支，继续搜索发现搜索到合适的叶子结点。\n\n\n\n因此，used[i - 1] 前面加不加感叹号的区别仅在于保留的是相同元素的顺序索引，还是倒序索引。很明显，顺序索引（即使用 !used[i - 1] 作为剪枝判定条件得到）的递归树剪枝更彻底，思路也相对较自然。\n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-09-11 22:55:57accepted [https://leetcode-cn.com//submissions/detail/6938010/]4 ms44.9%n/ajava2018-09-11 21:54:21compile error [https://leetcode-cn.com//submissions/detail/6933952/]n/an/an/ajava2018-09-11 21:53:32compile error [https://leetcode-cn.com//submissions/detail/6933914/]n/an/an/ajava2018-09-11 21:17:36compile error [https://leetcode-cn.com//submissions/detail/6931800/]n/an/an/ajava2018-09-11 21:01:53compile error [https://leetcode-cn.com//submissions/detail/6930874/]n/an/an/ajava2018-09-11 21:00:41compile error [https://leetcode-cn.com//submissions/detail/6930810/]n/an/an/ajava2018-09-11 21:00:14compile error [https://leetcode-cn.com//submissions/detail/6930779/]n/an/an/ajava2018-09-11 20:58:31compile error [https://leetcode-cn.com//submissions/detail/6930700/]n/an/an/ajava2018-09-11 20:58:09compile error [https://leetcode-cn.com//submissions/detail/6930684/]n/an/an/ajava2018-09-11 20:57:05compile error [https://leetcode-cn.com//submissions/detail/6930624/]n/an/an/ajava2018-09-11 20:54:59compile error [https://leetcode-cn.com//submissions/detail/6930514/]n/an/an/ajava2018-09-11 20:52:35compile error [https://leetcode-cn.com//submissions/detail/6930376/]n/an/an/ajava2018-09-11 20:52:14compile error [https://leetcode-cn.com//submissions/detail/6930364/]n/an/an/ajava2018-09-11 20:51:48compile error [https://leetcode-cn.com//submissions/detail/6930330/]n/an/an/ajava2018-09-11 20:51:39compile error [https://leetcode-cn.com//submissions/detail/6930321/]n/an/an/ajava2018-09-11 20:51:06compile error [https://leetcode-cn.com//submissions/detail/6930293/]n/an/an/ajava# 统计信息\n通过次数提交次数ac比率344096082456.6%# 相似题目\n题目难度下一个排列 [https://leetcode-cn.com/problems/next-permutation/]中等全排列 [https://leetcode-cn.com/problems/permutations/]中等回文排列 ii [https://leetcode-cn.com/problems/palindrome-permutation-ii/]中等正方形数组的数目 [https://leetcode-cn.com/problems/number-of-squareful-arrays/]困难"},{title:"22-括号生成(Generate Parentheses)",frontmatter:{title:"22-括号生成(Generate Parentheses)",date:"2021-04-21T00:00:00.000Z",categories:["中等"],tags:["字符串<String>","回溯算法<Backtracking>"]},regularPath:"/views/%E4%B8%AD%E7%AD%89/0022-%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90.html",relativePath:"views/中等/0022-括号生成.md",key:"v-27f937b5",path:"/views/%E4%B8%AD%E7%AD%89/0022-%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90.html",headers:[{level:2,title:"中文题目",slug:"中文题目",charIndex:2},{level:2,title:"通过代码",slug:"通过代码",charIndex:171},{level:2,title:"我的笔记",slug:"我的笔记",charIndex:1202},{level:2,title:"高赞题解",slug:"高赞题解",charIndex:1216},{level:3,title:"方法一：深度优先遍历",slug:"方法一：深度优先遍历",charIndex:1386},{level:3,title:"方法二：广度优先遍历",slug:"方法二：广度优先遍历",charIndex:5629},{level:2,title:"提交历史",slug:"提交历史",charIndex:11233},{level:2,title:"统计信息",slug:"统计信息",charIndex:11367},{level:2,title:"相似题目",slug:"相似题目",charIndex:11403}],headersStr:"中文题目 通过代码 我的笔记 高赞题解 方法一：深度优先遍历 方法二：广度优先遍历 提交历史 统计信息 相似题目",content:'# 中文题目\n数字 n代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。\n\n\n\n示例 1：\n\n\n输入：n = 3\n输出：["((()))","(()())","(())()","()(())","()()()"]\n\n\n示例 2：\n\n\n输入：n = 1\n输出：["()"]\n\n\n\n\n提示：\n\n * 1 \n\n# 通过代码\n    class Solution {\n        public List<String> generateParenthesis(int n) {\n            List<String> res=new ArrayList<>();\n            generate(res,new StringBuilder(),0,0,n);\n            return res;\n        }\n\n        private void generate(List<String> res, StringBuilder str, int left, int right, int n) {\n            // 达到长度\n            if (str.length()==2*n){\n                res.add(str.toString());\n                return;\n            }\n            // 单独的左边的必须小于n\n            if (left<n){\n                // 先添加左边的\n                str.append("(");\n                // 继续递归\n                generate(res,str,left+1,right,n);\n                // 回溯\n                str.deleteCharAt(str.length()-1);\n            }\n            // 右边的必须小于等于左边的\n            if (right<left){\n                str.append(")");\n                generate(res, str, left, right+1, n);\n                str.deleteCharAt(str.length()-1);\n            }\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n# 我的笔记\n\n\n回溯法\n\n# 高赞题解\n这一类问题是在一棵隐式的树上求解，可以用深度优先遍历，也可以用广度优先遍历。 一般用深度优先遍历。原因是：\n\n * 代码好写，使用递归的方法，直接借助系统栈完成状态的转移；\n * 广度优先遍历得自己编写结点类和借助队列。\n\n这里的「状态」是指程序执行到 隐式树 的某个结点的语言描述，在程序中用不同的 变量 加以区分。\n\n\n\n# 方法一：深度优先遍历\n我们以 n = 2 为例，画树形结构图。方法是 「做减法」。\n\n{:width=500} {:align=center}\n\n画图以后，可以分析出的结论：\n\n * 当前左右括号都有大于 000 个可以使用的时候，才产生分支；\n * 产生左分支的时候，只看当前是否还有左括号可以使用；\n * 产生右分支的时候，还受到左分支的限制，右边剩余可以使用的括号数量一定得在严格大于左边剩余的数量的时候，才可以产生分支；\n * 在左边和右边剩余的括号数都等于 000 的时候结算。\n\n参考代码 1：\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Solution {\n\n    // 做减法\n\n    public List<String> generateParenthesis(int n) {\n        List<String> res = new ArrayList<>();\n        // 特判\n        if (n == 0) {\n            return res;\n        }\n\n        // 执行深度优先遍历，搜索可能的结果\n        dfs("", n, n, res);\n        return res;\n    }\n\n    /**\n     * @param curStr 当前递归得到的结果\n     * @param left   左括号还有几个可以使用\n     * @param right  右括号还有几个可以使用\n     * @param res    结果集\n     */\n    private void dfs(String curStr, int left, int right, List<String> res) {\n        // 因为每一次尝试，都使用新的字符串变量，所以无需回溯\n        // 在递归终止的时候，直接把它添加到结果集即可，注意与「力扣」第 46 题、第 39 题区分\n        if (left == 0 && right == 0) {\n            res.add(curStr);\n            return;\n        }\n\n        // 剪枝（如图，左括号可以使用的个数严格大于右括号可以使用的个数，才剪枝，注意这个细节）\n        if (left > right) {\n            return;\n        }\n\n        if (left > 0) {\n            dfs(curStr + "(", left - 1, right, res);\n        }\n\n        if (right > 0) {\n            dfs(curStr + ")", left, right - 1, res);\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\nfrom typing import List\n\n\nclass Solution:\n    def generateParenthesis(self, n: int) -> List[str]:\n\n        res = []\n        cur_str = \'\'\n\n        def dfs(cur_str, left, right):\n            """\n            :param cur_str: 从根结点到叶子结点的路径字符串\n            :param left: 左括号还可以使用的个数\n            :param right: 右括号还可以使用的个数\n            :return:\n            """\n            if left == 0 and right == 0:\n                res.append(cur_str)\n                return\n            if right < left:\n                return\n            if left > 0:\n                dfs(cur_str + \'(\', left - 1, right)\n            if right > 0:\n                dfs(cur_str + \')\', left, right - 1)\n\n        dfs(cur_str, n, n)\n        return res\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n我们运行 n = 2 的情况，得到结果 [(()), ()()] ，说明分析的结果是正确的。\n\n如果我们不用减法，使用加法，即 left 表示「左括号还有几个没有用掉」，right 表示「右括号还有几个没有用掉」，可以画出另一棵递归树。\n\n{:width=500} {:align=center}\n\n下面是参考代码。\n\n参考代码 2：\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Solution {\n\n    // 做加法\n\n    public List<String> generateParenthesis(int n) {\n        List<String> res = new ArrayList<>();\n        // 特判\n        if (n == 0) {\n            return res;\n        }\n\n        dfs("", 0, 0, n, res);\n        return res;\n    }\n\n    /**\n     * @param curStr 当前递归得到的结果\n     * @param left   左括号已经用了几个\n     * @param right  右括号已经用了几个\n     * @param n      左括号、右括号一共得用几个\n     * @param res    结果集\n     */\n    private void dfs(String curStr, int left, int right, int n, List<String> res) {\n        if (left == n && right == n) {\n            res.add(curStr);\n            return;\n        }\n\n        // 剪枝\n        if (left < right) {\n            return;\n        }\n\n        if (left < n) {\n            dfs(curStr + "(", left + 1, right, n, res);\n        }\n        if (right < n) {\n            dfs(curStr + ")", left, right + 1, n, res);\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\nfrom typing import List\n\n\nclass Solution:\n    def generateParenthesis(self, n: int) -> List[str]:\n\n        res = []\n        cur_str = \'\'\n\n        def dfs(cur_str, left, right, n):\n            """\n            :param cur_str: 从根结点到叶子结点的路径字符串\n            :param left: 左括号已经使用的个数\n            :param right: 右括号已经使用的个数\n            :return:\n            """\n            if left == n and right == n:\n                res.append(cur_str)\n                return\n            if left < right:\n                return\n\n            if left < n:\n                dfs(cur_str + \'(\', left + 1, right, n)\n\n            if right < n:\n                dfs(cur_str + \')\', left, right + 1, n)\n\n        dfs(cur_str, 0, 0, n)\n        return res\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n\n# 方法二：广度优先遍历\n通过编写广度优先遍历的代码，读者可以体会一下，为什么搜索几乎都是用深度优先遍历（回溯算法）。\n\n广度优先遍历，得程序员自己编写结点类，显示使用队列这个数据结构。深度优先遍历的时候，就可以直接使用系统栈，在递归方法执行完成的时候，系统栈顶就把我们所需要的状态信息直接弹出，而无须编写结点类和显示使用栈。\n\n下面的代码，读者可以把 Queue 换成 Stack，提交以后，也可以得到 Accept。\n\n读者可以通过比较：\n\n * 广度优先遍历；\n * 自己使用栈编写深度优先遍历；\n * 使用系统栈的深度优先遍历（回溯算法）。\n\n来理解「回溯算法」作为一种「搜索算法」的合理性。\n\n还是上面的题解配图（1），使用广度优先遍历，结果集都在最后一层，即叶子结点处得到所有的结果集，编写代码如下。\n\n感谢 @liu-ren-you 朋友帮我优化了代码。\n\n参考代码 3：（前 2 个 Java 代码写法没有本质不同，仅供参考。第 3 个 Java 代码仅仅是把 Queue 换成了 Stack ，广度优先遍历就改成了深度优先遍历。）\n\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Deque;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Queue;\n\npublic class Solution {\n\n    class Node {\n        /**\n         * 当前得到的字符串\n         */\n        private String res;\n        /**\n         * 剩余左括号数量\n         */\n        private int left;\n        /**\n         * 剩余右括号数量\n         */\n        private int right;\n\n        public Node(String str, int left, int right) {\n            this.res = str;\n            this.left = left;\n            this.right = right;\n        }\n    }\n\n    public List<String> generateParenthesis(int n) {\n        List<String> res = new ArrayList<>();\n        if (n == 0) {\n            return res;\n        }\n        Queue<Node> queue = new LinkedList<>();\n        queue.offer(new Node("", n, n));\n\n        while (!queue.isEmpty()) {\n\n            Node curNode = queue.poll();\n            if (curNode.left == 0 && curNode.right == 0) {\n                res.add(curNode.res);\n            }\n            if (curNode.left > 0) {\n                queue.offer(new Node(curNode.res + "(", curNode.left - 1, curNode.right));\n            }\n            if (curNode.right > 0 && curNode.left < curNode.right) {\n                queue.offer(new Node(curNode.res + ")", curNode.left, curNode.right - 1));\n            }\n        }\n        return res;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\nimport java.util.ArrayList;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Queue;\n\npublic class Solution {\n\n    class Node {\n        /**\n         * 当前得到的字符串\n         */\n        private String res;\n        /**\n         * 剩余左括号数量\n         */\n        private int left;\n        /**\n         * 剩余右括号数量\n         */\n        private int right;\n\n        public Node(String res, int left, int right) {\n            this.res = res;\n            this.left = left;\n            this.right = right;\n        }\n\n        @Override\n        public String toString() {\n            return "Node{" +\n                    "res=\'" + res + \'\\\'\' +\n                    ", left=" + left +\n                    ", right=" + right +\n                    \'}\';\n        }\n    }\n\n    public List<String> generateParenthesis(int n) {\n        List<String> res = new ArrayList<>();\n        if (n == 0) {\n            return res;\n        }\n        Queue<Node> queue = new LinkedList<>();\n        queue.offer(new Node("", n, n));\n        // 总共需要拼凑的字符总数是 2 * n\n        n = 2 * n;\n        while (n > 0) {\n            int size = queue.size();\n            for (int i = 0; i < size; i++) {\n                Node curNode = queue.poll();\n                if (curNode.left > 0) {\n                    queue.offer(new Node(curNode.res + "(", curNode.left - 1, curNode.right));\n                }\n                if (curNode.right > 0 && curNode.left < curNode.right) {\n                    queue.offer(new Node(curNode.res + ")", curNode.left, curNode.right - 1));\n                }\n            }\n            n--;\n        }\n\n        // 最后一层就是题目要求的结果集\n        while (!queue.isEmpty()) {\n            res.add(queue.poll().res);\n        }\n        return res;\n    }\n} \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Deque;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Queue;\nimport java.util.Stack;\n\npublic class Solution {\n\n    class Node {\n        /**\n         * 当前得到的字符串\n         */\n        private String res;\n        /**\n         * 剩余左括号数量\n         */\n        private int left;\n        /**\n         * 剩余右括号数量\n         */\n        private int right;\n\n        public Node(String str, int left, int right) {\n            this.res = str;\n            this.left = left;\n            this.right = right;\n        }\n    }\n    \n    // 注意：这是深度优先遍历\n\n    public List<String> generateParenthesis(int n) {\n        List<String> res = new ArrayList<>();\n        if (n == 0) {\n            return res;\n        }\n\n        // 查看了 Stack 源码，官方推荐使用 Deque 对象，\n        // 注意：只使用栈相关的接口，即只使用 `addLast()` 和 `removeLast()`\n        Deque<Node> stack = new ArrayDeque<>();\n        stack.addLast(new Node("", n, n));\n\n        while (!stack.isEmpty()) {\n\n            Node curNode = stack.removeLast();\n            if (curNode.left == 0 && curNode.right == 0) {\n                res.add(curNode.res);\n            }\n            if (curNode.left > 0) {\n                stack.addLast(new Node(curNode.res + "(", curNode.left - 1, curNode.right));\n            }\n            if (curNode.right > 0 && curNode.left < curNode.right) {\n                stack.addLast(new Node(curNode.res + ")", curNode.left, curNode.right - 1));\n            }\n        }\n        return res;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2021-04-21 22:28:44Accepted [https://leetcode-cn.com//submissions/detail/170564394/]1 ms100.0%38.8 MBjava# 统计信息\n通过次数提交次数AC比率26337034174677.1%# 相似题目\n题目难度电话号码的字母组合 [https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/]中等有效的括号 [https://leetcode-cn.com/problems/valid-parentheses/]简单',contentLowercase:'# 中文题目\n数字 n代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。\n\n\n\n示例 1：\n\n\n输入：n = 3\n输出：["((()))","(()())","(())()","()(())","()()()"]\n\n\n示例 2：\n\n\n输入：n = 1\n输出：["()"]\n\n\n\n\n提示：\n\n * 1 \n\n# 通过代码\n    class solution {\n        public list<string> generateparenthesis(int n) {\n            list<string> res=new arraylist<>();\n            generate(res,new stringbuilder(),0,0,n);\n            return res;\n        }\n\n        private void generate(list<string> res, stringbuilder str, int left, int right, int n) {\n            // 达到长度\n            if (str.length()==2*n){\n                res.add(str.tostring());\n                return;\n            }\n            // 单独的左边的必须小于n\n            if (left<n){\n                // 先添加左边的\n                str.append("(");\n                // 继续递归\n                generate(res,str,left+1,right,n);\n                // 回溯\n                str.deletecharat(str.length()-1);\n            }\n            // 右边的必须小于等于左边的\n            if (right<left){\n                str.append(")");\n                generate(res, str, left, right+1, n);\n                str.deletecharat(str.length()-1);\n            }\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n# 我的笔记\n\n\n回溯法\n\n# 高赞题解\n这一类问题是在一棵隐式的树上求解，可以用深度优先遍历，也可以用广度优先遍历。 一般用深度优先遍历。原因是：\n\n * 代码好写，使用递归的方法，直接借助系统栈完成状态的转移；\n * 广度优先遍历得自己编写结点类和借助队列。\n\n这里的「状态」是指程序执行到 隐式树 的某个结点的语言描述，在程序中用不同的 变量 加以区分。\n\n\n\n# 方法一：深度优先遍历\n我们以 n = 2 为例，画树形结构图。方法是 「做减法」。\n\n{:width=500} {:align=center}\n\n画图以后，可以分析出的结论：\n\n * 当前左右括号都有大于 000 个可以使用的时候，才产生分支；\n * 产生左分支的时候，只看当前是否还有左括号可以使用；\n * 产生右分支的时候，还受到左分支的限制，右边剩余可以使用的括号数量一定得在严格大于左边剩余的数量的时候，才可以产生分支；\n * 在左边和右边剩余的括号数都等于 000 的时候结算。\n\n参考代码 1：\n\nimport java.util.arraylist;\nimport java.util.list;\n\npublic class solution {\n\n    // 做减法\n\n    public list<string> generateparenthesis(int n) {\n        list<string> res = new arraylist<>();\n        // 特判\n        if (n == 0) {\n            return res;\n        }\n\n        // 执行深度优先遍历，搜索可能的结果\n        dfs("", n, n, res);\n        return res;\n    }\n\n    /**\n     * @param curstr 当前递归得到的结果\n     * @param left   左括号还有几个可以使用\n     * @param right  右括号还有几个可以使用\n     * @param res    结果集\n     */\n    private void dfs(string curstr, int left, int right, list<string> res) {\n        // 因为每一次尝试，都使用新的字符串变量，所以无需回溯\n        // 在递归终止的时候，直接把它添加到结果集即可，注意与「力扣」第 46 题、第 39 题区分\n        if (left == 0 && right == 0) {\n            res.add(curstr);\n            return;\n        }\n\n        // 剪枝（如图，左括号可以使用的个数严格大于右括号可以使用的个数，才剪枝，注意这个细节）\n        if (left > right) {\n            return;\n        }\n\n        if (left > 0) {\n            dfs(curstr + "(", left - 1, right, res);\n        }\n\n        if (right > 0) {\n            dfs(curstr + ")", left, right - 1, res);\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\nfrom typing import list\n\n\nclass solution:\n    def generateparenthesis(self, n: int) -> list[str]:\n\n        res = []\n        cur_str = \'\'\n\n        def dfs(cur_str, left, right):\n            """\n            :param cur_str: 从根结点到叶子结点的路径字符串\n            :param left: 左括号还可以使用的个数\n            :param right: 右括号还可以使用的个数\n            :return:\n            """\n            if left == 0 and right == 0:\n                res.append(cur_str)\n                return\n            if right < left:\n                return\n            if left > 0:\n                dfs(cur_str + \'(\', left - 1, right)\n            if right > 0:\n                dfs(cur_str + \')\', left, right - 1)\n\n        dfs(cur_str, n, n)\n        return res\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n我们运行 n = 2 的情况，得到结果 [(()), ()()] ，说明分析的结果是正确的。\n\n如果我们不用减法，使用加法，即 left 表示「左括号还有几个没有用掉」，right 表示「右括号还有几个没有用掉」，可以画出另一棵递归树。\n\n{:width=500} {:align=center}\n\n下面是参考代码。\n\n参考代码 2：\n\nimport java.util.arraylist;\nimport java.util.list;\n\npublic class solution {\n\n    // 做加法\n\n    public list<string> generateparenthesis(int n) {\n        list<string> res = new arraylist<>();\n        // 特判\n        if (n == 0) {\n            return res;\n        }\n\n        dfs("", 0, 0, n, res);\n        return res;\n    }\n\n    /**\n     * @param curstr 当前递归得到的结果\n     * @param left   左括号已经用了几个\n     * @param right  右括号已经用了几个\n     * @param n      左括号、右括号一共得用几个\n     * @param res    结果集\n     */\n    private void dfs(string curstr, int left, int right, int n, list<string> res) {\n        if (left == n && right == n) {\n            res.add(curstr);\n            return;\n        }\n\n        // 剪枝\n        if (left < right) {\n            return;\n        }\n\n        if (left < n) {\n            dfs(curstr + "(", left + 1, right, n, res);\n        }\n        if (right < n) {\n            dfs(curstr + ")", left, right + 1, n, res);\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\nfrom typing import list\n\n\nclass solution:\n    def generateparenthesis(self, n: int) -> list[str]:\n\n        res = []\n        cur_str = \'\'\n\n        def dfs(cur_str, left, right, n):\n            """\n            :param cur_str: 从根结点到叶子结点的路径字符串\n            :param left: 左括号已经使用的个数\n            :param right: 右括号已经使用的个数\n            :return:\n            """\n            if left == n and right == n:\n                res.append(cur_str)\n                return\n            if left < right:\n                return\n\n            if left < n:\n                dfs(cur_str + \'(\', left + 1, right, n)\n\n            if right < n:\n                dfs(cur_str + \')\', left, right + 1, n)\n\n        dfs(cur_str, 0, 0, n)\n        return res\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n\n# 方法二：广度优先遍历\n通过编写广度优先遍历的代码，读者可以体会一下，为什么搜索几乎都是用深度优先遍历（回溯算法）。\n\n广度优先遍历，得程序员自己编写结点类，显示使用队列这个数据结构。深度优先遍历的时候，就可以直接使用系统栈，在递归方法执行完成的时候，系统栈顶就把我们所需要的状态信息直接弹出，而无须编写结点类和显示使用栈。\n\n下面的代码，读者可以把 queue 换成 stack，提交以后，也可以得到 accept。\n\n读者可以通过比较：\n\n * 广度优先遍历；\n * 自己使用栈编写深度优先遍历；\n * 使用系统栈的深度优先遍历（回溯算法）。\n\n来理解「回溯算法」作为一种「搜索算法」的合理性。\n\n还是上面的题解配图（1），使用广度优先遍历，结果集都在最后一层，即叶子结点处得到所有的结果集，编写代码如下。\n\n感谢 @liu-ren-you 朋友帮我优化了代码。\n\n参考代码 3：（前 2 个 java 代码写法没有本质不同，仅供参考。第 3 个 java 代码仅仅是把 queue 换成了 stack ，广度优先遍历就改成了深度优先遍历。）\n\nimport java.util.arraydeque;\nimport java.util.arraylist;\nimport java.util.deque;\nimport java.util.linkedlist;\nimport java.util.list;\nimport java.util.queue;\n\npublic class solution {\n\n    class node {\n        /**\n         * 当前得到的字符串\n         */\n        private string res;\n        /**\n         * 剩余左括号数量\n         */\n        private int left;\n        /**\n         * 剩余右括号数量\n         */\n        private int right;\n\n        public node(string str, int left, int right) {\n            this.res = str;\n            this.left = left;\n            this.right = right;\n        }\n    }\n\n    public list<string> generateparenthesis(int n) {\n        list<string> res = new arraylist<>();\n        if (n == 0) {\n            return res;\n        }\n        queue<node> queue = new linkedlist<>();\n        queue.offer(new node("", n, n));\n\n        while (!queue.isempty()) {\n\n            node curnode = queue.poll();\n            if (curnode.left == 0 && curnode.right == 0) {\n                res.add(curnode.res);\n            }\n            if (curnode.left > 0) {\n                queue.offer(new node(curnode.res + "(", curnode.left - 1, curnode.right));\n            }\n            if (curnode.right > 0 && curnode.left < curnode.right) {\n                queue.offer(new node(curnode.res + ")", curnode.left, curnode.right - 1));\n            }\n        }\n        return res;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\nimport java.util.arraylist;\nimport java.util.linkedlist;\nimport java.util.list;\nimport java.util.queue;\n\npublic class solution {\n\n    class node {\n        /**\n         * 当前得到的字符串\n         */\n        private string res;\n        /**\n         * 剩余左括号数量\n         */\n        private int left;\n        /**\n         * 剩余右括号数量\n         */\n        private int right;\n\n        public node(string res, int left, int right) {\n            this.res = res;\n            this.left = left;\n            this.right = right;\n        }\n\n        @override\n        public string tostring() {\n            return "node{" +\n                    "res=\'" + res + \'\\\'\' +\n                    ", left=" + left +\n                    ", right=" + right +\n                    \'}\';\n        }\n    }\n\n    public list<string> generateparenthesis(int n) {\n        list<string> res = new arraylist<>();\n        if (n == 0) {\n            return res;\n        }\n        queue<node> queue = new linkedlist<>();\n        queue.offer(new node("", n, n));\n        // 总共需要拼凑的字符总数是 2 * n\n        n = 2 * n;\n        while (n > 0) {\n            int size = queue.size();\n            for (int i = 0; i < size; i++) {\n                node curnode = queue.poll();\n                if (curnode.left > 0) {\n                    queue.offer(new node(curnode.res + "(", curnode.left - 1, curnode.right));\n                }\n                if (curnode.right > 0 && curnode.left < curnode.right) {\n                    queue.offer(new node(curnode.res + ")", curnode.left, curnode.right - 1));\n                }\n            }\n            n--;\n        }\n\n        // 最后一层就是题目要求的结果集\n        while (!queue.isempty()) {\n            res.add(queue.poll().res);\n        }\n        return res;\n    }\n} \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\nimport java.util.arraydeque;\nimport java.util.arraylist;\nimport java.util.deque;\nimport java.util.linkedlist;\nimport java.util.list;\nimport java.util.queue;\nimport java.util.stack;\n\npublic class solution {\n\n    class node {\n        /**\n         * 当前得到的字符串\n         */\n        private string res;\n        /**\n         * 剩余左括号数量\n         */\n        private int left;\n        /**\n         * 剩余右括号数量\n         */\n        private int right;\n\n        public node(string str, int left, int right) {\n            this.res = str;\n            this.left = left;\n            this.right = right;\n        }\n    }\n    \n    // 注意：这是深度优先遍历\n\n    public list<string> generateparenthesis(int n) {\n        list<string> res = new arraylist<>();\n        if (n == 0) {\n            return res;\n        }\n\n        // 查看了 stack 源码，官方推荐使用 deque 对象，\n        // 注意：只使用栈相关的接口，即只使用 `addlast()` 和 `removelast()`\n        deque<node> stack = new arraydeque<>();\n        stack.addlast(new node("", n, n));\n\n        while (!stack.isempty()) {\n\n            node curnode = stack.removelast();\n            if (curnode.left == 0 && curnode.right == 0) {\n                res.add(curnode.res);\n            }\n            if (curnode.left > 0) {\n                stack.addlast(new node(curnode.res + "(", curnode.left - 1, curnode.right));\n            }\n            if (curnode.right > 0 && curnode.left < curnode.right) {\n                stack.addlast(new node(curnode.res + ")", curnode.left, curnode.right - 1));\n            }\n        }\n        return res;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2021-04-21 22:28:44accepted [https://leetcode-cn.com//submissions/detail/170564394/]1 ms100.0%38.8 mbjava# 统计信息\n通过次数提交次数ac比率26337034174677.1%# 相似题目\n题目难度电话号码的字母组合 [https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/]中等有效的括号 [https://leetcode-cn.com/problems/valid-parentheses/]简单'},{title:"62-不同路径(Unique Paths)",frontmatter:{title:"62-不同路径(Unique Paths)",date:"2018-09-15T00:00:00.000Z",categories:["中等"],tags:["数组<Array>","动态规划<Dynamic Programming>"]},regularPath:"/views/%E4%B8%AD%E7%AD%89/0062-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84.html",relativePath:"views/中等/0062-不同路径.md",key:"v-662329a2",path:"/views/%E4%B8%AD%E7%AD%89/0062-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84.html",headers:[{level:2,title:"中文题目",slug:"中文题目",charIndex:2},{level:2,title:"通过代码",slug:"通过代码",charIndex:320},{level:2,title:"高赞题解",slug:"高赞题解",charIndex:1138},{level:2,title:"思路",slug:"思路",charIndex:1145},{level:2,title:"代码",slug:"代码",charIndex:322},{level:2,title:"提交历史",slug:"提交历史",charIndex:3700},{level:2,title:"统计信息",slug:"统计信息",charIndex:3927},{level:2,title:"相似题目",slug:"相似题目",charIndex:3962}],lastUpdated:"4/11/2021, 1:15:21 PM",headersStr:"中文题目 通过代码 高赞题解 思路 代码 提交历史 统计信息 相似题目",content:"# 中文题目\n一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。\n\n机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。\n\n问总共有多少条不同的路径？\n\n\n\n例如，上图是一个7 x 3 的网格。有多少可能的路径？\n\n说明：m和 n 的值均不超过 100。\n\n示例 1:\n\n输入: m = 3, n = 2\n输出: 3\n解释:\n从左上角开始，总共有 3 条路径可以到达右下角。\n1. 向右 -> 向右 -> 向下\n2. 向右 -> 向下 -> 向右\n3. 向下 -> 向右 -> 向右\n\n\n示例 2:\n\n输入: m = 7, n = 3\n输出: 28\n\n# 通过代码\nclass Solution {\n    public int uniquePaths(int m, int n) {\n        if (m == 0 && n == 0) {\n                return 0;\n            }\n            int[][] memo = new int[m][n];\n            for (int i = 0; i < m; i++) {\n                for (int j = 0; j < n; j++) {\n                    if (i == 0 && j == 0) {\n                        memo[i][j] = 1;\n                    } else if (i == 0 && j != 0) {\n                        memo[i][j] =  1;\n                    } else if (i != 0 && j == 0) {\n                        memo[i][j] =  1;\n                    } else {\n                        memo[i][j] = memo[i - 1][j] + memo[i][j - 1];\n                    }\n                }\n            }\n            return memo[m != 0 ? m - 1 : 0][n != 0 ? n - 1 : 0];\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n# 高赞题解\n# 思路\n思路一：排列组合\n\n因为机器到底右下角，向下几步，向右几步都是固定的，\n\n比如，m=3, n=2，我们只要向下 1 步，向右 2 步就一定能到达终点。\n\n所以有 Cm+n−2m−1C_{m+n-2}^{m-1}Cm+n−2m−1​\n\ndef uniquePaths(self, m: int, n: int) -> int:\n        return int(math.factorial(m+n-2)/math.factorial(m-1)/math.factorial(n-1))\n\n\n1\n2\n思路二：动态规划\n\n我们令 dp[i][j] 是到达 i, j 最多路径\n\n动态方程：dp[i][j] = dp[i-1][j] + dp[i][j-1]\n\n注意，对于第一行 dp[0][j]，或者第一列 dp[i][0]，由于都是在边界，所以只能为 1\n\n时间复杂度：O(m∗n)O(m*n)O(m∗n)\n\n空间复杂度：O(m∗n)O(m * n)O(m∗n)\n\n优化：因为我们每次只需要 dp[i-1][j],dp[i][j-1]\n\n所以我们只要记录这两个数，直接看代码吧！\n\n# 代码\n思路二：\n\nclass Solution:\n    def uniquePaths(self, m: int, n: int) -> int:\n        dp = [[1]*n] + [[1]+[0] * (n-1) for _ in range(m-1)]\n        #print(dp)\n        for i in range(1, m):\n            for j in range(1, n):\n                dp[i][j] = dp[i-1][j] + dp[i][j-1]\n        return dp[-1][-1]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\nclass Solution {\n    public int uniquePaths(int m, int n) {\n        int[][] dp = new int[m][n];\n        for (int i = 0; i < n; i++) dp[0][i] = 1;\n        for (int i = 0; i < m; i++) dp[i][0] = 1;\n        for (int i = 1; i < m; i++) {\n            for (int j = 1; j < n; j++) {\n                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\n            }\n        }\n        return dp[m - 1][n - 1];  \n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n优化1：空间复杂度 O(2n)O(2n)O(2n)\n\nclass Solution:\n    def uniquePaths(self, m: int, n: int) -> int:\n        pre = [1] * n\n        cur = [1] * n\n        for i in range(1, m):\n            for j in range(1, n):\n                cur[j] = pre[j] + cur[j-1]\n            pre = cur[:]\n        return pre[-1]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\nclass Solution {\n    public int uniquePaths(int m, int n) {\n        int[] pre = new int[n];\n        int[] cur = new int[n];\n        Arrays.fill(pre, 1);\n        Arrays.fill(cur,1);\n        for (int i = 1; i < m;i++){\n            for (int j = 1; j < n; j++){\n                cur[j] = cur[j-1] + pre[j];\n            }\n            pre = cur.clone();\n        }\n        return pre[n-1]; \n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n优化2：空间复杂度 O(n)O(n)O(n)\n\nclass Solution:\n    def uniquePaths(self, m: int, n: int) -> int:\n        cur = [1] * n\n        for i in range(1, m):\n            for j in range(1, n):\n                cur[j] += cur[j-1]\n        return cur[-1]\n\n\n1\n2\n3\n4\n5\n6\n7\nclass Solution {\n    public int uniquePaths(int m, int n) {\n        int[] cur = new int[n];\n        Arrays.fill(cur,1);\n        for (int i = 1; i < m;i++){\n            for (int j = 1; j < n; j++){\n                cur[j] += cur[j-1] ;\n            }\n        }\n        return cur[n-1];\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-09-15 09:41:32Accepted [https://leetcode-cn.com//submissions/detail/7116798/]0 ms100.0%N/Ajava2018-09-15 09:41:01Wrong Answer [https://leetcode-cn.com//submissions/detail/7116788/]N/AN/AN/Ajava# 统计信息\n通过次数提交次数AC比率6417211004658.3%# 相似题目\n题目难度不同路径 II [https://leetcode-cn.com/problems/unique-paths-ii/]中等最小路径和 [https://leetcode-cn.com/problems/minimum-path-sum/]中等地下城游戏 [https://leetcode-cn.com/problems/dungeon-game/]困难",contentLowercase:"# 中文题目\n一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“start” ）。\n\n机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“finish”）。\n\n问总共有多少条不同的路径？\n\n\n\n例如，上图是一个7 x 3 的网格。有多少可能的路径？\n\n说明：m和 n 的值均不超过 100。\n\n示例 1:\n\n输入: m = 3, n = 2\n输出: 3\n解释:\n从左上角开始，总共有 3 条路径可以到达右下角。\n1. 向右 -> 向右 -> 向下\n2. 向右 -> 向下 -> 向右\n3. 向下 -> 向右 -> 向右\n\n\n示例 2:\n\n输入: m = 7, n = 3\n输出: 28\n\n# 通过代码\nclass solution {\n    public int uniquepaths(int m, int n) {\n        if (m == 0 && n == 0) {\n                return 0;\n            }\n            int[][] memo = new int[m][n];\n            for (int i = 0; i < m; i++) {\n                for (int j = 0; j < n; j++) {\n                    if (i == 0 && j == 0) {\n                        memo[i][j] = 1;\n                    } else if (i == 0 && j != 0) {\n                        memo[i][j] =  1;\n                    } else if (i != 0 && j == 0) {\n                        memo[i][j] =  1;\n                    } else {\n                        memo[i][j] = memo[i - 1][j] + memo[i][j - 1];\n                    }\n                }\n            }\n            return memo[m != 0 ? m - 1 : 0][n != 0 ? n - 1 : 0];\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n# 高赞题解\n# 思路\n思路一：排列组合\n\n因为机器到底右下角，向下几步，向右几步都是固定的，\n\n比如，m=3, n=2，我们只要向下 1 步，向右 2 步就一定能到达终点。\n\n所以有 cm+n−2m−1c_{m+n-2}^{m-1}cm+n−2m−1​\n\ndef uniquepaths(self, m: int, n: int) -> int:\n        return int(math.factorial(m+n-2)/math.factorial(m-1)/math.factorial(n-1))\n\n\n1\n2\n思路二：动态规划\n\n我们令 dp[i][j] 是到达 i, j 最多路径\n\n动态方程：dp[i][j] = dp[i-1][j] + dp[i][j-1]\n\n注意，对于第一行 dp[0][j]，或者第一列 dp[i][0]，由于都是在边界，所以只能为 1\n\n时间复杂度：o(m∗n)o(m*n)o(m∗n)\n\n空间复杂度：o(m∗n)o(m * n)o(m∗n)\n\n优化：因为我们每次只需要 dp[i-1][j],dp[i][j-1]\n\n所以我们只要记录这两个数，直接看代码吧！\n\n# 代码\n思路二：\n\nclass solution:\n    def uniquepaths(self, m: int, n: int) -> int:\n        dp = [[1]*n] + [[1]+[0] * (n-1) for _ in range(m-1)]\n        #print(dp)\n        for i in range(1, m):\n            for j in range(1, n):\n                dp[i][j] = dp[i-1][j] + dp[i][j-1]\n        return dp[-1][-1]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\nclass solution {\n    public int uniquepaths(int m, int n) {\n        int[][] dp = new int[m][n];\n        for (int i = 0; i < n; i++) dp[0][i] = 1;\n        for (int i = 0; i < m; i++) dp[i][0] = 1;\n        for (int i = 1; i < m; i++) {\n            for (int j = 1; j < n; j++) {\n                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\n            }\n        }\n        return dp[m - 1][n - 1];  \n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n优化1：空间复杂度 o(2n)o(2n)o(2n)\n\nclass solution:\n    def uniquepaths(self, m: int, n: int) -> int:\n        pre = [1] * n\n        cur = [1] * n\n        for i in range(1, m):\n            for j in range(1, n):\n                cur[j] = pre[j] + cur[j-1]\n            pre = cur[:]\n        return pre[-1]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\nclass solution {\n    public int uniquepaths(int m, int n) {\n        int[] pre = new int[n];\n        int[] cur = new int[n];\n        arrays.fill(pre, 1);\n        arrays.fill(cur,1);\n        for (int i = 1; i < m;i++){\n            for (int j = 1; j < n; j++){\n                cur[j] = cur[j-1] + pre[j];\n            }\n            pre = cur.clone();\n        }\n        return pre[n-1]; \n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n优化2：空间复杂度 o(n)o(n)o(n)\n\nclass solution:\n    def uniquepaths(self, m: int, n: int) -> int:\n        cur = [1] * n\n        for i in range(1, m):\n            for j in range(1, n):\n                cur[j] += cur[j-1]\n        return cur[-1]\n\n\n1\n2\n3\n4\n5\n6\n7\nclass solution {\n    public int uniquepaths(int m, int n) {\n        int[] cur = new int[n];\n        arrays.fill(cur,1);\n        for (int i = 1; i < m;i++){\n            for (int j = 1; j < n; j++){\n                cur[j] += cur[j-1] ;\n            }\n        }\n        return cur[n-1];\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-09-15 09:41:32accepted [https://leetcode-cn.com//submissions/detail/7116798/]0 ms100.0%n/ajava2018-09-15 09:41:01wrong answer [https://leetcode-cn.com//submissions/detail/7116788/]n/an/an/ajava# 统计信息\n通过次数提交次数ac比率6417211004658.3%# 相似题目\n题目难度不同路径 ii [https://leetcode-cn.com/problems/unique-paths-ii/]中等最小路径和 [https://leetcode-cn.com/problems/minimum-path-sum/]中等地下城游戏 [https://leetcode-cn.com/problems/dungeon-game/]困难"},{title:"49-字母异位词分组(Group Anagrams)",frontmatter:{title:"49-字母异位词分组(Group Anagrams)",date:"2018-06-09T00:00:00.000Z",categories:["中等"],tags:["哈希表<Hash Table>","字符串<String>"]},regularPath:"/views/%E4%B8%AD%E7%AD%89/0049-%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D%E5%88%86%E7%BB%84.html",relativePath:"views/中等/0049-字母异位词分组.md",key:"v-37e48825",path:"/views/%E4%B8%AD%E7%AD%89/0049-%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D%E5%88%86%E7%BB%84.html",headers:[{level:2,title:"中文题目",slug:"中文题目",charIndex:2},{level:2,title:"通过代码",slug:"通过代码",charIndex:202},{level:2,title:"官方题解",slug:"官方题解",charIndex:923},{level:2,title:"提交历史",slug:"提交历史",charIndex:3828},{level:2,title:"统计信息",slug:"统计信息",charIndex:3957},{level:2,title:"相似题目",slug:"相似题目",charIndex:3991}],lastUpdated:"4/11/2021, 1:15:21 PM",headersStr:"中文题目 通过代码 官方题解 提交历史 统计信息 相似题目",content:'# 中文题目\n给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。\n\n示例:\n\n输入: ["eat", "tea", "tan", "ate", "nat", "bat"],\n输出:\n[\n  ["ate","eat","tea"],\n  ["nat","tan"],\n  ["bat"]\n]\n\n说明：\n\n * 所有输入均为小写字母。\n * 不考虑答案输出的顺序。\n\n# 通过代码\nimport java.util.*;\nclass Solution {\n    public List<List<String>> groupAnagrams(String[] strs) {\n        if (null == strs || strs.length==0)\n                return new ArrayList<List<String>>();\n            Map<String,List<String>> map=new HashMap<>();\n            for (String s :\n                    strs) {\n                char[] ca=s.toCharArray();\n                Arrays.sort(ca);\n                String keyStr=String.valueOf(ca);\n                if (!map.containsKey(keyStr)){\n                    map.put(keyStr,new ArrayList<>());\n                }\n                map.get(keyStr).add(s);\n            }\n            return new ArrayList<>(map.values());\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n# 官方题解\n# 方法一：排序数组分类\n思路\n\n当且仅当它们的排序字符串相等时，两个字符串是字母异位词。\n\n算法\n\n维护一个映射 ans : {String -> List}，其中每个键 K\\text{K}K 是一个排序字符串，每个值是初始输入的字符串列表，排序后等于 K\\text{K}K。\n\n在 Java 中，我们将键存储为字符串，例如，code。 在 Python 中，我们将键存储为散列化元组，例如，(\'c\', \'o\', \'d\', \'e\')。\n\n{:width="420px"} {:align="center"}\n\nclass Solution {\n    public List<List<String>> groupAnagrams(String[] strs) {\n        if (strs.length == 0) return new ArrayList();\n        Map<String, List> ans = new HashMap<String, List>();\n        for (String s : strs) {\n            char[] ca = s.toCharArray();\n            Arrays.sort(ca);\n            String key = String.valueOf(ca);\n            if (!ans.containsKey(key)) ans.put(key, new ArrayList());\n            ans.get(key).add(s);\n        }\n        return new ArrayList(ans.values());\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\nclass Solution(object):\n    def groupAnagrams(self, strs):\n        ans = collections.defaultdict(list)\n        for s in strs:\n            ans[tuple(sorted(s))].append(s)\n        return ans.values()\n\n\n1\n2\n3\n4\n5\n6\n复杂度分析\n\n * 时间复杂度：O(NKlog⁡K)O(NK \\log K)O(NKlogK)，其中 NNN 是 strs 的长度，而 KKK 是 strs 中字符串的最大长度。当我们遍历每个字符串时，外部循环具有的复杂度为 O(N)O(N)O(N)。然后，我们在 O(Klog⁡K)O(K \\log K)O(KlogK) 的时间内对每个字符串排序。\n   \n   \n * 空间复杂度：O(NK)O(NK)O(NK)，排序存储在 ans 中的全部信息内容。\n   \n   \n\n\n\n\n# 方法二：按计数分类\n思路\n\n当且仅当它们的字符计数（每个字符的出现次数）相同时，两个字符串是字母异位词。\n\n算法\n\n我们可以将每个字符串 s\\text{s}s 转换为字符数 count\\text{count}count，由26个非负整数组成，表示 a\\text{a}a，b\\text{b}b，c\\text{c}c 的数量等。我们使用这些计数作为哈希映射的基础。\n\n在 Java 中，我们的字符数 count 的散列化表示将是一个用 **＃** 字符分隔的字符串。 例如，abbccc 将表示为 ＃1＃2＃3＃0＃0＃0 ...＃0，其中总共有26个条目。 在 python 中，表示将是一个计数的元组。 例如，abbccc 将表示为 (1,2,3,0,0，...，0)，其中总共有 26 个条目。\n\n{:width="420px"} {:align="center"}\n\nclass Solution {\n    public List<List<String>> groupAnagrams(String[] strs) {\n        if (strs.length == 0) return new ArrayList();\n        Map<String, List> ans = new HashMap<String, List>();\n        int[] count = new int[26];\n        for (String s : strs) {\n            Arrays.fill(count, 0);\n            for (char c : s.toCharArray()) count[c - \'a\']++;\n\n            StringBuilder sb = new StringBuilder("");\n            for (int i = 0; i < 26; i++) {\n                sb.append(\'#\');\n                sb.append(count[i]);\n            }\n            String key = sb.toString();\n            if (!ans.containsKey(key)) ans.put(key, new ArrayList());\n            ans.get(key).add(s);\n        }\n        return new ArrayList(ans.values());\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\nclass Solution:\n    def groupAnagrams(strs):\n        ans = collections.defaultdict(list)\n        for s in strs:\n            count = [0] * 26\n            for c in s:\n                count[ord(c) - ord(\'a\')] += 1\n            ans[tuple(count)].append(s)\n        return ans.values()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n复杂度分析\n\n * 时间复杂度：O(NK)O(NK)O(NK)，其中 NNN 是 strs 的长度，而 KKK 是 strs 中字符串的最大长度。计算每个字符串的字符串大小是线性的，我们统计每个字符串。\n   \n   \n * 空间复杂度：O(NK)O(NK)O(NK)，排序存储在 ans 中的全部信息内容。\n   \n   \n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-06-09 23:31:41Accepted [https://leetcode-cn.com//submissions/detail/3049349/]31 ms18.71%N/Ajava# 统计信息\n通过次数提交次数AC比率449257465060.2%# 相似题目\n题目难度有效的字母异位词 [https://leetcode-cn.com/problems/valid-anagram/]简单移位字符串分组 [https://leetcode-cn.com/problems/group-shifted-strings/]中等',contentLowercase:'# 中文题目\n给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。\n\n示例:\n\n输入: ["eat", "tea", "tan", "ate", "nat", "bat"],\n输出:\n[\n  ["ate","eat","tea"],\n  ["nat","tan"],\n  ["bat"]\n]\n\n说明：\n\n * 所有输入均为小写字母。\n * 不考虑答案输出的顺序。\n\n# 通过代码\nimport java.util.*;\nclass solution {\n    public list<list<string>> groupanagrams(string[] strs) {\n        if (null == strs || strs.length==0)\n                return new arraylist<list<string>>();\n            map<string,list<string>> map=new hashmap<>();\n            for (string s :\n                    strs) {\n                char[] ca=s.tochararray();\n                arrays.sort(ca);\n                string keystr=string.valueof(ca);\n                if (!map.containskey(keystr)){\n                    map.put(keystr,new arraylist<>());\n                }\n                map.get(keystr).add(s);\n            }\n            return new arraylist<>(map.values());\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n# 官方题解\n# 方法一：排序数组分类\n思路\n\n当且仅当它们的排序字符串相等时，两个字符串是字母异位词。\n\n算法\n\n维护一个映射 ans : {string -> list}，其中每个键 k\\text{k}k 是一个排序字符串，每个值是初始输入的字符串列表，排序后等于 k\\text{k}k。\n\n在 java 中，我们将键存储为字符串，例如，code。 在 python 中，我们将键存储为散列化元组，例如，(\'c\', \'o\', \'d\', \'e\')。\n\n{:width="420px"} {:align="center"}\n\nclass solution {\n    public list<list<string>> groupanagrams(string[] strs) {\n        if (strs.length == 0) return new arraylist();\n        map<string, list> ans = new hashmap<string, list>();\n        for (string s : strs) {\n            char[] ca = s.tochararray();\n            arrays.sort(ca);\n            string key = string.valueof(ca);\n            if (!ans.containskey(key)) ans.put(key, new arraylist());\n            ans.get(key).add(s);\n        }\n        return new arraylist(ans.values());\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\nclass solution(object):\n    def groupanagrams(self, strs):\n        ans = collections.defaultdict(list)\n        for s in strs:\n            ans[tuple(sorted(s))].append(s)\n        return ans.values()\n\n\n1\n2\n3\n4\n5\n6\n复杂度分析\n\n * 时间复杂度：o(nklog⁡k)o(nk \\log k)o(nklogk)，其中 nnn 是 strs 的长度，而 kkk 是 strs 中字符串的最大长度。当我们遍历每个字符串时，外部循环具有的复杂度为 o(n)o(n)o(n)。然后，我们在 o(klog⁡k)o(k \\log k)o(klogk) 的时间内对每个字符串排序。\n   \n   \n * 空间复杂度：o(nk)o(nk)o(nk)，排序存储在 ans 中的全部信息内容。\n   \n   \n\n\n\n\n# 方法二：按计数分类\n思路\n\n当且仅当它们的字符计数（每个字符的出现次数）相同时，两个字符串是字母异位词。\n\n算法\n\n我们可以将每个字符串 s\\text{s}s 转换为字符数 count\\text{count}count，由26个非负整数组成，表示 a\\text{a}a，b\\text{b}b，c\\text{c}c 的数量等。我们使用这些计数作为哈希映射的基础。\n\n在 java 中，我们的字符数 count 的散列化表示将是一个用 **＃** 字符分隔的字符串。 例如，abbccc 将表示为 ＃1＃2＃3＃0＃0＃0 ...＃0，其中总共有26个条目。 在 python 中，表示将是一个计数的元组。 例如，abbccc 将表示为 (1,2,3,0,0，...，0)，其中总共有 26 个条目。\n\n{:width="420px"} {:align="center"}\n\nclass solution {\n    public list<list<string>> groupanagrams(string[] strs) {\n        if (strs.length == 0) return new arraylist();\n        map<string, list> ans = new hashmap<string, list>();\n        int[] count = new int[26];\n        for (string s : strs) {\n            arrays.fill(count, 0);\n            for (char c : s.tochararray()) count[c - \'a\']++;\n\n            stringbuilder sb = new stringbuilder("");\n            for (int i = 0; i < 26; i++) {\n                sb.append(\'#\');\n                sb.append(count[i]);\n            }\n            string key = sb.tostring();\n            if (!ans.containskey(key)) ans.put(key, new arraylist());\n            ans.get(key).add(s);\n        }\n        return new arraylist(ans.values());\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\nclass solution:\n    def groupanagrams(strs):\n        ans = collections.defaultdict(list)\n        for s in strs:\n            count = [0] * 26\n            for c in s:\n                count[ord(c) - ord(\'a\')] += 1\n            ans[tuple(count)].append(s)\n        return ans.values()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n复杂度分析\n\n * 时间复杂度：o(nk)o(nk)o(nk)，其中 nnn 是 strs 的长度，而 kkk 是 strs 中字符串的最大长度。计算每个字符串的字符串大小是线性的，我们统计每个字符串。\n   \n   \n * 空间复杂度：o(nk)o(nk)o(nk)，排序存储在 ans 中的全部信息内容。\n   \n   \n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-06-09 23:31:41accepted [https://leetcode-cn.com//submissions/detail/3049349/]31 ms18.71%n/ajava# 统计信息\n通过次数提交次数ac比率449257465060.2%# 相似题目\n题目难度有效的字母异位词 [https://leetcode-cn.com/problems/valid-anagram/]简单移位字符串分组 [https://leetcode-cn.com/problems/group-shifted-strings/]中等'},{title:"64-最小路径和(Minimum Path Sum)",frontmatter:{title:"64-最小路径和(Minimum Path Sum)",date:"2018-09-14T00:00:00.000Z",categories:["中等"],tags:["数组<Array>","动态规划<Dynamic Programming>"]},regularPath:"/views/%E4%B8%AD%E7%AD%89/0064-%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C.html",relativePath:"views/中等/0064-最小路径和.md",key:"v-4b70cbd6",path:"/views/%E4%B8%AD%E7%AD%89/0064-%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C.html",headers:[{level:2,title:"中文题目",slug:"中文题目",charIndex:2},{level:2,title:"通过代码",slug:"通过代码",charIndex:159},{level:2,title:"官方题解",slug:"官方题解",charIndex:998},{level:2,title:"概述",slug:"概述",charIndex:1005},{level:2,title:"题解",slug:"题解",charIndex:1e3},{level:2,title:"提交历史",slug:"提交历史",charIndex:5388},{level:2,title:"统计信息",slug:"统计信息",charIndex:5616},{level:2,title:"相似题目",slug:"相似题目",charIndex:5650}],lastUpdated:"4/11/2021, 1:15:21 PM",headersStr:"中文题目 通过代码 官方题解 概述 题解 提交历史 统计信息 相似题目",content:"# 中文题目\n给定一个包含非负整数的 mxn网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。\n\n说明：每次只能向下或者向右移动一步。\n\n示例:\n\n输入:\n[\n  [1,3,1],\n  [1,5,1],\n  [4,2,1]\n]\n输出: 7\n解释: 因为路径 1→3→1→1→1 的总和最小。\n\n\n# 通过代码\nclass Solution {\n    public int minPathSum(int[][] grid) {\n        if (grid.length==0 || grid==null){\n                return 0;\n            }\n            for (int i = 0; i < grid.length; i++) {\n                for (int j = 0; j < grid[0].length; j++) {\n                    if (i==0 && j==0){\n                        grid[i][j]=grid[0][0];\n                    }else if (i==0 && j!=0){\n                        grid[i][j]=grid[i][j-1]+grid[i][j];\n                    }else if (i!=0 && j==0){\n                        grid[i][j]=grid[i-1][j]+grid[i][j];\n                    }else {\n                        grid[i][j]=Math.min(grid[i-1][j],grid[i][j-1])+grid[i][j];\n                    }\n                }\n            }\n            return grid[grid.length-1][grid[0].length-1];\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n# 官方题解\n# 概述\n找出一条从左上角到右下角的路径，路径上数字之和最小。\n\n# 题解\n# 方法 1： 暴力\n暴力就是利用递归，对于每个元素我们考虑两条路径，向右走和向下走，在这两条路径中挑选路径权值和较小的一个。\n\ncost(i,j)=grid[i][j]+min⁡(cost(i+1,j),cost(i,j+1))\\mathrm{cost}(i, j)=\\mathrm{grid}[i][j] + \\min \\big(\\mathrm{cost}(i+1, j), \\mathrm{cost}(i, j+1) \\big)cost(i,j)=grid[i][j]+min(cost(i+1,j),cost(i,j+1))\n\npublic class Solution {\n    public int calculate(int[][] grid, int i, int j) {\n        if (i == grid.length || j == grid[0].length) return Integer.MAX_VALUE;\n        if (i == grid.length - 1 && j == grid[0].length - 1) return grid[i][j];\n        return grid[i][j] + Math.min(calculate(grid, i + 1, j), calculate(grid, i, j + 1));\n    }\n    public int minPathSum(int[][] grid) {\n        return calculate(grid, 0, 0);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n复杂度分析\n\n * 时间复杂度 ：O(2m+n)O\\big(2^{m+n}\\big)O(2m+n)。每次移动最多可以有两种选择。\n * 空间复杂度 ：O(m+n)O(m+n)O(m+n)。递归的深度是 m+nm+nm+n。\n\n# 方法 2：二维动态规划\n算法\n\n我们新建一个额外的 dpdpdp 数组，与原矩阵大小相同。在这个矩阵中，dp(i,j)dp(i, j)dp(i,j) 表示从坐标 (i,j)(i, j)(i,j) 到右下角的最小路径权值。我们初始化右下角的 dpdpdp 值为对应的原矩阵值，然后去填整个矩阵，对于每个元素考虑移动到右边或者下面，因此获得最小路径和我们有如下递推公式：\n\ndp(i,j)=grid(i,j)+min⁡(dp(i+1,j),dp(i,j+1))dp(i, j)= \\mathrm{grid}(i,j)+\\min\\big(dp(i+1,j),dp(i,j+1)\\big)dp(i,j)=grid(i,j)+min(dp(i+1,j),dp(i,j+1))\n\n注意边界情况。下图描述了这个过程：\n\n<,,,,,,,,,,,,,,,,>\n\npublic class Solution {\n    public int minPathSum(int[][] grid) {\n        int[][] dp = new int[grid.length][grid[0].length];\n        for (int i = grid.length - 1; i >= 0; i--) {\n            for (int j = grid[0].length - 1; j >= 0; j--) {\n                if(i == grid.length - 1 && j != grid[0].length - 1)\n                    dp[i][j] = grid[i][j] +  dp[i][j + 1];\n                else if(j == grid[0].length - 1 && i != grid.length - 1)\n                    dp[i][j] = grid[i][j] + dp[i + 1][j];\n                else if(j != grid[0].length - 1 && i != grid.length - 1)\n                    dp[i][j] = grid[i][j] + Math.min(dp[i + 1][j], dp[i][j + 1]);\n                else\n                    dp[i][j] = grid[i][j];\n            }\n        }\n        return dp[0][0];\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n复杂度分析\n\n * 时间复杂度 ：O(mn)O(mn)O(mn)。遍历整个矩阵恰好一次。\n * 空间复杂度 ：O(mn)O(mn)O(mn)。额外的一个同大小矩阵。\n\n# 方法 3：一维动态规划\n算法\n\n在上个解法中，我们可以用一个一维数组来代替二维数组，dpdpdp 数组的大小和行大小相同。这是因为对于某个固定状态，只需要考虑下方和右侧的节点。首先初始化 dpdpdp 数组最后一个元素是右下角的元素值，然后我们向左移更新每个 dp(j)dp(j)dp(j) 为：\n\ndp(j)=grid(i,j)+min⁡(dp(j),dp(j+1))dp(j)=\\mathrm{grid}(i,j)+\\min\\big(dp(j),dp(j+1)\\big)dp(j)=grid(i,j)+min(dp(j),dp(j+1))\n\n我们对于每一行都重复这个过程，然后向上一行移动，计算完成后 dp(0)dp(0)dp(0) 就是最后的结果。\n\npublic class Solution {\n   public int minPathSum(int[][] grid) {\n       int[] dp = new int[grid[0].length];\n       for (int i = grid.length - 1; i >= 0; i--) {\n           for (int j = grid[0].length - 1; j >= 0; j--) {\n               if(i == grid.length - 1 && j != grid[0].length - 1)\n                   dp[j] = grid[i][j] +  dp[j + 1];\n               else if(j == grid[0].length - 1 && i != grid.length - 1)\n                   dp[j] = grid[i][j] + dp[j];\n               else if(j != grid[0].length - 1 && i != grid.length - 1)\n                   dp[j] = grid[i][j] + Math.min(dp[j], dp[j + 1]);\n               else\n                   dp[j] = grid[i][j];\n           }\n       }\n       return dp[0];\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n复杂度分析\n\n * 时间复杂度 ：O(mn)O(mn)O(mn)。遍历整个矩阵恰好一次。\n * 空间复杂度 ：O(n)O(n)O(n)。额外的一维数组，和一行大小相同。\n\n# 方法 4：动态规划（不需要额外存储空间）\n算法\n\n和方法 2 相同，惟一的区别是，不需要用额外的 dpdpdp 数组，而是在原数组上存储，这样就不需要额外的存储空间。递推公式如下：\n\ngrid(i,j)=grid(i,j)+min⁡(grid(i+1,j),grid(i,j+1))\\mathrm{grid}(i, j)=\\mathrm{grid}(i,j)+\\min \\big(\\mathrm{grid}(i+1,j), \\mathrm{grid}(i,j+1)\\big)grid(i,j)=grid(i,j)+min(grid(i+1,j),grid(i,j+1))\n\npublic class Solution {\n    public int minPathSum(int[][] grid) {\n        for (int i = grid.length - 1; i >= 0; i--) {\n            for (int j = grid[0].length - 1; j >= 0; j--) {\n                if(i == grid.length - 1 && j != grid[0].length - 1)\n                    grid[i][j] = grid[i][j] +  grid[i][j + 1];\n                else if(j == grid[0].length - 1 && i != grid.length - 1)\n                    grid[i][j] = grid[i][j] + grid[i + 1][j];\n                else if(j != grid[0].length - 1 && i != grid.length - 1)\n                    grid[i][j] = grid[i][j] + Math.min(grid[i + 1][j],grid[i][j + 1]);\n            }\n        }\n        return grid[0][0];\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n复杂度分析\n\n * 时间复杂度 ：O(mn)O(mn)O(mn)。遍历整个矩阵恰好一次。\n * 空间复杂度 ：O(1)O(1)O(1)。不需要额外空间。\n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-09-14 15:37:55Accepted [https://leetcode-cn.com//submissions/detail/7089855/]10 ms8.53%N/Ajava2018-09-14 15:35:35Runtime Error [https://leetcode-cn.com//submissions/detail/7089670/]N/AN/AN/Ajava# 统计信息\n通过次数提交次数AC比率524168185464.0%# 相似题目\n题目难度不同路径 [https://leetcode-cn.com/problems/unique-paths/]中等地下城游戏 [https://leetcode-cn.com/problems/dungeon-game/]困难摘樱桃 [https://leetcode-cn.com/problems/cherry-pickup/]困难",contentLowercase:"# 中文题目\n给定一个包含非负整数的 mxn网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。\n\n说明：每次只能向下或者向右移动一步。\n\n示例:\n\n输入:\n[\n  [1,3,1],\n  [1,5,1],\n  [4,2,1]\n]\n输出: 7\n解释: 因为路径 1→3→1→1→1 的总和最小。\n\n\n# 通过代码\nclass solution {\n    public int minpathsum(int[][] grid) {\n        if (grid.length==0 || grid==null){\n                return 0;\n            }\n            for (int i = 0; i < grid.length; i++) {\n                for (int j = 0; j < grid[0].length; j++) {\n                    if (i==0 && j==0){\n                        grid[i][j]=grid[0][0];\n                    }else if (i==0 && j!=0){\n                        grid[i][j]=grid[i][j-1]+grid[i][j];\n                    }else if (i!=0 && j==0){\n                        grid[i][j]=grid[i-1][j]+grid[i][j];\n                    }else {\n                        grid[i][j]=math.min(grid[i-1][j],grid[i][j-1])+grid[i][j];\n                    }\n                }\n            }\n            return grid[grid.length-1][grid[0].length-1];\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n# 官方题解\n# 概述\n找出一条从左上角到右下角的路径，路径上数字之和最小。\n\n# 题解\n# 方法 1： 暴力\n暴力就是利用递归，对于每个元素我们考虑两条路径，向右走和向下走，在这两条路径中挑选路径权值和较小的一个。\n\ncost(i,j)=grid[i][j]+min⁡(cost(i+1,j),cost(i,j+1))\\mathrm{cost}(i, j)=\\mathrm{grid}[i][j] + \\min \\big(\\mathrm{cost}(i+1, j), \\mathrm{cost}(i, j+1) \\big)cost(i,j)=grid[i][j]+min(cost(i+1,j),cost(i,j+1))\n\npublic class solution {\n    public int calculate(int[][] grid, int i, int j) {\n        if (i == grid.length || j == grid[0].length) return integer.max_value;\n        if (i == grid.length - 1 && j == grid[0].length - 1) return grid[i][j];\n        return grid[i][j] + math.min(calculate(grid, i + 1, j), calculate(grid, i, j + 1));\n    }\n    public int minpathsum(int[][] grid) {\n        return calculate(grid, 0, 0);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n复杂度分析\n\n * 时间复杂度 ：o(2m+n)o\\big(2^{m+n}\\big)o(2m+n)。每次移动最多可以有两种选择。\n * 空间复杂度 ：o(m+n)o(m+n)o(m+n)。递归的深度是 m+nm+nm+n。\n\n# 方法 2：二维动态规划\n算法\n\n我们新建一个额外的 dpdpdp 数组，与原矩阵大小相同。在这个矩阵中，dp(i,j)dp(i, j)dp(i,j) 表示从坐标 (i,j)(i, j)(i,j) 到右下角的最小路径权值。我们初始化右下角的 dpdpdp 值为对应的原矩阵值，然后去填整个矩阵，对于每个元素考虑移动到右边或者下面，因此获得最小路径和我们有如下递推公式：\n\ndp(i,j)=grid(i,j)+min⁡(dp(i+1,j),dp(i,j+1))dp(i, j)= \\mathrm{grid}(i,j)+\\min\\big(dp(i+1,j),dp(i,j+1)\\big)dp(i,j)=grid(i,j)+min(dp(i+1,j),dp(i,j+1))\n\n注意边界情况。下图描述了这个过程：\n\n<,,,,,,,,,,,,,,,,>\n\npublic class solution {\n    public int minpathsum(int[][] grid) {\n        int[][] dp = new int[grid.length][grid[0].length];\n        for (int i = grid.length - 1; i >= 0; i--) {\n            for (int j = grid[0].length - 1; j >= 0; j--) {\n                if(i == grid.length - 1 && j != grid[0].length - 1)\n                    dp[i][j] = grid[i][j] +  dp[i][j + 1];\n                else if(j == grid[0].length - 1 && i != grid.length - 1)\n                    dp[i][j] = grid[i][j] + dp[i + 1][j];\n                else if(j != grid[0].length - 1 && i != grid.length - 1)\n                    dp[i][j] = grid[i][j] + math.min(dp[i + 1][j], dp[i][j + 1]);\n                else\n                    dp[i][j] = grid[i][j];\n            }\n        }\n        return dp[0][0];\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n复杂度分析\n\n * 时间复杂度 ：o(mn)o(mn)o(mn)。遍历整个矩阵恰好一次。\n * 空间复杂度 ：o(mn)o(mn)o(mn)。额外的一个同大小矩阵。\n\n# 方法 3：一维动态规划\n算法\n\n在上个解法中，我们可以用一个一维数组来代替二维数组，dpdpdp 数组的大小和行大小相同。这是因为对于某个固定状态，只需要考虑下方和右侧的节点。首先初始化 dpdpdp 数组最后一个元素是右下角的元素值，然后我们向左移更新每个 dp(j)dp(j)dp(j) 为：\n\ndp(j)=grid(i,j)+min⁡(dp(j),dp(j+1))dp(j)=\\mathrm{grid}(i,j)+\\min\\big(dp(j),dp(j+1)\\big)dp(j)=grid(i,j)+min(dp(j),dp(j+1))\n\n我们对于每一行都重复这个过程，然后向上一行移动，计算完成后 dp(0)dp(0)dp(0) 就是最后的结果。\n\npublic class solution {\n   public int minpathsum(int[][] grid) {\n       int[] dp = new int[grid[0].length];\n       for (int i = grid.length - 1; i >= 0; i--) {\n           for (int j = grid[0].length - 1; j >= 0; j--) {\n               if(i == grid.length - 1 && j != grid[0].length - 1)\n                   dp[j] = grid[i][j] +  dp[j + 1];\n               else if(j == grid[0].length - 1 && i != grid.length - 1)\n                   dp[j] = grid[i][j] + dp[j];\n               else if(j != grid[0].length - 1 && i != grid.length - 1)\n                   dp[j] = grid[i][j] + math.min(dp[j], dp[j + 1]);\n               else\n                   dp[j] = grid[i][j];\n           }\n       }\n       return dp[0];\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n复杂度分析\n\n * 时间复杂度 ：o(mn)o(mn)o(mn)。遍历整个矩阵恰好一次。\n * 空间复杂度 ：o(n)o(n)o(n)。额外的一维数组，和一行大小相同。\n\n# 方法 4：动态规划（不需要额外存储空间）\n算法\n\n和方法 2 相同，惟一的区别是，不需要用额外的 dpdpdp 数组，而是在原数组上存储，这样就不需要额外的存储空间。递推公式如下：\n\ngrid(i,j)=grid(i,j)+min⁡(grid(i+1,j),grid(i,j+1))\\mathrm{grid}(i, j)=\\mathrm{grid}(i,j)+\\min \\big(\\mathrm{grid}(i+1,j), \\mathrm{grid}(i,j+1)\\big)grid(i,j)=grid(i,j)+min(grid(i+1,j),grid(i,j+1))\n\npublic class solution {\n    public int minpathsum(int[][] grid) {\n        for (int i = grid.length - 1; i >= 0; i--) {\n            for (int j = grid[0].length - 1; j >= 0; j--) {\n                if(i == grid.length - 1 && j != grid[0].length - 1)\n                    grid[i][j] = grid[i][j] +  grid[i][j + 1];\n                else if(j == grid[0].length - 1 && i != grid.length - 1)\n                    grid[i][j] = grid[i][j] + grid[i + 1][j];\n                else if(j != grid[0].length - 1 && i != grid.length - 1)\n                    grid[i][j] = grid[i][j] + math.min(grid[i + 1][j],grid[i][j + 1]);\n            }\n        }\n        return grid[0][0];\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n复杂度分析\n\n * 时间复杂度 ：o(mn)o(mn)o(mn)。遍历整个矩阵恰好一次。\n * 空间复杂度 ：o(1)o(1)o(1)。不需要额外空间。\n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-09-14 15:37:55accepted [https://leetcode-cn.com//submissions/detail/7089855/]10 ms8.53%n/ajava2018-09-14 15:35:35runtime error [https://leetcode-cn.com//submissions/detail/7089670/]n/an/an/ajava# 统计信息\n通过次数提交次数ac比率524168185464.0%# 相似题目\n题目难度不同路径 [https://leetcode-cn.com/problems/unique-paths/]中等地下城游戏 [https://leetcode-cn.com/problems/dungeon-game/]困难摘樱桃 [https://leetcode-cn.com/problems/cherry-pickup/]困难"},{title:"75-颜色分类(Sort Colors)",frontmatter:{title:"75-颜色分类(Sort Colors)",date:"2018-07-27T00:00:00.000Z",categories:["中等"],tags:["排序<Sort>","数组<Array>","双指针<Two Pointers>"]},regularPath:"/views/%E4%B8%AD%E7%AD%89/0075-%E9%A2%9C%E8%89%B2%E5%88%86%E7%B1%BB.html",relativePath:"views/中等/0075-颜色分类.md",key:"v-92619eec",path:"/views/%E4%B8%AD%E7%AD%89/0075-%E9%A2%9C%E8%89%B2%E5%88%86%E7%B1%BB.html",headers:[{level:2,title:"中文题目",slug:"中文题目",charIndex:2},{level:2,title:"通过代码",slug:"通过代码",charIndex:352},{level:2,title:"官方题解",slug:"官方题解",charIndex:2370},{level:2,title:"提交历史",slug:"提交历史",charIndex:5255},{level:2,title:"统计信息",slug:"统计信息",charIndex:5681},{level:2,title:"相似题目",slug:"相似题目",charIndex:5715}],lastUpdated:"4/11/2021, 1:15:21 PM",headersStr:"中文题目 通过代码 官方题解 提交历史 统计信息 相似题目",content:"# 中文题目\n给定一个包含红色、白色和蓝色，一共n 个元素的数组，原地 [https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95]对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。\n\n此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。\n\n注意:\n不能使用代码库中的排序函数来解决这道题。\n\n示例:\n\n输入: [2,0,2,1,1,0]\n输出: [0,0,1,1,2,2]\n\n进阶：\n\n * 一个直观的解决方案是使用计数排序的两趟扫描算法。\n   首先，迭代计算出0、1 和 2 元素的个数，然后按照0、1、2的排序，重写当前数组。\n * 你能想出一个仅使用常数空间的一趟扫描算法吗？\n\n# 通过代码\nclass Solution {\n   public  void swap(int[] arr,int i,int j){\n            int temp=arr[i];\n            arr[i]=arr[j];\n            arr[j]=temp;\n        }\n\n        public  void sortColors(int[] nums){\n            int lt=-1;\n            int gt=nums.length;\n            int i=lt+1;\n            while (i<gt){\n                if (nums[i]<1){\n                    swap(nums,i,lt+1);\n                    i++;\n                    lt++;\n                }else if (nums[i]>1){\n                    swap(nums,i,gt-1);\n                    gt--;\n                }else {\n                    i++;\n                }\n            }\n        }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\nclass Solution {\n    public static void sortColors(int[] nums){\n            int zero=-1;\n            int two=nums.length;\n            for (int i = 0; i < two; ) {\n                if (nums[i]==1){\n                    i++;\n                }else if (nums[i]==2){\n                    two--;\n                    swap(nums,i,two);\n                }else {\n                    zero++;\n                    swap(nums,zero,i);\n                    i++;\n                }\n\n            }\n        }\n\n        public static void swap(int[] arr,int i,int j){\n            int temp=arr[i];\n            arr[i]=arr[j];\n            arr[j]=temp;\n        }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\nclass Solution {\n    public void sortColors(int[] nums) {\n        int i0=0;\n            int i1=0;\n            for (int i = 0; i < nums.length; i++) {\n                if (nums[i]==0){\n                    i0++;\n                }else if (nums[i]==1){\n                    i1++;\n                }\n            }\n            for (int i=0;i<nums.length;i++){\n                if (i<i0){\n                    nums[i]=0;\n                }else if (i <i1+i0){\n                    nums[i]=1;\n                }else {\n                    nums[i]=2;\n                }\n            }\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n# 官方题解\n# 方法一: 一次遍历\n直觉\n\n本问题被称为 荷兰国旗问题 [https://en.wikipedia.org/wiki/Dutch_national_flag_problem]，最初由 Edsger W. Dijkstra [https://baike.baidu.com/item/%E8%89%BE%E5%85%B9%E6%A0%BC%C2%B7%E8%BF%AA%E7%A7%91%E6%96%AF%E5%BD%BB/5029407?fromtitle=Dijkstra&fromid=1880870&fr=aladdin]提出。 其主要思想是给每个数字设定一种颜色，并按照荷兰国旗颜色的顺序进行调整。\n\n\n\n我们用三个指针（p0, p2 和curr）来分别追踪0的最右边界，2的最左边界和当前考虑的元素。\n\n\n\n本解法的思路是沿着数组移动 curr 指针，若nums[curr] = 0，则将其与 nums[p0]互换；若 nums[curr] = 2 ，则与 nums[p2]互换。\n\n算法\n\n * 初始化0的最右边界：p0 = 0。在整个算法执行过程中 nums[idx < p0] = 0.\n   \n   \n * 初始化2的最左边界 ：p2 = n - 1。在整个算法执行过程中 nums[idx > p2] = 2.\n   \n   \n * 初始化当前考虑的元素序号 ：curr = 0.\n   \n   \n * While curr <= p2 :\n   \n    * 若 nums[curr] = 0 ：交换第 curr个 和 第p0个 元素，并将指针都向右移。\n      \n      \n    * 若 nums[curr] = 2 ：交换第 curr个和第 p2个元素，并将 p2指针左移 。\n      \n      \n    * 若 nums[curr] = 1 ：将指针curr右移。\n      \n      \n   \n   \n\n实现\n\n<,,,,,,,,,,,,>\n\nclass Solution {\n  /*\n  荷兰三色旗问题解\n  */\n  public void sortColors(int[] nums) {\n    // 对于所有 idx < i : nums[idx < i] = 0\n    // j是当前考虑元素的下标\n    int p0 = 0, curr = 0;\n    // 对于所有 idx > k : nums[idx > k] = 2\n    int p2 = nums.length - 1;\n\n    int tmp;\n    while (curr <= p2) {\n      if (nums[curr] == 0) {\n        // 交换第 p0个和第curr个元素\n        // i++，j++\n        tmp = nums[p0];\n        nums[p0++] = nums[curr];\n        nums[curr++] = tmp;\n      }\n      else if (nums[curr] == 2) {\n        // 交换第k个和第curr个元素\n        // p2--\n        tmp = nums[curr];\n        nums[curr] = nums[p2];\n        nums[p2--] = tmp;\n      }\n      else curr++;\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\nclass Solution:\n    def sortColors(self, nums: List[int]) -> None:\n        '''\n        荷兰三色旗问题解\n        '''\n        # 对于所有 idx < p0 : nums[idx < p0] = 0\n        # curr是当前考虑元素的下标\n        p0 = curr = 0\n        # 对于所有 idx > p2 : nums[idx > p2] = 2\n        p2 = len(nums) - 1\n\n        while curr <= p2:\n            if nums[curr] == 0:\n                nums[p0], nums[curr] = nums[curr], nums[p0]\n                p0 += 1\n                curr += 1\n            elif nums[curr] == 2:\n                nums[curr], nums[p2] = nums[p2], nums[curr]\n                p2 -= 1\n            else:\n                curr += 1\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\nclass Solution {\n  public:\n  /*\n  荷兰三色旗问题解\n  */\n  void sortColors(vector<int>& nums) {\n    // 对于所有 idx < p0 : nums[idx < p0] = 0\n    // curr 是当前考虑元素的下标\n    int p0 = 0, curr = 0;\n    // 对于所有 idx > p2 : nums[idx > p2] = 2\n    int p2 = nums.size() - 1;\n\n    while (curr <= p2) {\n      if (nums[curr] == 0) {\n        swap(nums[curr++], nums[p0++]);\n      }\n      else if (nums[curr] == 2) {\n        swap(nums[curr], nums[p2--]);\n      }\n      else curr++;\n    }\n  }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n复杂度分析\n\n * 时间复杂度 :由于对长度 NNN的数组进行了一次遍历，时间复杂度为O(N)O(N)O(N) 。\n   \n   \n * 空间复杂度 :由于只使用了常数空间，空间复杂度为O(1)O(1)O(1) 。\n   \n   \n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-07-27 20:17:56Accepted [https://leetcode-cn.com//submissions/detail/4740213/]0 ms100.0%N/Ajava2018-07-27 20:17:15Compile Error [https://leetcode-cn.com//submissions/detail/4740165/]N/AN/AN/Ajava2018-05-14 00:16:38Accepted [https://leetcode-cn.com//submissions/detail/2236157/]0 ms100.0%N/Ajava2018-05-14 00:05:47Accepted [https://leetcode-cn.com//submissions/detail/2235838/]0 ms100.0%N/Ajava# 统计信息\n通过次数提交次数AC比率518939555454.3%# 相似题目\n题目难度排序链表 [https://leetcode-cn.com/problems/sort-list/]中等摆动排序 [https://leetcode-cn.com/problems/wiggle-sort/]中等摆动排序 II [https://leetcode-cn.com/problems/wiggle-sort-ii/]中等",contentLowercase:"# 中文题目\n给定一个包含红色、白色和蓝色，一共n 个元素的数组，原地 [https://baike.baidu.com/item/%e5%8e%9f%e5%9c%b0%e7%ae%97%e6%b3%95]对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。\n\n此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。\n\n注意:\n不能使用代码库中的排序函数来解决这道题。\n\n示例:\n\n输入: [2,0,2,1,1,0]\n输出: [0,0,1,1,2,2]\n\n进阶：\n\n * 一个直观的解决方案是使用计数排序的两趟扫描算法。\n   首先，迭代计算出0、1 和 2 元素的个数，然后按照0、1、2的排序，重写当前数组。\n * 你能想出一个仅使用常数空间的一趟扫描算法吗？\n\n# 通过代码\nclass solution {\n   public  void swap(int[] arr,int i,int j){\n            int temp=arr[i];\n            arr[i]=arr[j];\n            arr[j]=temp;\n        }\n\n        public  void sortcolors(int[] nums){\n            int lt=-1;\n            int gt=nums.length;\n            int i=lt+1;\n            while (i<gt){\n                if (nums[i]<1){\n                    swap(nums,i,lt+1);\n                    i++;\n                    lt++;\n                }else if (nums[i]>1){\n                    swap(nums,i,gt-1);\n                    gt--;\n                }else {\n                    i++;\n                }\n            }\n        }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\nclass solution {\n    public static void sortcolors(int[] nums){\n            int zero=-1;\n            int two=nums.length;\n            for (int i = 0; i < two; ) {\n                if (nums[i]==1){\n                    i++;\n                }else if (nums[i]==2){\n                    two--;\n                    swap(nums,i,two);\n                }else {\n                    zero++;\n                    swap(nums,zero,i);\n                    i++;\n                }\n\n            }\n        }\n\n        public static void swap(int[] arr,int i,int j){\n            int temp=arr[i];\n            arr[i]=arr[j];\n            arr[j]=temp;\n        }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\nclass solution {\n    public void sortcolors(int[] nums) {\n        int i0=0;\n            int i1=0;\n            for (int i = 0; i < nums.length; i++) {\n                if (nums[i]==0){\n                    i0++;\n                }else if (nums[i]==1){\n                    i1++;\n                }\n            }\n            for (int i=0;i<nums.length;i++){\n                if (i<i0){\n                    nums[i]=0;\n                }else if (i <i1+i0){\n                    nums[i]=1;\n                }else {\n                    nums[i]=2;\n                }\n            }\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n# 官方题解\n# 方法一: 一次遍历\n直觉\n\n本问题被称为 荷兰国旗问题 [https://en.wikipedia.org/wiki/dutch_national_flag_problem]，最初由 edsger w. dijkstra [https://baike.baidu.com/item/%e8%89%be%e5%85%b9%e6%a0%bc%c2%b7%e8%bf%aa%e7%a7%91%e6%96%af%e5%bd%bb/5029407?fromtitle=dijkstra&fromid=1880870&fr=aladdin]提出。 其主要思想是给每个数字设定一种颜色，并按照荷兰国旗颜色的顺序进行调整。\n\n\n\n我们用三个指针（p0, p2 和curr）来分别追踪0的最右边界，2的最左边界和当前考虑的元素。\n\n\n\n本解法的思路是沿着数组移动 curr 指针，若nums[curr] = 0，则将其与 nums[p0]互换；若 nums[curr] = 2 ，则与 nums[p2]互换。\n\n算法\n\n * 初始化0的最右边界：p0 = 0。在整个算法执行过程中 nums[idx < p0] = 0.\n   \n   \n * 初始化2的最左边界 ：p2 = n - 1。在整个算法执行过程中 nums[idx > p2] = 2.\n   \n   \n * 初始化当前考虑的元素序号 ：curr = 0.\n   \n   \n * while curr <= p2 :\n   \n    * 若 nums[curr] = 0 ：交换第 curr个 和 第p0个 元素，并将指针都向右移。\n      \n      \n    * 若 nums[curr] = 2 ：交换第 curr个和第 p2个元素，并将 p2指针左移 。\n      \n      \n    * 若 nums[curr] = 1 ：将指针curr右移。\n      \n      \n   \n   \n\n实现\n\n<,,,,,,,,,,,,>\n\nclass solution {\n  /*\n  荷兰三色旗问题解\n  */\n  public void sortcolors(int[] nums) {\n    // 对于所有 idx < i : nums[idx < i] = 0\n    // j是当前考虑元素的下标\n    int p0 = 0, curr = 0;\n    // 对于所有 idx > k : nums[idx > k] = 2\n    int p2 = nums.length - 1;\n\n    int tmp;\n    while (curr <= p2) {\n      if (nums[curr] == 0) {\n        // 交换第 p0个和第curr个元素\n        // i++，j++\n        tmp = nums[p0];\n        nums[p0++] = nums[curr];\n        nums[curr++] = tmp;\n      }\n      else if (nums[curr] == 2) {\n        // 交换第k个和第curr个元素\n        // p2--\n        tmp = nums[curr];\n        nums[curr] = nums[p2];\n        nums[p2--] = tmp;\n      }\n      else curr++;\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\nclass solution:\n    def sortcolors(self, nums: list[int]) -> none:\n        '''\n        荷兰三色旗问题解\n        '''\n        # 对于所有 idx < p0 : nums[idx < p0] = 0\n        # curr是当前考虑元素的下标\n        p0 = curr = 0\n        # 对于所有 idx > p2 : nums[idx > p2] = 2\n        p2 = len(nums) - 1\n\n        while curr <= p2:\n            if nums[curr] == 0:\n                nums[p0], nums[curr] = nums[curr], nums[p0]\n                p0 += 1\n                curr += 1\n            elif nums[curr] == 2:\n                nums[curr], nums[p2] = nums[p2], nums[curr]\n                p2 -= 1\n            else:\n                curr += 1\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\nclass solution {\n  public:\n  /*\n  荷兰三色旗问题解\n  */\n  void sortcolors(vector<int>& nums) {\n    // 对于所有 idx < p0 : nums[idx < p0] = 0\n    // curr 是当前考虑元素的下标\n    int p0 = 0, curr = 0;\n    // 对于所有 idx > p2 : nums[idx > p2] = 2\n    int p2 = nums.size() - 1;\n\n    while (curr <= p2) {\n      if (nums[curr] == 0) {\n        swap(nums[curr++], nums[p0++]);\n      }\n      else if (nums[curr] == 2) {\n        swap(nums[curr], nums[p2--]);\n      }\n      else curr++;\n    }\n  }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n复杂度分析\n\n * 时间复杂度 :由于对长度 nnn的数组进行了一次遍历，时间复杂度为o(n)o(n)o(n) 。\n   \n   \n * 空间复杂度 :由于只使用了常数空间，空间复杂度为o(1)o(1)o(1) 。\n   \n   \n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-07-27 20:17:56accepted [https://leetcode-cn.com//submissions/detail/4740213/]0 ms100.0%n/ajava2018-07-27 20:17:15compile error [https://leetcode-cn.com//submissions/detail/4740165/]n/an/an/ajava2018-05-14 00:16:38accepted [https://leetcode-cn.com//submissions/detail/2236157/]0 ms100.0%n/ajava2018-05-14 00:05:47accepted [https://leetcode-cn.com//submissions/detail/2235838/]0 ms100.0%n/ajava# 统计信息\n通过次数提交次数ac比率518939555454.3%# 相似题目\n题目难度排序链表 [https://leetcode-cn.com/problems/sort-list/]中等摆动排序 [https://leetcode-cn.com/problems/wiggle-sort/]中等摆动排序 ii [https://leetcode-cn.com/problems/wiggle-sort-ii/]中等"},{title:"63-不同路径 II(Unique Paths II)",frontmatter:{title:"63-不同路径 II(Unique Paths II)",date:"2018-09-15T00:00:00.000Z",categories:["中等"],tags:["数组<Array>","动态规划<Dynamic Programming>"]},regularPath:"/views/%E4%B8%AD%E7%AD%89/0063-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84%20II.html",relativePath:"views/中等/0063-不同路径 II.md",key:"v-0e1774ab",path:"/views/%E4%B8%AD%E7%AD%89/0063-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84%20II.html",headers:[{level:2,title:"中文题目",slug:"中文题目",charIndex:2},{level:2,title:"通过代码",slug:"通过代码",charIndex:339},{level:2,title:"官方题解",slug:"官方题解",charIndex:3067},{level:2,title:"提交历史",slug:"提交历史",charIndex:7185},{level:2,title:"统计信息",slug:"统计信息",charIndex:7412},{level:2,title:"相似题目",slug:"相似题目",charIndex:7447}],lastUpdated:"4/11/2021, 1:15:21 PM",headersStr:"中文题目 通过代码 官方题解 提交历史 统计信息 相似题目",content:'# 中文题目\n一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。\n\n机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。\n\n现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？\n\n\n\n网格中的障碍物和空位置分别用 1 和 0 来表示。\n\n说明：m和 n 的值均不超过 100。\n\n示例 1:\n\n输入:\n[\n  [0,0,0],\n  [0,1,0],\n  [0,0,0]\n]\n输出: 2\n解释:\n3x3 网格的正中间有一个障碍物。\n从左上角到右下角一共有 2 条不同的路径：\n1. 向右 -> 向右 -> 向下 -> 向下\n2. 向下 -> 向下 -> 向右 -> 向右\n\n\n# 通过代码\nclass Solution {\n             public int uniquePathsWithObstacles(int[][] obstacleGrid) {\n            if (obstacleGrid.length == 0 || obstacleGrid == null) {\n                return 0;\n            }\n            int[][] memo = new int[obstacleGrid.length][obstacleGrid[0].length];\n            for (int i = 0; i < obstacleGrid.length; i++) {\n                for (int j = 0; j < obstacleGrid[0].length; j++) {\n                    if (i == 0 && j == 0) {\n                        if (obstacleGrid[i][j] == 1) {\n                            return 0;\n                        } else {\n                            memo[i][j] = 1;\n                        }\n                    } else if (i == 0 && j != 0) {\n                        if (obstacleGrid[i][j] == 1) {\n                            memo[i][j] = 0;\n                            continue;\n                        }\n                        if (obstacleGrid[i][j - 1] == 1) {\n                            obstacleGrid[i][j] = 1;\n                            memo[i][j] = 0;\n                        } else {\n                            memo[i][j] = 1;\n                        }\n                    } else if (i != 0 && j == 0) {\n                        if (obstacleGrid[i][j] == 1) {\n                            memo[i][j] = 0;\n                            continue;\n                        }\n                        if (obstacleGrid[i - 1][j] == 1) {\n                            obstacleGrid[i][j] = 1;\n                            memo[i][j] = 0;\n                        } else {\n                            memo[i][j] = 1;\n                        }\n                    } else {\n                        if (obstacleGrid[i][j] == 1) {\n                            memo[i][j] = 0;\n                            continue;\n                        }\n                        if (obstacleGrid[i - 1][j] == 1 && obstacleGrid[i][j - 1] == 1) {\n                            obstacleGrid[i][j] = 1;\n                            memo[i][j] = 0;\n                        } else if (obstacleGrid[i - 1][j] != 1 && obstacleGrid[i][j - 1] == 1) {\n                            memo[i][j] = memo[i - 1][j];\n                        } else if (obstacleGrid[i - 1][j] == 1 && obstacleGrid[i][j - 1] != 1) {\n                            memo[i][j] = memo[i][j - 1];\n                        } else {\n                            memo[i][j] = memo[i][j - 1] + memo[i - 1][j];\n                        }\n                    }\n                }\n            }\n            return memo[obstacleGrid.length - 1][obstacleGrid[0].length - 1];\n        }\n\n\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n# 官方题解\n# 方法 1：动态规划\n直觉\n\n机器人只可以向下和向右移动，因此第一行的格子只能从左边的格子移动到，第一列的格子只能从上方的格子移动到。\n\n<,,,>\n\n对于剩下的格子，可以从左边或者上方的格子移动到。\n\n<,,,>\n\n如果格子上有障碍，那么我们不考虑包含这个格子的任何路径。我们从左至右、从上至下的遍历整个数组，那么在到达某个顶点之前我们就已经获得了到达前驱节点的方案数，这就变成了一个动态规划问题。我们只需要一个 obstacleGrid 数组作为 DP 数组。\n\n注意： 根据题目描述，包含障碍物的格点有权值 1，我们依此来判断是否包含在路径中，然后我们可以用这个空间来存储到达这个格点的方案数。\n\n算法\n\n 1. 如果第一个格点 obstacleGrid[0,0] 是 1，说明有障碍物，那么机器人不能做任何移动，我们返回结果 0。\n 2. 否则，如果 obstacleGrid[0,0] 是 0，我们初始化这个值为 1 然后继续算法。\n 3. 遍历第一行，如果有一个格点初始值为 1 ，说明当前节点有障碍物，没有路径可以通过，设值为 0 ；否则设这个值是前一个节点的值 obstacleGrid[i,j] = obstacleGrid[i,j-1]。\n 4. 遍历第一列，如果有一个格点初始值为 1 ，说明当前节点有障碍物，没有路径可以通过，设值为 0 ；否则设这个值是前一个节点的值 obstacleGrid[i,j] = obstacleGrid[i-1,j]。\n 5. 现在，从 obstacleGrid[1,1] 开始遍历整个数组，如果某个格点初始不包含任何障碍物，就把值赋为上方和左侧两个格点方案数之和 obstacleGrid[i,j] = obstacleGrid[i-1,j] + obstacleGrid[i,j-1]。\n 6. 如果这个点有障碍物，设值为 0 ，这可以保证不会对后面的路径产生贡献。\n\n<,,,,,,,,,,,,,,,,,>\n\nclass Solution {\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\n\n        int R = obstacleGrid.length;\n        int C = obstacleGrid[0].length;\n\n        // If the starting cell has an obstacle, then simply return as there would be\n        // no paths to the destination.\n        if (obstacleGrid[0][0] == 1) {\n            return 0;\n        }\n\n        // Number of ways of reaching the starting cell = 1.\n        obstacleGrid[0][0] = 1;\n\n        // Filling the values for the first column\n        for (int i = 1; i < R; i++) {\n            obstacleGrid[i][0] = (obstacleGrid[i][0] == 0 && obstacleGrid[i - 1][0] == 1) ? 1 : 0;\n        }\n\n        // Filling the values for the first row\n        for (int i = 1; i < C; i++) {\n            obstacleGrid[0][i] = (obstacleGrid[0][i] == 0 && obstacleGrid[0][i - 1] == 1) ? 1 : 0;\n        }\n\n        // Starting from cell(1,1) fill up the values\n        // No. of ways of reaching cell[i][j] = cell[i - 1][j] + cell[i][j - 1]\n        // i.e. From above and left.\n        for (int i = 1; i < R; i++) {\n            for (int j = 1; j < C; j++) {\n                if (obstacleGrid[i][j] == 0) {\n                    obstacleGrid[i][j] = obstacleGrid[i - 1][j] + obstacleGrid[i][j - 1];\n                } else {\n                    obstacleGrid[i][j] = 0;\n                }\n            }\n        }\n\n        // Return value stored in rightmost bottommost cell. That is the destination.\n        return obstacleGrid[R - 1][C - 1];\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\nclass Solution(object):\n    def uniquePathsWithObstacles(self, obstacleGrid):\n        """\n        :type obstacleGrid: List[List[int]]\n        :rtype: int\n        """\n\n        m = len(obstacleGrid)\n        n = len(obstacleGrid[0])\n\n        # If the starting cell has an obstacle, then simply return as there would be\n        # no paths to the destination.\n        if obstacleGrid[0][0] == 1:\n            return 0\n\n        # Number of ways of reaching the starting cell = 1.\n        obstacleGrid[0][0] = 1\n\n        # Filling the values for the first column\n        for i in range(1,m):\n            obstacleGrid[i][0] = int(obstacleGrid[i][0] == 0 and obstacleGrid[i-1][0] == 1)\n\n        # Filling the values for the first row        \n        for j in range(1, n):\n            obstacleGrid[0][j] = int(obstacleGrid[0][j] == 0 and obstacleGrid[0][j-1] == 1)\n\n        # Starting from cell(1,1) fill up the values\n        # No. of ways of reaching cell[i][j] = cell[i - 1][j] + cell[i][j - 1]\n        # i.e. From above and left.\n        for i in range(1,m):\n            for j in range(1,n):\n                if obstacleGrid[i][j] == 0:\n                    obstacleGrid[i][j] = obstacleGrid[i-1][j] + obstacleGrid[i][j-1]\n                else:\n                    obstacleGrid[i][j] = 0\n\n        # Return value stored in rightmost bottommost cell. That is the destination.            \n        return obstacleGrid[m-1][n-1]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n复杂度分析\n\n * 时间复杂度 ： O(M×N)O(M \\times N)O(M×N) 。长方形网格的大小是 M×NM \\times NM×N，而访问每个格点恰好一次。\n * 空间复杂度 ： O(1)O(1)O(1)。我们利用 obstacleGrid 作为 DP 数组，因此不需要额外的空间。\n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-09-15 16:06:16Accepted [https://leetcode-cn.com//submissions/detail/7131004/]2 ms90.55%N/Ajava2018-09-15 16:04:45Wrong Answer [https://leetcode-cn.com//submissions/detail/7130938/]N/AN/AN/Ajava# 统计信息\n通过次数提交次数AC比率3663911375732.2%# 相似题目\n题目难度不同路径 [https://leetcode-cn.com/problems/unique-paths/]中等不同路径 III [https://leetcode-cn.com/problems/unique-paths-iii/]困难',contentLowercase:'# 中文题目\n一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“start” ）。\n\n机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“finish”）。\n\n现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？\n\n\n\n网格中的障碍物和空位置分别用 1 和 0 来表示。\n\n说明：m和 n 的值均不超过 100。\n\n示例 1:\n\n输入:\n[\n  [0,0,0],\n  [0,1,0],\n  [0,0,0]\n]\n输出: 2\n解释:\n3x3 网格的正中间有一个障碍物。\n从左上角到右下角一共有 2 条不同的路径：\n1. 向右 -> 向右 -> 向下 -> 向下\n2. 向下 -> 向下 -> 向右 -> 向右\n\n\n# 通过代码\nclass solution {\n             public int uniquepathswithobstacles(int[][] obstaclegrid) {\n            if (obstaclegrid.length == 0 || obstaclegrid == null) {\n                return 0;\n            }\n            int[][] memo = new int[obstaclegrid.length][obstaclegrid[0].length];\n            for (int i = 0; i < obstaclegrid.length; i++) {\n                for (int j = 0; j < obstaclegrid[0].length; j++) {\n                    if (i == 0 && j == 0) {\n                        if (obstaclegrid[i][j] == 1) {\n                            return 0;\n                        } else {\n                            memo[i][j] = 1;\n                        }\n                    } else if (i == 0 && j != 0) {\n                        if (obstaclegrid[i][j] == 1) {\n                            memo[i][j] = 0;\n                            continue;\n                        }\n                        if (obstaclegrid[i][j - 1] == 1) {\n                            obstaclegrid[i][j] = 1;\n                            memo[i][j] = 0;\n                        } else {\n                            memo[i][j] = 1;\n                        }\n                    } else if (i != 0 && j == 0) {\n                        if (obstaclegrid[i][j] == 1) {\n                            memo[i][j] = 0;\n                            continue;\n                        }\n                        if (obstaclegrid[i - 1][j] == 1) {\n                            obstaclegrid[i][j] = 1;\n                            memo[i][j] = 0;\n                        } else {\n                            memo[i][j] = 1;\n                        }\n                    } else {\n                        if (obstaclegrid[i][j] == 1) {\n                            memo[i][j] = 0;\n                            continue;\n                        }\n                        if (obstaclegrid[i - 1][j] == 1 && obstaclegrid[i][j - 1] == 1) {\n                            obstaclegrid[i][j] = 1;\n                            memo[i][j] = 0;\n                        } else if (obstaclegrid[i - 1][j] != 1 && obstaclegrid[i][j - 1] == 1) {\n                            memo[i][j] = memo[i - 1][j];\n                        } else if (obstaclegrid[i - 1][j] == 1 && obstaclegrid[i][j - 1] != 1) {\n                            memo[i][j] = memo[i][j - 1];\n                        } else {\n                            memo[i][j] = memo[i][j - 1] + memo[i - 1][j];\n                        }\n                    }\n                }\n            }\n            return memo[obstaclegrid.length - 1][obstaclegrid[0].length - 1];\n        }\n\n\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n# 官方题解\n# 方法 1：动态规划\n直觉\n\n机器人只可以向下和向右移动，因此第一行的格子只能从左边的格子移动到，第一列的格子只能从上方的格子移动到。\n\n<,,,>\n\n对于剩下的格子，可以从左边或者上方的格子移动到。\n\n<,,,>\n\n如果格子上有障碍，那么我们不考虑包含这个格子的任何路径。我们从左至右、从上至下的遍历整个数组，那么在到达某个顶点之前我们就已经获得了到达前驱节点的方案数，这就变成了一个动态规划问题。我们只需要一个 obstaclegrid 数组作为 dp 数组。\n\n注意： 根据题目描述，包含障碍物的格点有权值 1，我们依此来判断是否包含在路径中，然后我们可以用这个空间来存储到达这个格点的方案数。\n\n算法\n\n 1. 如果第一个格点 obstaclegrid[0,0] 是 1，说明有障碍物，那么机器人不能做任何移动，我们返回结果 0。\n 2. 否则，如果 obstaclegrid[0,0] 是 0，我们初始化这个值为 1 然后继续算法。\n 3. 遍历第一行，如果有一个格点初始值为 1 ，说明当前节点有障碍物，没有路径可以通过，设值为 0 ；否则设这个值是前一个节点的值 obstaclegrid[i,j] = obstaclegrid[i,j-1]。\n 4. 遍历第一列，如果有一个格点初始值为 1 ，说明当前节点有障碍物，没有路径可以通过，设值为 0 ；否则设这个值是前一个节点的值 obstaclegrid[i,j] = obstaclegrid[i-1,j]。\n 5. 现在，从 obstaclegrid[1,1] 开始遍历整个数组，如果某个格点初始不包含任何障碍物，就把值赋为上方和左侧两个格点方案数之和 obstaclegrid[i,j] = obstaclegrid[i-1,j] + obstaclegrid[i,j-1]。\n 6. 如果这个点有障碍物，设值为 0 ，这可以保证不会对后面的路径产生贡献。\n\n<,,,,,,,,,,,,,,,,,>\n\nclass solution {\n    public int uniquepathswithobstacles(int[][] obstaclegrid) {\n\n        int r = obstaclegrid.length;\n        int c = obstaclegrid[0].length;\n\n        // if the starting cell has an obstacle, then simply return as there would be\n        // no paths to the destination.\n        if (obstaclegrid[0][0] == 1) {\n            return 0;\n        }\n\n        // number of ways of reaching the starting cell = 1.\n        obstaclegrid[0][0] = 1;\n\n        // filling the values for the first column\n        for (int i = 1; i < r; i++) {\n            obstaclegrid[i][0] = (obstaclegrid[i][0] == 0 && obstaclegrid[i - 1][0] == 1) ? 1 : 0;\n        }\n\n        // filling the values for the first row\n        for (int i = 1; i < c; i++) {\n            obstaclegrid[0][i] = (obstaclegrid[0][i] == 0 && obstaclegrid[0][i - 1] == 1) ? 1 : 0;\n        }\n\n        // starting from cell(1,1) fill up the values\n        // no. of ways of reaching cell[i][j] = cell[i - 1][j] + cell[i][j - 1]\n        // i.e. from above and left.\n        for (int i = 1; i < r; i++) {\n            for (int j = 1; j < c; j++) {\n                if (obstaclegrid[i][j] == 0) {\n                    obstaclegrid[i][j] = obstaclegrid[i - 1][j] + obstaclegrid[i][j - 1];\n                } else {\n                    obstaclegrid[i][j] = 0;\n                }\n            }\n        }\n\n        // return value stored in rightmost bottommost cell. that is the destination.\n        return obstaclegrid[r - 1][c - 1];\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\nclass solution(object):\n    def uniquepathswithobstacles(self, obstaclegrid):\n        """\n        :type obstaclegrid: list[list[int]]\n        :rtype: int\n        """\n\n        m = len(obstaclegrid)\n        n = len(obstaclegrid[0])\n\n        # if the starting cell has an obstacle, then simply return as there would be\n        # no paths to the destination.\n        if obstaclegrid[0][0] == 1:\n            return 0\n\n        # number of ways of reaching the starting cell = 1.\n        obstaclegrid[0][0] = 1\n\n        # filling the values for the first column\n        for i in range(1,m):\n            obstaclegrid[i][0] = int(obstaclegrid[i][0] == 0 and obstaclegrid[i-1][0] == 1)\n\n        # filling the values for the first row        \n        for j in range(1, n):\n            obstaclegrid[0][j] = int(obstaclegrid[0][j] == 0 and obstaclegrid[0][j-1] == 1)\n\n        # starting from cell(1,1) fill up the values\n        # no. of ways of reaching cell[i][j] = cell[i - 1][j] + cell[i][j - 1]\n        # i.e. from above and left.\n        for i in range(1,m):\n            for j in range(1,n):\n                if obstaclegrid[i][j] == 0:\n                    obstaclegrid[i][j] = obstaclegrid[i-1][j] + obstaclegrid[i][j-1]\n                else:\n                    obstaclegrid[i][j] = 0\n\n        # return value stored in rightmost bottommost cell. that is the destination.            \n        return obstaclegrid[m-1][n-1]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n复杂度分析\n\n * 时间复杂度 ： o(m×n)o(m \\times n)o(m×n) 。长方形网格的大小是 m×nm \\times nm×n，而访问每个格点恰好一次。\n * 空间复杂度 ： o(1)o(1)o(1)。我们利用 obstaclegrid 作为 dp 数组，因此不需要额外的空间。\n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-09-15 16:06:16accepted [https://leetcode-cn.com//submissions/detail/7131004/]2 ms90.55%n/ajava2018-09-15 16:04:45wrong answer [https://leetcode-cn.com//submissions/detail/7130938/]n/an/an/ajava# 统计信息\n通过次数提交次数ac比率3663911375732.2%# 相似题目\n题目难度不同路径 [https://leetcode-cn.com/problems/unique-paths/]中等不同路径 iii [https://leetcode-cn.com/problems/unique-paths-iii/]困难'},{title:"78-子集(Subsets)",frontmatter:{title:"78-子集(Subsets)",date:"2018-09-13T00:00:00.000Z",categories:["中等"],tags:["位运算<Bit Manipulation>","数组<Array>","回溯算法<Backtracking>"]},regularPath:"/views/%E4%B8%AD%E7%AD%89/0078-%E5%AD%90%E9%9B%86.html",relativePath:"views/中等/0078-子集.md",key:"v-7c92bd0a",path:"/views/%E4%B8%AD%E7%AD%89/0078-%E5%AD%90%E9%9B%86.html",headers:[{level:2,title:"中文题目",slug:"中文题目",charIndex:2},{level:2,title:"通过代码",slug:"通过代码",charIndex:162},{level:2,title:"高赞题解",slug:"高赞题解",charIndex:1709},{level:2,title:"思路:",slug:"思路",charIndex:1716},{level:2,title:"提交历史",slug:"提交历史",charIndex:8491},{level:2,title:"统计信息",slug:"统计信息",charIndex:8718},{level:2,title:"相似题目",slug:"相似题目",charIndex:8752}],lastUpdated:"4/11/2021, 1:15:21 PM",headersStr:"中文题目 通过代码 高赞题解 思路: 提交历史 统计信息 相似题目",content:'# 中文题目\n给定一组不含重复元素的整数数组nums，返回该数组所有可能的子集（幂集）。\n\n说明：解集不能包含重复的子集。\n\n示例:\n\n输入: nums = [1,2,3]\n输出:\n[\n  [3],\n  [1],\n  [2],\n  [1,2,3],\n  [1,3],\n  [2,3],\n  [1,2],\n  []\n]\n\n# 通过代码\nclass Solution {\n   public List<List<Integer>> subsets(int[] nums) {\n            List<List<Integer>> res=new LinkedList<List<Integer>>();\n            LinkedList<Integer> list=new LinkedList<Integer>();\n            if (nums==null || nums.length==0){\n                return res;\n            }\n            subsets(nums,res,list,0);\n            return res;\n        }\n\n        private void subsets(int[] nums, List<List<Integer>> res, LinkedList<Integer> list, int start) {\n            res.add(new LinkedList<Integer>(list));\n            for (int j = start; j < nums.length; j++) {\n                list.addLast(nums[j]);\n                subsets(nums,res,list,j+1);\n                list.removeLast();\n            }\n        }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\nclass Solution {\n   public List<List<Integer>> subsets(int[] nums) {\n            List<List<Integer>> res=new LinkedList<List<Integer>>();\n            LinkedList<Integer> list=new LinkedList<Integer>();\n            if (nums==null || nums.length==0){\n                return res;\n            }\n            subsets(nums,res,list,0);\n            return res;\n        }\n\n        private void subsets(int[] nums, List<List<Integer>> res, LinkedList<Integer> list, int start) {\n            res.add(new LinkedList<Integer>(list));\n            for (int j = start; j < nums.length; j++) {\n                list.addLast(nums[j]);\n                subsets(nums,res,list,j+1);\n                list.removeLast();\n            }\n        }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n# 高赞题解\n# 思路:\n思路一:库函数\n\nclass Solution:\n    def subsets(self, nums: List[int]) -> List[List[int]]:\n        res = []\n        for i in range(len(nums)+1):\n            for tmp in itertools.combinations(nums, i):\n                res.append(tmp)\n        return res\n\n\n1\n2\n3\n4\n5\n6\n7\n思路二:迭代\n\nclass Solution:\n    def subsets(self, nums: List[int]) -> List[List[int]]:\n        res = [[]]\n        for i in nums:\n            res = res + [[i] + num for num in res]\n        return res\n\n\n1\n2\n3\n4\n5\n6\n思路三:递归(回溯算法)\n\nclass Solution:\n    def subsets(self, nums: List[int]) -> List[List[int]]:\n        res = []\n        n = len(nums)\n        \n        def helper(i, tmp):\n            res.append(tmp)\n            for j in range(i, n):\n                helper(j + 1,tmp + [nums[j]] )\n        helper(0, [])\n        return res  \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\nclass Solution {\n    public List<List<Integer>> subsets(int[] nums) {\n        List<List<Integer>> res = new ArrayList<>();\n        backtrack(0, nums, res, new ArrayList<Integer>());\n        return res;\n\n    }\n\n    private void backtrack(int i, int[] nums, List<List<Integer>> res, ArrayList<Integer> tmp) {\n        res.add(new ArrayList<>(tmp));\n        for (int j = i; j < nums.length; j++) {\n            tmp.add(nums[j]);\n            backtrack(j + 1, nums, res, tmp);\n            tmp.remove(tmp.size() - 1);\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n类似题目还有:\n\n39.组合总和 [https://leetcode-cn.com/problems/combination-sum/]\n\n40. 组合总和 II [https://leetcode-cn.com/problems/combination-sum-ii/]\n\n46. 全排列 [https://leetcode-cn.com/problems/permutations/]\n\n47. 全排列 II [https://leetcode-cn.com/problems/permutations-ii/]\n\n78. 子集 [https://leetcode-cn.com/problems/subsets/]\n\n90. 子集 II [https://leetcode-cn.com/problems/subsets-ii/]\n\n这类题目都是同一类型的,用回溯算法!\n\n其实回溯算法关键在于:不合适就退回上一步\n\n然后通过约束条件, 减少时间复杂度.\n\n大家可以从下面的解法找出一点感觉!\n\n78. 子集 [https://leetcode-cn.com/problems/subsets/]\n\nclass Solution:\n\tdef subsets(self, nums):\t\t\n                if not nums:\n\t\t\treturn []\n\t\tres = []\n\t\tn = len(nums)\n\n\t\tdef helper(idx, temp_list):\n\t\t\tres.append(temp_list)\n\t\t\tfor i in range(idx, n):\n\t\t\t\thelper(i + 1, temp_list + [nums[i]])\n\n\t\thelper(0, [])\n\t\treturn res\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n90. 子集 II [https://leetcode-cn.com/problems/subsets-ii/]\n\nclass Solution(object):\n    def subsetsWithDup(self, nums):\n        """\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        """\n        if not nums:\n            return []\n        n = len(nums)\n        res = []\n        nums.sort()\n\t\t# 思路1\n        def helper1(idx, n, temp_list):\n            if temp_list not in res:\n                res.append(temp_list)\n            for i in range(idx, n):\n                helper1(i + 1, n, temp_list + [nums[i]])\n\t\t# 思路2\n        def helper2(idx, n, temp_list):\n            res.append(temp_list)\n            for i in range(idx, n):\n                if i > idx and  nums[i] == nums[i - 1]:\n                    continue\n                helper2(i + 1, n, temp_list + [nums[i]])\n\n        helper2(0, n, [])\n        return res\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n46. 全排列 [https://leetcode-cn.com/problems/permutations/]\n\nclass Solution(object):\n    def permute(self, nums):\n        """\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        """\n        if not nums:\n            return\n        res = []\n        n = len(nums)\n        visited = [0] * n\n        def helper1(temp_list,length):\n            if length == n:\n                res.append(temp_list)\n            for i in range(n):\n                if visited[i] :\n                    continue\n                visited[i] = 1\n                helper1(temp_list+[nums[i]],length+1)\n                visited[i] = 0\n        def helper2(nums,temp_list,length):\n            if length == n:\n                res.append(temp_list)\n            for i in range(len(nums)):\n                helper2(nums[:i]+nums[i+1:],temp_list+[nums[i]],length+1)\n        helper1([],0)\n        return res\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n47. 全排列 II [https://leetcode-cn.com/problems/permutations-ii/]\n\nclass Solution(object):\n    def permuteUnique(self, nums):\n        """\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        """\n                if not nums:\n\t\t\treturn []\n\t\tnums.sort()\n\t\tn = len(nums)\n\t\tvisited = [0] * n\n\t\tres = []\n\n\t\tdef helper1(temp_list, length):\n\t\t\t# if length == n and temp_list not in res:\n\t\t\t# \tres.append(temp_list)\n\t\t\tif length == n:\n\t\t\t\tres.append(temp_list)\n\t\t\tfor i in range(n):\n\t\t\t\tif visited[i] or (i > 0 and nums[i] == nums[i - 1] and not visited[i - 1]):\n\t\t\t\t\tcontinue\n\t\t\t\tvisited[i] = 1\n\t\t\t\thelper1(temp_list + [nums[i]], length + 1)\n\t\t\t\tvisited[i] = 0\n\n\t\tdef helper2(nums, temp_list, length):\n\t\t\tif length == n and temp_list not in res:\n\t\t\t\tres.append(temp_list)\n\t\t\tfor i in range(len(nums)):\n\t\t\t\thelper2(nums[:i] + nums[i + 1:], temp_list + [nums[i]], length + 1)\n\n\t\thelper1([],0)\n\t\t# helper2(nums, [], 0)\n\t\treturn res\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n39.组合总和 [https://leetcode-cn.com/problems/combination-sum/]\n\nclass Solution(object):\n    def combinationSum(self, candidates, target):\n        """\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        """\n        if not candidates:\n            return []\n        if min(candidates) > target:\n            return []\n        candidates.sort()\n        res = []\n\n        def helper(candidates, target, temp_list):\n            if target == 0:\n                res.append(temp_list)\n            if target < 0:\n                return\n            for i in range(len(candidates)):\n                if candidates[i] > target:\n                    break\n                helper(candidates[i:], target - candidates[i], temp_list + [candidates[i]])\n        helper(candidates,target,[])\n        return res\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n40. 组合总和 II [https://leetcode-cn.com/problems/combination-sum-ii/]\n\nclass Solution:\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\n        if not candidates:\n            return []\n        candidates.sort()\n        n = len(candidates)\n        res = []\n        \n        def backtrack(i, tmp_sum, tmp_list):\n            if tmp_sum == target:\n                res.append(tmp_list)\n                return \n            for j in range(i, n):\n                if tmp_sum + candidates[j]  > target : break\n                if j > i and candidates[j] == candidates[j-1]:continue\n                backtrack(j + 1, tmp_sum + candidates[j], tmp_list + [candidates[j]])\n        backtrack(0, 0, [])    \n        return res\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-09-13 17:37:56Accepted [https://leetcode-cn.com//submissions/detail/7040685/]5 ms11.77%N/Ajava2018-09-13 17:37:45Accepted [https://leetcode-cn.com//submissions/detail/7040673/]5 ms11.77%N/Ajava# 统计信息\n通过次数提交次数AC比率547407203376.0%# 相似题目\n题目难度子集 II [https://leetcode-cn.com/problems/subsets-ii/]中等列举单词的全部缩写 [https://leetcode-cn.com/problems/generalized-abbreviation/]中等字母大小写全排列 [https://leetcode-cn.com/problems/letter-case-permutation/]简单',contentLowercase:'# 中文题目\n给定一组不含重复元素的整数数组nums，返回该数组所有可能的子集（幂集）。\n\n说明：解集不能包含重复的子集。\n\n示例:\n\n输入: nums = [1,2,3]\n输出:\n[\n  [3],\n  [1],\n  [2],\n  [1,2,3],\n  [1,3],\n  [2,3],\n  [1,2],\n  []\n]\n\n# 通过代码\nclass solution {\n   public list<list<integer>> subsets(int[] nums) {\n            list<list<integer>> res=new linkedlist<list<integer>>();\n            linkedlist<integer> list=new linkedlist<integer>();\n            if (nums==null || nums.length==0){\n                return res;\n            }\n            subsets(nums,res,list,0);\n            return res;\n        }\n\n        private void subsets(int[] nums, list<list<integer>> res, linkedlist<integer> list, int start) {\n            res.add(new linkedlist<integer>(list));\n            for (int j = start; j < nums.length; j++) {\n                list.addlast(nums[j]);\n                subsets(nums,res,list,j+1);\n                list.removelast();\n            }\n        }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\nclass solution {\n   public list<list<integer>> subsets(int[] nums) {\n            list<list<integer>> res=new linkedlist<list<integer>>();\n            linkedlist<integer> list=new linkedlist<integer>();\n            if (nums==null || nums.length==0){\n                return res;\n            }\n            subsets(nums,res,list,0);\n            return res;\n        }\n\n        private void subsets(int[] nums, list<list<integer>> res, linkedlist<integer> list, int start) {\n            res.add(new linkedlist<integer>(list));\n            for (int j = start; j < nums.length; j++) {\n                list.addlast(nums[j]);\n                subsets(nums,res,list,j+1);\n                list.removelast();\n            }\n        }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n# 高赞题解\n# 思路:\n思路一:库函数\n\nclass solution:\n    def subsets(self, nums: list[int]) -> list[list[int]]:\n        res = []\n        for i in range(len(nums)+1):\n            for tmp in itertools.combinations(nums, i):\n                res.append(tmp)\n        return res\n\n\n1\n2\n3\n4\n5\n6\n7\n思路二:迭代\n\nclass solution:\n    def subsets(self, nums: list[int]) -> list[list[int]]:\n        res = [[]]\n        for i in nums:\n            res = res + [[i] + num for num in res]\n        return res\n\n\n1\n2\n3\n4\n5\n6\n思路三:递归(回溯算法)\n\nclass solution:\n    def subsets(self, nums: list[int]) -> list[list[int]]:\n        res = []\n        n = len(nums)\n        \n        def helper(i, tmp):\n            res.append(tmp)\n            for j in range(i, n):\n                helper(j + 1,tmp + [nums[j]] )\n        helper(0, [])\n        return res  \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\nclass solution {\n    public list<list<integer>> subsets(int[] nums) {\n        list<list<integer>> res = new arraylist<>();\n        backtrack(0, nums, res, new arraylist<integer>());\n        return res;\n\n    }\n\n    private void backtrack(int i, int[] nums, list<list<integer>> res, arraylist<integer> tmp) {\n        res.add(new arraylist<>(tmp));\n        for (int j = i; j < nums.length; j++) {\n            tmp.add(nums[j]);\n            backtrack(j + 1, nums, res, tmp);\n            tmp.remove(tmp.size() - 1);\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n类似题目还有:\n\n39.组合总和 [https://leetcode-cn.com/problems/combination-sum/]\n\n40. 组合总和 ii [https://leetcode-cn.com/problems/combination-sum-ii/]\n\n46. 全排列 [https://leetcode-cn.com/problems/permutations/]\n\n47. 全排列 ii [https://leetcode-cn.com/problems/permutations-ii/]\n\n78. 子集 [https://leetcode-cn.com/problems/subsets/]\n\n90. 子集 ii [https://leetcode-cn.com/problems/subsets-ii/]\n\n这类题目都是同一类型的,用回溯算法!\n\n其实回溯算法关键在于:不合适就退回上一步\n\n然后通过约束条件, 减少时间复杂度.\n\n大家可以从下面的解法找出一点感觉!\n\n78. 子集 [https://leetcode-cn.com/problems/subsets/]\n\nclass solution:\n\tdef subsets(self, nums):\t\t\n                if not nums:\n\t\t\treturn []\n\t\tres = []\n\t\tn = len(nums)\n\n\t\tdef helper(idx, temp_list):\n\t\t\tres.append(temp_list)\n\t\t\tfor i in range(idx, n):\n\t\t\t\thelper(i + 1, temp_list + [nums[i]])\n\n\t\thelper(0, [])\n\t\treturn res\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n90. 子集 ii [https://leetcode-cn.com/problems/subsets-ii/]\n\nclass solution(object):\n    def subsetswithdup(self, nums):\n        """\n        :type nums: list[int]\n        :rtype: list[list[int]]\n        """\n        if not nums:\n            return []\n        n = len(nums)\n        res = []\n        nums.sort()\n\t\t# 思路1\n        def helper1(idx, n, temp_list):\n            if temp_list not in res:\n                res.append(temp_list)\n            for i in range(idx, n):\n                helper1(i + 1, n, temp_list + [nums[i]])\n\t\t# 思路2\n        def helper2(idx, n, temp_list):\n            res.append(temp_list)\n            for i in range(idx, n):\n                if i > idx and  nums[i] == nums[i - 1]:\n                    continue\n                helper2(i + 1, n, temp_list + [nums[i]])\n\n        helper2(0, n, [])\n        return res\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n46. 全排列 [https://leetcode-cn.com/problems/permutations/]\n\nclass solution(object):\n    def permute(self, nums):\n        """\n        :type nums: list[int]\n        :rtype: list[list[int]]\n        """\n        if not nums:\n            return\n        res = []\n        n = len(nums)\n        visited = [0] * n\n        def helper1(temp_list,length):\n            if length == n:\n                res.append(temp_list)\n            for i in range(n):\n                if visited[i] :\n                    continue\n                visited[i] = 1\n                helper1(temp_list+[nums[i]],length+1)\n                visited[i] = 0\n        def helper2(nums,temp_list,length):\n            if length == n:\n                res.append(temp_list)\n            for i in range(len(nums)):\n                helper2(nums[:i]+nums[i+1:],temp_list+[nums[i]],length+1)\n        helper1([],0)\n        return res\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n47. 全排列 ii [https://leetcode-cn.com/problems/permutations-ii/]\n\nclass solution(object):\n    def permuteunique(self, nums):\n        """\n        :type nums: list[int]\n        :rtype: list[list[int]]\n        """\n                if not nums:\n\t\t\treturn []\n\t\tnums.sort()\n\t\tn = len(nums)\n\t\tvisited = [0] * n\n\t\tres = []\n\n\t\tdef helper1(temp_list, length):\n\t\t\t# if length == n and temp_list not in res:\n\t\t\t# \tres.append(temp_list)\n\t\t\tif length == n:\n\t\t\t\tres.append(temp_list)\n\t\t\tfor i in range(n):\n\t\t\t\tif visited[i] or (i > 0 and nums[i] == nums[i - 1] and not visited[i - 1]):\n\t\t\t\t\tcontinue\n\t\t\t\tvisited[i] = 1\n\t\t\t\thelper1(temp_list + [nums[i]], length + 1)\n\t\t\t\tvisited[i] = 0\n\n\t\tdef helper2(nums, temp_list, length):\n\t\t\tif length == n and temp_list not in res:\n\t\t\t\tres.append(temp_list)\n\t\t\tfor i in range(len(nums)):\n\t\t\t\thelper2(nums[:i] + nums[i + 1:], temp_list + [nums[i]], length + 1)\n\n\t\thelper1([],0)\n\t\t# helper2(nums, [], 0)\n\t\treturn res\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n39.组合总和 [https://leetcode-cn.com/problems/combination-sum/]\n\nclass solution(object):\n    def combinationsum(self, candidates, target):\n        """\n        :type candidates: list[int]\n        :type target: int\n        :rtype: list[list[int]]\n        """\n        if not candidates:\n            return []\n        if min(candidates) > target:\n            return []\n        candidates.sort()\n        res = []\n\n        def helper(candidates, target, temp_list):\n            if target == 0:\n                res.append(temp_list)\n            if target < 0:\n                return\n            for i in range(len(candidates)):\n                if candidates[i] > target:\n                    break\n                helper(candidates[i:], target - candidates[i], temp_list + [candidates[i]])\n        helper(candidates,target,[])\n        return res\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n40. 组合总和 ii [https://leetcode-cn.com/problems/combination-sum-ii/]\n\nclass solution:\n    def combinationsum2(self, candidates: list[int], target: int) -> list[list[int]]:\n        if not candidates:\n            return []\n        candidates.sort()\n        n = len(candidates)\n        res = []\n        \n        def backtrack(i, tmp_sum, tmp_list):\n            if tmp_sum == target:\n                res.append(tmp_list)\n                return \n            for j in range(i, n):\n                if tmp_sum + candidates[j]  > target : break\n                if j > i and candidates[j] == candidates[j-1]:continue\n                backtrack(j + 1, tmp_sum + candidates[j], tmp_list + [candidates[j]])\n        backtrack(0, 0, [])    \n        return res\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-09-13 17:37:56accepted [https://leetcode-cn.com//submissions/detail/7040685/]5 ms11.77%n/ajava2018-09-13 17:37:45accepted [https://leetcode-cn.com//submissions/detail/7040673/]5 ms11.77%n/ajava# 统计信息\n通过次数提交次数ac比率547407203376.0%# 相似题目\n题目难度子集 ii [https://leetcode-cn.com/problems/subsets-ii/]中等列举单词的全部缩写 [https://leetcode-cn.com/problems/generalized-abbreviation/]中等字母大小写全排列 [https://leetcode-cn.com/problems/letter-case-permutation/]简单'},{title:"77-组合(Combinations)",frontmatter:{title:"77-组合(Combinations)",date:"2018-07-22T00:00:00.000Z",categories:["中等"],tags:["回溯算法<Backtracking>"]},regularPath:"/views/%E4%B8%AD%E7%AD%89/0077-%E7%BB%84%E5%90%88.html",relativePath:"views/中等/0077-组合.md",key:"v-4ec67454",path:"/views/%E4%B8%AD%E7%AD%89/0077-%E7%BB%84%E5%90%88.html",headers:[{level:2,title:"中文题目",slug:"中文题目",charIndex:2},{level:2,title:"通过代码",slug:"通过代码",charIndex:135},{level:2,title:"官方题解",slug:"官方题解",charIndex:1932},{level:2,title:"提交历史",slug:"提交历史",charIndex:6188},{level:2,title:"统计信息",slug:"统计信息",charIndex:6417},{level:2,title:"相似题目",slug:"相似题目",charIndex:6451}],lastUpdated:"4/11/2021, 1:15:21 PM",headersStr:"中文题目 通过代码 官方题解 提交历史 统计信息 相似题目",content:"# 中文题目\n给定两个整数 n 和 k，返回 1 ... n 中所有可能的 k 个数的组合。\n\n示例:\n\n输入: n = 4, k = 2\n输出:\n[\n  [2,4],\n  [3,4],\n  [2,3],\n  [1,2],\n  [1,3],\n  [1,4],\n]\n\n# 通过代码\nclass Solution {\n   public List<List<Integer>> res=new LinkedList<>();\n\n        public void generateCombinations(int n,int k,int start,LinkedList<Integer> c){\n            if (c.size()==k){\n                List<Integer> list=new LinkedList<>();\n                list.addAll(c);\n                res.add(list);\n                return;\n            }\n            for (int i = start; i <= n-(k-c.size())+1 ; i++) {\n                c.add(i);\n                generateCombinations(n,k,i+1,c);\n                c.removeLast();\n            }\n            return;\n        }\n\n        public List<List<Integer>> combine(int n, int k) {\n            if (n<=0|| k <=0 || k >n){\n                return res;\n            }\n            LinkedList<Integer> c=new LinkedList<>();\n            generateCombinations(n,k,1,c);\n            return res;\n        }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\nclass Solution {\n   public List<List<Integer>> res=new LinkedList<>();\n\n        public void generateCombinations(int n,int k,int start,LinkedList<Integer> c){\n            if (c.size()==k){\n                List<Integer> list=new LinkedList<>();\n                list.addAll(c);\n                res.add(list);\n                return;\n            }\n            for (int i = start; i <=n ; i++) {\n                c.add(i);\n                generateCombinations(n,k,i+1,c);\n                c.removeLast();\n            }\n            return;\n        }\n\n        public List<List<Integer>> combine(int n, int k) {\n            if (n<=0|| k <=0 || k >n){\n                return res;\n            }\n            LinkedList<Integer> c=new LinkedList<>();\n            generateCombinations(n,k,1,c);\n            return res;\n        }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n# 官方题解\n# 方法一 : 回溯法\n算法\n\n回溯法 [https://baike.baidu.com/item/%E5%9B%9E%E6%BA%AF%E6%B3%95/86074?fr=aladdin]是一种通过遍历所有可能成员来寻找全部可行解的算法。若候选 不是 可行解 (或者至少不是 最后一个 解)，回溯法会在前一步进行一些修改以舍弃该候选，换而言之， 回溯 并再次尝试。\n\n这是一个回溯法函数，它将第一个添加到组合中的数和现有的组合作为参数。 backtrack(first, curr)\n\n * 若组合完成- 添加到输出中。\n   \n   \n * 遍历从 first t到 n的所有整数。\n   \n    * 将整数 i 添加到现有组合 curr中。\n      \n      \n    * 继续向组合中添加更多整数 :backtrack(i + 1, curr).\n      \n      \n    * 将 i 从 curr中移除，实现回溯。\n      \n      \n   \n   \n\n实现\n\n<,,,,,,,,,,,>\n\nclass Solution:\n    def combine(self, n: int, k: int) -> List[List[int]]:\n        def backtrack(first = 1, curr = []):\n            # if the combination is done\n            if len(curr) == k:  \n                output.append(curr[:])\n            for i in range(first, n + 1):\n                # add i into the current combination\n                curr.append(i)\n                # use next integers to complete the combination\n                backtrack(i + 1, curr)\n                # backtrack\n                curr.pop()\n        \n        output = []\n        backtrack()\n        return output\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\nclass Solution {\n  List<List<Integer>> output = new LinkedList();\n  int n;\n  int k;\n\n  public void backtrack(int first, LinkedList<Integer> curr) {\n    // if the combination is done\n    if (curr.size() == k)\n      output.add(new LinkedList(curr));\n\n    for (int i = first; i < n + 1; ++i) {\n      // add i into the current combination\n      curr.add(i);\n      // use next integers to complete the combination\n      backtrack(i + 1, curr);\n      // backtrack\n      curr.removeLast();\n    }\n  }\n\n  public List<List<Integer>> combine(int n, int k) {\n    this.n = n;\n    this.k = k;\n    backtrack(1, new LinkedList<Integer>());\n    return output;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n复杂度分析\n\n * 时间复杂度 : O(kCNk)O(k C_N^k)O(kCNk​)，其中 CNk=N!(N−k)!k!C_N^k = \\frac{N!}{(N - k)! k!}CNk​=(N−k)!k!N!​ 是要构成的组合数。append / pop (add / removeLast) 操作使用常数时间，唯一耗费时间的是将长度为 k 的组合添加到输出中。\n   \n   \n * 空间复杂度 : O(CNk)O(C_N^k)O(CNk​) ，用于保存全部组合数以输出。\n   \n   \n   \n   \n\n\n\n\n# 方法二: 字典序 (二进制排序) 组合\n直觉\n\n主要思路是以字典序的顺序获得全部组合。\n\n算法\n\n算法非常直截了当 :\n\n * 将 nums 初始化为从 1 到 k的整数序列。 将 n + 1添加为末尾元素，起到“哨兵”的作用。 将指针设为列表的开头 j = 0.\n   \n   \n * While j < k :\n   \n    * 将nums 中的前k个元素添加到输出中，换而言之，除了“哨兵”之外的全部元素。\n      \n      \n    * 找到nums中的第一个满足 nums[j] + 1 != nums[j + 1]的元素，并将其加一nums[j]++ 以转到下一个组合。\n      \n      \n   \n   \n\n实现\n\nclass Solution:\n    def combine(self, n: int, k: int) -> List[List[int]]:\n        # init first combination\n        nums = list(range(1, k + 1)) + [n + 1]\n        \n        output, j = [], 0\n        while j < k:\n            # add current combination\n            output.append(nums[:k])\n            # increase first nums[j] by one\n            # if nums[j] + 1 != nums[j + 1]\n            j = 0\n            while j < k and nums[j + 1] == nums[j] + 1:\n                nums[j] = j + 1\n                j += 1\n            nums[j] += 1\n            \n        return output\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\nclass Solution {\n  public List<List<Integer>> combine(int n, int k) {\n    // init first combination\n    LinkedList<Integer> nums = new LinkedList<Integer>();\n    for(int i = 1; i < k + 1; ++i)\n      nums.add(i);\n    nums.add(n + 1);\n\n    List<List<Integer>> output = new ArrayList<List<Integer>>();\n    int j = 0;\n    while (j < k) {\n      // add current combination\n      output.add(new LinkedList(nums.subList(0, k)));\n      // increase first nums[j] by one\n      // if nums[j] + 1 != nums[j + 1]\n      j = 0;\n      while ((j < k) && (nums.get(j + 1) == nums.get(j) + 1))\n        nums.set(j, j++ + 1);\n      nums.set(j, nums.get(j) + 1);\n    }\n    return output;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n复杂度分析\n\n * 时间复杂度 : O(kCNk)O(k C_N^k)O(kCNk​)，其中CNk=N!(N−k)!k!C_N^k = \\frac{N!}{(N - k)! k!}CNk​=(N−k)!k!N!​ 是要构建的组合数。由于组合数是CNkC_N^kCNk​，外层的 while 循环执行了CNkC_N^kCNk​次 。对给定的一个j，内层的 while 循环执行了CN−jk−jC_{N - j}^{k - j}CN−jk−j​次。外层循环超过 CNkC_N^kCNk​次访问，平均而言每次访问的执行次数少于1。因此，最耗费时间的部分是将每个长度为kkk 的组合(共计CNkC_N^kCNk​ 个组合) 添加到输出中， 消耗 O(kCNk)O(k C_N^k)O(kCNk​) 的时间。\n   \n   你可能注意到，尽管方法二的时间复杂度与方法一相同，但方法二却要快上许多。这是由于方法一需要处理递归调用栈，且其带来的影响在Python中比在Java中更为显著。\n   \n   \n * 空间复杂度 : O(CNk)O(C_N^k)O(CNk​) ，用于保存全部组合数以输出。\n   \n   \n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-07-22 20:41:47Accepted [https://leetcode-cn.com//submissions/detail/4509723/]18 ms59.14%N/Ajava2018-07-22 20:04:31Accepted [https://leetcode-cn.com//submissions/detail/4508605/]26 ms54.65%N/Ajava# 统计信息\n通过次数提交次数AC比率305954238572.2%# 相似题目\n题目难度组合总和 [https://leetcode-cn.com/problems/combination-sum/]中等全排列 [https://leetcode-cn.com/problems/permutations/]中等",contentLowercase:"# 中文题目\n给定两个整数 n 和 k，返回 1 ... n 中所有可能的 k 个数的组合。\n\n示例:\n\n输入: n = 4, k = 2\n输出:\n[\n  [2,4],\n  [3,4],\n  [2,3],\n  [1,2],\n  [1,3],\n  [1,4],\n]\n\n# 通过代码\nclass solution {\n   public list<list<integer>> res=new linkedlist<>();\n\n        public void generatecombinations(int n,int k,int start,linkedlist<integer> c){\n            if (c.size()==k){\n                list<integer> list=new linkedlist<>();\n                list.addall(c);\n                res.add(list);\n                return;\n            }\n            for (int i = start; i <= n-(k-c.size())+1 ; i++) {\n                c.add(i);\n                generatecombinations(n,k,i+1,c);\n                c.removelast();\n            }\n            return;\n        }\n\n        public list<list<integer>> combine(int n, int k) {\n            if (n<=0|| k <=0 || k >n){\n                return res;\n            }\n            linkedlist<integer> c=new linkedlist<>();\n            generatecombinations(n,k,1,c);\n            return res;\n        }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\nclass solution {\n   public list<list<integer>> res=new linkedlist<>();\n\n        public void generatecombinations(int n,int k,int start,linkedlist<integer> c){\n            if (c.size()==k){\n                list<integer> list=new linkedlist<>();\n                list.addall(c);\n                res.add(list);\n                return;\n            }\n            for (int i = start; i <=n ; i++) {\n                c.add(i);\n                generatecombinations(n,k,i+1,c);\n                c.removelast();\n            }\n            return;\n        }\n\n        public list<list<integer>> combine(int n, int k) {\n            if (n<=0|| k <=0 || k >n){\n                return res;\n            }\n            linkedlist<integer> c=new linkedlist<>();\n            generatecombinations(n,k,1,c);\n            return res;\n        }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n# 官方题解\n# 方法一 : 回溯法\n算法\n\n回溯法 [https://baike.baidu.com/item/%e5%9b%9e%e6%ba%af%e6%b3%95/86074?fr=aladdin]是一种通过遍历所有可能成员来寻找全部可行解的算法。若候选 不是 可行解 (或者至少不是 最后一个 解)，回溯法会在前一步进行一些修改以舍弃该候选，换而言之， 回溯 并再次尝试。\n\n这是一个回溯法函数，它将第一个添加到组合中的数和现有的组合作为参数。 backtrack(first, curr)\n\n * 若组合完成- 添加到输出中。\n   \n   \n * 遍历从 first t到 n的所有整数。\n   \n    * 将整数 i 添加到现有组合 curr中。\n      \n      \n    * 继续向组合中添加更多整数 :backtrack(i + 1, curr).\n      \n      \n    * 将 i 从 curr中移除，实现回溯。\n      \n      \n   \n   \n\n实现\n\n<,,,,,,,,,,,>\n\nclass solution:\n    def combine(self, n: int, k: int) -> list[list[int]]:\n        def backtrack(first = 1, curr = []):\n            # if the combination is done\n            if len(curr) == k:  \n                output.append(curr[:])\n            for i in range(first, n + 1):\n                # add i into the current combination\n                curr.append(i)\n                # use next integers to complete the combination\n                backtrack(i + 1, curr)\n                # backtrack\n                curr.pop()\n        \n        output = []\n        backtrack()\n        return output\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\nclass solution {\n  list<list<integer>> output = new linkedlist();\n  int n;\n  int k;\n\n  public void backtrack(int first, linkedlist<integer> curr) {\n    // if the combination is done\n    if (curr.size() == k)\n      output.add(new linkedlist(curr));\n\n    for (int i = first; i < n + 1; ++i) {\n      // add i into the current combination\n      curr.add(i);\n      // use next integers to complete the combination\n      backtrack(i + 1, curr);\n      // backtrack\n      curr.removelast();\n    }\n  }\n\n  public list<list<integer>> combine(int n, int k) {\n    this.n = n;\n    this.k = k;\n    backtrack(1, new linkedlist<integer>());\n    return output;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n复杂度分析\n\n * 时间复杂度 : o(kcnk)o(k c_n^k)o(kcnk​)，其中 cnk=n!(n−k)!k!c_n^k = \\frac{n!}{(n - k)! k!}cnk​=(n−k)!k!n!​ 是要构成的组合数。append / pop (add / removelast) 操作使用常数时间，唯一耗费时间的是将长度为 k 的组合添加到输出中。\n   \n   \n * 空间复杂度 : o(cnk)o(c_n^k)o(cnk​) ，用于保存全部组合数以输出。\n   \n   \n   \n   \n\n\n\n\n# 方法二: 字典序 (二进制排序) 组合\n直觉\n\n主要思路是以字典序的顺序获得全部组合。\n\n算法\n\n算法非常直截了当 :\n\n * 将 nums 初始化为从 1 到 k的整数序列。 将 n + 1添加为末尾元素，起到“哨兵”的作用。 将指针设为列表的开头 j = 0.\n   \n   \n * while j < k :\n   \n    * 将nums 中的前k个元素添加到输出中，换而言之，除了“哨兵”之外的全部元素。\n      \n      \n    * 找到nums中的第一个满足 nums[j] + 1 != nums[j + 1]的元素，并将其加一nums[j]++ 以转到下一个组合。\n      \n      \n   \n   \n\n实现\n\nclass solution:\n    def combine(self, n: int, k: int) -> list[list[int]]:\n        # init first combination\n        nums = list(range(1, k + 1)) + [n + 1]\n        \n        output, j = [], 0\n        while j < k:\n            # add current combination\n            output.append(nums[:k])\n            # increase first nums[j] by one\n            # if nums[j] + 1 != nums[j + 1]\n            j = 0\n            while j < k and nums[j + 1] == nums[j] + 1:\n                nums[j] = j + 1\n                j += 1\n            nums[j] += 1\n            \n        return output\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\nclass solution {\n  public list<list<integer>> combine(int n, int k) {\n    // init first combination\n    linkedlist<integer> nums = new linkedlist<integer>();\n    for(int i = 1; i < k + 1; ++i)\n      nums.add(i);\n    nums.add(n + 1);\n\n    list<list<integer>> output = new arraylist<list<integer>>();\n    int j = 0;\n    while (j < k) {\n      // add current combination\n      output.add(new linkedlist(nums.sublist(0, k)));\n      // increase first nums[j] by one\n      // if nums[j] + 1 != nums[j + 1]\n      j = 0;\n      while ((j < k) && (nums.get(j + 1) == nums.get(j) + 1))\n        nums.set(j, j++ + 1);\n      nums.set(j, nums.get(j) + 1);\n    }\n    return output;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n复杂度分析\n\n * 时间复杂度 : o(kcnk)o(k c_n^k)o(kcnk​)，其中cnk=n!(n−k)!k!c_n^k = \\frac{n!}{(n - k)! k!}cnk​=(n−k)!k!n!​ 是要构建的组合数。由于组合数是cnkc_n^kcnk​，外层的 while 循环执行了cnkc_n^kcnk​次 。对给定的一个j，内层的 while 循环执行了cn−jk−jc_{n - j}^{k - j}cn−jk−j​次。外层循环超过 cnkc_n^kcnk​次访问，平均而言每次访问的执行次数少于1。因此，最耗费时间的部分是将每个长度为kkk 的组合(共计cnkc_n^kcnk​ 个组合) 添加到输出中， 消耗 o(kcnk)o(k c_n^k)o(kcnk​) 的时间。\n   \n   你可能注意到，尽管方法二的时间复杂度与方法一相同，但方法二却要快上许多。这是由于方法一需要处理递归调用栈，且其带来的影响在python中比在java中更为显著。\n   \n   \n * 空间复杂度 : o(cnk)o(c_n^k)o(cnk​) ，用于保存全部组合数以输出。\n   \n   \n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-07-22 20:41:47accepted [https://leetcode-cn.com//submissions/detail/4509723/]18 ms59.14%n/ajava2018-07-22 20:04:31accepted [https://leetcode-cn.com//submissions/detail/4508605/]26 ms54.65%n/ajava# 统计信息\n通过次数提交次数ac比率305954238572.2%# 相似题目\n题目难度组合总和 [https://leetcode-cn.com/problems/combination-sum/]中等全排列 [https://leetcode-cn.com/problems/permutations/]中等"},{title:"79-单词搜索(Word Search)",frontmatter:{title:"79-单词搜索(Word Search)",date:"2018-07-22T00:00:00.000Z",categories:["中等"],tags:["数组<Array>","回溯算法<Backtracking>"]},regularPath:"/views/%E4%B8%AD%E7%AD%89/0079-%E5%8D%95%E8%AF%8D%E6%90%9C%E7%B4%A2.html",relativePath:"views/中等/0079-单词搜索.md",key:"v-67f0bc42",path:"/views/%E4%B8%AD%E7%AD%89/0079-%E5%8D%95%E8%AF%8D%E6%90%9C%E7%B4%A2.html",headers:[{level:2,title:"中文题目",slug:"中文题目",charIndex:2},{level:2,title:"通过代码",slug:"通过代码",charIndex:276},{level:2,title:"高赞题解",slug:"高赞题解",charIndex:2355},{level:2,title:"提交历史",slug:"提交历史",charIndex:7218},{level:2,title:"统计信息",slug:"统计信息",charIndex:7346},{level:2,title:"相似题目",slug:"相似题目",charIndex:7380}],lastUpdated:"4/11/2021, 1:15:21 PM",headersStr:"中文题目 通过代码 高赞题解 提交历史 统计信息 相似题目",content:"# 中文题目\n给定一个二维网格和一个单词，找出该单词是否存在于网格中。\n\n单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。\n\n示例:\n\nboard =\n[\n  ['A','B','C','E'],\n  ['S','F','C','S'],\n  ['A','D','E','E']\n]\n\n给定 word = \"ABCCED\", 返回 true.\n给定 word = \"SEE\", 返回 true.\n给定 word = \"ABCB\", 返回 false.\n\n# 通过代码\nclass Solution {\n   //        设置一个辅助数组来确定下一次要转移的方向，四个元素分别代表下一次要走上、右、下、左\n        int[][] d={{-1,0},{0,1},{1,0},{0,-1}};\n        static int m; //board的行数\n        static int n; //board的列数\n        static boolean[][] visited; // 访问标记\n        public boolean searchWord(char[][] board,String word,int index,int startx,int starty){\n            if (index == word.length()-1){\n//                最后一个元素，直接判断是否相等\n                return board[startx][starty]==word.charAt(index);\n            }\n//            如果当前元素和要word要比较的元素相等，则继续\n            if (board[startx][starty]==word.charAt(index)){\n//                è®¾ç½®å½åä¸º访问标记ä¸ºtrue\n                visited[startx][starty]=true;\n//                从startx，starty出发，向四个方向寻找\n                for (int i = 0; i < 4; i++) {\n                    int newx=startx+d[i][0]; //新的行\n                    int newy=starty+d[i][1]; //行的列\n//                    检查新的位置是否在区域内并且没有被访问过\n                    if (inArea(newx,newy)&& !visited[newx][newy]){\n                        if (searchWord(board,word,index+1,newx,newy)) {\n//                            如果找到返回为true\n                            return true;\n                        }\n                    }\n                }\n//                æ¸ç©º访问标记\n                visited[startx][starty]=false;\n            }\n//            没找到，返回为false\n            return false;\n        }\n\n        private boolean inArea(int newx, int newy) {\n            return newx>=0 && newx<m && newy>=0 && newy<n;\n        }\n\n        public  boolean exist(char[][] board, String word) {\n            m=board.length;\n            n=board[0].length;\n            visited=new boolean[m][n];\n            for (int i = 0; i < board.length; i++) {\n                for (int j = 0; j < board[i].length; j++) {\n                    if (searchWord(board,word,0,i,j)) {\n                        return true;\n                    }\n                }\n            }\n            return false;\n        }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n# 高赞题解\n这是一个使用回溯算法解决的问题，涉及的知识点有 DFS 和状态重置。\n\n<,,,,,,,,,,,,>\n\n参考代码：\n\nfrom typing import List\n\n\nclass Solution:\n    #         (x-1,y)\n    # (x,y-1) (x,y) (x,y+1)\n    #         (x+1,y)\n\n    directions = [(0, -1), (-1, 0), (0, 1), (1, 0)]\n\n    def exist(self, board: List[List[str]], word: str) -> bool:\n        m = len(board)\n        if m == 0:\n            return False\n        n = len(board[0])\n\n        marked = [[False for _ in range(n)] for _ in range(m)]\n        for i in range(m):\n            for j in range(n):\n                # 对每一个格子都从头开始搜索\n                if self.__search_word(board, word, 0, i, j, marked, m, n):\n                    return True\n        return False\n\n    def __search_word(self, board, word, index,\n                      start_x, start_y, marked, m, n):\n        # 先写递归终止条件\n        if index == len(word) - 1:\n            return board[start_x][start_y] == word[index]\n\n        # 中间匹配了，再继续搜索\n        if board[start_x][start_y] == word[index]:\n            # 先占住这个位置，搜索不成功的话，要释放掉\n            marked[start_x][start_y] = True\n            for direction in self.directions:\n                new_x = start_x + direction[0]\n                new_y = start_y + direction[1]\n                # 注意：如果这一次 search word 成功的话，就返回\n                if 0 <= new_x < m and 0 <= new_y < n and \\\n                        not marked[new_x][new_y] and \\\n                        self.__search_word(board, word,\n                                           index + 1,\n                                           new_x, new_y,\n                                           marked, m, n):\n                    return True\n            marked[start_x][start_y] = False\n        return False\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\npublic class Solution {\n\n    private boolean[][] marked;\n\n    //        x-1,y\n    // x,y-1  x,y    x,y+1\n    //        x+1,y\n    private int[][] direction = {{-1, 0}, {0, -1}, {0, 1}, {1, 0}};\n    // 盘面上有多少行\n    private int m;\n    // 盘面上有多少列\n    private int n;\n    private String word;\n    private char[][] board;\n\n    public boolean exist(char[][] board, String word) {\n        m = board.length;\n        if (m == 0) {\n            return false;\n        }\n        n = board[0].length;\n        marked = new boolean[m][n];\n        this.word = word;\n        this.board = board;\n\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (dfs(i, j, 0)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    private boolean dfs(int i, int j, int start) {\n        if (start == word.length() - 1) {\n            return board[i][j] == word.charAt(start);\n        }\n        if (board[i][j] == word.charAt(start)) {\n            marked[i][j] = true;\n            for (int k = 0; k < 4; k++) {\n                int newX = i + direction[k][0];\n                int newY = j + direction[k][1];\n                if (inArea(newX, newY) && !marked[newX][newY]) {\n                    if (dfs(newX, newY, start + 1)) {\n                        return true;\n                    }\n                }\n            }\n            marked[i][j] = false;\n        }\n        return false;\n    }\n\n    private boolean inArea(int x, int y) {\n        return x >= 0 && x < m && y >= 0 && y < n;\n    }\n\n    public static void main(String[] args) {\n\n//        char[][] board =\n//                {\n//                        {'A', 'B', 'C', 'E'},\n//                        {'S', 'F', 'C', 'S'},\n//                        {'A', 'D', 'E', 'E'}\n//                };\n//\n//        String word = \"ABCCED\";\n\n\n        char[][] board = {{'a', 'b'}};\n        String word = \"ba\";\n        Solution solution = new Solution();\n        boolean exist = solution.exist(board, word);\n        System.out.println(exist);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n说明：\n\n1、偏移量数组在二维平面内是经常使用的，可以把它的设置当做一个技巧，并且在这个问题中，偏移量数组内的 4 个偏移的顺序无关紧要；\n\n说明：类似使用这个技巧的问题还有：「力扣」第 130 题：被围绕的区域 [https://leetcode-cn.com/problems/surrounded-regions/]、「力扣」第 200 题：岛屿数量 [https://leetcode-cn.com/problems/number-of-islands/]。\n\n2、对于这种搜索算法，我认为理解 DFS 和状态重置并不难，代码编写也相对固定，难在代码的编写和细节的处理，建议多次编写，自己多总结多思考，把自己遇到的坑记下。\n\n我自己在写\n\nfor i in range(m):\n    for j in range(n):\n        # 对每一个格子都从头开始搜索\n        if self.__search_word(board, word, 0, i, j, marked, m, n):\n            return True\n\n\n1\n2\n3\n4\n5\n这一段的时候，就傻乎乎地写成了：\n\n# 这一段代码是错误的，不要模仿\nfor i in range(m):\n    for j in range(n):\n        # 对每一个格子都从头开始搜索\n        return self.__search_word(board, word, 0, i, j, marked, m, n)\n\n\n1\n2\n3\n4\n5\n这样其实就变成只从坐标 (0,0) 开始搜索，搜索不到返回 False，但题目的意思是：只要你的搜索返回 True 才返回，如果全部的格子都搜索完了以后，都返回 False ，才返回 False。\n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-07-22 21:21:35Accepted [https://leetcode-cn.com//submissions/detail/4511302/]14 ms20.3%N/Ajava# 统计信息\n通过次数提交次数AC比率324718123440.0%# 相似题目\n题目难度单词搜索 II [https://leetcode-cn.com/problems/word-search-ii/]困难",contentLowercase:"# 中文题目\n给定一个二维网格和一个单词，找出该单词是否存在于网格中。\n\n单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。\n\n示例:\n\nboard =\n[\n  ['a','b','c','e'],\n  ['s','f','c','s'],\n  ['a','d','e','e']\n]\n\n给定 word = \"abcced\", 返回 true.\n给定 word = \"see\", 返回 true.\n给定 word = \"abcb\", 返回 false.\n\n# 通过代码\nclass solution {\n   //        设置一个辅助数组来确定下一次要转移的方向，四个元素分别代表下一次要走上、右、下、左\n        int[][] d={{-1,0},{0,1},{1,0},{0,-1}};\n        static int m; //board的行数\n        static int n; //board的列数\n        static boolean[][] visited; // 访问标记\n        public boolean searchword(char[][] board,string word,int index,int startx,int starty){\n            if (index == word.length()-1){\n//                最后一个元素，直接判断是否相等\n                return board[startx][starty]==word.charat(index);\n            }\n//            如果当前元素和要word要比较的元素相等，则继续\n            if (board[startx][starty]==word.charat(index)){\n//                è®¾ç½®å½åä¸º访问标记ä¸ºtrue\n                visited[startx][starty]=true;\n//                从startx，starty出发，向四个方向寻找\n                for (int i = 0; i < 4; i++) {\n                    int newx=startx+d[i][0]; //新的行\n                    int newy=starty+d[i][1]; //行的列\n//                    检查新的位置是否在区域内并且没有被访问过\n                    if (inarea(newx,newy)&& !visited[newx][newy]){\n                        if (searchword(board,word,index+1,newx,newy)) {\n//                            如果找到返回为true\n                            return true;\n                        }\n                    }\n                }\n//                æ¸ç©º访问标记\n                visited[startx][starty]=false;\n            }\n//            没找到，返回为false\n            return false;\n        }\n\n        private boolean inarea(int newx, int newy) {\n            return newx>=0 && newx<m && newy>=0 && newy<n;\n        }\n\n        public  boolean exist(char[][] board, string word) {\n            m=board.length;\n            n=board[0].length;\n            visited=new boolean[m][n];\n            for (int i = 0; i < board.length; i++) {\n                for (int j = 0; j < board[i].length; j++) {\n                    if (searchword(board,word,0,i,j)) {\n                        return true;\n                    }\n                }\n            }\n            return false;\n        }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n# 高赞题解\n这是一个使用回溯算法解决的问题，涉及的知识点有 dfs 和状态重置。\n\n<,,,,,,,,,,,,>\n\n参考代码：\n\nfrom typing import list\n\n\nclass solution:\n    #         (x-1,y)\n    # (x,y-1) (x,y) (x,y+1)\n    #         (x+1,y)\n\n    directions = [(0, -1), (-1, 0), (0, 1), (1, 0)]\n\n    def exist(self, board: list[list[str]], word: str) -> bool:\n        m = len(board)\n        if m == 0:\n            return false\n        n = len(board[0])\n\n        marked = [[false for _ in range(n)] for _ in range(m)]\n        for i in range(m):\n            for j in range(n):\n                # 对每一个格子都从头开始搜索\n                if self.__search_word(board, word, 0, i, j, marked, m, n):\n                    return true\n        return false\n\n    def __search_word(self, board, word, index,\n                      start_x, start_y, marked, m, n):\n        # 先写递归终止条件\n        if index == len(word) - 1:\n            return board[start_x][start_y] == word[index]\n\n        # 中间匹配了，再继续搜索\n        if board[start_x][start_y] == word[index]:\n            # 先占住这个位置，搜索不成功的话，要释放掉\n            marked[start_x][start_y] = true\n            for direction in self.directions:\n                new_x = start_x + direction[0]\n                new_y = start_y + direction[1]\n                # 注意：如果这一次 search word 成功的话，就返回\n                if 0 <= new_x < m and 0 <= new_y < n and \\\n                        not marked[new_x][new_y] and \\\n                        self.__search_word(board, word,\n                                           index + 1,\n                                           new_x, new_y,\n                                           marked, m, n):\n                    return true\n            marked[start_x][start_y] = false\n        return false\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\npublic class solution {\n\n    private boolean[][] marked;\n\n    //        x-1,y\n    // x,y-1  x,y    x,y+1\n    //        x+1,y\n    private int[][] direction = {{-1, 0}, {0, -1}, {0, 1}, {1, 0}};\n    // 盘面上有多少行\n    private int m;\n    // 盘面上有多少列\n    private int n;\n    private string word;\n    private char[][] board;\n\n    public boolean exist(char[][] board, string word) {\n        m = board.length;\n        if (m == 0) {\n            return false;\n        }\n        n = board[0].length;\n        marked = new boolean[m][n];\n        this.word = word;\n        this.board = board;\n\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (dfs(i, j, 0)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    private boolean dfs(int i, int j, int start) {\n        if (start == word.length() - 1) {\n            return board[i][j] == word.charat(start);\n        }\n        if (board[i][j] == word.charat(start)) {\n            marked[i][j] = true;\n            for (int k = 0; k < 4; k++) {\n                int newx = i + direction[k][0];\n                int newy = j + direction[k][1];\n                if (inarea(newx, newy) && !marked[newx][newy]) {\n                    if (dfs(newx, newy, start + 1)) {\n                        return true;\n                    }\n                }\n            }\n            marked[i][j] = false;\n        }\n        return false;\n    }\n\n    private boolean inarea(int x, int y) {\n        return x >= 0 && x < m && y >= 0 && y < n;\n    }\n\n    public static void main(string[] args) {\n\n//        char[][] board =\n//                {\n//                        {'a', 'b', 'c', 'e'},\n//                        {'s', 'f', 'c', 's'},\n//                        {'a', 'd', 'e', 'e'}\n//                };\n//\n//        string word = \"abcced\";\n\n\n        char[][] board = {{'a', 'b'}};\n        string word = \"ba\";\n        solution solution = new solution();\n        boolean exist = solution.exist(board, word);\n        system.out.println(exist);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n说明：\n\n1、偏移量数组在二维平面内是经常使用的，可以把它的设置当做一个技巧，并且在这个问题中，偏移量数组内的 4 个偏移的顺序无关紧要；\n\n说明：类似使用这个技巧的问题还有：「力扣」第 130 题：被围绕的区域 [https://leetcode-cn.com/problems/surrounded-regions/]、「力扣」第 200 题：岛屿数量 [https://leetcode-cn.com/problems/number-of-islands/]。\n\n2、对于这种搜索算法，我认为理解 dfs 和状态重置并不难，代码编写也相对固定，难在代码的编写和细节的处理，建议多次编写，自己多总结多思考，把自己遇到的坑记下。\n\n我自己在写\n\nfor i in range(m):\n    for j in range(n):\n        # 对每一个格子都从头开始搜索\n        if self.__search_word(board, word, 0, i, j, marked, m, n):\n            return true\n\n\n1\n2\n3\n4\n5\n这一段的时候，就傻乎乎地写成了：\n\n# 这一段代码是错误的，不要模仿\nfor i in range(m):\n    for j in range(n):\n        # 对每一个格子都从头开始搜索\n        return self.__search_word(board, word, 0, i, j, marked, m, n)\n\n\n1\n2\n3\n4\n5\n这样其实就变成只从坐标 (0,0) 开始搜索，搜索不到返回 false，但题目的意思是：只要你的搜索返回 true 才返回，如果全部的格子都搜索完了以后，都返回 false ，才返回 false。\n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-07-22 21:21:35accepted [https://leetcode-cn.com//submissions/detail/4511302/]14 ms20.3%n/ajava# 统计信息\n通过次数提交次数ac比率324718123440.0%# 相似题目\n题目难度单词搜索 ii [https://leetcode-cn.com/problems/word-search-ii/]困难"},{title:"80-删除排序数组中的重复项 II(Remove Duplicates from Sorted Array II)",frontmatter:{title:"80-删除排序数组中的重复项 II(Remove Duplicates from Sorted Array II)",date:"2018-07-27T00:00:00.000Z",categories:["中等"],tags:["数组<Array>","双指针<Two Pointers>"]},regularPath:"/views/%E4%B8%AD%E7%AD%89/0080-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9%20II.html",relativePath:"views/中等/0080-删除排序数组中的重复项 II.md",key:"v-69c9e716",path:"/views/%E4%B8%AD%E7%AD%89/0080-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9%20II.html",headers:[{level:2,title:"中文题目",slug:"中文题目",charIndex:2},{level:2,title:"通过代码",slug:"通过代码",charIndex:749},{level:2,title:"官方题解",slug:"官方题解",charIndex:1304},{level:2,title:"提交历史",slug:"提交历史",charIndex:8746},{level:2,title:"统计信息",slug:"统计信息",charIndex:8973},{level:2,title:"相似题目",slug:"相似题目",charIndex:9007}],lastUpdated:"4/11/2021, 1:15:21 PM",headersStr:"中文题目 通过代码 官方题解 提交历史 统计信息 相似题目",content:'# 中文题目\n给定一个排序数组，你需要在原地 [http://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95]删除重复出现的元素，使得每个元素最多出现两次，返回移除后数组的新长度。\n\n不要使用额外的数组空间，你必须在原地 [https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95]修改输入数组并在使用 O(1) 额外空间的条件下完成。\n\n示例 1:\n\n给定 nums = [1,1,1,2,2,3],\n\n函数应返回新长度 length = 5, 并且原数组的前五个元素被修改为 1, 1, 2, 2, 3 。\n\n你不需要考虑数组中超出新长度后面的元素。\n\n示例 2:\n\n给定 nums = [0,0,1,1,1,1,2,3,3],\n\n函数应返回新长度 length = 7, 并且原数组的前五个元素被修改为 0, 0, 1, 1, 2, 3, 3 。\n\n你不需要考虑数组中超出新长度后面的元素。\n\n\n说明:\n\n为什么返回数值是整数，但输出的答案是数组呢?\n\n请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。\n\n你可以想象内部操作如下:\n\n// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝\nint len = removeDuplicates(nums);\n\n// 在函数里修改输入数组对于调用者是可见的。\n// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。\nfor (int i = 0; i < len; i++) {\n    print(nums[i]);\n}\n\n# 通过代码\nclass Solution {\n    public int removeDuplicates(int[] nums) {\n        int i=0;\n            for (int n :nums) {\n                if (i < 2 ||n > nums[i-2] ){\n                    nums[i++]=n;\n                }\n            }\n            return i;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\nclass Solution {\n    public int removeDuplicates(int[] nums) {\n        int i=0;\n            for (int n :nums) {\n                if (i < 2 ||n > nums[i-2] ){\n                    nums[i++]=n;\n                }\n            }\n            return i;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n# 官方题解\n# 方法一：删除多余的重复项\n由于输入数组已经排序，所以重复项都显示在旁边。题目要求我们不使用额外的空间，在原地修改数组，而最简单的方法就是删除多余的重复项。对于数组中的每个数字，若出现 2 个以上的重复项，就将多余的重复项从数组列表中删除。\n\n算法：\n\n 1. 我们需要在遍历数组元素的同时删除多余的重复项，那么我们需要在删除多余重复项的同时更新数组的索引，否则将访问到无效的元素或跳过需要访问的元素。\n 2. 我们使用两个变量，i 是遍历数组的指针，count 是记录当前数字出现的次数。count 的最小计数始终为 1。\n 3. 我们从索引 1 开始一次处理一个数组元素。\n 4. 若当前元素与前一个元素相同，即 nums[i]==nums[i-1]，则增加计数 count++。若 count > 2，则说明遇到了多余的重复元素 ，要从数组中删除它。由于我们知道这个元素的索引，可以使用 del，pop 或 remove 操作（或你选择语言支持的任何相应的操作）从数组中删除它。由于删除了一个元素，所以我们的索引应该要减一。\n 5. 若当前元素与前一个元素不相同，即 nums[i] != nums[i - 1]，说明我们遇到了一个新元素，则更新 count = 1。\n 6. 由于我们从原始数组中删除了所有多余的重复项，所以最终在原数组只保留了有效元素，返回数组长度。\n\nclass Solution(object):\n    def removeDuplicates(self, nums):\n        """\n        :type nums: List[int]\n        :rtype: int\n        """\n        \n        # Initialize the counter and the array index.\n        i, count = 1, 1\n        \n        # Start from the second element of the array and process\n        # elements one by one.\n        while i < len(nums):\n            \n            # If the current element is a duplicate, \n            # increment the count.\n            if nums[i] == nums[i - 1]:\n                count += 1\n                \n                # If the count is more than 2, this is an\n                # unwanted duplicate element and hence we \n                # remove it from the array.\n                if count > 2:\n                    nums.pop(i)\n                    \n                    # Note that we have to decrement the\n                    # array index value to keep it consistent\n                    # with the size of the array.\n                    i-= 1\n                \n            else:\n                \n                # Reset the count since we encountered a different element\n                # than the previous one\n                count = 1\n           \n            # Move on to the next element in the array\n            i += 1    \n                \n        return len(nums)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\nclass Solution {\n    \n    public int[] remElement(int[] arr, int index) {\n        \n        //\n        // Overwrite the element at the given index by \n        // moving all the elements to the right of the\n        // index, one position to the left.\n        //\n        for (int i = index + 1; i < arr.length; i++) {\n            arr[i - 1] = arr[i];\n        }\n        \n        return arr;\n    }    \n    \n    public int removeDuplicates(int[] nums) {\n        \n        // Initialize the counter and the array index.\n        int i = 1, count = 1, length = nums.length;\n        \n        //\n        // Start from the second element of the array and process\n        // elements one by one.\n        //\n        while (i < length) {\n            \n            //\n            // If the current element is a duplicate, \n            // increment the count.\n            //\n            if (nums[i] == nums[i - 1]) {\n                \n                count++;\n                \n                //    \n                // If the count is more than 2, this is an unwanted duplicate element\n                // and hence we remove it from the array.\n                //    \n                if (count > 2) {\n                    \n                    this.remElement(nums, i);\n                    \n                    //\n                    // Note that we have to decrement the array index value to\n                    // keep it consistent with the size of the array.\n                    //    \n                    i--;\n                    \n                    //\n                    // Since we have a fixed size array and we can\'t actually\n                    // remove an element, we reduce the length of the array as\n                    // well.\n                    //\n                    length--;\n                }\n            } else {\n                \n                //\n                // Reset the count since we encountered a different element\n                // than the previous one.\n                //\n                count = 1;\n            }\n                \n            // Move on to the next element in the array\n            i++;\n        }\n            \n        return length;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n复杂度分析\n\n * 时间复杂度：让我们看看最耗时的操作是什么： * 我们必须遍历数组中的所有元素，若数组中有 N 个元素，则花费的时间为 O(N)O(N)O(N)。\n    * 删除多余的重复项，del 操作也是 O(N)O(N)O(N)。\n    * 最糟糕的情况是数组中的元素都相同，则我们需要执行 N−1N-1N−1 次的删除操作，则需要花费 O(N2)O(N^2)O(N2)。\n    * 总的复杂度：O(N)+O(N2)≡O(N2)O(N) + O(N^2) \\equiv O(N^2)O(N)+O(N2)≡O(N2)\n   \n   \n * 空间复杂度：O(1)O(1)O(1)，我们在原地修改数组。\n\n# 方法二：覆盖多余的重复项\n算法：\n\n 1. 我们使用了两个指针，i 是遍历指针，指向当前遍历的元素；j 指向下一个要覆盖元素的位置。\n 2. 同样，我们用 count 记录当前数字出现的次数。count 的最小计数始终为 1。\n 3. 我们从索引 1 开始一次处理一个数组元素。\n 4. 若当前元素与前一个元素相同，即 nums[i]==nums[i-1]，则 count++。若 count > 2，则说明遇到了多余的重复项。在这种情况下，我们只向前移动 i，而 j 不动。\n 5. 若 count <=2，则我们将 i 所指向的元素移动到 j 位置，并同时增加 i 和 j。\n 6. 若当前元素与前一个元素不相同，即 nums[i] != nums[i - 1]，说明遇到了新元素，则我们更新 count = 1，并且将该元素移动到 j 位置，并同时增加 i 和 j。\n 7. 当数组遍历完成，则返回 j。\n\nclass Solution(object):\n    def removeDuplicates(self, nums):\n        """\n        :type nums: List[int]\n        :rtype: int\n        """\n        \n        # Initialize the counter and the second pointer.\n        j, count = 1, 1\n        \n        # Start from the second element of the array and process\n        # elements one by one.\n        for i in range(1, len(nums)):\n            \n            # If the current element is a duplicate, \n            # increment the count.\n            if nums[i] == nums[i - 1]:\n                count += 1\n            else:\n                # Reset the count since we encountered a different element\n                # than the previous one\n                count = 1\n            \n            # For a count <= 2, we copy the element over thus\n            # overwriting the element at index "j" in the array\n            if count <= 2:\n                nums[j] = nums[i]\n                j += 1\n                \n        return j\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\nclass Solution {\n    \n    public int removeDuplicates(int[] nums) {\n        \n        //\n        // Initialize the counter and the second pointer.\n        //\n        int j = 1, count = 1;\n        \n        //\n        // Start from the second element of the array and process\n        // elements one by one.\n        //\n        for (int i = 1; i < nums.length; i++) {\n            \n            //\n            // If the current element is a duplicate, increment the count.\n            //\n            if (nums[i] == nums[i - 1]) {\n                \n                count++;\n                \n            } else {\n                \n                //\n                // Reset the count since we encountered a different element\n                // than the previous one.\n                //\n                count = 1;\n            }\n            \n            //\n            // For a count <= 2, we copy the element over thus\n            // overwriting the element at index "j" in the array\n            //\n            if (count <= 2) {\n                nums[j++] = nums[i];\n            }\n        }\n        return j;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n复杂度分析\n\n * 时间复杂度：O(N)O(N)O(N)，我们遍历每个数组元素一次。\n * 空间复杂度：O(1)O(1)O(1)。\n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-07-27 19:58:48Accepted [https://leetcode-cn.com//submissions/detail/4739599/]2 ms10.43%N/Ajava2018-05-13 23:00:41Accepted [https://leetcode-cn.com//submissions/detail/2233858/]2 ms10.43%N/Ajava# 统计信息\n通过次数提交次数AC比率292655427753.9%# 相似题目\n题目难度删除排序数组中的重复项 [https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/]简单',contentLowercase:'# 中文题目\n给定一个排序数组，你需要在原地 [http://baike.baidu.com/item/%e5%8e%9f%e5%9c%b0%e7%ae%97%e6%b3%95]删除重复出现的元素，使得每个元素最多出现两次，返回移除后数组的新长度。\n\n不要使用额外的数组空间，你必须在原地 [https://baike.baidu.com/item/%e5%8e%9f%e5%9c%b0%e7%ae%97%e6%b3%95]修改输入数组并在使用 o(1) 额外空间的条件下完成。\n\n示例 1:\n\n给定 nums = [1,1,1,2,2,3],\n\n函数应返回新长度 length = 5, 并且原数组的前五个元素被修改为 1, 1, 2, 2, 3 。\n\n你不需要考虑数组中超出新长度后面的元素。\n\n示例 2:\n\n给定 nums = [0,0,1,1,1,1,2,3,3],\n\n函数应返回新长度 length = 7, 并且原数组的前五个元素被修改为 0, 0, 1, 1, 2, 3, 3 。\n\n你不需要考虑数组中超出新长度后面的元素。\n\n\n说明:\n\n为什么返回数值是整数，但输出的答案是数组呢?\n\n请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。\n\n你可以想象内部操作如下:\n\n// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝\nint len = removeduplicates(nums);\n\n// 在函数里修改输入数组对于调用者是可见的。\n// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。\nfor (int i = 0; i < len; i++) {\n    print(nums[i]);\n}\n\n# 通过代码\nclass solution {\n    public int removeduplicates(int[] nums) {\n        int i=0;\n            for (int n :nums) {\n                if (i < 2 ||n > nums[i-2] ){\n                    nums[i++]=n;\n                }\n            }\n            return i;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\nclass solution {\n    public int removeduplicates(int[] nums) {\n        int i=0;\n            for (int n :nums) {\n                if (i < 2 ||n > nums[i-2] ){\n                    nums[i++]=n;\n                }\n            }\n            return i;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n# 官方题解\n# 方法一：删除多余的重复项\n由于输入数组已经排序，所以重复项都显示在旁边。题目要求我们不使用额外的空间，在原地修改数组，而最简单的方法就是删除多余的重复项。对于数组中的每个数字，若出现 2 个以上的重复项，就将多余的重复项从数组列表中删除。\n\n算法：\n\n 1. 我们需要在遍历数组元素的同时删除多余的重复项，那么我们需要在删除多余重复项的同时更新数组的索引，否则将访问到无效的元素或跳过需要访问的元素。\n 2. 我们使用两个变量，i 是遍历数组的指针，count 是记录当前数字出现的次数。count 的最小计数始终为 1。\n 3. 我们从索引 1 开始一次处理一个数组元素。\n 4. 若当前元素与前一个元素相同，即 nums[i]==nums[i-1]，则增加计数 count++。若 count > 2，则说明遇到了多余的重复元素 ，要从数组中删除它。由于我们知道这个元素的索引，可以使用 del，pop 或 remove 操作（或你选择语言支持的任何相应的操作）从数组中删除它。由于删除了一个元素，所以我们的索引应该要减一。\n 5. 若当前元素与前一个元素不相同，即 nums[i] != nums[i - 1]，说明我们遇到了一个新元素，则更新 count = 1。\n 6. 由于我们从原始数组中删除了所有多余的重复项，所以最终在原数组只保留了有效元素，返回数组长度。\n\nclass solution(object):\n    def removeduplicates(self, nums):\n        """\n        :type nums: list[int]\n        :rtype: int\n        """\n        \n        # initialize the counter and the array index.\n        i, count = 1, 1\n        \n        # start from the second element of the array and process\n        # elements one by one.\n        while i < len(nums):\n            \n            # if the current element is a duplicate, \n            # increment the count.\n            if nums[i] == nums[i - 1]:\n                count += 1\n                \n                # if the count is more than 2, this is an\n                # unwanted duplicate element and hence we \n                # remove it from the array.\n                if count > 2:\n                    nums.pop(i)\n                    \n                    # note that we have to decrement the\n                    # array index value to keep it consistent\n                    # with the size of the array.\n                    i-= 1\n                \n            else:\n                \n                # reset the count since we encountered a different element\n                # than the previous one\n                count = 1\n           \n            # move on to the next element in the array\n            i += 1    \n                \n        return len(nums)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\nclass solution {\n    \n    public int[] remelement(int[] arr, int index) {\n        \n        //\n        // overwrite the element at the given index by \n        // moving all the elements to the right of the\n        // index, one position to the left.\n        //\n        for (int i = index + 1; i < arr.length; i++) {\n            arr[i - 1] = arr[i];\n        }\n        \n        return arr;\n    }    \n    \n    public int removeduplicates(int[] nums) {\n        \n        // initialize the counter and the array index.\n        int i = 1, count = 1, length = nums.length;\n        \n        //\n        // start from the second element of the array and process\n        // elements one by one.\n        //\n        while (i < length) {\n            \n            //\n            // if the current element is a duplicate, \n            // increment the count.\n            //\n            if (nums[i] == nums[i - 1]) {\n                \n                count++;\n                \n                //    \n                // if the count is more than 2, this is an unwanted duplicate element\n                // and hence we remove it from the array.\n                //    \n                if (count > 2) {\n                    \n                    this.remelement(nums, i);\n                    \n                    //\n                    // note that we have to decrement the array index value to\n                    // keep it consistent with the size of the array.\n                    //    \n                    i--;\n                    \n                    //\n                    // since we have a fixed size array and we can\'t actually\n                    // remove an element, we reduce the length of the array as\n                    // well.\n                    //\n                    length--;\n                }\n            } else {\n                \n                //\n                // reset the count since we encountered a different element\n                // than the previous one.\n                //\n                count = 1;\n            }\n                \n            // move on to the next element in the array\n            i++;\n        }\n            \n        return length;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n复杂度分析\n\n * 时间复杂度：让我们看看最耗时的操作是什么： * 我们必须遍历数组中的所有元素，若数组中有 n 个元素，则花费的时间为 o(n)o(n)o(n)。\n    * 删除多余的重复项，del 操作也是 o(n)o(n)o(n)。\n    * 最糟糕的情况是数组中的元素都相同，则我们需要执行 n−1n-1n−1 次的删除操作，则需要花费 o(n2)o(n^2)o(n2)。\n    * 总的复杂度：o(n)+o(n2)≡o(n2)o(n) + o(n^2) \\equiv o(n^2)o(n)+o(n2)≡o(n2)\n   \n   \n * 空间复杂度：o(1)o(1)o(1)，我们在原地修改数组。\n\n# 方法二：覆盖多余的重复项\n算法：\n\n 1. 我们使用了两个指针，i 是遍历指针，指向当前遍历的元素；j 指向下一个要覆盖元素的位置。\n 2. 同样，我们用 count 记录当前数字出现的次数。count 的最小计数始终为 1。\n 3. 我们从索引 1 开始一次处理一个数组元素。\n 4. 若当前元素与前一个元素相同，即 nums[i]==nums[i-1]，则 count++。若 count > 2，则说明遇到了多余的重复项。在这种情况下，我们只向前移动 i，而 j 不动。\n 5. 若 count <=2，则我们将 i 所指向的元素移动到 j 位置，并同时增加 i 和 j。\n 6. 若当前元素与前一个元素不相同，即 nums[i] != nums[i - 1]，说明遇到了新元素，则我们更新 count = 1，并且将该元素移动到 j 位置，并同时增加 i 和 j。\n 7. 当数组遍历完成，则返回 j。\n\nclass solution(object):\n    def removeduplicates(self, nums):\n        """\n        :type nums: list[int]\n        :rtype: int\n        """\n        \n        # initialize the counter and the second pointer.\n        j, count = 1, 1\n        \n        # start from the second element of the array and process\n        # elements one by one.\n        for i in range(1, len(nums)):\n            \n            # if the current element is a duplicate, \n            # increment the count.\n            if nums[i] == nums[i - 1]:\n                count += 1\n            else:\n                # reset the count since we encountered a different element\n                # than the previous one\n                count = 1\n            \n            # for a count <= 2, we copy the element over thus\n            # overwriting the element at index "j" in the array\n            if count <= 2:\n                nums[j] = nums[i]\n                j += 1\n                \n        return j\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\nclass solution {\n    \n    public int removeduplicates(int[] nums) {\n        \n        //\n        // initialize the counter and the second pointer.\n        //\n        int j = 1, count = 1;\n        \n        //\n        // start from the second element of the array and process\n        // elements one by one.\n        //\n        for (int i = 1; i < nums.length; i++) {\n            \n            //\n            // if the current element is a duplicate, increment the count.\n            //\n            if (nums[i] == nums[i - 1]) {\n                \n                count++;\n                \n            } else {\n                \n                //\n                // reset the count since we encountered a different element\n                // than the previous one.\n                //\n                count = 1;\n            }\n            \n            //\n            // for a count <= 2, we copy the element over thus\n            // overwriting the element at index "j" in the array\n            //\n            if (count <= 2) {\n                nums[j++] = nums[i];\n            }\n        }\n        return j;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n复杂度分析\n\n * 时间复杂度：o(n)o(n)o(n)，我们遍历每个数组元素一次。\n * 空间复杂度：o(1)o(1)o(1)。\n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-07-27 19:58:48accepted [https://leetcode-cn.com//submissions/detail/4739599/]2 ms10.43%n/ajava2018-05-13 23:00:41accepted [https://leetcode-cn.com//submissions/detail/2233858/]2 ms10.43%n/ajava# 统计信息\n通过次数提交次数ac比率292655427753.9%# 相似题目\n题目难度删除排序数组中的重复项 [https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/]简单'},{title:"86-分隔链表(Partition List)",frontmatter:{title:"86-分隔链表(Partition List)",date:"2018-09-04T00:00:00.000Z",categories:["中等"],tags:["链表<Linked List>","双指针<Two Pointers>"]},regularPath:"/views/%E4%B8%AD%E7%AD%89/0086-%E5%88%86%E9%9A%94%E9%93%BE%E8%A1%A8.html",relativePath:"views/中等/0086-分隔链表.md",key:"v-09fa2471",path:"/views/%E4%B8%AD%E7%AD%89/0086-%E5%88%86%E9%9A%94%E9%93%BE%E8%A1%A8.html",headers:[{level:2,title:"中文题目",slug:"中文题目",charIndex:2},{level:2,title:"通过代码",slug:"通过代码",charIndex:149},{level:2,title:"官方题解",slug:"官方题解",charIndex:1031},{level:2,title:"提交历史",slug:"提交历史",charIndex:5126},{level:2,title:"统计信息",slug:"统计信息",charIndex:5460}],lastUpdated:"4/11/2021, 1:15:21 PM",headersStr:"中文题目 通过代码 官方题解 提交历史 统计信息",content:'# 中文题目\n给定一个链表和一个特定值 x，对链表进行分隔，使得所有小于 x 的节点都在大于或等于 x 的节点之前。\n\n你应当保留两个分区中每个节点的初始相对位置。\n\n示例:\n\n输入: head = 1->4->3->2->5->2, x = 3\n输出: 1->2->2->4->3->5\n\n\n# 通过代码\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public ListNode partition(ListNode head, int x) {\n            ListNode dummy1 = new ListNode(0), dummy2 = new ListNode(0);  //dummy heads of the 1st and 2nd queues\n    ListNode curr1 = dummy1, curr2 = dummy2;      //current tails of the two queues;\n    while (head!=null){\n        if (head.val<x) {\n            curr1.next = head;\n            curr1 = head;\n        }else {\n            curr2.next = head;\n            curr2 = head;\n        }\n        head = head.next;\n    }\n    curr2.next = null;          //important! avoid cycle in linked list. otherwise u will get TLE.\n    curr1.next = dummy2.next;\n    return dummy1.next;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n# 官方题解\n本题要求我们改变链表结构，使得值小于 x的元素，位于值大于等于x元素的前面。这实质上意味着在改变后的链表中有某个点，在该点之前的元素全部小于x ，该点之后的元素全部 大于等于x。 我们将这个点记为JOINT。\n\n{:width=700px} {:align="center"}\n\n对该问题的逆向工程告诉我们，如果我们在JOINT将改后链表拆分，我们会得到两个更小的链表，其中一个包括全部值小于x的元素，另一个包括全部值大于x的元素。\b在解法中，我们的主要目的是创建这两个链表，并将它们连接。\n\n# 双指针法：\n直觉\n\n我们可以用两个指针before 和 after 来追踪上述的两个链表。两个指针可以用于分别创建两个链表，然后将这两个链表连接即可获得所需的链表。\n\n算法\n\n 1. 初始化两个指针 before 和 after。在实现中，我们将两个指针初始化为哑 ListNode。这有助于减少条件判断。（不信的话，你可以试着写一个不带哑结点的方法自己看看！）\n\n{:width=400px} {:align="center"}\n\n 2. 利用head指针遍历原链表。\n 3. 若head 指针指向的元素值 小于 x，该节点应当是 before 链表的一部分。因此我们将其移到 before 中。\n\n{:width=700px} {:align="center"}\n\n 4. 否则，该节点应当是after 链表的一部分。因此我们将其移到 after 中。\n\n{:width=700px} {:align="center"}\n\n 5. 遍历完原有链表的全部元素之后，我们得到了两个链表 before 和 after。原有链表的元素或者在before 中或者在 after 中，这取决于它们的值。\n\n{:width=700px} {:align="center"}\n\n*`注意:` 由于我们从左到右遍历了原有链表，故两个链表中元素的相对顺序不会发生变化。另外值得注意的是，在图中我们完好地保留了原有链表。事实上，在算法实现中，我们将节点从原有链表中移除，并将它们添加到别的链表中。我们没有使用任何额外的空间，只是将原有的链表元素进行移动。*\n\n\n 6. 现在，可以将 before 和 after 连接，组成所求的链表。\n\n{:width=700px} {:align="center"}\n\n为了算法实现更容易，我们使用了哑结点初始化。不能让哑结点成为返回链表中的一部分，因此在组合两个链表时需要向前移动一个节点。\n\nclass Solution {\n    public ListNode partition(ListNode head, int x) {\n\n        // before and after are the two pointers used to create the two list\n        // before_head and after_head are used to save the heads of the two lists.\n        // All of these are initialized with the dummy nodes created.\n        ListNode before_head = new ListNode(0);\n        ListNode before = before_head;\n        ListNode after_head = new ListNode(0);\n        ListNode after = after_head;\n\n        while (head != null) {\n\n            // If the original list node is lesser than the given x,\n            // assign it to the before list.\n            if (head.val < x) {\n                before.next = head;\n                before = before.next;\n            } else {\n                // If the original list node is greater or equal to the given x,\n                // assign it to the after list.\n                after.next = head;\n                after = after.next;\n            }\n\n            // move ahead in the original list\n            head = head.next;\n        }\n\n        // Last node of "after" list would also be ending node of the reformed list\n        after.next = null;\n\n        // Once all the nodes are correctly assigned to the two lists,\n        // combine them to form a single list which would be returned.\n        before.next = after_head.next;\n\n        return before_head.next;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\nclass Solution(object):\n    def partition(self, head, x):\n        """\n        :type head: ListNode\n        :type x: int\n        :rtype: ListNode\n        """\n\n        # before and after are the two pointers used to create two list\n        # before_head and after_head are used to save the heads of the two lists.\n        # All of these are initialized with the dummy nodes created.\n        before = before_head = ListNode(0)\n        after = after_head = ListNode(0)\n\n        while head:\n            # If the original list node is lesser than the given x,\n            # assign it to the before list.\n            if head.val < x:\n                before.next = head\n                before = before.next\n            else:\n                # If the original list node is greater or equal to the given x,\n                # assign it to the after list.\n                after.next = head\n                after = after.next\n\n            # move ahead in the original list\n            head = head.next\n\n        # Last node of "after" list would also be ending node of the reformed list\n        after.next = None\n        # Once all the nodes are correctly assigned to the two lists,\n        # combine them to form a single list which would be returned.\n        before.next = after_head.next\n\n        return before_head.next\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n复杂度分析\n\n * 时间复杂度: O(N)O(N)O(N)，其中NNN是原链表的长度，我们对该链表进行了遍历。\n * 空间复杂度: O(1)O(1)O(1)，我们没有申请任何新空间。值得注意的是，我们只移动了原有的结点，因此没有使用任何额外空间。\n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-09-04 21:33:17Accepted [https://leetcode-cn.com//submissions/detail/6546836/]1 ms71.14%N/Ajava2018-09-04 21:28:46Runtime Error [https://leetcode-cn.com//submissions/detail/6546361/]N/AN/AN/Ajava2018-09-03 21:28:46Time Limit Exceeded [https://leetcode-cn.com//submissions/detail/6486461/]N/AN/AN/Ajava# 统计信息\n通过次数提交次数AC比率233304245255.0%',contentLowercase:'# 中文题目\n给定一个链表和一个特定值 x，对链表进行分隔，使得所有小于 x 的节点都在大于或等于 x 的节点之前。\n\n你应当保留两个分区中每个节点的初始相对位置。\n\n示例:\n\n输入: head = 1->4->3->2->5->2, x = 3\n输出: 1->2->2->4->3->5\n\n\n# 通过代码\n/**\n * definition for singly-linked list.\n * public class listnode {\n *     int val;\n *     listnode next;\n *     listnode(int x) { val = x; }\n * }\n */\nclass solution {\n    public listnode partition(listnode head, int x) {\n            listnode dummy1 = new listnode(0), dummy2 = new listnode(0);  //dummy heads of the 1st and 2nd queues\n    listnode curr1 = dummy1, curr2 = dummy2;      //current tails of the two queues;\n    while (head!=null){\n        if (head.val<x) {\n            curr1.next = head;\n            curr1 = head;\n        }else {\n            curr2.next = head;\n            curr2 = head;\n        }\n        head = head.next;\n    }\n    curr2.next = null;          //important! avoid cycle in linked list. otherwise u will get tle.\n    curr1.next = dummy2.next;\n    return dummy1.next;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n# 官方题解\n本题要求我们改变链表结构，使得值小于 x的元素，位于值大于等于x元素的前面。这实质上意味着在改变后的链表中有某个点，在该点之前的元素全部小于x ，该点之后的元素全部 大于等于x。 我们将这个点记为joint。\n\n{:width=700px} {:align="center"}\n\n对该问题的逆向工程告诉我们，如果我们在joint将改后链表拆分，我们会得到两个更小的链表，其中一个包括全部值小于x的元素，另一个包括全部值大于x的元素。\b在解法中，我们的主要目的是创建这两个链表，并将它们连接。\n\n# 双指针法：\n直觉\n\n我们可以用两个指针before 和 after 来追踪上述的两个链表。两个指针可以用于分别创建两个链表，然后将这两个链表连接即可获得所需的链表。\n\n算法\n\n 1. 初始化两个指针 before 和 after。在实现中，我们将两个指针初始化为哑 listnode。这有助于减少条件判断。（不信的话，你可以试着写一个不带哑结点的方法自己看看！）\n\n{:width=400px} {:align="center"}\n\n 2. 利用head指针遍历原链表。\n 3. 若head 指针指向的元素值 小于 x，该节点应当是 before 链表的一部分。因此我们将其移到 before 中。\n\n{:width=700px} {:align="center"}\n\n 4. 否则，该节点应当是after 链表的一部分。因此我们将其移到 after 中。\n\n{:width=700px} {:align="center"}\n\n 5. 遍历完原有链表的全部元素之后，我们得到了两个链表 before 和 after。原有链表的元素或者在before 中或者在 after 中，这取决于它们的值。\n\n{:width=700px} {:align="center"}\n\n*`注意:` 由于我们从左到右遍历了原有链表，故两个链表中元素的相对顺序不会发生变化。另外值得注意的是，在图中我们完好地保留了原有链表。事实上，在算法实现中，我们将节点从原有链表中移除，并将它们添加到别的链表中。我们没有使用任何额外的空间，只是将原有的链表元素进行移动。*\n\n\n 6. 现在，可以将 before 和 after 连接，组成所求的链表。\n\n{:width=700px} {:align="center"}\n\n为了算法实现更容易，我们使用了哑结点初始化。不能让哑结点成为返回链表中的一部分，因此在组合两个链表时需要向前移动一个节点。\n\nclass solution {\n    public listnode partition(listnode head, int x) {\n\n        // before and after are the two pointers used to create the two list\n        // before_head and after_head are used to save the heads of the two lists.\n        // all of these are initialized with the dummy nodes created.\n        listnode before_head = new listnode(0);\n        listnode before = before_head;\n        listnode after_head = new listnode(0);\n        listnode after = after_head;\n\n        while (head != null) {\n\n            // if the original list node is lesser than the given x,\n            // assign it to the before list.\n            if (head.val < x) {\n                before.next = head;\n                before = before.next;\n            } else {\n                // if the original list node is greater or equal to the given x,\n                // assign it to the after list.\n                after.next = head;\n                after = after.next;\n            }\n\n            // move ahead in the original list\n            head = head.next;\n        }\n\n        // last node of "after" list would also be ending node of the reformed list\n        after.next = null;\n\n        // once all the nodes are correctly assigned to the two lists,\n        // combine them to form a single list which would be returned.\n        before.next = after_head.next;\n\n        return before_head.next;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\nclass solution(object):\n    def partition(self, head, x):\n        """\n        :type head: listnode\n        :type x: int\n        :rtype: listnode\n        """\n\n        # before and after are the two pointers used to create two list\n        # before_head and after_head are used to save the heads of the two lists.\n        # all of these are initialized with the dummy nodes created.\n        before = before_head = listnode(0)\n        after = after_head = listnode(0)\n\n        while head:\n            # if the original list node is lesser than the given x,\n            # assign it to the before list.\n            if head.val < x:\n                before.next = head\n                before = before.next\n            else:\n                # if the original list node is greater or equal to the given x,\n                # assign it to the after list.\n                after.next = head\n                after = after.next\n\n            # move ahead in the original list\n            head = head.next\n\n        # last node of "after" list would also be ending node of the reformed list\n        after.next = none\n        # once all the nodes are correctly assigned to the two lists,\n        # combine them to form a single list which would be returned.\n        before.next = after_head.next\n\n        return before_head.next\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n复杂度分析\n\n * 时间复杂度: o(n)o(n)o(n)，其中nnn是原链表的长度，我们对该链表进行了遍历。\n * 空间复杂度: o(1)o(1)o(1)，我们没有申请任何新空间。值得注意的是，我们只移动了原有的结点，因此没有使用任何额外空间。\n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-09-04 21:33:17accepted [https://leetcode-cn.com//submissions/detail/6546836/]1 ms71.14%n/ajava2018-09-04 21:28:46runtime error [https://leetcode-cn.com//submissions/detail/6546361/]n/an/an/ajava2018-09-03 21:28:46time limit exceeded [https://leetcode-cn.com//submissions/detail/6486461/]n/an/an/ajava# 统计信息\n通过次数提交次数ac比率233304245255.0%'},{title:"50-Pow(x, n)(Pow(x, n))",frontmatter:{title:"50-Pow(x, n)(Pow(x, n))",date:"2021-04-22T00:00:00.000Z",categories:["中等"],tags:["数学<Math>","二分查找<Binary Search>"]},regularPath:"/views/%E4%B8%AD%E7%AD%89/0050-Pow(x,%20n).html",relativePath:"views/中等/0050-Pow(x, n).md",key:"v-a45a98cc",path:"/views/%E4%B8%AD%E7%AD%89/0050-Pow(x,%20n).html",headers:[{level:2,title:"中文题目",slug:"中文题目",charIndex:2},{level:2,title:"通过代码",slug:"通过代码",charIndex:302},{level:2,title:"高赞题解",slug:"高赞题解",charIndex:905},{level:3,title:"📺视频题解",slug:"📺视频题解",charIndex:912},{level:3,title:"📖文字题解",slug:"📖文字题解",charIndex:923},{level:2,title:"提交历史",slug:"提交历史",charIndex:7728},{level:2,title:"统计信息",slug:"统计信息",charIndex:7862},{level:2,title:"相似题目",slug:"相似题目",charIndex:7898}],headersStr:"中文题目 通过代码 高赞题解 📺视频题解 📖文字题解 提交历史 统计信息 相似题目",content:"# 中文题目\n实现pow(x, n) [https://www.cplusplus.com/reference/valarray/pow/]，即计算 x 的 n 次幂函数（即，xn）。\n\n\n\n示例 1：\n\n\n输入：x = 2.00000, n = 10\n输出：1024.00000\n\n\n示例 2：\n\n\n输入：x = 2.10000, n = 3\n输出：9.26100\n\n\n示例 3：\n\n\n输入：x = 2.00000, n = -2\n输出：0.25000\n解释：2-2 = 1/22 = 1/4 = 0.25\n\n\n\n\n提示：\n\n * -100.0 \n * -23131-1\n * -104 n 4\n\n# 通过代码\n    class Solution {\n        public double myPow(double x, int n) {\n            return n >= 0 ? quickMul(x, n) : 1.0 / quickMul(x, -n);\n        }\n\n        /**\n         * 快速幂\n         *\n         * @param x\n         * @param n\n         * @return\n         */\n        private double quickMul(double x, int n) {\n            //递归终止条件\n            if (n == 0)\n                return 1.0;\n            // 分支\n            double y = quickMul(x, n / 2);\n            // 判断奇数还是偶数，进行组装\n            return n % 2 == 0 ? y * y : y * y * x;\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n# 高赞题解\n# 📺视频题解\n\n\n# 📖文字题解\n# 前言\n本题的方法被称为「快速幂算法」，有递归和迭代两个版本。这篇题解会从递归版本的开始讲起，再逐步引出迭代的版本。\n\n当指数 nnn 为负数时，我们可以计算 x−nx^{-n}x−n 再取倒数得到结果，因此我们只需要考虑 nnn 为自然数的情况。\n\n# 方法一：快速幂 + 递归\n「快速幂算法」的本质是分治算法。举个例子，如果我们要计算 x64x^{64}x64，我们可以按照：\n\nx→x2→x4→x8→x16→x32→x64x \\to x^2 \\to x^4 \\to x^8 \\to x^{16} \\to x^{32} \\to x^{64}x→x2→x4→x8→x16→x32→x64\n\n的顺序，从 xxx 开始，每次直接把上一次的结果进行平方，计算 666 次就可以得到 x64x^{64}x64 的值，而不需要对 xxx 乘 636363 次 xxx。\n\n再举一个例子，如果我们要计算 x77x^{77}x77，我们可以按照：\n\nx→x2→x4→x9→x19→x38→x77x \\to x^2 \\to x^4 \\to x^9 \\to x^{19} \\to x^{38} \\to x^{77}x→x2→x4→x9→x19→x38→x77\n\n的顺序，在 x→x2x \\to x^2x→x2，x2→x4x^2 \\to x^4x2→x4，x19→x38x^{19} \\to x^{38}x19→x38 这些步骤中，我们直接把上一次的结果进行平方，而在 x4→x9x^4 \\to x^9x4→x9，x9→x19x^9 \\to x^{19}x9→x19，x38→x77x^{38} \\to x^{77}x38→x77 这些步骤中，我们把上一次的结果进行平方后，还要额外乘一个 xxx。\n\n直接从左到右进行推导看上去很困难，因为在每一步中，我们不知道在将上一次的结果平方之后，还需不需要额外乘 xxx。但如果我们从右往左看，分治的思想就十分明显了：\n\n * 当我们要计算 xnx^nxn 时，我们可以先递归地计算出 y=x⌊n/2⌋y = x^{\\lfloor n/2 \\rfloor}y=x⌊n/2⌋，其中 ⌊a⌋\\lfloor a \\rfloor⌊a⌋ 表示对 aaa 进行下取整；\n   \n   \n * 根据递归计算的结果，如果 nnn 为偶数，那么 xn=y2x^n = y^2xn=y2；如果 nnn 为奇数，那么 xn=y2×xx^n = y^2 \\times xxn=y2×x；\n   \n   \n * 递归的边界为 n=0n = 0n=0，任意数的 000 次方均为 111。\n   \n   \n\n由于每次递归都会使得指数减少一半，因此递归的层数为 O(log⁡n)O(\\log n)O(logn)，算法可以在很快的时间内得到结果。\n\nclass Solution {\npublic:\n    double quickMul(double x, long long N) {\n        if (N == 0) {\n            return 1.0;\n        }\n        double y = quickMul(x, N / 2);\n        return N % 2 == 0 ? y * y : y * y * x;\n    }\n\n    double myPow(double x, int n) {\n        long long N = n;\n        return N >= 0 ? quickMul(x, N) : 1.0 / quickMul(x, -N);\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\nclass Solution {\n    public double myPow(double x, int n) {\n        long N = n;\n        return N >= 0 ? quickMul(x, N) : 1.0 / quickMul(x, -N);\n    }\n\n    public double quickMul(double x, long N) {\n        if (N == 0) {\n            return 1.0;\n        }\n        double y = quickMul(x, N / 2);\n        return N % 2 == 0 ? y * y : y * y * x;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\nclass Solution:\n    def myPow(self, x: float, n: int) -> float:\n        def quickMul(N):\n            if N == 0:\n                return 1.0\n            y = quickMul(N // 2)\n            return y * y if N % 2 == 0 else y * y * x\n        \n        return quickMul(n) if n >= 0 else 1.0 / quickMul(-n)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\nfunc myPow(x float64, n int) float64 {\n    if n >= 0 {\n        return quickMul(x, n)\n    }\n    return 1.0 / quickMul(x, -n)\n}\n\nfunc quickMul(x float64, n int) float64 {\n    if n == 0 {\n        return 1\n    }\n    y := quickMul(x, n/2)\n    if n%2 == 0 {\n        return y * y\n    }\n    return y * y * x\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n复杂度分析\n\n * 时间复杂度：O(log⁡n)O(\\log n)O(logn)，即为递归的层数。\n   \n   \n * 空间复杂度：O(log⁡n)O(\\log n)O(logn)，即为递归的层数。这是由于递归的函数调用会使用栈空间。\n   \n   \n\n# 方法二：快速幂 + 迭代\n由于递归需要使用额外的栈空间，我们试着将递归转写为迭代。在方法一中，我们也提到过，从左到右进行推导是不容易的，因为我们不知道是否需要额外乘 xxx。但我们不妨找一找规律，看看哪些地方额外乘了 xxx，并且它们对答案产生了什么影响。\n\n我们还是以 x77x^{77}x77 作为例子：\n\nx→x2→x4→+x9→+x19→x38→+x77x \\to x^2 \\to x^4 \\to^+ x^9 \\to^+ x^{19} \\to x^{38} \\to^+ x^{77}x→x2→x4→+x9→+x19→x38→+x77\n\n并且把需要额外乘 xxx 的步骤打上了 +++ 标记。可以发现：\n\n * x38→+x77x^{38} \\to^+ x^{77}x38→+x77 中额外乘的 xxx 在 x77x^{77}x77 中贡献了 xxx；\n   \n   \n * x9→+x19x^9 \\to^+ x^{19}x9→+x19 中额外乘的 xxx 在之后被平方了 222 次，因此在 x77x^{77}x77 中贡献了 x22=x4x^{2^2} = x^4x22=x4；\n   \n   \n * x4→+x9x^4 \\to^+ x^9x4→+x9 中额外乘的 xxx 在之后被平方了 333 次，因此在 x77x^{77}x77 中贡献了 x23=x8x^{2^3} = x^8x23=x8；\n   \n   \n * 最初的 xxx 在之后被平方了 666 次，因此在 x77x^{77}x77 中贡献了 x26=x64x^{2^6} = x^{64}x26=x64。\n   \n   \n\n我们把这些贡献相乘，x×x4×x8×x64x \\times x^4 \\times x^8 \\times x^{64}x×x4×x8×x64 恰好等于 x77x^{77}x77。而这些贡献的指数部分又是什么呢？它们都是 222 的幂次，这是因为每个额外乘的 xxx 在之后都会被平方若干次。而这些指数 111，444，888 和 646464，恰好就对应了 777777 的二进制表示 (1001101)2(1001101)_2(1001101)2​ 中的每个 111！\n\n因此我们借助整数的二进制拆分，就可以得到迭代计算的方法，一般地，如果整数 nnn 的二进制拆分为\n\nn=2i0+2i1+⋯+2ikn = 2^{i_0} + 2^{i_1} + \\cdots + 2^{i_k}n=2i0​+2i1​+⋯+2ik​\n\n那么\n\nxn=x2i0×x2i1×⋯×x2ikx^n = x^{2^{i_0}} \\times x^{2^{i_1}} \\times \\cdots \\times x^{2^{i_k}}xn=x2i0​×x2i1​×⋯×x2ik​\n\n这样以来，我们从 xxx 开始不断地进行平方，得到 x2,x4,x8,x16,⋯x^2, x^4, x^8, x^{16}, \\cdotsx2,x4,x8,x16,⋯，如果 nnn 的第 kkk 个（从右往左，从 000 开始计数）二进制位为 111，那么我们就将对应的贡献 x2kx^{2^k}x2k计入答案。\n\n下面的代码给出了详细的注释。\n\nclass Solution {\npublic:\n    double quickMul(double x, long long N) {\n        double ans = 1.0;\n        // 贡献的初始值为 x\n        double x_contribute = x;\n        // 在对 N 进行二进制拆分的同时计算答案\n        while (N > 0) {\n            if (N % 2 == 1) {\n                // 如果 N 二进制表示的最低位为 1，那么需要计入贡献\n                ans *= x_contribute;\n            }\n            // 将贡献不断地平方\n            x_contribute *= x_contribute;\n            // 舍弃 N 二进制表示的最低位，这样我们每次只要判断最低位即可\n            N /= 2;\n        }\n        return ans;\n    }\n\n    double myPow(double x, int n) {\n        long long N = n;\n        return N >= 0 ? quickMul(x, N) : 1.0 / quickMul(x, -N);\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\nclass Solution {\n    public double myPow(double x, int n) {\n        long N = n;\n        return N >= 0 ? quickMul(x, N) : 1.0 / quickMul(x, -N);\n    }\n\n    public double quickMul(double x, long N) {\n        double ans = 1.0;\n        // 贡献的初始值为 x\n        double x_contribute = x;\n        // 在对 N 进行二进制拆分的同时计算答案\n        while (N > 0) {\n            if (N % 2 == 1) {\n                // 如果 N 二进制表示的最低位为 1，那么需要计入贡献\n                ans *= x_contribute;\n            }\n            // 将贡献不断地平方\n            x_contribute *= x_contribute;\n            // 舍弃 N 二进制表示的最低位，这样我们每次只要判断最低位即可\n            N /= 2;\n        }\n        return ans;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\nclass Solution:\n    def myPow(self, x: float, n: int) -> float:\n        def quickMul(N):\n            ans = 1.0\n            # 贡献的初始值为 x\n            x_contribute = x\n            # 在对 N 进行二进制拆分的同时计算答案\n            while N > 0:\n                if N % 2 == 1:\n                    # 如果 N 二进制表示的最低位为 1，那么需要计入贡献\n                    ans *= x_contribute\n                # 将贡献不断地平方\n                x_contribute *= x_contribute\n                # 舍弃 N 二进制表示的最低位，这样我们每次只要判断最低位即可\n                N //= 2\n            return ans\n        \n        return quickMul(n) if n >= 0 else 1.0 / quickMul(-n)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\nfunc myPow(x float64, n int) float64 {\n    if n >= 0 {\n        return quickMul(x, n)\n    }\n    return 1.0 / quickMul(x, -n)\n}\n\nfunc quickMul(x float64, N int) float64 {\n    ans := 1.0\n    // 贡献的初始值为 x\n    x_contribute := x\n    // 在对 N 进行二进制拆分的同时计算答案\n    for N > 0 {\n        if N % 2 == 1 {\n            // 如果 N 二进制表示的最低位为 1，那么需要计入贡献\n            ans *= x_contribute\n        }\n        // 将贡献不断地平方\n        x_contribute *= x_contribute\n        // 舍弃 N 二进制表示的最低位，这样我们每次只要判断最低位即可\n        N /= 2\n    }\n    return ans\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n复杂度分析\n\n * 时间复杂度：O(log⁡n)O(\\log n)O(logn)，即为对 nnn 进行二进制拆分的时间复杂度。\n   \n   \n * 空间复杂度：O(1)O(1)O(1)。\n   \n   \n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2021-04-22 22:13:37Accepted [https://leetcode-cn.com//submissions/detail/170935077/]1 ms100.0%37.2 MBjava# 统计信息\n通过次数提交次数AC比率17667547202037.4%# 相似题目\n题目难度x 的平方根 [https://leetcode-cn.com/problems/sqrtx/]简单超级次方 [https://leetcode-cn.com/problems/super-pow/]中等",contentLowercase:"# 中文题目\n实现pow(x, n) [https://www.cplusplus.com/reference/valarray/pow/]，即计算 x 的 n 次幂函数（即，xn）。\n\n\n\n示例 1：\n\n\n输入：x = 2.00000, n = 10\n输出：1024.00000\n\n\n示例 2：\n\n\n输入：x = 2.10000, n = 3\n输出：9.26100\n\n\n示例 3：\n\n\n输入：x = 2.00000, n = -2\n输出：0.25000\n解释：2-2 = 1/22 = 1/4 = 0.25\n\n\n\n\n提示：\n\n * -100.0 \n * -23131-1\n * -104 n 4\n\n# 通过代码\n    class solution {\n        public double mypow(double x, int n) {\n            return n >= 0 ? quickmul(x, n) : 1.0 / quickmul(x, -n);\n        }\n\n        /**\n         * 快速幂\n         *\n         * @param x\n         * @param n\n         * @return\n         */\n        private double quickmul(double x, int n) {\n            //递归终止条件\n            if (n == 0)\n                return 1.0;\n            // 分支\n            double y = quickmul(x, n / 2);\n            // 判断奇数还是偶数，进行组装\n            return n % 2 == 0 ? y * y : y * y * x;\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n# 高赞题解\n# 📺视频题解\n\n\n# 📖文字题解\n# 前言\n本题的方法被称为「快速幂算法」，有递归和迭代两个版本。这篇题解会从递归版本的开始讲起，再逐步引出迭代的版本。\n\n当指数 nnn 为负数时，我们可以计算 x−nx^{-n}x−n 再取倒数得到结果，因此我们只需要考虑 nnn 为自然数的情况。\n\n# 方法一：快速幂 + 递归\n「快速幂算法」的本质是分治算法。举个例子，如果我们要计算 x64x^{64}x64，我们可以按照：\n\nx→x2→x4→x8→x16→x32→x64x \\to x^2 \\to x^4 \\to x^8 \\to x^{16} \\to x^{32} \\to x^{64}x→x2→x4→x8→x16→x32→x64\n\n的顺序，从 xxx 开始，每次直接把上一次的结果进行平方，计算 666 次就可以得到 x64x^{64}x64 的值，而不需要对 xxx 乘 636363 次 xxx。\n\n再举一个例子，如果我们要计算 x77x^{77}x77，我们可以按照：\n\nx→x2→x4→x9→x19→x38→x77x \\to x^2 \\to x^4 \\to x^9 \\to x^{19} \\to x^{38} \\to x^{77}x→x2→x4→x9→x19→x38→x77\n\n的顺序，在 x→x2x \\to x^2x→x2，x2→x4x^2 \\to x^4x2→x4，x19→x38x^{19} \\to x^{38}x19→x38 这些步骤中，我们直接把上一次的结果进行平方，而在 x4→x9x^4 \\to x^9x4→x9，x9→x19x^9 \\to x^{19}x9→x19，x38→x77x^{38} \\to x^{77}x38→x77 这些步骤中，我们把上一次的结果进行平方后，还要额外乘一个 xxx。\n\n直接从左到右进行推导看上去很困难，因为在每一步中，我们不知道在将上一次的结果平方之后，还需不需要额外乘 xxx。但如果我们从右往左看，分治的思想就十分明显了：\n\n * 当我们要计算 xnx^nxn 时，我们可以先递归地计算出 y=x⌊n/2⌋y = x^{\\lfloor n/2 \\rfloor}y=x⌊n/2⌋，其中 ⌊a⌋\\lfloor a \\rfloor⌊a⌋ 表示对 aaa 进行下取整；\n   \n   \n * 根据递归计算的结果，如果 nnn 为偶数，那么 xn=y2x^n = y^2xn=y2；如果 nnn 为奇数，那么 xn=y2×xx^n = y^2 \\times xxn=y2×x；\n   \n   \n * 递归的边界为 n=0n = 0n=0，任意数的 000 次方均为 111。\n   \n   \n\n由于每次递归都会使得指数减少一半，因此递归的层数为 o(log⁡n)o(\\log n)o(logn)，算法可以在很快的时间内得到结果。\n\nclass solution {\npublic:\n    double quickmul(double x, long long n) {\n        if (n == 0) {\n            return 1.0;\n        }\n        double y = quickmul(x, n / 2);\n        return n % 2 == 0 ? y * y : y * y * x;\n    }\n\n    double mypow(double x, int n) {\n        long long n = n;\n        return n >= 0 ? quickmul(x, n) : 1.0 / quickmul(x, -n);\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\nclass solution {\n    public double mypow(double x, int n) {\n        long n = n;\n        return n >= 0 ? quickmul(x, n) : 1.0 / quickmul(x, -n);\n    }\n\n    public double quickmul(double x, long n) {\n        if (n == 0) {\n            return 1.0;\n        }\n        double y = quickmul(x, n / 2);\n        return n % 2 == 0 ? y * y : y * y * x;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\nclass solution:\n    def mypow(self, x: float, n: int) -> float:\n        def quickmul(n):\n            if n == 0:\n                return 1.0\n            y = quickmul(n // 2)\n            return y * y if n % 2 == 0 else y * y * x\n        \n        return quickmul(n) if n >= 0 else 1.0 / quickmul(-n)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\nfunc mypow(x float64, n int) float64 {\n    if n >= 0 {\n        return quickmul(x, n)\n    }\n    return 1.0 / quickmul(x, -n)\n}\n\nfunc quickmul(x float64, n int) float64 {\n    if n == 0 {\n        return 1\n    }\n    y := quickmul(x, n/2)\n    if n%2 == 0 {\n        return y * y\n    }\n    return y * y * x\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n复杂度分析\n\n * 时间复杂度：o(log⁡n)o(\\log n)o(logn)，即为递归的层数。\n   \n   \n * 空间复杂度：o(log⁡n)o(\\log n)o(logn)，即为递归的层数。这是由于递归的函数调用会使用栈空间。\n   \n   \n\n# 方法二：快速幂 + 迭代\n由于递归需要使用额外的栈空间，我们试着将递归转写为迭代。在方法一中，我们也提到过，从左到右进行推导是不容易的，因为我们不知道是否需要额外乘 xxx。但我们不妨找一找规律，看看哪些地方额外乘了 xxx，并且它们对答案产生了什么影响。\n\n我们还是以 x77x^{77}x77 作为例子：\n\nx→x2→x4→+x9→+x19→x38→+x77x \\to x^2 \\to x^4 \\to^+ x^9 \\to^+ x^{19} \\to x^{38} \\to^+ x^{77}x→x2→x4→+x9→+x19→x38→+x77\n\n并且把需要额外乘 xxx 的步骤打上了 +++ 标记。可以发现：\n\n * x38→+x77x^{38} \\to^+ x^{77}x38→+x77 中额外乘的 xxx 在 x77x^{77}x77 中贡献了 xxx；\n   \n   \n * x9→+x19x^9 \\to^+ x^{19}x9→+x19 中额外乘的 xxx 在之后被平方了 222 次，因此在 x77x^{77}x77 中贡献了 x22=x4x^{2^2} = x^4x22=x4；\n   \n   \n * x4→+x9x^4 \\to^+ x^9x4→+x9 中额外乘的 xxx 在之后被平方了 333 次，因此在 x77x^{77}x77 中贡献了 x23=x8x^{2^3} = x^8x23=x8；\n   \n   \n * 最初的 xxx 在之后被平方了 666 次，因此在 x77x^{77}x77 中贡献了 x26=x64x^{2^6} = x^{64}x26=x64。\n   \n   \n\n我们把这些贡献相乘，x×x4×x8×x64x \\times x^4 \\times x^8 \\times x^{64}x×x4×x8×x64 恰好等于 x77x^{77}x77。而这些贡献的指数部分又是什么呢？它们都是 222 的幂次，这是因为每个额外乘的 xxx 在之后都会被平方若干次。而这些指数 111，444，888 和 646464，恰好就对应了 777777 的二进制表示 (1001101)2(1001101)_2(1001101)2​ 中的每个 111！\n\n因此我们借助整数的二进制拆分，就可以得到迭代计算的方法，一般地，如果整数 nnn 的二进制拆分为\n\nn=2i0+2i1+⋯+2ikn = 2^{i_0} + 2^{i_1} + \\cdots + 2^{i_k}n=2i0​+2i1​+⋯+2ik​\n\n那么\n\nxn=x2i0×x2i1×⋯×x2ikx^n = x^{2^{i_0}} \\times x^{2^{i_1}} \\times \\cdots \\times x^{2^{i_k}}xn=x2i0​×x2i1​×⋯×x2ik​\n\n这样以来，我们从 xxx 开始不断地进行平方，得到 x2,x4,x8,x16,⋯x^2, x^4, x^8, x^{16}, \\cdotsx2,x4,x8,x16,⋯，如果 nnn 的第 kkk 个（从右往左，从 000 开始计数）二进制位为 111，那么我们就将对应的贡献 x2kx^{2^k}x2k计入答案。\n\n下面的代码给出了详细的注释。\n\nclass solution {\npublic:\n    double quickmul(double x, long long n) {\n        double ans = 1.0;\n        // 贡献的初始值为 x\n        double x_contribute = x;\n        // 在对 n 进行二进制拆分的同时计算答案\n        while (n > 0) {\n            if (n % 2 == 1) {\n                // 如果 n 二进制表示的最低位为 1，那么需要计入贡献\n                ans *= x_contribute;\n            }\n            // 将贡献不断地平方\n            x_contribute *= x_contribute;\n            // 舍弃 n 二进制表示的最低位，这样我们每次只要判断最低位即可\n            n /= 2;\n        }\n        return ans;\n    }\n\n    double mypow(double x, int n) {\n        long long n = n;\n        return n >= 0 ? quickmul(x, n) : 1.0 / quickmul(x, -n);\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\nclass solution {\n    public double mypow(double x, int n) {\n        long n = n;\n        return n >= 0 ? quickmul(x, n) : 1.0 / quickmul(x, -n);\n    }\n\n    public double quickmul(double x, long n) {\n        double ans = 1.0;\n        // 贡献的初始值为 x\n        double x_contribute = x;\n        // 在对 n 进行二进制拆分的同时计算答案\n        while (n > 0) {\n            if (n % 2 == 1) {\n                // 如果 n 二进制表示的最低位为 1，那么需要计入贡献\n                ans *= x_contribute;\n            }\n            // 将贡献不断地平方\n            x_contribute *= x_contribute;\n            // 舍弃 n 二进制表示的最低位，这样我们每次只要判断最低位即可\n            n /= 2;\n        }\n        return ans;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\nclass solution:\n    def mypow(self, x: float, n: int) -> float:\n        def quickmul(n):\n            ans = 1.0\n            # 贡献的初始值为 x\n            x_contribute = x\n            # 在对 n 进行二进制拆分的同时计算答案\n            while n > 0:\n                if n % 2 == 1:\n                    # 如果 n 二进制表示的最低位为 1，那么需要计入贡献\n                    ans *= x_contribute\n                # 将贡献不断地平方\n                x_contribute *= x_contribute\n                # 舍弃 n 二进制表示的最低位，这样我们每次只要判断最低位即可\n                n //= 2\n            return ans\n        \n        return quickmul(n) if n >= 0 else 1.0 / quickmul(-n)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\nfunc mypow(x float64, n int) float64 {\n    if n >= 0 {\n        return quickmul(x, n)\n    }\n    return 1.0 / quickmul(x, -n)\n}\n\nfunc quickmul(x float64, n int) float64 {\n    ans := 1.0\n    // 贡献的初始值为 x\n    x_contribute := x\n    // 在对 n 进行二进制拆分的同时计算答案\n    for n > 0 {\n        if n % 2 == 1 {\n            // 如果 n 二进制表示的最低位为 1，那么需要计入贡献\n            ans *= x_contribute\n        }\n        // 将贡献不断地平方\n        x_contribute *= x_contribute\n        // 舍弃 n 二进制表示的最低位，这样我们每次只要判断最低位即可\n        n /= 2\n    }\n    return ans\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n复杂度分析\n\n * 时间复杂度：o(log⁡n)o(\\log n)o(logn)，即为对 nnn 进行二进制拆分的时间复杂度。\n   \n   \n * 空间复杂度：o(1)o(1)o(1)。\n   \n   \n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2021-04-22 22:13:37accepted [https://leetcode-cn.com//submissions/detail/170935077/]1 ms100.0%37.2 mbjava# 统计信息\n通过次数提交次数ac比率17667547202037.4%# 相似题目\n题目难度x 的平方根 [https://leetcode-cn.com/problems/sqrtx/]简单超级次方 [https://leetcode-cn.com/problems/super-pow/]中等"},{title:"90-子集 II(Subsets II)",frontmatter:{title:"90-子集 II(Subsets II)",date:"2018-09-13T00:00:00.000Z",categories:["中等"],tags:["数组<Array>","回溯算法<Backtracking>"]},regularPath:"/views/%E4%B8%AD%E7%AD%89/0090-%E5%AD%90%E9%9B%86%20II.html",relativePath:"views/中等/0090-子集 II.md",key:"v-636b4c6e",path:"/views/%E4%B8%AD%E7%AD%89/0090-%E5%AD%90%E9%9B%86%20II.html",headers:[{level:2,title:"中文题目",slug:"中文题目",charIndex:2},{level:2,title:"通过代码",slug:"通过代码",charIndex:142},{level:2,title:"高赞题解",slug:"高赞题解",charIndex:1131},{level:2,title:"提交历史",slug:"提交历史",charIndex:7268},{level:2,title:"统计信息",slug:"统计信息",charIndex:7396},{level:2,title:"相似题目",slug:"相似题目",charIndex:7430}],lastUpdated:"4/11/2021, 1:15:21 PM",headersStr:"中文题目 通过代码 高赞题解 提交历史 统计信息 相似题目",content:"# 中文题目\n给定一个可能包含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。\n\n说明：解集不能包含重复的子集。\n\n示例:\n\n输入: [1,2,2]\n输出:\n[\n  [2],\n  [1],\n  [1,2,2],\n  [2,2],\n  [1,2],\n  []\n]\n\n# 通过代码\nclass Solution {\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\n            List<List<Integer>> res=new LinkedList<List<Integer>>();\n            LinkedList<Integer> list=new LinkedList<Integer>();\n            if (nums==null || nums.length==0){\n                return res;\n            }\n            Arrays.sort(nums);\n            subsetsWithDup(nums,res,list,0);\n            return res;\n        }\n\n        private void subsetsWithDup(int[] nums, List<List<Integer>> res, LinkedList<Integer> list, int start) {\n            res.add(new LinkedList<Integer>(list));\n            for (int j = start; j < nums.length; j++) {\n//                这里用i>start\n                if (j>start && nums[j]==nums[j-1]){\n                    continue;\n                }\n                list.addLast(nums[j]);\n                subsetsWithDup(nums,res,list,j+1);\n                list.removeLast();\n            }\n        }\n    \n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n# 高赞题解\n# 题目描述（中等难度）\n\n\n直接根据 78 题 [https://leetcode.wang/leetCode-78-Subsets.html] 的思路去做的，可以先去看一下。\n\n# 解法一 回溯法\n这个比较好改，我们只需要判断当前数字和上一个数字是否相同，相同的话跳过即可。当然，要把数字首先进行排序。\n\npublic List<List<Integer>> subsetsWithDup(int[] nums) {\n    List<List<Integer>> ans = new ArrayList<>();\n    Arrays.sort(nums); //排序\n    getAns(nums, 0, new ArrayList<>(), ans);\n    return ans;\n}\n\nprivate void getAns(int[] nums, int start, ArrayList<Integer> temp, List<List<Integer>> ans) {\n    ans.add(new ArrayList<>(temp));\n    for (int i = start; i < nums.length; i++) {\n        //和上个数字相等就跳过\n        if (i > start && nums[i] == nums[i - 1]) {\n            continue;\n        }\n        temp.add(nums[i]);\n        getAns(nums, i + 1, temp, ans);\n        temp.remove(temp.size() - 1);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n时间复杂度：\n\n空间复杂度：\n\n# 解法二 迭代法\n根据 78题 解法二修改。我们看一下如果直接按照 78 题的思路会出什么问题。之前的思路是，先考虑 0 个数字的所有子串，再考虑 1 个的所有子串，再考虑 2 个的所有子串。而求 n 个的所有子串，就是 【n - 1 的所有子串】和 【n - 1 的所有子串加上 n】。例如，\n\n数组 [ 1 2 3 ] \n[ ]的所有子串 [ ]\n[ 1 ] 个的所有子串 [ ] [ 1 ] \n[ 1 2 ] 个的所有子串 [ ] [ 1 ] [ 2 ][ 1 2 ]\n[ 1 2 3 ] 个的所有子串 [ ] [ 1 ] [ 2 ] [ 1 2 ] [ 3 ] [ 1 3 ] [ 2 3 ] [ 1 2 3 ] \n\n\n1\n2\n3\n4\n5\n但是如果有重复的数字，会出现什么问题呢\n\n数组 [ 1 2 2 ] \n[ ] 的所有子串 [ ]\n[ 1 ] 的所有子串 [ ] [ 1 ] \n[ 1 2 ] 的所有子串 [ ] [ 1 ] [ 2 ][ 1 2 ]\n[ 1 2 2 ] 的所有子串 [ ] [ 1 ] [ 2 ] [ 1 2 ] [ 2 ] [ 1 2 ] [ 2 2 ] [ 1 2 2 ] \n\n\n1\n2\n3\n4\n5\n我们发现出现了重复的数组，那么我们可不可以像解法一那样，遇到重复的就跳过这个数字呢？答案是否定的，如果最后一步 [ 1 2 2 ] 增加了 2 ，跳过后，最终答案会缺少 [ 2 2 ]、[ 1 2 2 ] 这两个解。我们仔细观察这两个解是怎么产生的。\n\n\n\n我们看到第 4 行黑色的部分，重复了，是怎么造成的呢？\n\n第 4 行新添加的 2 要加到第 3 行的所有解中，而第 3 行的一部分解是旧解，一部分是新解。可以看到，我们黑色部分是由第 3 行的旧解产生的，橙色部分是由新解产生的。\n\n而第 1 行到第 2 行，已经在旧解中加入了 2 产生了第 2 行的橙色部分，所以这里如果再在旧解中加 2 产生黑色部分就造成了重复。\n\n所以当有重复数字的时候，我们只考虑上一步的新解，算法中用一个指针保存每一步的新解开始的位置即可。\n\npublic List<List<Integer>> subsetsWithDup(int[] nums) {\n    List<List<Integer>> ans = new ArrayList<>();\n    ans.add(new ArrayList<>());// 初始化空数组\n    Arrays.sort(nums);\n    int start = 1; //保存新解的开始位置\n    for (int i = 0; i < nums.length; i++) {\n        List<List<Integer>> ans_tmp = new ArrayList<>();\n        // 遍历之前的所有结果\n        for (int j = 0; j < ans.size(); j++) {\n            List<Integer> list = ans.get(j);\n            //如果出现重复数字，就跳过所有旧解\n            if (i > 0 && nums[i] == nums[i - 1] && j < start) {\n                continue;\n            }\n            List<Integer> tmp = new ArrayList<>(list);\n            tmp.add(nums[i]); // 加入新增数字\n            ans_tmp.add(tmp);\n        }\n\n        start = ans.size(); //更新新解的开始位置\n        ans.addAll(ans_tmp);\n    }\n    return ans;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n时间复杂度：\n\n空间复杂度：O（1）。\n\n还有一种思路，参考这里 [https://leetcode.com/problems/subsets-ii/discuss/30168/C%2B%2B-solution-and-explanation]，当有重复数字出现的时候我们不再按照之前的思路走，而是单独考虑这种情况。\n\n当有 n 个重复数字出现，其实就是在出现重复数字之前的所有解中，分别加 1 个重复数字， 2 个重复数字，3 个重复数字 ... 什么意思呢，看一个例子。\n\n数组 [ 1 2 2 2 ] \n[ ]的所有子串 [ ]\n[ 1 ] 个的所有子串 [ ] [ 1 ] \n然后出现了重复数字 2，那么我们记录重复的次数。然后遍历之前每个解即可\n对于 [ ] 这个解，\n加 1 个 2，变成 [ 2 ] \n加 2 个 2，变成 [ 2 2 ]\n加 3 个 2，变成 [ 2 2 2 ]\n对于 [ 1 ] 这个解\n加 1 个 2，变成 [ 1 2 ] \n加 2 个 2，变成 [ 1 2 2 ]\n加 3 个 2，变成 [ 1 2 2 2 ]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n代码的话，就很好写了。\n\npublic List<List<Integer>> subsetsWithDup(int[] num) {\n    List<List<Integer>> result = new ArrayList<List<Integer>>();\n    List<Integer> empty = new ArrayList<Integer>();\n    result.add(empty);\n    Arrays.sort(num);\n\n    for (int i = 0; i < num.length; i++) {\n        int dupCount = 0;\n        //判断当前是否是重复数字，并且记录重复的次数\n        while( ((i+1) < num.length) && num[i+1] == num[i]) {\n            dupCount++;\n            i++;\n        }\n        int prevNum = result.size();\n        //遍历之前几个结果的每个解\n        for (int j = 0; j < prevNum; j++) {\n            List<Integer> element = new ArrayList<Integer>(result.get(j));\n            //每次在上次的结果中多加 1 个重复数字\n            for (int t = 0; t <= dupCount; t++) {\n                element.add(num[i]); //加入当前重复的数字\n                result.add(new ArrayList<Integer>(element));\n            }\n        }\n    }\n    return result;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n# 解法三 位操作\n本以为这个思路想不出来怎么去改了。\n\n回顾一下，这个题的思想就是每一个数字，考虑它的二进制表示。\n\n例如，nums = [ 1, 2 , 3 ]。用 1 代表在，0 代表不在。\n\n1 2 3\n0 0 0 -> [     ]\n0 0 1 -> [    3]\n0 1 0 -> [  2  ]   \n0 1 1 -> [  2 3]  \n1 0 0 -> [1    ]\n1 0 1 -> [1   3] \n1 1 0 -> [1 2  ]\n1 1 1 -> [1 2 3]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n但是如果有了重复数字，很明显就行不通了。例如对于 nums = [ 1 2 2 2 3 ]。\n\n1 2 2 2 3\n0 1 1 0 0  -> [  2 2  ]\n0 1 0 1 0  -> [  2 2  ]\n0 0 1 1 0  -> [  2 2  ]\n\n\n1\n2\n3\n4\n上边三个数产生的数组重复的了。三个中我们只取其中 1 个，取哪个呢？取从重复数字的开头连续的数字。什么意思呢？就是下边的情况是我们所保留的。\n\n2 2 2 2 2 \n1 0 0 0 0 -> [  2         ]\n1 1 0 0 0 -> [  2 2       ]\n1 1 1 0 0 -> [  2 2 2     ]\n1 1 1 1 0 -> [  2 2 2 2   ]\n1 1 1 1 1 -> [  2 2 2 2 2 ]  \n\n\n1\n2\n3\n4\n5\n6\n而对于 [ 2 2 ] 来说，除了 1 1 0 0 0 可以产生，下边的几种情况，都是产生的 [ 2 2 ]\n\n2 2 2 2 2 \n1 1 0 0 0 -> [  2 2       ]\n1 0 1 0 0 -> [  2 2       ]\n0 1 1 0 0 -> [  2 2       ]\n0 1 0 1 0 -> [  2 2       ]\n0 0 0 1 1 -> [  2 2       ]\n......\n\n\n1\n2\n3\n4\n5\n6\n7\n怎么把 1 1 0 0 0 和上边的那么多种情况区分开来呢？我们来看一下出现了重复数字，并且当前是 1 的前一个的二进位。\n\n对于 1 1 0 0 0 ，是 1。\n\n对于 1 0 1 0 0 , 是 0。\n\n对于 0 1 1 0 0 ，是 0。\n\n对于 0 1 0 1 0 ，是 0。\n\n对于 0 0 0 1 1 ，是 0。\n\n......\n\n可以看到只有第一种情况对应的是 1 ，其他情况都是 0。其实除去从开头是连续的 1 的话，就是两种情况。\n\n第一种就是，占据了开头，类似于这种 10...1....\n\n第二种就是，没有占据开头，类似于这种 0...1...\n\n这两种情况，除了第一位，其他位的 1 的前边一定是 0。所以的话，我们的条件是看出现了重复数字，并且当前位是 1 的前一个的二进位。\n\n所以可以改代码了。\n\npublic List<List<Integer>> subsetsWithDup(int[] num) {\n    Arrays.sort(num);\n    List<List<Integer>> lists = new ArrayList<>();\n    int subsetNum = 1<<num.length;\n    for(int i=0;i<subsetNum;i++){\n        List<Integer> list = new ArrayList<>();\n        boolean illegal=false;\n        for(int j=0;j<num.length;j++){\n            //当前位是 1\n            if((i>>j&1)==1){\n                //当前是重复数字，并且前一位是 0，跳过这种情况\n                if(j>0&&num[j]==num[j-1]&&(i>>(j-1)&1)==0){\n                    illegal=true;\n                    break;\n                }else{\n                    list.add(num[j]);\n                }\n            }\n        }\n        if(!illegal){\n            lists.add(list); \n        }\n\n    }\n    return lists;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n# 总\n解法一和解法二怎么改，分析一下比较容易想到。解法三就比较难了，突破口就是选一个特殊的结构做代表，和其他情况区分出来。而从头开始的连续 1 可能就会是我们第一个想到的数，然后分析一下，发现果然可以和其他所有情况区分开来。\n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-09-13 17:54:20Accepted [https://leetcode-cn.com//submissions/detail/7042092/]4 ms21.95%N/Ajava# 统计信息\n通过次数提交次数AC比率196083359358.4%# 相似题目\n题目难度子集 [https://leetcode-cn.com/problems/subsets/]中等",contentLowercase:"# 中文题目\n给定一个可能包含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。\n\n说明：解集不能包含重复的子集。\n\n示例:\n\n输入: [1,2,2]\n输出:\n[\n  [2],\n  [1],\n  [1,2,2],\n  [2,2],\n  [1,2],\n  []\n]\n\n# 通过代码\nclass solution {\n    public list<list<integer>> subsetswithdup(int[] nums) {\n            list<list<integer>> res=new linkedlist<list<integer>>();\n            linkedlist<integer> list=new linkedlist<integer>();\n            if (nums==null || nums.length==0){\n                return res;\n            }\n            arrays.sort(nums);\n            subsetswithdup(nums,res,list,0);\n            return res;\n        }\n\n        private void subsetswithdup(int[] nums, list<list<integer>> res, linkedlist<integer> list, int start) {\n            res.add(new linkedlist<integer>(list));\n            for (int j = start; j < nums.length; j++) {\n//                这里用i>start\n                if (j>start && nums[j]==nums[j-1]){\n                    continue;\n                }\n                list.addlast(nums[j]);\n                subsetswithdup(nums,res,list,j+1);\n                list.removelast();\n            }\n        }\n    \n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n# 高赞题解\n# 题目描述（中等难度）\n\n\n直接根据 78 题 [https://leetcode.wang/leetcode-78-subsets.html] 的思路去做的，可以先去看一下。\n\n# 解法一 回溯法\n这个比较好改，我们只需要判断当前数字和上一个数字是否相同，相同的话跳过即可。当然，要把数字首先进行排序。\n\npublic list<list<integer>> subsetswithdup(int[] nums) {\n    list<list<integer>> ans = new arraylist<>();\n    arrays.sort(nums); //排序\n    getans(nums, 0, new arraylist<>(), ans);\n    return ans;\n}\n\nprivate void getans(int[] nums, int start, arraylist<integer> temp, list<list<integer>> ans) {\n    ans.add(new arraylist<>(temp));\n    for (int i = start; i < nums.length; i++) {\n        //和上个数字相等就跳过\n        if (i > start && nums[i] == nums[i - 1]) {\n            continue;\n        }\n        temp.add(nums[i]);\n        getans(nums, i + 1, temp, ans);\n        temp.remove(temp.size() - 1);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n时间复杂度：\n\n空间复杂度：\n\n# 解法二 迭代法\n根据 78题 解法二修改。我们看一下如果直接按照 78 题的思路会出什么问题。之前的思路是，先考虑 0 个数字的所有子串，再考虑 1 个的所有子串，再考虑 2 个的所有子串。而求 n 个的所有子串，就是 【n - 1 的所有子串】和 【n - 1 的所有子串加上 n】。例如，\n\n数组 [ 1 2 3 ] \n[ ]的所有子串 [ ]\n[ 1 ] 个的所有子串 [ ] [ 1 ] \n[ 1 2 ] 个的所有子串 [ ] [ 1 ] [ 2 ][ 1 2 ]\n[ 1 2 3 ] 个的所有子串 [ ] [ 1 ] [ 2 ] [ 1 2 ] [ 3 ] [ 1 3 ] [ 2 3 ] [ 1 2 3 ] \n\n\n1\n2\n3\n4\n5\n但是如果有重复的数字，会出现什么问题呢\n\n数组 [ 1 2 2 ] \n[ ] 的所有子串 [ ]\n[ 1 ] 的所有子串 [ ] [ 1 ] \n[ 1 2 ] 的所有子串 [ ] [ 1 ] [ 2 ][ 1 2 ]\n[ 1 2 2 ] 的所有子串 [ ] [ 1 ] [ 2 ] [ 1 2 ] [ 2 ] [ 1 2 ] [ 2 2 ] [ 1 2 2 ] \n\n\n1\n2\n3\n4\n5\n我们发现出现了重复的数组，那么我们可不可以像解法一那样，遇到重复的就跳过这个数字呢？答案是否定的，如果最后一步 [ 1 2 2 ] 增加了 2 ，跳过后，最终答案会缺少 [ 2 2 ]、[ 1 2 2 ] 这两个解。我们仔细观察这两个解是怎么产生的。\n\n\n\n我们看到第 4 行黑色的部分，重复了，是怎么造成的呢？\n\n第 4 行新添加的 2 要加到第 3 行的所有解中，而第 3 行的一部分解是旧解，一部分是新解。可以看到，我们黑色部分是由第 3 行的旧解产生的，橙色部分是由新解产生的。\n\n而第 1 行到第 2 行，已经在旧解中加入了 2 产生了第 2 行的橙色部分，所以这里如果再在旧解中加 2 产生黑色部分就造成了重复。\n\n所以当有重复数字的时候，我们只考虑上一步的新解，算法中用一个指针保存每一步的新解开始的位置即可。\n\npublic list<list<integer>> subsetswithdup(int[] nums) {\n    list<list<integer>> ans = new arraylist<>();\n    ans.add(new arraylist<>());// 初始化空数组\n    arrays.sort(nums);\n    int start = 1; //保存新解的开始位置\n    for (int i = 0; i < nums.length; i++) {\n        list<list<integer>> ans_tmp = new arraylist<>();\n        // 遍历之前的所有结果\n        for (int j = 0; j < ans.size(); j++) {\n            list<integer> list = ans.get(j);\n            //如果出现重复数字，就跳过所有旧解\n            if (i > 0 && nums[i] == nums[i - 1] && j < start) {\n                continue;\n            }\n            list<integer> tmp = new arraylist<>(list);\n            tmp.add(nums[i]); // 加入新增数字\n            ans_tmp.add(tmp);\n        }\n\n        start = ans.size(); //更新新解的开始位置\n        ans.addall(ans_tmp);\n    }\n    return ans;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n时间复杂度：\n\n空间复杂度：o（1）。\n\n还有一种思路，参考这里 [https://leetcode.com/problems/subsets-ii/discuss/30168/c%2b%2b-solution-and-explanation]，当有重复数字出现的时候我们不再按照之前的思路走，而是单独考虑这种情况。\n\n当有 n 个重复数字出现，其实就是在出现重复数字之前的所有解中，分别加 1 个重复数字， 2 个重复数字，3 个重复数字 ... 什么意思呢，看一个例子。\n\n数组 [ 1 2 2 2 ] \n[ ]的所有子串 [ ]\n[ 1 ] 个的所有子串 [ ] [ 1 ] \n然后出现了重复数字 2，那么我们记录重复的次数。然后遍历之前每个解即可\n对于 [ ] 这个解，\n加 1 个 2，变成 [ 2 ] \n加 2 个 2，变成 [ 2 2 ]\n加 3 个 2，变成 [ 2 2 2 ]\n对于 [ 1 ] 这个解\n加 1 个 2，变成 [ 1 2 ] \n加 2 个 2，变成 [ 1 2 2 ]\n加 3 个 2，变成 [ 1 2 2 2 ]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n代码的话，就很好写了。\n\npublic list<list<integer>> subsetswithdup(int[] num) {\n    list<list<integer>> result = new arraylist<list<integer>>();\n    list<integer> empty = new arraylist<integer>();\n    result.add(empty);\n    arrays.sort(num);\n\n    for (int i = 0; i < num.length; i++) {\n        int dupcount = 0;\n        //判断当前是否是重复数字，并且记录重复的次数\n        while( ((i+1) < num.length) && num[i+1] == num[i]) {\n            dupcount++;\n            i++;\n        }\n        int prevnum = result.size();\n        //遍历之前几个结果的每个解\n        for (int j = 0; j < prevnum; j++) {\n            list<integer> element = new arraylist<integer>(result.get(j));\n            //每次在上次的结果中多加 1 个重复数字\n            for (int t = 0; t <= dupcount; t++) {\n                element.add(num[i]); //加入当前重复的数字\n                result.add(new arraylist<integer>(element));\n            }\n        }\n    }\n    return result;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n# 解法三 位操作\n本以为这个思路想不出来怎么去改了。\n\n回顾一下，这个题的思想就是每一个数字，考虑它的二进制表示。\n\n例如，nums = [ 1, 2 , 3 ]。用 1 代表在，0 代表不在。\n\n1 2 3\n0 0 0 -> [     ]\n0 0 1 -> [    3]\n0 1 0 -> [  2  ]   \n0 1 1 -> [  2 3]  \n1 0 0 -> [1    ]\n1 0 1 -> [1   3] \n1 1 0 -> [1 2  ]\n1 1 1 -> [1 2 3]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n但是如果有了重复数字，很明显就行不通了。例如对于 nums = [ 1 2 2 2 3 ]。\n\n1 2 2 2 3\n0 1 1 0 0  -> [  2 2  ]\n0 1 0 1 0  -> [  2 2  ]\n0 0 1 1 0  -> [  2 2  ]\n\n\n1\n2\n3\n4\n上边三个数产生的数组重复的了。三个中我们只取其中 1 个，取哪个呢？取从重复数字的开头连续的数字。什么意思呢？就是下边的情况是我们所保留的。\n\n2 2 2 2 2 \n1 0 0 0 0 -> [  2         ]\n1 1 0 0 0 -> [  2 2       ]\n1 1 1 0 0 -> [  2 2 2     ]\n1 1 1 1 0 -> [  2 2 2 2   ]\n1 1 1 1 1 -> [  2 2 2 2 2 ]  \n\n\n1\n2\n3\n4\n5\n6\n而对于 [ 2 2 ] 来说，除了 1 1 0 0 0 可以产生，下边的几种情况，都是产生的 [ 2 2 ]\n\n2 2 2 2 2 \n1 1 0 0 0 -> [  2 2       ]\n1 0 1 0 0 -> [  2 2       ]\n0 1 1 0 0 -> [  2 2       ]\n0 1 0 1 0 -> [  2 2       ]\n0 0 0 1 1 -> [  2 2       ]\n......\n\n\n1\n2\n3\n4\n5\n6\n7\n怎么把 1 1 0 0 0 和上边的那么多种情况区分开来呢？我们来看一下出现了重复数字，并且当前是 1 的前一个的二进位。\n\n对于 1 1 0 0 0 ，是 1。\n\n对于 1 0 1 0 0 , 是 0。\n\n对于 0 1 1 0 0 ，是 0。\n\n对于 0 1 0 1 0 ，是 0。\n\n对于 0 0 0 1 1 ，是 0。\n\n......\n\n可以看到只有第一种情况对应的是 1 ，其他情况都是 0。其实除去从开头是连续的 1 的话，就是两种情况。\n\n第一种就是，占据了开头，类似于这种 10...1....\n\n第二种就是，没有占据开头，类似于这种 0...1...\n\n这两种情况，除了第一位，其他位的 1 的前边一定是 0。所以的话，我们的条件是看出现了重复数字，并且当前位是 1 的前一个的二进位。\n\n所以可以改代码了。\n\npublic list<list<integer>> subsetswithdup(int[] num) {\n    arrays.sort(num);\n    list<list<integer>> lists = new arraylist<>();\n    int subsetnum = 1<<num.length;\n    for(int i=0;i<subsetnum;i++){\n        list<integer> list = new arraylist<>();\n        boolean illegal=false;\n        for(int j=0;j<num.length;j++){\n            //当前位是 1\n            if((i>>j&1)==1){\n                //当前是重复数字，并且前一位是 0，跳过这种情况\n                if(j>0&&num[j]==num[j-1]&&(i>>(j-1)&1)==0){\n                    illegal=true;\n                    break;\n                }else{\n                    list.add(num[j]);\n                }\n            }\n        }\n        if(!illegal){\n            lists.add(list); \n        }\n\n    }\n    return lists;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n# 总\n解法一和解法二怎么改，分析一下比较容易想到。解法三就比较难了，突破口就是选一个特殊的结构做代表，和其他情况区分出来。而从头开始的连续 1 可能就会是我们第一个想到的数，然后分析一下，发现果然可以和其他所有情况区分开来。\n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-09-13 17:54:20accepted [https://leetcode-cn.com//submissions/detail/7042092/]4 ms21.95%n/ajava# 统计信息\n通过次数提交次数ac比率196083359358.4%# 相似题目\n题目难度子集 [https://leetcode-cn.com/problems/subsets/]中等"},{title:"94-二叉树的中序遍历(Binary Tree Inorder Traversal)",frontmatter:{title:"94-二叉树的中序遍历(Binary Tree Inorder Traversal)",date:"2021-04-19T00:00:00.000Z",categories:["中等"],tags:["栈<Stack>","树<Tree>","哈希表<Hash Table>"]},regularPath:"/views/%E4%B8%AD%E7%AD%89/0094-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86.html",relativePath:"views/中等/0094-二叉树的中序遍历.md",key:"v-4cbecd9d",path:"/views/%E4%B8%AD%E7%AD%89/0094-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86.html",headers:[{level:2,title:"中文题目",slug:"中文题目",charIndex:2},{level:2,title:"通过代码",slug:"通过代码",charIndex:289},{level:2,title:"高赞题解",slug:"高赞题解",charIndex:7504},{level:2,title:"提交历史",slug:"提交历史",charIndex:8501},{level:2,title:"统计信息",slug:"统计信息",charIndex:9136},{level:2,title:"相似题目",slug:"相似题目",charIndex:9172}],lastUpdated:"4/11/2021, 1:15:21 PM",headersStr:"中文题目 通过代码 高赞题解 提交历史 统计信息 相似题目",content:'# 中文题目\n给定一个二叉树的根节点 root ，返回它的 中序遍历。\n\n\n\n示例 1：\n\n\n输入：root = [1,null,2,3]\n输出：[1,3,2]\n\n\n示例 2：\n\n\n输入：root = []\n输出：[]\n\n\n示例 3：\n\n\n输入：root = [1]\n输出：[1]\n\n\n示例 4：\n\n\n输入：root = [1,2]\n输出：[2,1]\n\n\n示例 5：\n\n\n输入：root = [1,null,2]\n输出：[1,2]\n\n\n\n\n提示：\n\n * 树中节点数目在范围 [0, 100] 内\n * -100 \n\n\n\n进阶:递归算法很简单，你可以通过迭代算法完成吗？\n\n# 通过代码\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n        public List<Integer> inorderTraversal(TreeNode root) {\n            List<Integer> result=new ArrayList<>();\n            Stack<TreeNode> stack=new Stack<>();\n            while (root!=null||!stack.isEmpty()){\n                while (root != null){\n                    // 一直向左找\n                    stack.push(root);\n                    root=root.left;\n                }\n                // 找到最左边的\n                root=stack.pop();\n                result.add(root.val);\n                // 换成右边的\n                root=root.right;\n            }\n            return result;\n        }\n\n    }\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n        public List<Integer> inorderTraversal(TreeNode root) {\n            List<Integer> result=new ArrayList<>();\n            inOrder(root,result);\n            return result;\n        }\n\n        public void inOrder(TreeNode root,List<Integer> result){\n            if (root!=null){\n                inOrder(root.left,result);\n                result.add(root.val);\n                inOrder(root.right,result);\n            }\n        }\n    }\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\nclass Solution{\n     class Command{\n            String s;\n            TreeNode node;\n\n            public Command(String s, TreeNode node) {\n                this.s = s;\n                this.node = node;\n            }\n        }\n        public  List<Integer> inorderTraversal(TreeNode root) {\n            LinkedList<Integer> linkedList=new LinkedList<>();\n            if (root==null){\n                return linkedList;\n            }\n//            模拟系统栈调用\n            Stack<Command> stack=new Stack<>();\n            stack.push(new Command("go",root));\n            while (!stack.isEmpty()){\n                Command command=stack.pop();\n                if (command.s.equals("print")){\n                    linkedList.add(command.node.val);\n                }else {\n//                    与递归的相反\n                    if (command.node.right!=null){\n                        stack.push(new Command("go",command.node.right));\n                    }\n                     stack.push(new Command("print",command.node));\n                    if (command.node.left!=null){\n                        stack.push(new Command("go",command.node.left));\n                    }\n                   \n                }\n            }\n            return linkedList;\n        }\n    \n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public List<Integer> inorderTraversal(TreeNode root) {\n                    List<Integer> list=new LinkedList<>();\n            Stack<TreeNode> stack=new Stack<>();\n            while (!stack.isEmpty()||root!=null){\n                while (root !=null){\n                    stack.push(root);\n                    root=root.left;\n                }\n                root=stack.pop();\n                list.add(root.val);\n                root=root.right;\n            }\n            return list;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nimport java.util.Stack;\nclass Solution{\n     class Command{\n            String s;\n            TreeNode node;\n\n            public Command(String s, TreeNode node) {\n                this.s = s;\n                this.node = node;\n            }\n        }\n        public  List<Integer> inorderTraversal(TreeNode root) {\n            LinkedList<Integer> linkedList=new LinkedList<>();\n            if (root==null){\n                return linkedList;\n            }\n//            模拟系统栈调用\n            Stack<Command> stack=new Stack<>();\n            stack.push(new Command("go",root));\n            while (!stack.isEmpty()){\n                Command command=stack.pop();\n                if (command.s.equals("print")){\n                    linkedList.add(command.node.val);\n                }else {\n//                    与递归的相反\n                    if (command.node.right!=null){\n                        stack.push(new Command("go",command.node.right));\n                    }\n                     stack.push(new Command("print",command.node));\n                    if (command.node.left!=null){\n                        stack.push(new Command("go",command.node.left));\n                    }\n                   \n                }\n            }\n            return linkedList;\n        }\n    \n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nimport java.util.Stack;\nclass Solution{\n     class Command{\n            String s;\n            TreeNode node;\n\n            public Command(String s, TreeNode node) {\n                this.s = s;\n                this.node = node;\n            }\n        }\n        public  List<Integer> inorderTraversal(TreeNode root) {\n            LinkedList<Integer> linkedList=new LinkedList<>();\n            if (root==null){\n                return linkedList;\n            }\n//            模拟系统栈调用\n            Stack<Command> stack=new Stack<>();\n            stack.push(new Command("go",root));\n            while (!stack.isEmpty()){\n                Command command=stack.pop();\n                if (command.s.equals("print")){\n                    linkedList.add(command.node.val);\n                }else {\n//                    与递归的相反\n                    if (command.node.right!=null){\n                        stack.push(new Command("go",command.node.right));\n                    }\n                     stack.push(new Command("print",command.node));\n                    if (command.node.left!=null){\n                        stack.push(new Command("go",command.node.left));\n                    }\n                   \n                }\n            }\n            return linkedList;\n        }\n    \n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n# 高赞题解\n官方题解中介绍了三种方法来完成树的中序遍历，包括：\n\n * 递归\n * 借助栈的迭代方法\n * 莫里斯遍历\n\n在树的深度优先遍历中（包括前序、中序、后序遍历），递归方法最为直观易懂，但考虑到效率，我们通常不推荐使用递归。\n\n栈迭代方法虽然提高了效率，但其嵌套循环却非常烧脑，不易理解，容易造成“一看就懂，一写就废”的窘况。而且对于不同的遍历顺序（前序、中序、后序），循环结构差异很大，更增加了记忆负担。\n\n因此，我在这里介绍一种“颜色标记法”（瞎起的名字……），兼具栈迭代方法的高效，又像递归方法一样简洁易懂，更重要的是，这种方法对于前序、中序、后序遍历，能够写出完全一致的代码。\n\n其核心思想如下：\n\n * 使用颜色标记节点的状态，新节点为白色，已访问的节点为灰色。\n * 如果遇到的节点为白色，则将其标记为灰色，然后将其右子节点、自身、左子节点依次入栈。\n * 如果遇到的节点为灰色，则将节点的值输出。\n\n使用这种方法实现的中序遍历如下：\n\nclass Solution:\n    def inorderTraversal(self, root: TreeNode) -> List[int]:\n        WHITE, GRAY = 0, 1\n        res = []\n        stack = [(WHITE, root)]\n        while stack:\n            color, node = stack.pop()\n            if node is None: continue\n            if color == WHITE:\n                stack.append((WHITE, node.right))\n                stack.append((GRAY, node))\n                stack.append((WHITE, node.left))\n            else:\n                res.append(node.val)\n        return res\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n如要实现前序、后序遍历，只需要调整左右子节点的入栈顺序即可。\n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2021-04-19 22:40:46Accepted [https://leetcode-cn.com//submissions/detail/169784675/]1 ms100.0%36.5 MBjava2021-04-19 22:32:12Accepted [https://leetcode-cn.com//submissions/detail/169781001/]0 ms100.0%36.8 MBjava2018-09-05 16:15:34Accepted [https://leetcode-cn.com//submissions/detail/6587032/]2 ms100.0%N/Ajava2018-09-05 16:13:00Accepted [https://leetcode-cn.com//submissions/detail/6586836/]1 ms100.0%N/Ajava2018-09-05 16:04:42Accepted [https://leetcode-cn.com//submissions/detail/6586149/]3 ms100.0%N/Ajava2018-09-05 15:06:15Accepted [https://leetcode-cn.com//submissions/detail/6580493/]1 ms100.0%N/Ajava# 统计信息\n通过次数提交次数AC比率40592053916675.3%# 相似题目\n题目难度验证二叉搜索树 [https://leetcode-cn.com/problems/validate-binary-search-tree/]中等二叉树的前序遍历 [https://leetcode-cn.com/problems/binary-tree-preorder-traversal/]中等二叉树的后序遍历 [https://leetcode-cn.com/problems/binary-tree-postorder-traversal/]中等二叉搜索树迭代器 [https://leetcode-cn.com/problems/binary-search-tree-iterator/]中等二叉搜索树中第K小的元素 [https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/]中等最接近的二叉搜索树值 II [https://leetcode-cn.com/problems/closest-binary-search-tree-value-ii/]困难二叉搜索树中的中序后继 [https://leetcode-cn.com/problems/inorder-successor-in-bst/]中等将二叉搜索树转化为排序的双向链表 [https://leetcode-cn.com/problems/convert-binary-search-tree-to-sorted-doubly-linked-list/]中等二叉搜索树节点最小距离 [https://leetcode-cn.com/problems/minimum-distance-between-bst-nodes/]简单',contentLowercase:'# 中文题目\n给定一个二叉树的根节点 root ，返回它的 中序遍历。\n\n\n\n示例 1：\n\n\n输入：root = [1,null,2,3]\n输出：[1,3,2]\n\n\n示例 2：\n\n\n输入：root = []\n输出：[]\n\n\n示例 3：\n\n\n输入：root = [1]\n输出：[1]\n\n\n示例 4：\n\n\n输入：root = [1,2]\n输出：[2,1]\n\n\n示例 5：\n\n\n输入：root = [1,null,2]\n输出：[1,2]\n\n\n\n\n提示：\n\n * 树中节点数目在范围 [0, 100] 内\n * -100 \n\n\n\n进阶:递归算法很简单，你可以通过迭代算法完成吗？\n\n# 通过代码\n/**\n * definition for a binary tree node.\n * public class treenode {\n *     int val;\n *     treenode left;\n *     treenode right;\n *     treenode() {}\n *     treenode(int val) { this.val = val; }\n *     treenode(int val, treenode left, treenode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass solution {\n        public list<integer> inordertraversal(treenode root) {\n            list<integer> result=new arraylist<>();\n            stack<treenode> stack=new stack<>();\n            while (root!=null||!stack.isempty()){\n                while (root != null){\n                    // 一直向左找\n                    stack.push(root);\n                    root=root.left;\n                }\n                // 找到最左边的\n                root=stack.pop();\n                result.add(root.val);\n                // 换成右边的\n                root=root.right;\n            }\n            return result;\n        }\n\n    }\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n/**\n * definition for a binary tree node.\n * public class treenode {\n *     int val;\n *     treenode left;\n *     treenode right;\n *     treenode() {}\n *     treenode(int val) { this.val = val; }\n *     treenode(int val, treenode left, treenode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass solution {\n        public list<integer> inordertraversal(treenode root) {\n            list<integer> result=new arraylist<>();\n            inorder(root,result);\n            return result;\n        }\n\n        public void inorder(treenode root,list<integer> result){\n            if (root!=null){\n                inorder(root.left,result);\n                result.add(root.val);\n                inorder(root.right,result);\n            }\n        }\n    }\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\nclass solution{\n     class command{\n            string s;\n            treenode node;\n\n            public command(string s, treenode node) {\n                this.s = s;\n                this.node = node;\n            }\n        }\n        public  list<integer> inordertraversal(treenode root) {\n            linkedlist<integer> linkedlist=new linkedlist<>();\n            if (root==null){\n                return linkedlist;\n            }\n//            模拟系统栈调用\n            stack<command> stack=new stack<>();\n            stack.push(new command("go",root));\n            while (!stack.isempty()){\n                command command=stack.pop();\n                if (command.s.equals("print")){\n                    linkedlist.add(command.node.val);\n                }else {\n//                    与递归的相反\n                    if (command.node.right!=null){\n                        stack.push(new command("go",command.node.right));\n                    }\n                     stack.push(new command("print",command.node));\n                    if (command.node.left!=null){\n                        stack.push(new command("go",command.node.left));\n                    }\n                   \n                }\n            }\n            return linkedlist;\n        }\n    \n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n/**\n * definition for a binary tree node.\n * public class treenode {\n *     int val;\n *     treenode left;\n *     treenode right;\n *     treenode(int x) { val = x; }\n * }\n */\nclass solution {\n    public list<integer> inordertraversal(treenode root) {\n                    list<integer> list=new linkedlist<>();\n            stack<treenode> stack=new stack<>();\n            while (!stack.isempty()||root!=null){\n                while (root !=null){\n                    stack.push(root);\n                    root=root.left;\n                }\n                root=stack.pop();\n                list.add(root.val);\n                root=root.right;\n            }\n            return list;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n/**\n * definition for a binary tree node.\n * public class treenode {\n *     int val;\n *     treenode left;\n *     treenode right;\n *     treenode(int x) { val = x; }\n * }\n */\nimport java.util.stack;\nclass solution{\n     class command{\n            string s;\n            treenode node;\n\n            public command(string s, treenode node) {\n                this.s = s;\n                this.node = node;\n            }\n        }\n        public  list<integer> inordertraversal(treenode root) {\n            linkedlist<integer> linkedlist=new linkedlist<>();\n            if (root==null){\n                return linkedlist;\n            }\n//            模拟系统栈调用\n            stack<command> stack=new stack<>();\n            stack.push(new command("go",root));\n            while (!stack.isempty()){\n                command command=stack.pop();\n                if (command.s.equals("print")){\n                    linkedlist.add(command.node.val);\n                }else {\n//                    与递归的相反\n                    if (command.node.right!=null){\n                        stack.push(new command("go",command.node.right));\n                    }\n                     stack.push(new command("print",command.node));\n                    if (command.node.left!=null){\n                        stack.push(new command("go",command.node.left));\n                    }\n                   \n                }\n            }\n            return linkedlist;\n        }\n    \n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n/**\n * definition for a binary tree node.\n * public class treenode {\n *     int val;\n *     treenode left;\n *     treenode right;\n *     treenode(int x) { val = x; }\n * }\n */\nimport java.util.stack;\nclass solution{\n     class command{\n            string s;\n            treenode node;\n\n            public command(string s, treenode node) {\n                this.s = s;\n                this.node = node;\n            }\n        }\n        public  list<integer> inordertraversal(treenode root) {\n            linkedlist<integer> linkedlist=new linkedlist<>();\n            if (root==null){\n                return linkedlist;\n            }\n//            模拟系统栈调用\n            stack<command> stack=new stack<>();\n            stack.push(new command("go",root));\n            while (!stack.isempty()){\n                command command=stack.pop();\n                if (command.s.equals("print")){\n                    linkedlist.add(command.node.val);\n                }else {\n//                    与递归的相反\n                    if (command.node.right!=null){\n                        stack.push(new command("go",command.node.right));\n                    }\n                     stack.push(new command("print",command.node));\n                    if (command.node.left!=null){\n                        stack.push(new command("go",command.node.left));\n                    }\n                   \n                }\n            }\n            return linkedlist;\n        }\n    \n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n# 高赞题解\n官方题解中介绍了三种方法来完成树的中序遍历，包括：\n\n * 递归\n * 借助栈的迭代方法\n * 莫里斯遍历\n\n在树的深度优先遍历中（包括前序、中序、后序遍历），递归方法最为直观易懂，但考虑到效率，我们通常不推荐使用递归。\n\n栈迭代方法虽然提高了效率，但其嵌套循环却非常烧脑，不易理解，容易造成“一看就懂，一写就废”的窘况。而且对于不同的遍历顺序（前序、中序、后序），循环结构差异很大，更增加了记忆负担。\n\n因此，我在这里介绍一种“颜色标记法”（瞎起的名字……），兼具栈迭代方法的高效，又像递归方法一样简洁易懂，更重要的是，这种方法对于前序、中序、后序遍历，能够写出完全一致的代码。\n\n其核心思想如下：\n\n * 使用颜色标记节点的状态，新节点为白色，已访问的节点为灰色。\n * 如果遇到的节点为白色，则将其标记为灰色，然后将其右子节点、自身、左子节点依次入栈。\n * 如果遇到的节点为灰色，则将节点的值输出。\n\n使用这种方法实现的中序遍历如下：\n\nclass solution:\n    def inordertraversal(self, root: treenode) -> list[int]:\n        white, gray = 0, 1\n        res = []\n        stack = [(white, root)]\n        while stack:\n            color, node = stack.pop()\n            if node is none: continue\n            if color == white:\n                stack.append((white, node.right))\n                stack.append((gray, node))\n                stack.append((white, node.left))\n            else:\n                res.append(node.val)\n        return res\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n如要实现前序、后序遍历，只需要调整左右子节点的入栈顺序即可。\n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2021-04-19 22:40:46accepted [https://leetcode-cn.com//submissions/detail/169784675/]1 ms100.0%36.5 mbjava2021-04-19 22:32:12accepted [https://leetcode-cn.com//submissions/detail/169781001/]0 ms100.0%36.8 mbjava2018-09-05 16:15:34accepted [https://leetcode-cn.com//submissions/detail/6587032/]2 ms100.0%n/ajava2018-09-05 16:13:00accepted [https://leetcode-cn.com//submissions/detail/6586836/]1 ms100.0%n/ajava2018-09-05 16:04:42accepted [https://leetcode-cn.com//submissions/detail/6586149/]3 ms100.0%n/ajava2018-09-05 15:06:15accepted [https://leetcode-cn.com//submissions/detail/6580493/]1 ms100.0%n/ajava# 统计信息\n通过次数提交次数ac比率40592053916675.3%# 相似题目\n题目难度验证二叉搜索树 [https://leetcode-cn.com/problems/validate-binary-search-tree/]中等二叉树的前序遍历 [https://leetcode-cn.com/problems/binary-tree-preorder-traversal/]中等二叉树的后序遍历 [https://leetcode-cn.com/problems/binary-tree-postorder-traversal/]中等二叉搜索树迭代器 [https://leetcode-cn.com/problems/binary-search-tree-iterator/]中等二叉搜索树中第k小的元素 [https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/]中等最接近的二叉搜索树值 ii [https://leetcode-cn.com/problems/closest-binary-search-tree-value-ii/]困难二叉搜索树中的中序后继 [https://leetcode-cn.com/problems/inorder-successor-in-bst/]中等将二叉搜索树转化为排序的双向链表 [https://leetcode-cn.com/problems/convert-binary-search-tree-to-sorted-doubly-linked-list/]中等二叉搜索树节点最小距离 [https://leetcode-cn.com/problems/minimum-distance-between-bst-nodes/]简单'},{title:"91-解码方法(Decode Ways)",frontmatter:{title:"91-解码方法(Decode Ways)",date:"2018-09-14T00:00:00.000Z",categories:["中等"],tags:["字符串<String>","动态规划<Dynamic Programming>"]},regularPath:"/views/%E4%B8%AD%E7%AD%89/0091-%E8%A7%A3%E7%A0%81%E6%96%B9%E6%B3%95.html",relativePath:"views/中等/0091-解码方法.md",key:"v-3bb3d58a",path:"/views/%E4%B8%AD%E7%AD%89/0091-%E8%A7%A3%E7%A0%81%E6%96%B9%E6%B3%95.html",headers:[{level:2,title:"中文题目",slug:"中文题目",charIndex:2},{level:2,title:"通过代码",slug:"通过代码",charIndex:236},{level:2,title:"高赞题解",slug:"高赞题解",charIndex:1086},{level:2,title:"提交历史",slug:"提交历史",charIndex:1590},{level:2,title:"统计信息",slug:"统计信息",charIndex:1817},{level:2,title:"相似题目",slug:"相似题目",charIndex:1852}],lastUpdated:"4/11/2021, 1:15:21 PM",headersStr:"中文题目 通过代码 高赞题解 提交历史 统计信息 相似题目",content:"# 中文题目\n一条包含字母A-Z 的消息通过以下方式进行了编码：\n\n'A' -> 1\n'B' -> 2\n...\n'Z' -> 26\n\n\n给定一个只包含数字的非空字符串，请计算解码方法的总数。\n\n示例 1:\n\n输入: \"12\"\n输出: 2\n解释: 它可以解码为 \"AB\"（1 2）或者 \"L\"（12）。\n\n\n示例 2:\n\n输入: \"226\"\n输出: 3\n解释: 它可以解码为 \"BZ\" (2 26), \"VF\" (22 6), 或者 \"BBF\" (2 2 6) 。\n\n\n# 通过代码\nclass Solution {\n    public int numDecodings(String s) {\n         if (s == null || s.length() == 0) {\n                return 0;\n            }\n            int n = s.length();\n            int[] dp = new int[n + 1];\n//            空字符串\"\",1种方式\n            dp[0] = 1;\n//            排除像012这种带前缀0的\n            dp[1] = s.charAt(0) != '0' ? 1 : 0;\n            for (int i = 2; i <= n; i++) {\n                int first = Integer.valueOf(s.substring(i - 1, i));\n                int second = Integer.valueOf(s.substring(i - 2, i));\n                if (first >= 1 && first <= 9) {\n                    dp[i] += dp[i - 1];\n                }\n                if (second >= 10 && second <= 26) {\n                    dp[i] += dp[i - 2];\n                }\n            }\n            return dp[n];\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n# 高赞题解\n# 算法分析\n\n\n# 源码\nint numDecodings(string s) {\n    if (s[0] == '0') return 0;\n    int pre = 1, curr = 1;//dp[-1] = dp[0] = 1\n    for (int i = 1; i < s.size(); i++) {\n        int tmp = curr;\n        if (s[i] == '0')\n            if (s[i - 1] == '1' || s[i - 1] == '2') curr = pre;\n            else return 0;\n        else if (s[i - 1] == '1' || (s[i - 1] == '2' && s[i] >= '1' && s[i] <= '6'))\n            curr = curr + pre;\n        pre = tmp;\n    }\n    return curr;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-09-14 23:16:27Accepted [https://leetcode-cn.com//submissions/detail/7111500/]4 ms28.93%N/Ajava2018-09-14 23:13:58Wrong Answer [https://leetcode-cn.com//submissions/detail/7111422/]N/AN/AN/Ajava# 统计信息\n通过次数提交次数AC比率2814712379522.7%# 相似题目\n题目难度解码方法 2 [https://leetcode-cn.com/problems/decode-ways-ii/]困难",contentLowercase:"# 中文题目\n一条包含字母a-z 的消息通过以下方式进行了编码：\n\n'a' -> 1\n'b' -> 2\n...\n'z' -> 26\n\n\n给定一个只包含数字的非空字符串，请计算解码方法的总数。\n\n示例 1:\n\n输入: \"12\"\n输出: 2\n解释: 它可以解码为 \"ab\"（1 2）或者 \"l\"（12）。\n\n\n示例 2:\n\n输入: \"226\"\n输出: 3\n解释: 它可以解码为 \"bz\" (2 26), \"vf\" (22 6), 或者 \"bbf\" (2 2 6) 。\n\n\n# 通过代码\nclass solution {\n    public int numdecodings(string s) {\n         if (s == null || s.length() == 0) {\n                return 0;\n            }\n            int n = s.length();\n            int[] dp = new int[n + 1];\n//            空字符串\"\",1种方式\n            dp[0] = 1;\n//            排除像012这种带前缀0的\n            dp[1] = s.charat(0) != '0' ? 1 : 0;\n            for (int i = 2; i <= n; i++) {\n                int first = integer.valueof(s.substring(i - 1, i));\n                int second = integer.valueof(s.substring(i - 2, i));\n                if (first >= 1 && first <= 9) {\n                    dp[i] += dp[i - 1];\n                }\n                if (second >= 10 && second <= 26) {\n                    dp[i] += dp[i - 2];\n                }\n            }\n            return dp[n];\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n# 高赞题解\n# 算法分析\n\n\n# 源码\nint numdecodings(string s) {\n    if (s[0] == '0') return 0;\n    int pre = 1, curr = 1;//dp[-1] = dp[0] = 1\n    for (int i = 1; i < s.size(); i++) {\n        int tmp = curr;\n        if (s[i] == '0')\n            if (s[i - 1] == '1' || s[i - 1] == '2') curr = pre;\n            else return 0;\n        else if (s[i - 1] == '1' || (s[i - 1] == '2' && s[i] >= '1' && s[i] <= '6'))\n            curr = curr + pre;\n        pre = tmp;\n    }\n    return curr;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-09-14 23:16:27accepted [https://leetcode-cn.com//submissions/detail/7111500/]4 ms28.93%n/ajava2018-09-14 23:13:58wrong answer [https://leetcode-cn.com//submissions/detail/7111422/]n/an/an/ajava# 统计信息\n通过次数提交次数ac比率2814712379522.7%# 相似题目\n题目难度解码方法 2 [https://leetcode-cn.com/problems/decode-ways-ii/]困难"},{title:"92-反转链表 II(Reverse Linked List II)",frontmatter:{title:"92-反转链表 II(Reverse Linked List II)",date:"2018-09-03T00:00:00.000Z",categories:["中等"],tags:["链表<Linked List>"]},regularPath:"/views/%E4%B8%AD%E7%AD%89/0092-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8%20II.html",relativePath:"views/中等/0092-反转链表 II.md",key:"v-70fe855a",path:"/views/%E4%B8%AD%E7%AD%89/0092-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8%20II.html",headers:[{level:2,title:"中文题目",slug:"中文题目",charIndex:2},{level:2,title:"通过代码",slug:"通过代码",charIndex:126},{level:2,title:"官方题解",slug:"官方题解",charIndex:2803},{level:2,title:"提交历史",slug:"提交历史",charIndex:11916},{level:2,title:"统计信息",slug:"统计信息",charIndex:12440},{level:2,title:"相似题目",slug:"相似题目",charIndex:12474}],lastUpdated:"4/11/2021, 1:15:21 PM",headersStr:"中文题目 通过代码 官方题解 提交历史 统计信息 相似题目",content:'# 中文题目\n反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。\n\n说明:\n1 ≤m≤n≤ 链表长度。\n\n示例:\n\n输入: 1->2->3->4->5->NULL, m = 2, n = 4\n输出: 1->4->3->2->5->NULL\n\n# 通过代码\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public ListNode reverseBetween(ListNode head, int m, int n) {\n         ListNode temphead=new ListNode(0);\n            temphead.next=head;\n            head=temphead;\n\n            ListNode pre=null;\n            ListNode cur=head;\n            ListNode ne=head.next;\n            ListNode temp1= null;\n            ListNode temp2=null;\n\n            if (m==n){\n                return head.next;\n            }\n            for (int i = 0; i <= n+1; i++) {\n                if (i==m-1){\n                    pre=cur;\n                    temp1=pre;\n                    temp2=cur.next;\n                    ne=cur.next;\n                }else if (i >=m){\n                    cur.next=pre;\n                    pre=cur;\n                    cur=ne;\n                    if (ne ==null){\n                        break;\n                    }\n                    ne=ne.next;\n                }else {\n                    cur=cur.next;\n                }\n            }\n            temp1.next=pre;\n            temp2.next=cur;\n            return head.next;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public ListNode reverseBetween(ListNode head, int m, int n) {\n         ListNode temphead=new ListNode(0);\n            temphead.next=head;\n            head=temphead;\n\n            ListNode pre=null;\n            ListNode cur=head;\n            ListNode ne=head.next;\n            ListNode temp1= null;\n            ListNode temp2=null;\n\n            if (m==n){\n                return head.next;\n            }\n            for (int i = 0; i <= n+1; i++) {\n                if (i==m-1){\n                    pre=cur;\n                    temp1=pre;\n                    temp2=cur.next;\n                    ne=cur.next;\n                }else if (i >=m){\n                    cur.next=pre;\n                    pre=cur;\n                    cur=ne;\n                    if (ne ==null){\n                        break;\n                    }\n                    ne=ne.next;\n                }else {\n                    cur=cur.next;\n                }\n            }\n            temp1.next=pre;\n            temp2.next=cur;\n            return head.next;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n# 官方题解\n# 方法一: 递归\n直觉\n\n使用递归反转链表的思路来源于反转字符串时使用的类似方法。反转字符串的一个巨大优势是可以使用下标信息。我们可以创建两个指针，一个开头，一个结尾。不断地交换这两个指针指向的元素，并将两个指针向中间移动。在分析链表的情况前，先让我们看看字符串上的示例。\n\n{:width=500} {:align=center}\n\n反转给定链表的一部分的思路基于上述方法。我们需要两个不同指针，一个指向第 mmm 个结点，另一个指向第 nnn 个结点。一旦有了这两个指针，我们就可以不断地交换这两个指针指向结点的数据，并将两个指针相向移动，就像字符串的情况那样。\n\n> 然而，链表中没有向后指针，也没有下标。因此，我们需要使用递归来 模拟 向后指针。递归中的回溯可以帮助我们模拟一个指针从第nnn个结点向中心移动的移动过程。\n\n\n算法\n\n 1.  我们定义一个递归函数用于反转给定链表的一部分。\n 2.  将函数记为 recurse。该函数使用三个参数: m 为反转的起点, n 为反转的终点, 以及从第 nnn 个结点开始，随着递归回溯过程向后移动的指针 right。不清楚的话，可以参考后文的示意图。\n 3.  此外，我们还有一个指针 left，它从第 m 个结点开始向前移动。在 `P\n 4.  \n 5.  \n 6.  thon中, 我们需要一个全局变量，值随着递归的进行而改变。在其他函数调用造成的变化可以持续的编程语言中，可以考虑将该指针加为函数recurse` 的一个变量。\n 7.  在\n 8.  递归调用中，给定 m，n，和 right, 首先判断 n = 1。 若判断为真, 则结束。\n 9.  于是，当 n 的值达到 1 时，我们便回溯。这时，right 指针在我们要反转的子链表结尾，left 到达了字列表的开头。于是，我们置换数据，并将 left 指针前移：left = left.next。我们需要此变化在回溯过程中保持。\n 10. 自此，每当我们回溯时，right 指针向后移一位。这就是前文所说的模拟。通过回溯模拟向后移动。\n 11. 当 right == left 或者 right.next == left 时停止交换。当子链表的长度为奇数时，情况为前者；当子链表长度为偶数时为后者。我们使用一个全局 boolean 变量 flag 来停止交换。\n\n下面是一系列整个算法的示意图，希望能够帮助你理解清楚。\n\n{:width=500} {:align=center}\n\n这是递归过程的第一步。给定所用链表，left 和 right 指针从链表的 head 开始。第一步是以更新过的 m 和 n 进行递归调用，换而言之，它们的值各自减 1。此外，left 和 right 指针向前移动一位。\n\n{:width=500} {:align=center}\n\n接下来的两步展示了 left 和 right 指针在链表中的移动。注意到在第二步之后，left 指针抵达了目标位置。因此，后续不再移动。从现在起，只有 right 指针继续移动，直到抵达结点 6。\n\n{:width=500} {:align=center}\n\n如你所见，在第五步之后，两个指针均抵达了目标位置，可以开始进行回溯。我们不再继续递归。回溯过程中的操作是交换 left 和 right 结点的数据。\n\n{:width=500} {:align=center}\n\n如你所见，在第三步（回溯）之后，right 指针 穿过了 left 指针，此时已经完成了要求部分链表的反转。结果是 [7 → 9 → 8 → 1 → 10 → 2 → 6]。 于是不再进行数据交换，在代码中，我们使用全局 boolean 变量 flag 来停止数据交换。不能直接跳出递归。\n\nclass Solution {\n\n    // Object level variables since we need the changes\n    // to persist across recursive calls and Java is pass by value.\n    private boolean stop;\n    private ListNode left;\n\n    public void recurseAndReverse(ListNode right, int m, int n) {\n\n        // base case. Don\'t proceed any further\n        if (n == 1) {\n            return;\n        }\n\n        // Keep moving the right pointer one step forward until (n == 1)\n        right = right.next;\n\n        // Keep moving left pointer to the right until we reach the proper node\n        // from where the reversal is to start.\n        if (m > 1) {\n            this.left = this.left.next;\n        }\n\n        // Recurse with m and n reduced.\n        this.recurseAndReverse(right, m - 1, n - 1);\n\n        // In case both the pointers cross each other or become equal, we\n        // stop i.e. don\'t swap data any further. We are done reversing at this\n        // point.\n        if (this.left == right || right.next == this.left) {\n            this.stop = true;            \n        }\n\n        // Until the boolean stop is false, swap data between the two pointers\n        if (!this.stop) {\n            int t = this.left.val;\n            this.left.val = right.val;\n            right.val = t;\n\n            // Move left one step to the right.\n            // The right pointer moves one step back via backtracking.\n            this.left = this.left.next;\n        }\n    }\n\n    public ListNode reverseBetween(ListNode head, int m, int n) {\n        this.left = head;\n        this.stop = false;\n        this.recurseAndReverse(head, m, n);\n        return head;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\nclass Solution:\n    def reverseBetween(self, head, m, n):\n        """\n        :type head: ListNode\n        :type m: int\n        :type n: int\n        :rtype: ListNode\n        """\n\n        if not head:\n            return None\n\n        left, right = head, head\n        stop = False\n        def recurseAndReverse(right, m, n):\n            nonlocal left, stop\n\n            # base case. Don\'t proceed any further\n            if n == 1:\n                return\n\n            # Keep moving the right pointer one step forward until (n == 1)\n            right = right.next\n\n            # Keep moving left pointer to the right until we reach the proper node\n            # from where the reversal is to start.\n            if m > 1:\n                left = left.next\n\n            # Recurse with m and n reduced.\n            recurseAndReverse(right, m - 1, n - 1)\n\n            # In case both the pointers cross each other or become equal, we\n            # stop i.e. don\'t swap data any further. We are done reversing at this\n            # point.\n            if left == right or right.next == left:\n                stop = True\n\n            # Until the boolean stop is false, swap data between the two pointers     \n            if not stop:\n                left.val, right.val = right.val, left.val\n\n                # Move left one step to the right.\n                # The right pointer moves one step back via backtracking.\n                left = left.next           \n\n        recurseAndReverse(right, m, n)\n        return head\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n复杂度分析\n\n * 时间复杂度: O(N)O(N)O(N)。对每个结点最多处理两次。递归过程\n * ，回溯\n * 。在回溯过程中，我们只交换了一半的结点，但总复杂度是 O(N)O(N)O(N)。\n * 空间复杂度: 最坏情况下为 O(N)O(N)O(N)。在最坏的情况下，我们需要反转整个链表。这是此时递归栈的大小。\n   \n   \n\n\n\n\n# 方法二: 迭代链接反转\n直觉\n\n在上个方法中，我们研究了一种反转给定链表部分的算法，该算法不改变给定链表的内在结构，只是修改了对于结点的值。 然而，有时可能无法修改结点的数据值。这时，我们就需要改变结点的链接来完成反转。\n\n从位置 m 到位置 n 的全部结点，我们需要反转每个结点的 next 指针。下面来看看具体的算法。\n\n算法\n\n在看具体算法之前，有必要先弄清楚链接反转的原理以及需要哪些指针。举例而言，有一个三个不同结点组成的链表 A → B → C，需要反转结点中的链接成为 A ← B ← C。\n\n假设我们有两个指针，一个指向结点 A，一个指向结点 B。 分别记为 prev 和 cur。则可以用这两个指针简单地实现 A 和 B 之间的链接反转：\n\ncur.next = prev\n\n\n1\n这样做唯一的问题是，没有办法继续下去，换而言之，这样做之后就无法再访问到结点 C。因此，我们需要引入第三个指针，用于帮助反转过程的进行。因此，我们不采用上面的反转方法，而是：\n\nthird = cur.next\ncur.next = prev\nprev = cur\ncur = third\n\n\n1\n2\n3\n4\n迭代 地进行上述过程，即可完成问题的要求。下面来看看算法的步骤。\n\n 1. 如上所述，我们需要两个指针 prev 和 cur。\n 2. prev 指针初始化为 None，cur 指针初始化为链表的 head。\n 3. 一步步地向前推进 cur 指针，prev 指针跟随其后。\n 4. 如此推进两个指针，直到 cur 指针到达从链表头起的第 mmm 个结点。这就是我们反转链表的起始位置。\n 5. 注意我们要引入两个额外指针，分别称为 tail 和 con。tail 指针指向从链表头起的第mmm个结点，此结点是反转后链表的尾部，故称为 tail。con 指针指向第 mmm 个结点的前一个结点，此结点是新链表的头部。下图可以帮助你更好的理解这两个指针。\n\n{:width=500} {:align=center}\n\n 6. tail 和 con 指针在算法开始时被初始化，在算法最后被调用，用于完成链表反转。\n 7. 如前文所解释的那样，抵达第 mmm 个结点后，在用到上述两个指针前，先迭代地反转链接。不断迭代，直到完成指向第 nnn 个结点的链接。此时，prev 指针会指向第 nnn 个结点。\n 8. 我们使用 con 指针来连接 prev 指针，这是因为 prev 指针当前指向的结点(第 nnn 个结点)会代替第 mmm 个结点的位置。 类似地，我们利用 tail 指针来连接 prev 指针之后的结点（第 n+1n+1n+1 个结点）。\n\n为了便于理清每个指针的用法，我们来看一个算法运行的实例。给定一个链表 7 → 9 → 2 → 10 → 1 → 8 → 6，我们需要反转从第 3 个结点到第 6 个结点的子链表。\n\n{:width=500} {:align=center}\n\n从上图可以看到迭代法的前几步。第一步展示了两个指针的初始化，第三步展示了链表反转过程的初始位置。\n\n{:width=500} {:align=center}\n\n上图详细显示了链接反转的过程以及反转两个结点的链接后如何向前移动。如下图所示，本步骤将执行多次。\n\n{:width=500} {:align=center}\n\n{:width=500} {:align=center}\n\n如上图所示, 两个指针都已经到达最终位置。我们完成了子链表的反转工作。然而，还有一些链接需要调整。下图展示了利用 tail 和 con 指针完成链接调整的过程。\n\n{:width=500} {:align=center}\n\nclass Solution {\n    public ListNode reverseBetween(ListNode head, int m, int n) {\n\n        // Empty list\n        if (head == null) {\n            return null;\n        }\n\n        // Move the two pointers until they reach the proper starting point\n        // in the list.\n        ListNode cur = head, prev = null;\n        while (m > 1) {\n            prev = cur;\n            cur = cur.next;\n            m--;\n            n--;\n        }\n\n        // The two pointers that will fix the final connections.\n        ListNode con = prev, tail = cur;\n\n        // Iteratively reverse the nodes until n becomes 0.\n        ListNode third = null;\n        while (n > 0) {\n            third = cur.next;\n            cur.next = prev;\n            prev = cur;\n            cur = third;\n            n--;\n        }\n\n        // Adjust the final connections as explained in the algorithm\n        if (con != null) {\n            con.next = prev;\n        } else {\n            head = prev;\n        }\n\n        tail.next = cur;\n        return head;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\nclass Solution:\n    def reverseBetween(self, head, m, n):\n        """\n        :type head: ListNode\n        :type m: int\n        :type n: int\n        :rtype: ListNode\n        """\n\n        # Empty list\n        if not head:\n            return None\n\n        # Move the two pointers until they reach the proper starting point\n        # in the list.\n        cur, prev = head, None\n        while m > 1:\n            prev = cur\n            cur = cur.next\n            m, n = m - 1, n - 1\n\n        # The two pointers that will fix the final connections.\n        tail, con = cur, prev\n\n        # Iteratively reverse the nodes until n becomes 0.\n        while n:\n            third = cur.next\n            cur.next = prev\n            prev = cur\n            cur = third\n            n -= 1\n\n        # Adjust the final connections as explained in the algorithm\n        if con:\n            con.next = prev\n        else:\n            head = prev\n        tail.next = cur\n        return head\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n复杂度分析\n\n * 时间复杂度: O(N)O(N)O(N)。考虑包含 NNN 个结点的链表。对每个节点最多会处理\n * （第 nnn 个结点之后的结点不处理）。\n * 空间复杂度: O(1)O(1)O(1)。我们仅仅在原有链表的基础上调整了一些指针，只使用了 O(1)O(1)O(1) 的额外存储空间来获得结果。\n   \n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-09-03 20:45:53Accepted [https://leetcode-cn.com//submissions/detail/6483917/]4 ms5.73%N/Ajava2018-09-03 20:41:06Accepted [https://leetcode-cn.com//submissions/detail/6483613/]12 ms5.73%N/Ajava2018-09-03 20:20:18Wrong Answer [https://leetcode-cn.com//submissions/detail/6482482/]N/AN/AN/Ajava2018-09-03 20:19:24Wrong Answer [https://leetcode-cn.com//submissions/detail/6482438/]N/AN/AN/Ajava2018-09-03 20:16:13Runtime Error [https://leetcode-cn.com//submissions/detail/6482257/]N/AN/AN/Ajava# 统计信息\n通过次数提交次数AC比率306686316048.6%# 相似题目\n题目难度反转链表 [https://leetcode-cn.com/problems/reverse-linked-list/]简单',contentLowercase:'# 中文题目\n反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。\n\n说明:\n1 ≤m≤n≤ 链表长度。\n\n示例:\n\n输入: 1->2->3->4->5->null, m = 2, n = 4\n输出: 1->4->3->2->5->null\n\n# 通过代码\n/**\n * definition for singly-linked list.\n * public class listnode {\n *     int val;\n *     listnode next;\n *     listnode(int x) { val = x; }\n * }\n */\nclass solution {\n    public listnode reversebetween(listnode head, int m, int n) {\n         listnode temphead=new listnode(0);\n            temphead.next=head;\n            head=temphead;\n\n            listnode pre=null;\n            listnode cur=head;\n            listnode ne=head.next;\n            listnode temp1= null;\n            listnode temp2=null;\n\n            if (m==n){\n                return head.next;\n            }\n            for (int i = 0; i <= n+1; i++) {\n                if (i==m-1){\n                    pre=cur;\n                    temp1=pre;\n                    temp2=cur.next;\n                    ne=cur.next;\n                }else if (i >=m){\n                    cur.next=pre;\n                    pre=cur;\n                    cur=ne;\n                    if (ne ==null){\n                        break;\n                    }\n                    ne=ne.next;\n                }else {\n                    cur=cur.next;\n                }\n            }\n            temp1.next=pre;\n            temp2.next=cur;\n            return head.next;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n/**\n * definition for singly-linked list.\n * public class listnode {\n *     int val;\n *     listnode next;\n *     listnode(int x) { val = x; }\n * }\n */\nclass solution {\n    public listnode reversebetween(listnode head, int m, int n) {\n         listnode temphead=new listnode(0);\n            temphead.next=head;\n            head=temphead;\n\n            listnode pre=null;\n            listnode cur=head;\n            listnode ne=head.next;\n            listnode temp1= null;\n            listnode temp2=null;\n\n            if (m==n){\n                return head.next;\n            }\n            for (int i = 0; i <= n+1; i++) {\n                if (i==m-1){\n                    pre=cur;\n                    temp1=pre;\n                    temp2=cur.next;\n                    ne=cur.next;\n                }else if (i >=m){\n                    cur.next=pre;\n                    pre=cur;\n                    cur=ne;\n                    if (ne ==null){\n                        break;\n                    }\n                    ne=ne.next;\n                }else {\n                    cur=cur.next;\n                }\n            }\n            temp1.next=pre;\n            temp2.next=cur;\n            return head.next;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n# 官方题解\n# 方法一: 递归\n直觉\n\n使用递归反转链表的思路来源于反转字符串时使用的类似方法。反转字符串的一个巨大优势是可以使用下标信息。我们可以创建两个指针，一个开头，一个结尾。不断地交换这两个指针指向的元素，并将两个指针向中间移动。在分析链表的情况前，先让我们看看字符串上的示例。\n\n{:width=500} {:align=center}\n\n反转给定链表的一部分的思路基于上述方法。我们需要两个不同指针，一个指向第 mmm 个结点，另一个指向第 nnn 个结点。一旦有了这两个指针，我们就可以不断地交换这两个指针指向结点的数据，并将两个指针相向移动，就像字符串的情况那样。\n\n> 然而，链表中没有向后指针，也没有下标。因此，我们需要使用递归来 模拟 向后指针。递归中的回溯可以帮助我们模拟一个指针从第nnn个结点向中心移动的移动过程。\n\n\n算法\n\n 1.  我们定义一个递归函数用于反转给定链表的一部分。\n 2.  将函数记为 recurse。该函数使用三个参数: m 为反转的起点, n 为反转的终点, 以及从第 nnn 个结点开始，随着递归回溯过程向后移动的指针 right。不清楚的话，可以参考后文的示意图。\n 3.  此外，我们还有一个指针 left，它从第 m 个结点开始向前移动。在 `p\n 4.  \n 5.  \n 6.  thon中, 我们需要一个全局变量，值随着递归的进行而改变。在其他函数调用造成的变化可以持续的编程语言中，可以考虑将该指针加为函数recurse` 的一个变量。\n 7.  在\n 8.  递归调用中，给定 m，n，和 right, 首先判断 n = 1。 若判断为真, 则结束。\n 9.  于是，当 n 的值达到 1 时，我们便回溯。这时，right 指针在我们要反转的子链表结尾，left 到达了字列表的开头。于是，我们置换数据，并将 left 指针前移：left = left.next。我们需要此变化在回溯过程中保持。\n 10. 自此，每当我们回溯时，right 指针向后移一位。这就是前文所说的模拟。通过回溯模拟向后移动。\n 11. 当 right == left 或者 right.next == left 时停止交换。当子链表的长度为奇数时，情况为前者；当子链表长度为偶数时为后者。我们使用一个全局 boolean 变量 flag 来停止交换。\n\n下面是一系列整个算法的示意图，希望能够帮助你理解清楚。\n\n{:width=500} {:align=center}\n\n这是递归过程的第一步。给定所用链表，left 和 right 指针从链表的 head 开始。第一步是以更新过的 m 和 n 进行递归调用，换而言之，它们的值各自减 1。此外，left 和 right 指针向前移动一位。\n\n{:width=500} {:align=center}\n\n接下来的两步展示了 left 和 right 指针在链表中的移动。注意到在第二步之后，left 指针抵达了目标位置。因此，后续不再移动。从现在起，只有 right 指针继续移动，直到抵达结点 6。\n\n{:width=500} {:align=center}\n\n如你所见，在第五步之后，两个指针均抵达了目标位置，可以开始进行回溯。我们不再继续递归。回溯过程中的操作是交换 left 和 right 结点的数据。\n\n{:width=500} {:align=center}\n\n如你所见，在第三步（回溯）之后，right 指针 穿过了 left 指针，此时已经完成了要求部分链表的反转。结果是 [7 → 9 → 8 → 1 → 10 → 2 → 6]。 于是不再进行数据交换，在代码中，我们使用全局 boolean 变量 flag 来停止数据交换。不能直接跳出递归。\n\nclass solution {\n\n    // object level variables since we need the changes\n    // to persist across recursive calls and java is pass by value.\n    private boolean stop;\n    private listnode left;\n\n    public void recurseandreverse(listnode right, int m, int n) {\n\n        // base case. don\'t proceed any further\n        if (n == 1) {\n            return;\n        }\n\n        // keep moving the right pointer one step forward until (n == 1)\n        right = right.next;\n\n        // keep moving left pointer to the right until we reach the proper node\n        // from where the reversal is to start.\n        if (m > 1) {\n            this.left = this.left.next;\n        }\n\n        // recurse with m and n reduced.\n        this.recurseandreverse(right, m - 1, n - 1);\n\n        // in case both the pointers cross each other or become equal, we\n        // stop i.e. don\'t swap data any further. we are done reversing at this\n        // point.\n        if (this.left == right || right.next == this.left) {\n            this.stop = true;            \n        }\n\n        // until the boolean stop is false, swap data between the two pointers\n        if (!this.stop) {\n            int t = this.left.val;\n            this.left.val = right.val;\n            right.val = t;\n\n            // move left one step to the right.\n            // the right pointer moves one step back via backtracking.\n            this.left = this.left.next;\n        }\n    }\n\n    public listnode reversebetween(listnode head, int m, int n) {\n        this.left = head;\n        this.stop = false;\n        this.recurseandreverse(head, m, n);\n        return head;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\nclass solution:\n    def reversebetween(self, head, m, n):\n        """\n        :type head: listnode\n        :type m: int\n        :type n: int\n        :rtype: listnode\n        """\n\n        if not head:\n            return none\n\n        left, right = head, head\n        stop = false\n        def recurseandreverse(right, m, n):\n            nonlocal left, stop\n\n            # base case. don\'t proceed any further\n            if n == 1:\n                return\n\n            # keep moving the right pointer one step forward until (n == 1)\n            right = right.next\n\n            # keep moving left pointer to the right until we reach the proper node\n            # from where the reversal is to start.\n            if m > 1:\n                left = left.next\n\n            # recurse with m and n reduced.\n            recurseandreverse(right, m - 1, n - 1)\n\n            # in case both the pointers cross each other or become equal, we\n            # stop i.e. don\'t swap data any further. we are done reversing at this\n            # point.\n            if left == right or right.next == left:\n                stop = true\n\n            # until the boolean stop is false, swap data between the two pointers     \n            if not stop:\n                left.val, right.val = right.val, left.val\n\n                # move left one step to the right.\n                # the right pointer moves one step back via backtracking.\n                left = left.next           \n\n        recurseandreverse(right, m, n)\n        return head\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n复杂度分析\n\n * 时间复杂度: o(n)o(n)o(n)。对每个结点最多处理两次。递归过程\n * ，回溯\n * 。在回溯过程中，我们只交换了一半的结点，但总复杂度是 o(n)o(n)o(n)。\n * 空间复杂度: 最坏情况下为 o(n)o(n)o(n)。在最坏的情况下，我们需要反转整个链表。这是此时递归栈的大小。\n   \n   \n\n\n\n\n# 方法二: 迭代链接反转\n直觉\n\n在上个方法中，我们研究了一种反转给定链表部分的算法，该算法不改变给定链表的内在结构，只是修改了对于结点的值。 然而，有时可能无法修改结点的数据值。这时，我们就需要改变结点的链接来完成反转。\n\n从位置 m 到位置 n 的全部结点，我们需要反转每个结点的 next 指针。下面来看看具体的算法。\n\n算法\n\n在看具体算法之前，有必要先弄清楚链接反转的原理以及需要哪些指针。举例而言，有一个三个不同结点组成的链表 a → b → c，需要反转结点中的链接成为 a ← b ← c。\n\n假设我们有两个指针，一个指向结点 a，一个指向结点 b。 分别记为 prev 和 cur。则可以用这两个指针简单地实现 a 和 b 之间的链接反转：\n\ncur.next = prev\n\n\n1\n这样做唯一的问题是，没有办法继续下去，换而言之，这样做之后就无法再访问到结点 c。因此，我们需要引入第三个指针，用于帮助反转过程的进行。因此，我们不采用上面的反转方法，而是：\n\nthird = cur.next\ncur.next = prev\nprev = cur\ncur = third\n\n\n1\n2\n3\n4\n迭代 地进行上述过程，即可完成问题的要求。下面来看看算法的步骤。\n\n 1. 如上所述，我们需要两个指针 prev 和 cur。\n 2. prev 指针初始化为 none，cur 指针初始化为链表的 head。\n 3. 一步步地向前推进 cur 指针，prev 指针跟随其后。\n 4. 如此推进两个指针，直到 cur 指针到达从链表头起的第 mmm 个结点。这就是我们反转链表的起始位置。\n 5. 注意我们要引入两个额外指针，分别称为 tail 和 con。tail 指针指向从链表头起的第mmm个结点，此结点是反转后链表的尾部，故称为 tail。con 指针指向第 mmm 个结点的前一个结点，此结点是新链表的头部。下图可以帮助你更好的理解这两个指针。\n\n{:width=500} {:align=center}\n\n 6. tail 和 con 指针在算法开始时被初始化，在算法最后被调用，用于完成链表反转。\n 7. 如前文所解释的那样，抵达第 mmm 个结点后，在用到上述两个指针前，先迭代地反转链接。不断迭代，直到完成指向第 nnn 个结点的链接。此时，prev 指针会指向第 nnn 个结点。\n 8. 我们使用 con 指针来连接 prev 指针，这是因为 prev 指针当前指向的结点(第 nnn 个结点)会代替第 mmm 个结点的位置。 类似地，我们利用 tail 指针来连接 prev 指针之后的结点（第 n+1n+1n+1 个结点）。\n\n为了便于理清每个指针的用法，我们来看一个算法运行的实例。给定一个链表 7 → 9 → 2 → 10 → 1 → 8 → 6，我们需要反转从第 3 个结点到第 6 个结点的子链表。\n\n{:width=500} {:align=center}\n\n从上图可以看到迭代法的前几步。第一步展示了两个指针的初始化，第三步展示了链表反转过程的初始位置。\n\n{:width=500} {:align=center}\n\n上图详细显示了链接反转的过程以及反转两个结点的链接后如何向前移动。如下图所示，本步骤将执行多次。\n\n{:width=500} {:align=center}\n\n{:width=500} {:align=center}\n\n如上图所示, 两个指针都已经到达最终位置。我们完成了子链表的反转工作。然而，还有一些链接需要调整。下图展示了利用 tail 和 con 指针完成链接调整的过程。\n\n{:width=500} {:align=center}\n\nclass solution {\n    public listnode reversebetween(listnode head, int m, int n) {\n\n        // empty list\n        if (head == null) {\n            return null;\n        }\n\n        // move the two pointers until they reach the proper starting point\n        // in the list.\n        listnode cur = head, prev = null;\n        while (m > 1) {\n            prev = cur;\n            cur = cur.next;\n            m--;\n            n--;\n        }\n\n        // the two pointers that will fix the final connections.\n        listnode con = prev, tail = cur;\n\n        // iteratively reverse the nodes until n becomes 0.\n        listnode third = null;\n        while (n > 0) {\n            third = cur.next;\n            cur.next = prev;\n            prev = cur;\n            cur = third;\n            n--;\n        }\n\n        // adjust the final connections as explained in the algorithm\n        if (con != null) {\n            con.next = prev;\n        } else {\n            head = prev;\n        }\n\n        tail.next = cur;\n        return head;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\nclass solution:\n    def reversebetween(self, head, m, n):\n        """\n        :type head: listnode\n        :type m: int\n        :type n: int\n        :rtype: listnode\n        """\n\n        # empty list\n        if not head:\n            return none\n\n        # move the two pointers until they reach the proper starting point\n        # in the list.\n        cur, prev = head, none\n        while m > 1:\n            prev = cur\n            cur = cur.next\n            m, n = m - 1, n - 1\n\n        # the two pointers that will fix the final connections.\n        tail, con = cur, prev\n\n        # iteratively reverse the nodes until n becomes 0.\n        while n:\n            third = cur.next\n            cur.next = prev\n            prev = cur\n            cur = third\n            n -= 1\n\n        # adjust the final connections as explained in the algorithm\n        if con:\n            con.next = prev\n        else:\n            head = prev\n        tail.next = cur\n        return head\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n复杂度分析\n\n * 时间复杂度: o(n)o(n)o(n)。考虑包含 nnn 个结点的链表。对每个节点最多会处理\n * （第 nnn 个结点之后的结点不处理）。\n * 空间复杂度: o(1)o(1)o(1)。我们仅仅在原有链表的基础上调整了一些指针，只使用了 o(1)o(1)o(1) 的额外存储空间来获得结果。\n   \n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-09-03 20:45:53accepted [https://leetcode-cn.com//submissions/detail/6483917/]4 ms5.73%n/ajava2018-09-03 20:41:06accepted [https://leetcode-cn.com//submissions/detail/6483613/]12 ms5.73%n/ajava2018-09-03 20:20:18wrong answer [https://leetcode-cn.com//submissions/detail/6482482/]n/an/an/ajava2018-09-03 20:19:24wrong answer [https://leetcode-cn.com//submissions/detail/6482438/]n/an/an/ajava2018-09-03 20:16:13runtime error [https://leetcode-cn.com//submissions/detail/6482257/]n/an/an/ajava# 统计信息\n通过次数提交次数ac比率306686316048.6%# 相似题目\n题目难度反转链表 [https://leetcode-cn.com/problems/reverse-linked-list/]简单'},{title:"93-复原IP地址(Restore IP Addresses)",frontmatter:{title:"93-复原IP地址(Restore IP Addresses)",date:"2018-09-05T00:00:00.000Z",categories:["中等"],tags:["字符串<String>","回溯算法<Backtracking>"]},regularPath:"/views/%E4%B8%AD%E7%AD%89/0093-%E5%A4%8D%E5%8E%9FIP%E5%9C%B0%E5%9D%80.html",relativePath:"views/中等/0093-复原IP地址.md",key:"v-7dcfc1d7",path:"/views/%E4%B8%AD%E7%AD%89/0093-%E5%A4%8D%E5%8E%9FIP%E5%9C%B0%E5%9D%80.html",headers:[{level:2,title:"中文题目",slug:"中文题目",charIndex:2},{level:2,title:"通过代码",slug:"通过代码",charIndex:110},{level:2,title:"官方题解",slug:"官方题解",charIndex:1161},{level:2,title:"提交历史",slug:"提交历史",charIndex:6167},{level:2,title:"统计信息",slug:"统计信息",charIndex:6295},{level:2,title:"相似题目",slug:"相似题目",charIndex:6329}],lastUpdated:"4/11/2021, 1:15:21 PM",headersStr:"中文题目 通过代码 官方题解 提交历史 统计信息 相似题目",content:'# 中文题目\n给定一个只包含数字的字符串，复原它并返回所有可能的 IP 地址格式。\n\n示例:\n\n输入: "25525511135"\n输出: ["255.255.11.135", "255.255.111.35"]\n\n# 通过代码\nclass Solution {\n   public  List<String> list=new LinkedList<String>();\n        public  List<String> restoreIpAddresses(String s) {\n            if (s==null || s.equals("")){\n                return list;\n            }\n            getAllIPAddress(s,0,"",0);\n            return list;\n        }\n\n        private  void getAllIPAddress(String ip,int idx,String restored,int count) {\n            if (count > 4) {\n                return;\n            }\n            if (count==4 && idx==ip.length()){\n                list.add(restored);\n            }\n            for (int i = 1; i < 4; i++) {\n                if (idx+i > ip.length()){\n                    break;\n                }\n                String s=ip.substring(idx,idx+i);\n                if ((s.startsWith("0") && s.length()>1)||(i==3 && Integer.parseInt(s)>=256)){\n                    continue;\n                }\n                getAllIPAddress(ip,idx+i,restored+s+(count==3?"":"."),count+1);\n            }\n        }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n# 官方题解\n# 直觉\n最朴素的解法是暴力法,换而言之，检查点可能的所有位置，并只保留有效的部分。在最坏的情况下，有11个可能的位置，因此需要11×10×9=99011 \\times 10 \\times 9 = 99011×10×9=990 次检查。\n\n可以通过以下两个概念来优化。\n\n> 第一个概念是 约束规划。\n\n\n这意味着对每个点的放置设置一些限制。若已经放置了一个点，下一个点只有 3 种可能：1/2/3个数字之后。\n\n这样做传播了_约束_ ，且减少了需要考虑的情况。我们只需要检测 3×3×3=273 \\times 3 \\times 3 = 273×3×3=27种情况，而非f 990990990 种。\n\n> 第二个概念是 回溯。\n\n\n我们假设已经放置了一或两个点使得无法摆放其他点来生成有效IP地址。这时应该做什么？ 回溯。T也就是说，回到之前，改变上一个摆放点的位置。并试着继续。如果依然不行，则继续 回溯。\n\n\n\n\n\n\n# 方法一 ： 回溯(DFS)\n这是一个回溯函数backtrack(prev_pos = -1, dots = 3) 的算法，该函数使用上一个放置的点 prev_pos和待放置点的数量 dots 两个参数 :\n\n * 遍历三个有效位置curr_pos 以放置点。 * 检查从上一个点到现在点中间的部分是否有效 : * 是 : * 放置该点。\n          * 检查全部 3个点是否放好: * 是 : * 将结果添加到输出列表中。\n               \n               \n             * 否 : * 继续放下一个点 backtrack(curr_pos, dots - 1)。\n               \n               \n            \n            \n          * 回溯，移除最后一个点。\n         \n         \n      \n      \n   \n   \n\n<,,,,,,,,,,,,,,,,,,,,,>\n\nclass Solution {\n  int n;\n  String s;\n  LinkedList<String> segments = new LinkedList<String>();\n  ArrayList<String> output = new ArrayList<String>();\n\n  public boolean valid(String segment) {\n    /*\n    Check if the current segment is valid :\n    1. less or equal to 255      \n    2. the first character could be \'0\' \n    only if the segment is equal to \'0\'\n    */\n    int m = segment.length();\n    if (m > 3)\n      return false;\n    return (segment.charAt(0) != \'0\') ? (Integer.valueOf(segment) <= 255) : (m == 1);\n  }\n\n  public void update_output(int curr_pos) {\n    /*\n    Append the current list of segments \n    to the list of solutions\n    */\n    String segment = s.substring(curr_pos + 1, n);\n    if (valid(segment)) {\n      segments.add(segment);\n      output.add(String.join(".", segments));\n      segments.removeLast();\n    }\n  }\n\n  public void backtrack(int prev_pos, int dots) {\n    /*\n    prev_pos : the position of the previously placed dot\n    dots : number of dots to place\n    */\n    // The current dot curr_pos could be placed \n    // in a range from prev_pos + 1 to prev_pos + 4.\n    // The dot couldn\'t be placed \n    // after the last character in the string.\n    int max_pos = Math.min(n - 1, prev_pos + 4);\n    for (int curr_pos = prev_pos + 1; curr_pos < max_pos; curr_pos++) {\n      String segment = s.substring(prev_pos + 1, curr_pos + 1);\n      if (valid(segment)) {\n        segments.add(segment);  // place dot\n        if (dots - 1 == 0)      // if all 3 dots are placed\n          update_output(curr_pos);  // add the solution to output\n        else\n          backtrack(curr_pos, dots - 1);  // continue to place dots\n        segments.removeLast();  // remove the last placed dot \n      }\n    }\n  }\n\n  public List<String> restoreIpAddresses(String s) {\n    n = s.length();\n    this.s = s;\n    backtrack(-1, 3);\n    return output;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\nclass Solution:\n    def restoreIpAddresses(self, s):\n        """\n        :type s: str\n        :rtype: List[str]\n        """\n        def valid(segment):\n            """\n            Check if the current segment is valid :\n            1. less or equal to 255      \n            2. the first character could be \'0\' \n               only if the segment is equal to \'0\'\n            """\n            return int(segment) <= 255 if segment[0] != \'0\' else len(segment) == 1\n            \n        def update_output(curr_pos):\n            """\n            Append the current list of segments \n            to the list of solutions\n            """\n            segment = s[curr_pos + 1:n]\n            if valid(segment):\n                segments.append(segment)\n                output.append(\'.\'.join(segments))\n                segments.pop()    \n            \n        def backtrack(prev_pos = -1, dots = 3):\n            """\n            prev_pos : the position of the previously placed dot\n            dots : number of dots to place\n            """\n            # The current dot curr_pos could be placed \n            # in a range from prev_pos + 1 to prev_pos + 4.\n            # The dot couldn\'t be placed \n            # after the last character in the string.\n            for curr_pos in range(prev_pos + 1, min(n - 1, prev_pos + 4)):\n                segment = s[prev_pos + 1:curr_pos + 1]\n                if valid(segment):\n                    segments.append(segment)  # place dot\n                    if dots - 1 == 0:  # if all 3 dots are placed\n                        update_output(curr_pos)  # add the solution to output\n                    else:\n                        backtrack(curr_pos, dots - 1)  # continue to place dots\n                    segments.pop()  # remove the last placed dot\n        \n        n = len(s)\n        output, segments = [], []\n        backtrack() \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n复杂度分析\n\n * 时间复杂度 : 如上文所述，需要检查的组合不多于27个。\n * 空间复杂度 : 常数空间存储解，不多于19 个有效IP地址。{:width=500px}\n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-09-05 21:21:38Accepted [https://leetcode-cn.com//submissions/detail/6605667/]6 ms10.75%N/Ajava# 统计信息\n通过次数提交次数AC比率228855047445.3%# 相似题目\n题目难度IP 到 CIDR [https://leetcode-cn.com/problems/ip-to-cidr/]简单',contentLowercase:'# 中文题目\n给定一个只包含数字的字符串，复原它并返回所有可能的 ip 地址格式。\n\n示例:\n\n输入: "25525511135"\n输出: ["255.255.11.135", "255.255.111.35"]\n\n# 通过代码\nclass solution {\n   public  list<string> list=new linkedlist<string>();\n        public  list<string> restoreipaddresses(string s) {\n            if (s==null || s.equals("")){\n                return list;\n            }\n            getallipaddress(s,0,"",0);\n            return list;\n        }\n\n        private  void getallipaddress(string ip,int idx,string restored,int count) {\n            if (count > 4) {\n                return;\n            }\n            if (count==4 && idx==ip.length()){\n                list.add(restored);\n            }\n            for (int i = 1; i < 4; i++) {\n                if (idx+i > ip.length()){\n                    break;\n                }\n                string s=ip.substring(idx,idx+i);\n                if ((s.startswith("0") && s.length()>1)||(i==3 && integer.parseint(s)>=256)){\n                    continue;\n                }\n                getallipaddress(ip,idx+i,restored+s+(count==3?"":"."),count+1);\n            }\n        }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n# 官方题解\n# 直觉\n最朴素的解法是暴力法,换而言之，检查点可能的所有位置，并只保留有效的部分。在最坏的情况下，有11个可能的位置，因此需要11×10×9=99011 \\times 10 \\times 9 = 99011×10×9=990 次检查。\n\n可以通过以下两个概念来优化。\n\n> 第一个概念是 约束规划。\n\n\n这意味着对每个点的放置设置一些限制。若已经放置了一个点，下一个点只有 3 种可能：1/2/3个数字之后。\n\n这样做传播了_约束_ ，且减少了需要考虑的情况。我们只需要检测 3×3×3=273 \\times 3 \\times 3 = 273×3×3=27种情况，而非f 990990990 种。\n\n> 第二个概念是 回溯。\n\n\n我们假设已经放置了一或两个点使得无法摆放其他点来生成有效ip地址。这时应该做什么？ 回溯。t也就是说，回到之前，改变上一个摆放点的位置。并试着继续。如果依然不行，则继续 回溯。\n\n\n\n\n\n\n# 方法一 ： 回溯(dfs)\n这是一个回溯函数backtrack(prev_pos = -1, dots = 3) 的算法，该函数使用上一个放置的点 prev_pos和待放置点的数量 dots 两个参数 :\n\n * 遍历三个有效位置curr_pos 以放置点。 * 检查从上一个点到现在点中间的部分是否有效 : * 是 : * 放置该点。\n          * 检查全部 3个点是否放好: * 是 : * 将结果添加到输出列表中。\n               \n               \n             * 否 : * 继续放下一个点 backtrack(curr_pos, dots - 1)。\n               \n               \n            \n            \n          * 回溯，移除最后一个点。\n         \n         \n      \n      \n   \n   \n\n<,,,,,,,,,,,,,,,,,,,,,>\n\nclass solution {\n  int n;\n  string s;\n  linkedlist<string> segments = new linkedlist<string>();\n  arraylist<string> output = new arraylist<string>();\n\n  public boolean valid(string segment) {\n    /*\n    check if the current segment is valid :\n    1. less or equal to 255      \n    2. the first character could be \'0\' \n    only if the segment is equal to \'0\'\n    */\n    int m = segment.length();\n    if (m > 3)\n      return false;\n    return (segment.charat(0) != \'0\') ? (integer.valueof(segment) <= 255) : (m == 1);\n  }\n\n  public void update_output(int curr_pos) {\n    /*\n    append the current list of segments \n    to the list of solutions\n    */\n    string segment = s.substring(curr_pos + 1, n);\n    if (valid(segment)) {\n      segments.add(segment);\n      output.add(string.join(".", segments));\n      segments.removelast();\n    }\n  }\n\n  public void backtrack(int prev_pos, int dots) {\n    /*\n    prev_pos : the position of the previously placed dot\n    dots : number of dots to place\n    */\n    // the current dot curr_pos could be placed \n    // in a range from prev_pos + 1 to prev_pos + 4.\n    // the dot couldn\'t be placed \n    // after the last character in the string.\n    int max_pos = math.min(n - 1, prev_pos + 4);\n    for (int curr_pos = prev_pos + 1; curr_pos < max_pos; curr_pos++) {\n      string segment = s.substring(prev_pos + 1, curr_pos + 1);\n      if (valid(segment)) {\n        segments.add(segment);  // place dot\n        if (dots - 1 == 0)      // if all 3 dots are placed\n          update_output(curr_pos);  // add the solution to output\n        else\n          backtrack(curr_pos, dots - 1);  // continue to place dots\n        segments.removelast();  // remove the last placed dot \n      }\n    }\n  }\n\n  public list<string> restoreipaddresses(string s) {\n    n = s.length();\n    this.s = s;\n    backtrack(-1, 3);\n    return output;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\nclass solution:\n    def restoreipaddresses(self, s):\n        """\n        :type s: str\n        :rtype: list[str]\n        """\n        def valid(segment):\n            """\n            check if the current segment is valid :\n            1. less or equal to 255      \n            2. the first character could be \'0\' \n               only if the segment is equal to \'0\'\n            """\n            return int(segment) <= 255 if segment[0] != \'0\' else len(segment) == 1\n            \n        def update_output(curr_pos):\n            """\n            append the current list of segments \n            to the list of solutions\n            """\n            segment = s[curr_pos + 1:n]\n            if valid(segment):\n                segments.append(segment)\n                output.append(\'.\'.join(segments))\n                segments.pop()    \n            \n        def backtrack(prev_pos = -1, dots = 3):\n            """\n            prev_pos : the position of the previously placed dot\n            dots : number of dots to place\n            """\n            # the current dot curr_pos could be placed \n            # in a range from prev_pos + 1 to prev_pos + 4.\n            # the dot couldn\'t be placed \n            # after the last character in the string.\n            for curr_pos in range(prev_pos + 1, min(n - 1, prev_pos + 4)):\n                segment = s[prev_pos + 1:curr_pos + 1]\n                if valid(segment):\n                    segments.append(segment)  # place dot\n                    if dots - 1 == 0:  # if all 3 dots are placed\n                        update_output(curr_pos)  # add the solution to output\n                    else:\n                        backtrack(curr_pos, dots - 1)  # continue to place dots\n                    segments.pop()  # remove the last placed dot\n        \n        n = len(s)\n        output, segments = [], []\n        backtrack() \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n复杂度分析\n\n * 时间复杂度 : 如上文所述，需要检查的组合不多于27个。\n * 空间复杂度 : 常数空间存储解，不多于19 个有效ip地址。{:width=500px}\n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-09-05 21:21:38accepted [https://leetcode-cn.com//submissions/detail/6605667/]6 ms10.75%n/ajava# 统计信息\n通过次数提交次数ac比率228855047445.3%# 相似题目\n题目难度ip 到 cidr [https://leetcode-cn.com/problems/ip-to-cidr/]简单'},{title:"98-验证二叉搜索树(Validate Binary Search Tree)",frontmatter:{title:"98-验证二叉搜索树(Validate Binary Search Tree)",date:"2018-09-08T00:00:00.000Z",categories:["中等"],tags:["树<Tree>","深度优先搜索<Depth-first Search>"]},regularPath:"/views/%E4%B8%AD%E7%AD%89/0098-%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.html",relativePath:"views/中等/0098-验证二叉搜索树.md",key:"v-78c30bf4",path:"/views/%E4%B8%AD%E7%AD%89/0098-%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.html",headers:[{level:2,title:"中文题目",slug:"中文题目",charIndex:2},{level:2,title:"通过代码",slug:"通过代码",charIndex:291},{level:2,title:"官方题解",slug:"官方题解",charIndex:2300},{level:2,title:"提交历史",slug:"提交历史",charIndex:7810},{level:2,title:"统计信息",slug:"统计信息",charIndex:8835},{level:2,title:"相似题目",slug:"相似题目",charIndex:8870}],lastUpdated:"4/11/2021, 1:15:21 PM",headersStr:"中文题目 通过代码 官方题解 提交历史 统计信息 相似题目",content:'# 中文题目\n给定一个二叉树，判断其是否是一个有效的二叉搜索树。\n\n假设一个二叉搜索树具有如下特征：\n\n * 节点的左子树只包含小于当前节点的数。\n * 节点的右子树只包含大于当前节点的数。\n * 所有左子树和右子树自身必须也是二叉搜索树。\n\n示例 1:\n\n输入:\n    2\n   / \\\n  1   3\n输出: true\n\n\n示例 2:\n\n输入:\n    5\n   / \\\n  1   4\n     / \\\n    3   6\n输出: false\n解释: 输入为: [5,1,4,null,null,3,6]。\n     根节点的值为 5 ，但是其右子节点值为 4 。\n\n\n# 通过代码\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n//     public boolean isValidBST(TreeNode root) {\n//         return isValidBST(root,Long.MIN_VALUE,Long.MAX_VALUE);\n//     }\n\n//     private boolean isValidBST(TreeNode root, long minValue, long maxValue) {\n//         if (root==null){\n//             return true;\n//         }\n//         if (root.val>=maxValue||root.val<=minValue){\n//             return false;\n//         }\n//         return isValidBST(root.left,minValue,root.val)&&isValidBST(root.right,root.val,maxValue);\n//     }\n        public boolean isValidBST(TreeNode root) {\n\n        ArrayList<Integer> list = new ArrayList<>();\n        inOrder(root, list);\n        for(int i = 1 ; i < list.size() ; i ++)\n            if(list.get(i - 1) >= list.get(i))\n                return false;\n        return true;\n    }\n\n    private void inOrder(TreeNode node, ArrayList<Integer> list){\n\n        if(node == null)\n            return;\n\n        inOrder(node.left, list);\n        list.add(node.val);\n        inOrder(node.right, list);\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public boolean isValidBST(TreeNode root) {\n        return isValidBST(root,Long.MIN_VALUE,Long.MAX_VALUE);\n    }\n\n    private boolean isValidBST(TreeNode root, long minValue, long maxValue) {\n        if (root==null){\n            return true;\n        }\n        if (root.val>=maxValue||root.val<=minValue){\n            return false;\n        }\n        return isValidBST(root.left,minValue,root.val)&&isValidBST(root.right,root.val,maxValue);\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n# 官方题解\n# 树的定义\n首先，这是 TreeNode 的定义，后续会使用到。\n\n// Definition for a binary tree node.\npublic class TreeNode {\n  int val;\n  TreeNode left;\n  TreeNode right;\n\n  TreeNode(int x) {\n    val = x;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n\n# 直觉\n乍一看，这是一个平凡的问题。只需要遍历整棵树，检查 node.right.val > node.val 和node.left.val < node.val 对每个结点是否成立。\n\n{:width=500} {:align=center}\n\n问题是，这种方法并不总是正确。不仅右子结点要大于该节点，整个右子树的元素都应该大于该节点。例如:\n\n{:width=500} {:align=center}\n\n这意味着我们需要在遍历树的同时保留结点的上界与下界，在比较时不仅比较子结点的值，也要与上下界比较。\n\n\n\n\n\n\n# 方法一: 递归\n上述思路可以用递归法实现。首先将结点的值与上界和下界（如果有）比较。然后，对左子树和右子树递归进行该过程。\n\n<,,,>\n\nclass Solution {\n  public boolean helper(TreeNode node, Integer lower, Integer upper) {\n    if (node == null) return true;\n\n    int val = node.val;\n    if (lower != null && val <= lower) return false;\n    if (upper != null && val >= upper) return false;\n\n    if (! helper(node.right, val, upper)) return false;\n    if (! helper(node.left, lower, val)) return false;\n    return true;\n  }\n\n  public boolean isValidBST(TreeNode root) {\n    return helper(root, null, null);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\nclass Solution:\n    def isValidBST(self, root):\n        """\n        :type root: TreeNode\n        :rtype: bool\n        """\n        def helper(node, lower = float(\'-inf\'), upper = float(\'inf\')):\n            if not node:\n                return True\n            \n            val = node.val\n            if val <= lower or val >= upper:\n                return False\n\n            if not helper(node.right, val, upper):\n                return False\n            if not helper(node.left, lower, val):\n                return False\n            return True\n\n        return helper(root)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n复杂度分析\n\n * 时间复杂度 : O(N)O(N)O(N)。每个结点访问一次。\n * 空间复杂度 : O(N)O(N)O(N)。我们跟进了整棵树。\n\n\n\n\n\n\n# 方法二: 迭代\n通过使用栈，上面的递归法可以转化为迭代法。这里使用深度优先搜索，比广度优先搜索要快一些。\n\nclass Solution {\n  LinkedList<TreeNode> stack = new LinkedList();\n  LinkedList<Integer> uppers = new LinkedList(),\n          lowers = new LinkedList();\n\n  public void update(TreeNode root, Integer lower, Integer upper) {\n    stack.add(root);\n    lowers.add(lower);\n    uppers.add(upper);\n  }\n\n  public boolean isValidBST(TreeNode root) {\n    Integer lower = null, upper = null, val;\n    update(root, lower, upper);\n\n    while (!stack.isEmpty()) {\n      root = stack.poll();\n      lower = lowers.poll();\n      upper = uppers.poll();\n\n      if (root == null) continue;\n      val = root.val;\n      if (lower != null && val <= lower) return false;\n      if (upper != null && val >= upper) return false;\n      update(root.right, val, upper);\n      update(root.left, lower, val);\n    }\n    return true;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\nclass Solution:\n    def isValidBST(self, root):\n        """\n        :type root: TreeNode\n        :rtype: bool\n        """\n        if not root:\n            return True\n            \n        stack = [(root, float(\'-inf\'), float(\'inf\')), ] \n        while stack:\n            root, lower, upper = stack.pop()\n            if not root:\n                continue\n            val = root.val\n            if val <= lower or val >= upper:\n                return False\n            stack.append((root.right, val, upper))\n            stack.append((root.left, lower, val))\n        return True  \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n复杂度分析\n\n * 时间复杂度 : O(N)O(N)O(N)。每个结点访问一次。\n * 空间复杂度 : O(N)O(N)O(N)。我们跟进了整棵树。\n   \n   \n\n\n\n\n# 方法三：中序遍历\n算法\n\n我们使用中序遍历 [https://leetcode-cn.com/problems/binary-tree-inorder-traversal/solution/er-cha-shu-de-zhong-xu-bian-li-by-leetcode/]左子树 -> 结点 -> 右子树的顺序。\n\n{:width=500} {:align=center}\n\n上面的结点按照访问的顺序标号，你可以按照 1-2-3-4-5 的顺序来比较不同的策略。\n\n左子树 -> 结点 -> 右子树 意味着对于二叉搜索树而言，每个元素都应该比下一个元素小。\n\n因此，具有 O(N){O}(N)O(N) 时间复杂度与 O(N){O}(N)O(N) 空间复杂度的算法十分简单:\n\n * 计算中序遍历列表 inorder.\n   \n   \n * 检查 inorder中的每个元素是否小于下一个。\n   \n   \n\n{:width=500} {:align=center}\n\n> 我们需要保留整个inorder列表吗？\n\n\n事实上不需要。每一步最后一个添加的元素就足以保证树是（或不是）二叉搜索树。 因此，我们可以将步骤整合并复用空间。\n\n实现\n\nclass Solution {\n  public boolean isValidBST(TreeNode root) {\n    Stack<TreeNode> stack = new Stack();\n    double inorder = - Double.MAX_VALUE;\n\n    while (!stack.isEmpty() || root != null) {\n      while (root != null) {\n        stack.push(root);\n        root = root.left;\n      }\n      root = stack.pop();\n      // If next element in inorder traversal\n      // is smaller than the previous one\n      // that\'s not BST.\n      if (root.val <= inorder) return false;\n      inorder = root.val;\n      root = root.right;\n    }\n    return true;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\nclass Solution:\n    def isValidBST(self, root):\n        """\n        :type root: TreeNode\n        :rtype: bool\n        """\n        stack, inorder = [], float(\'-inf\')\n        \n        while stack or root:\n            while root:\n                stack.append(root)\n                root = root.left\n            root = stack.pop()\n            # If next element in inorder traversal\n            # is smaller than the previous one\n            # that\'s not BST.\n            if root.val <= inorder:\n                return False\n            inorder = root.val\n            root = root.right\n\n        return True\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n复杂度分析\n\n * 时间复杂度 : 最坏情况下（树为二叉搜索树或破坏条件的元素是最右叶结点）为 O(N){O}(N)O(N)。\n   \n   \n * 空间复杂度 : O(N){O}(N)O(N) 用于存储 stack。\n   \n   \n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-09-08 16:55:55Accepted [https://leetcode-cn.com//submissions/detail/6749553/]2 ms38.76%N/Ajava2018-09-08 16:45:53Accepted [https://leetcode-cn.com//submissions/detail/6749125/]0 ms100.0%N/Ajava2018-09-08 16:24:52Wrong Answer [https://leetcode-cn.com//submissions/detail/6748003/]N/AN/AN/Ajava2018-09-08 16:24:33Wrong Answer [https://leetcode-cn.com//submissions/detail/6747983/]N/AN/AN/Ajava2018-09-08 16:24:18Compile Error [https://leetcode-cn.com//submissions/detail/6747970/]N/AN/AN/Ajava2018-09-08 16:23:53Compile Error [https://leetcode-cn.com//submissions/detail/6747947/]N/AN/AN/Ajava2018-09-08 16:23:43Compile Error [https://leetcode-cn.com//submissions/detail/6747933/]N/AN/AN/Ajava2018-09-08 16:23:41Compile Error [https://leetcode-cn.com//submissions/detail/6747928/]N/AN/AN/Ajava2018-09-08 16:20:02Runtime Error [https://leetcode-cn.com//submissions/detail/6747706/]N/AN/AN/Ajava2018-09-08 16:15:22Runtime Error [https://leetcode-cn.com//submissions/detail/6747464/]N/AN/AN/Ajava# 统计信息\n通过次数提交次数AC比率6104821496228.4%# 相似题目\n题目难度二叉树的中序遍历 [https://leetcode-cn.com/problems/binary-tree-inorder-traversal/]中等二叉搜索树中的众数 [https://leetcode-cn.com/problems/find-mode-in-binary-search-tree/]简单',contentLowercase:'# 中文题目\n给定一个二叉树，判断其是否是一个有效的二叉搜索树。\n\n假设一个二叉搜索树具有如下特征：\n\n * 节点的左子树只包含小于当前节点的数。\n * 节点的右子树只包含大于当前节点的数。\n * 所有左子树和右子树自身必须也是二叉搜索树。\n\n示例 1:\n\n输入:\n    2\n   / \\\n  1   3\n输出: true\n\n\n示例 2:\n\n输入:\n    5\n   / \\\n  1   4\n     / \\\n    3   6\n输出: false\n解释: 输入为: [5,1,4,null,null,3,6]。\n     根节点的值为 5 ，但是其右子节点值为 4 。\n\n\n# 通过代码\n/**\n * definition for a binary tree node.\n * public class treenode {\n *     int val;\n *     treenode left;\n *     treenode right;\n *     treenode(int x) { val = x; }\n * }\n */\nclass solution {\n//     public boolean isvalidbst(treenode root) {\n//         return isvalidbst(root,long.min_value,long.max_value);\n//     }\n\n//     private boolean isvalidbst(treenode root, long minvalue, long maxvalue) {\n//         if (root==null){\n//             return true;\n//         }\n//         if (root.val>=maxvalue||root.val<=minvalue){\n//             return false;\n//         }\n//         return isvalidbst(root.left,minvalue,root.val)&&isvalidbst(root.right,root.val,maxvalue);\n//     }\n        public boolean isvalidbst(treenode root) {\n\n        arraylist<integer> list = new arraylist<>();\n        inorder(root, list);\n        for(int i = 1 ; i < list.size() ; i ++)\n            if(list.get(i - 1) >= list.get(i))\n                return false;\n        return true;\n    }\n\n    private void inorder(treenode node, arraylist<integer> list){\n\n        if(node == null)\n            return;\n\n        inorder(node.left, list);\n        list.add(node.val);\n        inorder(node.right, list);\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n/**\n * definition for a binary tree node.\n * public class treenode {\n *     int val;\n *     treenode left;\n *     treenode right;\n *     treenode(int x) { val = x; }\n * }\n */\nclass solution {\n    public boolean isvalidbst(treenode root) {\n        return isvalidbst(root,long.min_value,long.max_value);\n    }\n\n    private boolean isvalidbst(treenode root, long minvalue, long maxvalue) {\n        if (root==null){\n            return true;\n        }\n        if (root.val>=maxvalue||root.val<=minvalue){\n            return false;\n        }\n        return isvalidbst(root.left,minvalue,root.val)&&isvalidbst(root.right,root.val,maxvalue);\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n# 官方题解\n# 树的定义\n首先，这是 treenode 的定义，后续会使用到。\n\n// definition for a binary tree node.\npublic class treenode {\n  int val;\n  treenode left;\n  treenode right;\n\n  treenode(int x) {\n    val = x;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n# definition for a binary tree node.\nclass treenode:\n    def __init__(self, x):\n        self.val = x\n        self.left = none\n        self.right = none\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n\n# 直觉\n乍一看，这是一个平凡的问题。只需要遍历整棵树，检查 node.right.val > node.val 和node.left.val < node.val 对每个结点是否成立。\n\n{:width=500} {:align=center}\n\n问题是，这种方法并不总是正确。不仅右子结点要大于该节点，整个右子树的元素都应该大于该节点。例如:\n\n{:width=500} {:align=center}\n\n这意味着我们需要在遍历树的同时保留结点的上界与下界，在比较时不仅比较子结点的值，也要与上下界比较。\n\n\n\n\n\n\n# 方法一: 递归\n上述思路可以用递归法实现。首先将结点的值与上界和下界（如果有）比较。然后，对左子树和右子树递归进行该过程。\n\n<,,,>\n\nclass solution {\n  public boolean helper(treenode node, integer lower, integer upper) {\n    if (node == null) return true;\n\n    int val = node.val;\n    if (lower != null && val <= lower) return false;\n    if (upper != null && val >= upper) return false;\n\n    if (! helper(node.right, val, upper)) return false;\n    if (! helper(node.left, lower, val)) return false;\n    return true;\n  }\n\n  public boolean isvalidbst(treenode root) {\n    return helper(root, null, null);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\nclass solution:\n    def isvalidbst(self, root):\n        """\n        :type root: treenode\n        :rtype: bool\n        """\n        def helper(node, lower = float(\'-inf\'), upper = float(\'inf\')):\n            if not node:\n                return true\n            \n            val = node.val\n            if val <= lower or val >= upper:\n                return false\n\n            if not helper(node.right, val, upper):\n                return false\n            if not helper(node.left, lower, val):\n                return false\n            return true\n\n        return helper(root)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n复杂度分析\n\n * 时间复杂度 : o(n)o(n)o(n)。每个结点访问一次。\n * 空间复杂度 : o(n)o(n)o(n)。我们跟进了整棵树。\n\n\n\n\n\n\n# 方法二: 迭代\n通过使用栈，上面的递归法可以转化为迭代法。这里使用深度优先搜索，比广度优先搜索要快一些。\n\nclass solution {\n  linkedlist<treenode> stack = new linkedlist();\n  linkedlist<integer> uppers = new linkedlist(),\n          lowers = new linkedlist();\n\n  public void update(treenode root, integer lower, integer upper) {\n    stack.add(root);\n    lowers.add(lower);\n    uppers.add(upper);\n  }\n\n  public boolean isvalidbst(treenode root) {\n    integer lower = null, upper = null, val;\n    update(root, lower, upper);\n\n    while (!stack.isempty()) {\n      root = stack.poll();\n      lower = lowers.poll();\n      upper = uppers.poll();\n\n      if (root == null) continue;\n      val = root.val;\n      if (lower != null && val <= lower) return false;\n      if (upper != null && val >= upper) return false;\n      update(root.right, val, upper);\n      update(root.left, lower, val);\n    }\n    return true;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\nclass solution:\n    def isvalidbst(self, root):\n        """\n        :type root: treenode\n        :rtype: bool\n        """\n        if not root:\n            return true\n            \n        stack = [(root, float(\'-inf\'), float(\'inf\')), ] \n        while stack:\n            root, lower, upper = stack.pop()\n            if not root:\n                continue\n            val = root.val\n            if val <= lower or val >= upper:\n                return false\n            stack.append((root.right, val, upper))\n            stack.append((root.left, lower, val))\n        return true  \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n复杂度分析\n\n * 时间复杂度 : o(n)o(n)o(n)。每个结点访问一次。\n * 空间复杂度 : o(n)o(n)o(n)。我们跟进了整棵树。\n   \n   \n\n\n\n\n# 方法三：中序遍历\n算法\n\n我们使用中序遍历 [https://leetcode-cn.com/problems/binary-tree-inorder-traversal/solution/er-cha-shu-de-zhong-xu-bian-li-by-leetcode/]左子树 -> 结点 -> 右子树的顺序。\n\n{:width=500} {:align=center}\n\n上面的结点按照访问的顺序标号，你可以按照 1-2-3-4-5 的顺序来比较不同的策略。\n\n左子树 -> 结点 -> 右子树 意味着对于二叉搜索树而言，每个元素都应该比下一个元素小。\n\n因此，具有 o(n){o}(n)o(n) 时间复杂度与 o(n){o}(n)o(n) 空间复杂度的算法十分简单:\n\n * 计算中序遍历列表 inorder.\n   \n   \n * 检查 inorder中的每个元素是否小于下一个。\n   \n   \n\n{:width=500} {:align=center}\n\n> 我们需要保留整个inorder列表吗？\n\n\n事实上不需要。每一步最后一个添加的元素就足以保证树是（或不是）二叉搜索树。 因此，我们可以将步骤整合并复用空间。\n\n实现\n\nclass solution {\n  public boolean isvalidbst(treenode root) {\n    stack<treenode> stack = new stack();\n    double inorder = - double.max_value;\n\n    while (!stack.isempty() || root != null) {\n      while (root != null) {\n        stack.push(root);\n        root = root.left;\n      }\n      root = stack.pop();\n      // if next element in inorder traversal\n      // is smaller than the previous one\n      // that\'s not bst.\n      if (root.val <= inorder) return false;\n      inorder = root.val;\n      root = root.right;\n    }\n    return true;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\nclass solution:\n    def isvalidbst(self, root):\n        """\n        :type root: treenode\n        :rtype: bool\n        """\n        stack, inorder = [], float(\'-inf\')\n        \n        while stack or root:\n            while root:\n                stack.append(root)\n                root = root.left\n            root = stack.pop()\n            # if next element in inorder traversal\n            # is smaller than the previous one\n            # that\'s not bst.\n            if root.val <= inorder:\n                return false\n            inorder = root.val\n            root = root.right\n\n        return true\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n复杂度分析\n\n * 时间复杂度 : 最坏情况下（树为二叉搜索树或破坏条件的元素是最右叶结点）为 o(n){o}(n)o(n)。\n   \n   \n * 空间复杂度 : o(n){o}(n)o(n) 用于存储 stack。\n   \n   \n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-09-08 16:55:55accepted [https://leetcode-cn.com//submissions/detail/6749553/]2 ms38.76%n/ajava2018-09-08 16:45:53accepted [https://leetcode-cn.com//submissions/detail/6749125/]0 ms100.0%n/ajava2018-09-08 16:24:52wrong answer [https://leetcode-cn.com//submissions/detail/6748003/]n/an/an/ajava2018-09-08 16:24:33wrong answer [https://leetcode-cn.com//submissions/detail/6747983/]n/an/an/ajava2018-09-08 16:24:18compile error [https://leetcode-cn.com//submissions/detail/6747970/]n/an/an/ajava2018-09-08 16:23:53compile error [https://leetcode-cn.com//submissions/detail/6747947/]n/an/an/ajava2018-09-08 16:23:43compile error [https://leetcode-cn.com//submissions/detail/6747933/]n/an/an/ajava2018-09-08 16:23:41compile error [https://leetcode-cn.com//submissions/detail/6747928/]n/an/an/ajava2018-09-08 16:20:02runtime error [https://leetcode-cn.com//submissions/detail/6747706/]n/an/an/ajava2018-09-08 16:15:22runtime error [https://leetcode-cn.com//submissions/detail/6747464/]n/an/an/ajava# 统计信息\n通过次数提交次数ac比率6104821496228.4%# 相似题目\n题目难度二叉树的中序遍历 [https://leetcode-cn.com/problems/binary-tree-inorder-traversal/]中等二叉搜索树中的众数 [https://leetcode-cn.com/problems/find-mode-in-binary-search-tree/]简单'},{title:"102-二叉树的层次遍历(Binary Tree Level Order Traversal)",frontmatter:{title:"102-二叉树的层次遍历(Binary Tree Level Order Traversal)",date:"2018-07-16T00:00:00.000Z",categories:["中等"],tags:["树<Tree>","广度优先搜索<Breadth-first Search>"]},regularPath:"/views/%E4%B8%AD%E7%AD%89/0102-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86.html",relativePath:"views/中等/0102-二叉树的层次遍历.md",key:"v-08021f6f",path:"/views/%E4%B8%AD%E7%AD%89/0102-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86.html",headers:[{level:2,title:"中文题目",slug:"中文题目",charIndex:2},{level:2,title:"通过代码",slug:"通过代码",charIndex:173},{level:2,title:"官方题解",slug:"官方题解",charIndex:3145},{level:2,title:"提交历史",slug:"提交历史",charIndex:8316},{level:2,title:"统计信息",slug:"统计信息",charIndex:8641},{level:2,title:"相似题目",slug:"相似题目",charIndex:8676}],lastUpdated:"4/11/2021, 1:15:21 PM",headersStr:"中文题目 通过代码 官方题解 提交历史 统计信息 相似题目",content:'# 中文题目\n给定一个二叉树，返回其按层次遍历的节点值。 （即逐层地，从左到右访问所有节点）。\n\n例如:\n给定二叉树:[3,9,20,null,null,15,7],\n\n    3\n   / \\\n  9  20\n    /  \\\n   15   7\n\n\n返回其层次遍历结果：\n\n[\n  [3],\n  [9,20],\n  [15,7]\n]\n\n\n# 通过代码\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Queue;\nclass Solution {\n    public List<List<Integer>> levelOrder(TreeNode root) {\n        Queue<TreeNode> queue = new LinkedList<TreeNode>();\n            List<List<Integer>> wrapList = new LinkedList<List<Integer>>();\n\n            if(root == null) return wrapList;\n\n            queue.offer(root);\n            while(!queue.isEmpty()){\n//                queueNum为该层元素的个数\n                int levelNum = queue.size();\n//                创建一个list把该层的元素全部装进去\n                List<Integer> subList = new LinkedList<Integer>();\n//                循环该层的元素个数次，把改成元素全部装进sublist\n                for(int i=0; i<levelNum; i++) {\n                    if(queue.peek().left != null) queue.offer(queue.peek().left);\n                    if(queue.peek().right != null) queue.offer(queue.peek().right);\n                    subList.add(queue.poll().val);\n                }\n                wrapList.add(subList);\n            }\n            return wrapList;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nimport java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nclass Solution {\n    public List<List<Integer>> levelOrder(TreeNode root) {\n        List<List<Integer>> res= new LinkedList<>();\n            LinkedList<Map<TreeNode,Integer>> queue=new LinkedList<>();\n        if (root==null){\n                return res;\n            }\n            Map<TreeNode,Integer> map1=new HashMap<>();\n            map1.put(root,0);\n            queue.add(map1);\n            while (!queue.isEmpty()){\n                TreeNode node = null;\n                int level = 0;\n                for (Map.Entry<TreeNode,Integer> e:queue.removeFirst().entrySet()) {\n                    node=e.getKey();\n                    level=e.getValue();\n                }\n                if (level==res.size()){\n                    res.add(new LinkedList<>());\n                }\n                res.get(level).add(node.val);\n                if (node.left!=null){\n                    Map<TreeNode,Integer> map=new HashMap<>();\n                    map.put(node.left,level+1);\n                    queue.add(map);\n                }\n                if (node.right!=null){\n                    Map<TreeNode,Integer> map=new HashMap<>();\n                    map.put(node.right,level+1);\n                    queue.add(map);\n                }\n            }\n            return res;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n# 官方题解\n# 如何遍历一棵树\n有两种通用的遍历树的策略：\n\n * 深度优先搜索（DFS）\n   \n   在这个策略中，我们采用深度作为优先级，以便从跟开始一直到达某个确定的叶子，然后再返回根到达另一个分支。\n   \n   深度优先搜索策略又可以根据根节点、左孩子和右孩子的相对顺序被细分为先序遍历，中序遍历和后序遍历。\n   \n   \n * 宽度优先搜索（BFS）\n   \n   我们按照高度顺序一层一层的访问整棵树，高层次的节点将会比低层次的节点先被访问到。\n   \n   \n\n下图中的顶点按照访问的顺序编号，按照 1-2-3-4-5 的顺序来比较不同的策略。\n\n{:width="450px"} {:align=center}\n\n本问题就是用宽度优先搜索遍历来划分层次：[[1], [2, 3], [4, 5]]。\n\n# 方法 1：递归\n算法\n\n最简单的解法就是递归，首先确认树非空，然后调用递归函数 helper(node, level)，参数是当前节点和节点的层次。程序过程如下：\n\n * 输出列表称为 levels，当前最高层数就是列表的长度 len(levels)。比较访问节点所在的层次 level 和当前最高层次 len(levels) 的大小，如果前者更大就向 levels 添加一个空列表。\n * 将当前节点插入到对应层的列表 levels[level] 中。\n * 递归非空的孩子节点：helper(node.left / node.right, level + 1)。\n\n实现\n\n<,,,,,,,,,,,,,,>\n\nclass Solution:\n    def levelOrder(self, root):\n        """\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        """\n        levels = []\n        if not root:\n            return levels\n        \n        def helper(node, level):\n            # start the current level\n            if len(levels) == level:\n                levels.append([])\n\n            # append the current node value\n            levels[level].append(node.val)\n\n            # process child nodes for the next level\n            if node.left:\n                helper(node.left, level + 1)\n            if node.right:\n                helper(node.right, level + 1)\n            \n        helper(root, 0)\n        return levels\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\nclass Solution {\n    List<List<Integer>> levels = new ArrayList<List<Integer>>();\n\n    public void helper(TreeNode node, int level) {\n        // start the current level\n        if (levels.size() == level)\n            levels.add(new ArrayList<Integer>());\n\n         // fulfil the current level\n         levels.get(level).add(node.val);\n\n         // process child nodes for the next level\n         if (node.left != null)\n            helper(node.left, level + 1);\n         if (node.right != null)\n            helper(node.right, level + 1);\n    }\n    \n    public List<List<Integer>> levelOrder(TreeNode root) {\n        if (root == null) return levels;\n        helper(root, 0);\n        return levels;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n复杂度分析\n\n * 时间复杂度：O(N)O(N)O(N)，因为每个节点恰好会被运算一次。\n * 空间复杂度：O(N)O(N)O(N)，保存输出结果的数组包含 N 个节点的值。\n\n# 方法 2：迭代\n算法\n\n上面的递归方法也可以写成迭代的形式。\n\n我们将树上顶点按照层次依次放入队列结构中，队列中元素满足 FIFO（先进先出）的原则。在 Java 中可以使用 Queue 接口中的 LinkedList [https://docs.oracle.com/javase/7/docs/api/java/util/Queue.html]实现。在 Python 中如果使用 Queue [https://docs.python.org/3/library/queue.html] 结构，但因为它是为多线程之间安全交换而设计的，所以使用了锁，会导致性能不佳。因此在 Python 中可以使用 deque [https://docs.python.org/3/library/collections.html#collections.deque] 的 append() 和 popleft() 函数来快速实现队列的功能。\n\n第 0 层只包含根节点 root ，算法实现如下：\n\n * 初始化队列只包含一个节点 root 和层次编号 0 ： level = 0。\n * 当队列非空的时候： * 在输出结果 levels 中插入一个空列表，开始当前层的算法。\n    * 计算当前层有多少个元素：等于队列的长度。\n    * 将这些元素从队列中弹出，并加入 levels 当前层的空列表中。\n    * 将他们的孩子节点作为下一层压入队列中。\n    * 进入下一层 level++。\n   \n   \n\n实现\n\nfrom collections import deque\nclass Solution:\n    def levelOrder(self, root):\n        """\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        """\n        levels = []\n        if not root:\n            return levels\n        \n        level = 0\n        queue = deque([root,])\n        while queue:\n            # start the current level\n            levels.append([])\n            # number of elements in the current level \n            level_length = len(queue)\n            \n            for i in range(level_length):\n                node = queue.popleft()\n                # fulfill the current level\n                levels[level].append(node.val)\n                \n                # add child nodes of the current level\n                # in the queue for the next level\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            \n            # go to next level\n            level += 1\n        \n        return levels\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\nclass Solution {\n  public List<List<Integer>> levelOrder(TreeNode root) {\n    List<List<Integer>> levels = new ArrayList<List<Integer>>();\n    if (root == null) return levels;\n\n    Queue<TreeNode> queue = new LinkedList<TreeNode>();\n    queue.add(root);\n    int level = 0;\n    while ( !queue.isEmpty() ) {\n      // start the current level\n      levels.add(new ArrayList<Integer>());\n\n      // number of elements in the current level\n      int level_length = queue.size();\n      for(int i = 0; i < level_length; ++i) {\n        TreeNode node = queue.remove();\n\n        // fulfill the current level\n        levels.get(level).add(node.val);\n\n        // add child nodes of the current level\n        // in the queue for the next level\n        if (node.left != null) queue.add(node.left);\n        if (node.right != null) queue.add(node.right);\n      }\n      // go to next level\n      level++;\n    }\n    return levels;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n复杂度分析\n\n * 时间复杂度：O(N)O(N)O(N)，因为每个节点恰好会被运算一次。\n * 空间复杂度：O(N)O(N)O(N)，保存输出结果的数组包含 N 个节点的值。\n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-07-16 21:40:13Accepted [https://leetcode-cn.com//submissions/detail/4255447/]2 ms21.42%N/Ajava2018-07-16 21:28:28Accepted [https://leetcode-cn.com//submissions/detail/4254949/]7 ms5.3%N/Ajava2018-07-16 21:26:22Runtime Error [https://leetcode-cn.com//submissions/detail/4254869/]N/AN/AN/Ajava# 统计信息\n通过次数提交次数AC比率7089511747660.3%# 相似题目\n题目难度二叉树的锯齿形层次遍历 [https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/]中等二叉树的层次遍历 II [https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/]简单二叉树的最小深度 [https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/]简单二叉树的垂直遍历 [https://leetcode-cn.com/problems/binary-tree-vertical-order-traversal/]中等二叉树的层平均值 [https://leetcode-cn.com/problems/average-of-levels-in-binary-tree/]简单N叉树的层序遍历 [https://leetcode-cn.com/problems/n-ary-tree-level-order-traversal/]中等二叉树的堂兄弟节点 [https://leetcode-cn.com/problems/cousins-in-binary-tree/]简单',contentLowercase:'# 中文题目\n给定一个二叉树，返回其按层次遍历的节点值。 （即逐层地，从左到右访问所有节点）。\n\n例如:\n给定二叉树:[3,9,20,null,null,15,7],\n\n    3\n   / \\\n  9  20\n    /  \\\n   15   7\n\n\n返回其层次遍历结果：\n\n[\n  [3],\n  [9,20],\n  [15,7]\n]\n\n\n# 通过代码\n/**\n * definition for a binary tree node.\n * public class treenode {\n *     int val;\n *     treenode left;\n *     treenode right;\n *     treenode(int x) { val = x; }\n * }\n */\nimport java.util.linkedlist;\nimport java.util.list;\nimport java.util.queue;\nclass solution {\n    public list<list<integer>> levelorder(treenode root) {\n        queue<treenode> queue = new linkedlist<treenode>();\n            list<list<integer>> wraplist = new linkedlist<list<integer>>();\n\n            if(root == null) return wraplist;\n\n            queue.offer(root);\n            while(!queue.isempty()){\n//                queuenum为该层元素的个数\n                int levelnum = queue.size();\n//                创建一个list把该层的元素全部装进去\n                list<integer> sublist = new linkedlist<integer>();\n//                循环该层的元素个数次，把改成元素全部装进sublist\n                for(int i=0; i<levelnum; i++) {\n                    if(queue.peek().left != null) queue.offer(queue.peek().left);\n                    if(queue.peek().right != null) queue.offer(queue.peek().right);\n                    sublist.add(queue.poll().val);\n                }\n                wraplist.add(sublist);\n            }\n            return wraplist;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n/**\n * definition for a binary tree node.\n * public class treenode {\n *     int val;\n *     treenode left;\n *     treenode right;\n *     treenode(int x) { val = x; }\n * }\n */\nimport java.util.hashmap;\nimport java.util.linkedlist;\nimport java.util.list;\nimport java.util.map;\nclass solution {\n    public list<list<integer>> levelorder(treenode root) {\n        list<list<integer>> res= new linkedlist<>();\n            linkedlist<map<treenode,integer>> queue=new linkedlist<>();\n        if (root==null){\n                return res;\n            }\n            map<treenode,integer> map1=new hashmap<>();\n            map1.put(root,0);\n            queue.add(map1);\n            while (!queue.isempty()){\n                treenode node = null;\n                int level = 0;\n                for (map.entry<treenode,integer> e:queue.removefirst().entryset()) {\n                    node=e.getkey();\n                    level=e.getvalue();\n                }\n                if (level==res.size()){\n                    res.add(new linkedlist<>());\n                }\n                res.get(level).add(node.val);\n                if (node.left!=null){\n                    map<treenode,integer> map=new hashmap<>();\n                    map.put(node.left,level+1);\n                    queue.add(map);\n                }\n                if (node.right!=null){\n                    map<treenode,integer> map=new hashmap<>();\n                    map.put(node.right,level+1);\n                    queue.add(map);\n                }\n            }\n            return res;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n# 官方题解\n# 如何遍历一棵树\n有两种通用的遍历树的策略：\n\n * 深度优先搜索（dfs）\n   \n   在这个策略中，我们采用深度作为优先级，以便从跟开始一直到达某个确定的叶子，然后再返回根到达另一个分支。\n   \n   深度优先搜索策略又可以根据根节点、左孩子和右孩子的相对顺序被细分为先序遍历，中序遍历和后序遍历。\n   \n   \n * 宽度优先搜索（bfs）\n   \n   我们按照高度顺序一层一层的访问整棵树，高层次的节点将会比低层次的节点先被访问到。\n   \n   \n\n下图中的顶点按照访问的顺序编号，按照 1-2-3-4-5 的顺序来比较不同的策略。\n\n{:width="450px"} {:align=center}\n\n本问题就是用宽度优先搜索遍历来划分层次：[[1], [2, 3], [4, 5]]。\n\n# 方法 1：递归\n算法\n\n最简单的解法就是递归，首先确认树非空，然后调用递归函数 helper(node, level)，参数是当前节点和节点的层次。程序过程如下：\n\n * 输出列表称为 levels，当前最高层数就是列表的长度 len(levels)。比较访问节点所在的层次 level 和当前最高层次 len(levels) 的大小，如果前者更大就向 levels 添加一个空列表。\n * 将当前节点插入到对应层的列表 levels[level] 中。\n * 递归非空的孩子节点：helper(node.left / node.right, level + 1)。\n\n实现\n\n<,,,,,,,,,,,,,,>\n\nclass solution:\n    def levelorder(self, root):\n        """\n        :type root: treenode\n        :rtype: list[list[int]]\n        """\n        levels = []\n        if not root:\n            return levels\n        \n        def helper(node, level):\n            # start the current level\n            if len(levels) == level:\n                levels.append([])\n\n            # append the current node value\n            levels[level].append(node.val)\n\n            # process child nodes for the next level\n            if node.left:\n                helper(node.left, level + 1)\n            if node.right:\n                helper(node.right, level + 1)\n            \n        helper(root, 0)\n        return levels\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\nclass solution {\n    list<list<integer>> levels = new arraylist<list<integer>>();\n\n    public void helper(treenode node, int level) {\n        // start the current level\n        if (levels.size() == level)\n            levels.add(new arraylist<integer>());\n\n         // fulfil the current level\n         levels.get(level).add(node.val);\n\n         // process child nodes for the next level\n         if (node.left != null)\n            helper(node.left, level + 1);\n         if (node.right != null)\n            helper(node.right, level + 1);\n    }\n    \n    public list<list<integer>> levelorder(treenode root) {\n        if (root == null) return levels;\n        helper(root, 0);\n        return levels;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n复杂度分析\n\n * 时间复杂度：o(n)o(n)o(n)，因为每个节点恰好会被运算一次。\n * 空间复杂度：o(n)o(n)o(n)，保存输出结果的数组包含 n 个节点的值。\n\n# 方法 2：迭代\n算法\n\n上面的递归方法也可以写成迭代的形式。\n\n我们将树上顶点按照层次依次放入队列结构中，队列中元素满足 fifo（先进先出）的原则。在 java 中可以使用 queue 接口中的 linkedlist [https://docs.oracle.com/javase/7/docs/api/java/util/queue.html]实现。在 python 中如果使用 queue [https://docs.python.org/3/library/queue.html] 结构，但因为它是为多线程之间安全交换而设计的，所以使用了锁，会导致性能不佳。因此在 python 中可以使用 deque [https://docs.python.org/3/library/collections.html#collections.deque] 的 append() 和 popleft() 函数来快速实现队列的功能。\n\n第 0 层只包含根节点 root ，算法实现如下：\n\n * 初始化队列只包含一个节点 root 和层次编号 0 ： level = 0。\n * 当队列非空的时候： * 在输出结果 levels 中插入一个空列表，开始当前层的算法。\n    * 计算当前层有多少个元素：等于队列的长度。\n    * 将这些元素从队列中弹出，并加入 levels 当前层的空列表中。\n    * 将他们的孩子节点作为下一层压入队列中。\n    * 进入下一层 level++。\n   \n   \n\n实现\n\nfrom collections import deque\nclass solution:\n    def levelorder(self, root):\n        """\n        :type root: treenode\n        :rtype: list[list[int]]\n        """\n        levels = []\n        if not root:\n            return levels\n        \n        level = 0\n        queue = deque([root,])\n        while queue:\n            # start the current level\n            levels.append([])\n            # number of elements in the current level \n            level_length = len(queue)\n            \n            for i in range(level_length):\n                node = queue.popleft()\n                # fulfill the current level\n                levels[level].append(node.val)\n                \n                # add child nodes of the current level\n                # in the queue for the next level\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            \n            # go to next level\n            level += 1\n        \n        return levels\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\nclass solution {\n  public list<list<integer>> levelorder(treenode root) {\n    list<list<integer>> levels = new arraylist<list<integer>>();\n    if (root == null) return levels;\n\n    queue<treenode> queue = new linkedlist<treenode>();\n    queue.add(root);\n    int level = 0;\n    while ( !queue.isempty() ) {\n      // start the current level\n      levels.add(new arraylist<integer>());\n\n      // number of elements in the current level\n      int level_length = queue.size();\n      for(int i = 0; i < level_length; ++i) {\n        treenode node = queue.remove();\n\n        // fulfill the current level\n        levels.get(level).add(node.val);\n\n        // add child nodes of the current level\n        // in the queue for the next level\n        if (node.left != null) queue.add(node.left);\n        if (node.right != null) queue.add(node.right);\n      }\n      // go to next level\n      level++;\n    }\n    return levels;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n复杂度分析\n\n * 时间复杂度：o(n)o(n)o(n)，因为每个节点恰好会被运算一次。\n * 空间复杂度：o(n)o(n)o(n)，保存输出结果的数组包含 n 个节点的值。\n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-07-16 21:40:13accepted [https://leetcode-cn.com//submissions/detail/4255447/]2 ms21.42%n/ajava2018-07-16 21:28:28accepted [https://leetcode-cn.com//submissions/detail/4254949/]7 ms5.3%n/ajava2018-07-16 21:26:22runtime error [https://leetcode-cn.com//submissions/detail/4254869/]n/an/an/ajava# 统计信息\n通过次数提交次数ac比率7089511747660.3%# 相似题目\n题目难度二叉树的锯齿形层次遍历 [https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/]中等二叉树的层次遍历 ii [https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/]简单二叉树的最小深度 [https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/]简单二叉树的垂直遍历 [https://leetcode-cn.com/problems/binary-tree-vertical-order-traversal/]中等二叉树的层平均值 [https://leetcode-cn.com/problems/average-of-levels-in-binary-tree/]简单n叉树的层序遍历 [https://leetcode-cn.com/problems/n-ary-tree-level-order-traversal/]中等二叉树的堂兄弟节点 [https://leetcode-cn.com/problems/cousins-in-binary-tree/]简单'},{title:"113-路径总和 II(Path Sum II)",frontmatter:{title:"113-路径总和 II(Path Sum II)",date:"2018-09-07T00:00:00.000Z",categories:["中等"],tags:["树<Tree>","深度优先搜索<Depth-first Search>"]},regularPath:"/views/%E4%B8%AD%E7%AD%89/0113-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C%20II.html",relativePath:"views/中等/0113-路径总和 II.md",key:"v-4fb1a763",path:"/views/%E4%B8%AD%E7%AD%89/0113-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C%20II.html",headers:[{level:2,title:"中文题目",slug:"中文题目",charIndex:2},{level:2,title:"通过代码",slug:"通过代码",charIndex:275},{level:2,title:"高赞题解",slug:"高赞题解",charIndex:1488},{level:2,title:"思路:",slug:"思路",charIndex:1495},{level:2,title:"提交历史",slug:"提交历史",charIndex:2847},{level:2,title:"统计信息",slug:"统计信息",charIndex:3173},{level:2,title:"相似题目",slug:"相似题目",charIndex:3207}],lastUpdated:"4/11/2021, 1:15:21 PM",headersStr:"中文题目 通过代码 高赞题解 思路: 提交历史 统计信息 相似题目",content:"# 中文题目\n给定一个二叉树和一个目标和，找到所有从根节点到叶子节点路径总和等于给定目标和的路径。\n\n说明:叶子节点是指没有子节点的节点。\n\n示例:\n给定如下二叉树，以及目标和sum = 22，\n\n              5\n             / \\\n            4   8\n           /   / \\\n          11  13  4\n         /  \\    / \\\n        7    2  5   1\n\n\n返回:\n\n[\n   [5,4,11,2],\n   [5,8,4,5]\n]\n\n\n# 通过代码\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public List<List<Integer>> pathSum(TreeNode root, int sum) {\n        List<List<Integer>> result = new LinkedList<List<Integer>>();\n        List<Integer> currentResult = new LinkedList<Integer>();\n        pathSum(root, sum, currentResult, result);\n        return result;\n    }\n\n    private void pathSum(TreeNode root, int sum, List<Integer> currentResult, List<List<Integer>> result) {\n        if (root ==null) {\n            return;\n        }\n        currentResult.add(new Integer(root.val));\n        if (root.left==null && root.right==null && sum==root.val){\n            result.add(new LinkedList<Integer>(currentResult));\n            currentResult.remove(currentResult.size()-1);\n            return;\n        }else {\n            pathSum(root.left,sum-root.val,currentResult,result);\n            pathSum(root.right,sum-root.val,currentResult,result);\n        }\n        currentResult.remove(currentResult.size()-1);\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n# 高赞题解\n# 思路:\n和上一题一样, 用DFS只不过在遍历时候,要记录val而已\n\ndef pathSum(self, root: TreeNode, sum: int) -> List[List[int]]:\n        res = []\n        if not root: return []\n        def helper(root,sum, tmp):\n            if not root:\n                return \n            if not root.left and not root.right and sum - root.val == 0 :\n                tmp += [root.val]\n                res.append(tmp)\n                return \n            helper(root.left, sum - root.val, tmp + [root.val])\n            helper(root.right, sum - root.val, tmp + [root.val])\n        helper(root, sum, [])\n        return res\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\nclass Solution {\n    public List<List<Integer>> pathSum(TreeNode root, int sum) {\n        List<List<Integer>> res = new ArrayList<>();\n        helper(root, sum, res, new ArrayList<Integer>());\n        return res;\n    }\n\n    private void helper(TreeNode root, int sum, List<List<Integer>> res, ArrayList<Integer> tmp) {\n        if (root == null) return;\n        tmp.add(root.val);\n        if (root.left == null && root.right == null && sum - root.val == 0) res.add(new ArrayList<>(tmp));\n        helper(root.left, sum - root.val, res, tmp);\n        helper(root.right, sum - root.val, res, tmp);\n        tmp.remove(tmp.size() - 1);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n相关题型 : 112. 路径总和 [https://leetcode-cn.com/problems/path-sum/]\n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-09-07 17:34:43Accepted [https://leetcode-cn.com//submissions/detail/6709900/]5 ms10.35%N/Ajava2018-09-07 17:16:55Wrong Answer [https://leetcode-cn.com//submissions/detail/6708760/]N/AN/AN/Ajava2018-09-07 17:08:57Wrong Answer [https://leetcode-cn.com//submissions/detail/6708205/]N/AN/AN/Ajava# 统计信息\n通过次数提交次数AC比率262264522558.0%# 相似题目\n题目难度路径总和 [https://leetcode-cn.com/problems/path-sum/]简单二叉树的所有路径 [https://leetcode-cn.com/problems/binary-tree-paths/]简单路径总和 III [https://leetcode-cn.com/problems/path-sum-iii/]简单路径和 IV [https://leetcode-cn.com/problems/path-sum-iv/]中等",contentLowercase:"# 中文题目\n给定一个二叉树和一个目标和，找到所有从根节点到叶子节点路径总和等于给定目标和的路径。\n\n说明:叶子节点是指没有子节点的节点。\n\n示例:\n给定如下二叉树，以及目标和sum = 22，\n\n              5\n             / \\\n            4   8\n           /   / \\\n          11  13  4\n         /  \\    / \\\n        7    2  5   1\n\n\n返回:\n\n[\n   [5,4,11,2],\n   [5,8,4,5]\n]\n\n\n# 通过代码\n/**\n * definition for a binary tree node.\n * public class treenode {\n *     int val;\n *     treenode left;\n *     treenode right;\n *     treenode(int x) { val = x; }\n * }\n */\nclass solution {\n    public list<list<integer>> pathsum(treenode root, int sum) {\n        list<list<integer>> result = new linkedlist<list<integer>>();\n        list<integer> currentresult = new linkedlist<integer>();\n        pathsum(root, sum, currentresult, result);\n        return result;\n    }\n\n    private void pathsum(treenode root, int sum, list<integer> currentresult, list<list<integer>> result) {\n        if (root ==null) {\n            return;\n        }\n        currentresult.add(new integer(root.val));\n        if (root.left==null && root.right==null && sum==root.val){\n            result.add(new linkedlist<integer>(currentresult));\n            currentresult.remove(currentresult.size()-1);\n            return;\n        }else {\n            pathsum(root.left,sum-root.val,currentresult,result);\n            pathsum(root.right,sum-root.val,currentresult,result);\n        }\n        currentresult.remove(currentresult.size()-1);\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n# 高赞题解\n# 思路:\n和上一题一样, 用dfs只不过在遍历时候,要记录val而已\n\ndef pathsum(self, root: treenode, sum: int) -> list[list[int]]:\n        res = []\n        if not root: return []\n        def helper(root,sum, tmp):\n            if not root:\n                return \n            if not root.left and not root.right and sum - root.val == 0 :\n                tmp += [root.val]\n                res.append(tmp)\n                return \n            helper(root.left, sum - root.val, tmp + [root.val])\n            helper(root.right, sum - root.val, tmp + [root.val])\n        helper(root, sum, [])\n        return res\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\nclass solution {\n    public list<list<integer>> pathsum(treenode root, int sum) {\n        list<list<integer>> res = new arraylist<>();\n        helper(root, sum, res, new arraylist<integer>());\n        return res;\n    }\n\n    private void helper(treenode root, int sum, list<list<integer>> res, arraylist<integer> tmp) {\n        if (root == null) return;\n        tmp.add(root.val);\n        if (root.left == null && root.right == null && sum - root.val == 0) res.add(new arraylist<>(tmp));\n        helper(root.left, sum - root.val, res, tmp);\n        helper(root.right, sum - root.val, res, tmp);\n        tmp.remove(tmp.size() - 1);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n相关题型 : 112. 路径总和 [https://leetcode-cn.com/problems/path-sum/]\n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-09-07 17:34:43accepted [https://leetcode-cn.com//submissions/detail/6709900/]5 ms10.35%n/ajava2018-09-07 17:16:55wrong answer [https://leetcode-cn.com//submissions/detail/6708760/]n/an/an/ajava2018-09-07 17:08:57wrong answer [https://leetcode-cn.com//submissions/detail/6708205/]n/an/an/ajava# 统计信息\n通过次数提交次数ac比率262264522558.0%# 相似题目\n题目难度路径总和 [https://leetcode-cn.com/problems/path-sum/]简单二叉树的所有路径 [https://leetcode-cn.com/problems/binary-tree-paths/]简单路径总和 iii [https://leetcode-cn.com/problems/path-sum-iii/]简单路径和 iv [https://leetcode-cn.com/problems/path-sum-iv/]中等"},{title:"103-二叉树的锯齿形层次遍历(Binary Tree Zigzag Level Order Traversal)",frontmatter:{title:"103-二叉树的锯齿形层次遍历(Binary Tree Zigzag Level Order Traversal)",date:"2018-09-05T00:00:00.000Z",categories:["中等"],tags:["栈<Stack>","树<Tree>","广度优先搜索<Breadth-first Search>"]},regularPath:"/views/%E4%B8%AD%E7%AD%89/0103-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%94%AF%E9%BD%BF%E5%BD%A2%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86.html",relativePath:"views/中等/0103-二叉树的锯齿形层次遍历.md",key:"v-b7e2d1be",path:"/views/%E4%B8%AD%E7%AD%89/0103-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%94%AF%E9%BD%BF%E5%BD%A2%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86.html",headers:[{level:2,title:"中文题目",slug:"中文题目",charIndex:2},{level:2,title:"通过代码",slug:"通过代码",charIndex:194},{level:2,title:"高赞题解",slug:"高赞题解",charIndex:1201},{level:2,title:"提交历史",slug:"提交历史",charIndex:2645},{level:2,title:"统计信息",slug:"统计信息",charIndex:3366},{level:2,title:"相似题目",slug:"相似题目",charIndex:3400}],lastUpdated:"4/11/2021, 1:15:21 PM",headersStr:"中文题目 通过代码 高赞题解 提交历史 统计信息 相似题目",content:"# 中文题目\n给定一个二叉树，返回其节点值的锯齿形层次遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。\n\n例如：\n给定二叉树[3,9,20,null,null,15,7],\n\n    3\n   / \\\n  9  20\n    /  \\\n   15   7\n\n\n返回锯齿形层次遍历如下：\n\n[\n  [3],\n  [20,9],\n  [15,7]\n]\n\n\n# 通过代码\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\npublic class Solution {\n    public List<List<Integer>> zigzagLevelOrder(TreeNode root) \n    {\n        List<List<Integer>> sol = new ArrayList<>();\n        travel(root, sol, 0);\n        return sol;\n    }\n    \n    private void travel(TreeNode curr, List<List<Integer>> sol, int level)\n    {\n        if(curr == null) return;\n        \n        if(sol.size() <= level)\n        {\n            List<Integer> newLevel = new LinkedList<>();\n            sol.add(newLevel);\n        }\n        \n        List<Integer> collection  = sol.get(level);\n        if(level % 2 == 0) collection.add(curr.val);\n        else collection.add(0, curr.val);\n        \n        travel(curr.left, sol, level + 1);\n        travel(curr.right, sol, level + 1);\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n# 高赞题解\n大家的做法大都是list或者queue反转，但是这是耗时操作，特别是queue自身并不支持反转（list在c++是双向链表，可以相当于有反转功能），用reverse我觉得可能是耗时的，我的解法是两个stack各自保存一层数据，然后先进后出的特性加上左右节点先后入栈的顺序细节（具体谁先谁后可以看代码）即可恰好对应zigZag的Z字形访问顺序：\n\n我的提交执行用时 已经战胜 96.52 % 的 cpp 提交记录\n\n    vector<vector<int>> zigzagLevelOrder(TreeNode *root) {\n        //右往左时右先入栈，左往右时，左先入栈。然后要两个栈分别保存每一层级的。\n        //这里借鉴了树的层次遍历的思想，不过那是用队列\n        vector<vector<int>> r;\n        if (!root) return r;\n        stack<TreeNode *> d1, d2;\n        d1.push(root);\n        TreeNode *curr = nullptr;\n        vector<int> tmp;\n        while (true) {\n            while (!d1.empty()) {\n                curr = d1.top();\n                d1.pop();\n                tmp.push_back(curr->val);\n                if (curr->left) d2.push(curr->left);\n                if (curr->right) d2.push(curr->right);\n            }\n            if (!tmp.empty()) {\n                r.push_back(tmp);\n                tmp.clear();\n            } else break;\n\n            while (!d2.empty()) {\n                curr = d2.top();\n                d2.pop();\n                tmp.push_back(curr->val);\n                if (curr->right) d1.push(curr->right);\n                if (curr->left) d1.push(curr->left);\n            }\n            if (!tmp.empty()) {\n                r.push_back(tmp);\n                tmp.clear();\n            } else break;\n        }\n        return r;\n    };\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-09-05 20:32:28Accepted [https://leetcode-cn.com//submissions/detail/6601980/]2 ms22.6%N/Ajava2018-09-05 20:19:22Wrong Answer [https://leetcode-cn.com//submissions/detail/6601211/]N/AN/AN/Ajava2018-09-05 20:01:02Wrong Answer [https://leetcode-cn.com//submissions/detail/6600085/]N/AN/AN/Ajava2018-09-05 19:59:05Wrong Answer [https://leetcode-cn.com//submissions/detail/6599985/]N/AN/AN/Ajava2018-09-05 19:54:11Wrong Answer [https://leetcode-cn.com//submissions/detail/6599728/]N/AN/AN/Ajava2018-09-05 19:52:32Wrong Answer [https://leetcode-cn.com//submissions/detail/6599632/]N/AN/AN/Ajava2018-09-05 19:52:00Wrong Answer [https://leetcode-cn.com//submissions/detail/6599605/]N/AN/AN/Ajava# 统计信息\n通过次数提交次数AC比率285665387453.0%# 相似题目\n题目难度二叉树的层次遍历 [https://leetcode-cn.com/problems/binary-tree-level-order-traversal/]中等",contentLowercase:"# 中文题目\n给定一个二叉树，返回其节点值的锯齿形层次遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。\n\n例如：\n给定二叉树[3,9,20,null,null,15,7],\n\n    3\n   / \\\n  9  20\n    /  \\\n   15   7\n\n\n返回锯齿形层次遍历如下：\n\n[\n  [3],\n  [20,9],\n  [15,7]\n]\n\n\n# 通过代码\n/**\n * definition for a binary tree node.\n * public class treenode {\n *     int val;\n *     treenode left;\n *     treenode right;\n *     treenode(int x) { val = x; }\n * }\n */\npublic class solution {\n    public list<list<integer>> zigzaglevelorder(treenode root) \n    {\n        list<list<integer>> sol = new arraylist<>();\n        travel(root, sol, 0);\n        return sol;\n    }\n    \n    private void travel(treenode curr, list<list<integer>> sol, int level)\n    {\n        if(curr == null) return;\n        \n        if(sol.size() <= level)\n        {\n            list<integer> newlevel = new linkedlist<>();\n            sol.add(newlevel);\n        }\n        \n        list<integer> collection  = sol.get(level);\n        if(level % 2 == 0) collection.add(curr.val);\n        else collection.add(0, curr.val);\n        \n        travel(curr.left, sol, level + 1);\n        travel(curr.right, sol, level + 1);\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n# 高赞题解\n大家的做法大都是list或者queue反转，但是这是耗时操作，特别是queue自身并不支持反转（list在c++是双向链表，可以相当于有反转功能），用reverse我觉得可能是耗时的，我的解法是两个stack各自保存一层数据，然后先进后出的特性加上左右节点先后入栈的顺序细节（具体谁先谁后可以看代码）即可恰好对应zigzag的z字形访问顺序：\n\n我的提交执行用时 已经战胜 96.52 % 的 cpp 提交记录\n\n    vector<vector<int>> zigzaglevelorder(treenode *root) {\n        //右往左时右先入栈，左往右时，左先入栈。然后要两个栈分别保存每一层级的。\n        //这里借鉴了树的层次遍历的思想，不过那是用队列\n        vector<vector<int>> r;\n        if (!root) return r;\n        stack<treenode *> d1, d2;\n        d1.push(root);\n        treenode *curr = nullptr;\n        vector<int> tmp;\n        while (true) {\n            while (!d1.empty()) {\n                curr = d1.top();\n                d1.pop();\n                tmp.push_back(curr->val);\n                if (curr->left) d2.push(curr->left);\n                if (curr->right) d2.push(curr->right);\n            }\n            if (!tmp.empty()) {\n                r.push_back(tmp);\n                tmp.clear();\n            } else break;\n\n            while (!d2.empty()) {\n                curr = d2.top();\n                d2.pop();\n                tmp.push_back(curr->val);\n                if (curr->right) d1.push(curr->right);\n                if (curr->left) d1.push(curr->left);\n            }\n            if (!tmp.empty()) {\n                r.push_back(tmp);\n                tmp.clear();\n            } else break;\n        }\n        return r;\n    };\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-09-05 20:32:28accepted [https://leetcode-cn.com//submissions/detail/6601980/]2 ms22.6%n/ajava2018-09-05 20:19:22wrong answer [https://leetcode-cn.com//submissions/detail/6601211/]n/an/an/ajava2018-09-05 20:01:02wrong answer [https://leetcode-cn.com//submissions/detail/6600085/]n/an/an/ajava2018-09-05 19:59:05wrong answer [https://leetcode-cn.com//submissions/detail/6599985/]n/an/an/ajava2018-09-05 19:54:11wrong answer [https://leetcode-cn.com//submissions/detail/6599728/]n/an/an/ajava2018-09-05 19:52:32wrong answer [https://leetcode-cn.com//submissions/detail/6599632/]n/an/an/ajava2018-09-05 19:52:00wrong answer [https://leetcode-cn.com//submissions/detail/6599605/]n/an/an/ajava# 统计信息\n通过次数提交次数ac比率285665387453.0%# 相似题目\n题目难度二叉树的层次遍历 [https://leetcode-cn.com/problems/binary-tree-level-order-traversal/]中等"},{title:"120-三角形最小路径和(Triangle)",frontmatter:{title:"120-三角形最小路径和(Triangle)",date:"2018-09-14T00:00:00.000Z",categories:["中等"],tags:["数组<Array>","动态规划<Dynamic Programming>"]},regularPath:"/views/%E4%B8%AD%E7%AD%89/0120-%E4%B8%89%E8%A7%92%E5%BD%A2%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C.html",relativePath:"views/中等/0120-三角形最小路径和.md",key:"v-4aeac5ec",path:"/views/%E4%B8%AD%E7%AD%89/0120-%E4%B8%89%E8%A7%92%E5%BD%A2%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C.html",headers:[{level:2,title:"中文题目",slug:"中文题目",charIndex:2},{level:2,title:"通过代码",slug:"通过代码",charIndex:201},{level:2,title:"高赞题解",slug:"高赞题解",charIndex:2014},{level:2,title:"提交历史",slug:"提交历史",charIndex:3666},{level:2,title:"统计信息",slug:"统计信息",charIndex:3992}],lastUpdated:"4/11/2021, 1:15:21 PM",headersStr:"中文题目 通过代码 高赞题解 提交历史 统计信息",content:'# 中文题目\n给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。\n\n例如，给定三角形：\n\n[\n     [2],\n    [3,4],\n   [6,5,7],\n  [4,1,8,3]\n]\n\n\n自顶向下的最小路径和为11（即，2+3+5+1= 11）。\n\n说明：\n\n如果你可以只使用 O(n) 的额外空间（n 为三角形的总行数）来解决这个问题，那么你的算法会很加分。\n\n# 通过代码\nclass Solution {\n    // public int minimumTotal(List<List<Integer>> triangle) {\n    //     int layer = triangle.size();\n    //         for (int i = layer - 2; i >= 0; i--) {\n    //             for (int j = 0; j < triangle.get(i).size(); j++) {\n    //                 triangle.get(i).set(j, Math.min(triangle.get(i + 1).get(j), triangle.get(i + 1).get(j + 1)) + triangle.get(i).get(j));\n    //             }\n    //         }\n    //         return triangle.get(0).get(0);\n    // }\n        public int minimumTotal(List<List<Integer>> triangle) {\n            if (triangle.size() == 0) {\n                return 0;\n            }\n            Integer[][] visited = new Integer[triangle.size()][triangle.get(triangle.size() - 1).size()];\n            return dfs(triangle, 0, 0, visited);\n        }\n\n        private int dfs(List<List<Integer>> triangle, int i, int j, Integer[][] visited) {\n            if (i == triangle.size()) {\n                return 0;\n            }\n            if (visited[i][j] != null) {\n                return visited[i][j];\n            }\n            int sum = triangle.get(i).get(j) + Math.min(dfs(triangle, i + 1, j, visited), dfs(triangle, i + 1, j + 1, visited));\n            visited[i][j] = sum;\n            return sum;\n        }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\nclass Solution {\n    public int minimumTotal(List<List<Integer>> triangle) {\n        int layer = triangle.size();\n            for (int i = layer - 2; i >= 0; i--) {\n                for (int j = 0; j < triangle.get(i).size(); j++) {\n                    triangle.get(i).set(j, Math.min(triangle.get(i + 1).get(j), triangle.get(i + 1).get(j + 1)) + triangle.get(i).get(j));\n                }\n            }\n            return triangle.get(0).get(0);\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n# 高赞题解\n# 递归，自顶向下 【超时】\nint row;\n\npublic int minimumTotal(List<List<Integer>> triangle) {\n    row=triangle.size();\n    return helper(0,0, triangle);\n}\nprivate int helper(int level, int c, List<List<Integer>> triangle){\n    // System.out.println("helper: level="+ level+ " c=" + c);\n    if (level==row-1){\n        return triangle.get(level).get(c);\n    }\n    int left = helper(level+1, c, triangle);\n    int right = helper(level+1, c+1, triangle);\n    return Math.min(left, right) + triangle.get(level).get(c);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n改进,避免重复计算\n\n# 自顶向下, 记忆化搜索 【AC】\nint row;\nInteger[][] memo;\n\npublic int minimumTotal(List<List<Integer>> triangle) {\n    row = triangle.size();\n    memo = new Integer[row][row];\n    return helper(0,0, triangle);\n}\nprivate int helper(int level, int c, List<List<Integer>> triangle){\n    // System.out.println("helper: level="+ level+ " c=" + c);\n    if (memo[level][c]!=null)\n        return memo[level][c];\n    if (level==row-1){\n        return memo[level][c] = triangle.get(level).get(c);\n    }\n    int left = helper(level+1, c, triangle);\n    int right = helper(level+1, c+1, triangle);\n    return memo[level][c] = Math.min(left, right) + triangle.get(level).get(c);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n# 自底向上, DP 【AC】\npublic int minimumTotal(List<List<Integer>> triangle) {\n    int row = triangle.size();\n    int[] minlen = new int[row+1];\n    for (int level = row-1;level>=0;level--){\n        for (int i = 0;i<=level;i++){   //第i行有i+1个数字\n            minlen[i] = Math.min(minlen[i], minlen[i+1]) + triangle.get(level).get(i);\n        }\n    }\n    return minlen[0];\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-09-14 15:21:18Compile Error [https://leetcode-cn.com//submissions/detail/7088643/]N/AN/AN/Ajava2018-09-14 15:20:04Accepted [https://leetcode-cn.com//submissions/detail/7088565/]7 ms19.87%N/Ajava2018-09-14 15:09:34Accepted [https://leetcode-cn.com//submissions/detail/7087881/]15 ms6.0%N/Ajava# 统计信息\n通过次数提交次数AC比率353825604563.1%',contentLowercase:'# 中文题目\n给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。\n\n例如，给定三角形：\n\n[\n     [2],\n    [3,4],\n   [6,5,7],\n  [4,1,8,3]\n]\n\n\n自顶向下的最小路径和为11（即，2+3+5+1= 11）。\n\n说明：\n\n如果你可以只使用 o(n) 的额外空间（n 为三角形的总行数）来解决这个问题，那么你的算法会很加分。\n\n# 通过代码\nclass solution {\n    // public int minimumtotal(list<list<integer>> triangle) {\n    //     int layer = triangle.size();\n    //         for (int i = layer - 2; i >= 0; i--) {\n    //             for (int j = 0; j < triangle.get(i).size(); j++) {\n    //                 triangle.get(i).set(j, math.min(triangle.get(i + 1).get(j), triangle.get(i + 1).get(j + 1)) + triangle.get(i).get(j));\n    //             }\n    //         }\n    //         return triangle.get(0).get(0);\n    // }\n        public int minimumtotal(list<list<integer>> triangle) {\n            if (triangle.size() == 0) {\n                return 0;\n            }\n            integer[][] visited = new integer[triangle.size()][triangle.get(triangle.size() - 1).size()];\n            return dfs(triangle, 0, 0, visited);\n        }\n\n        private int dfs(list<list<integer>> triangle, int i, int j, integer[][] visited) {\n            if (i == triangle.size()) {\n                return 0;\n            }\n            if (visited[i][j] != null) {\n                return visited[i][j];\n            }\n            int sum = triangle.get(i).get(j) + math.min(dfs(triangle, i + 1, j, visited), dfs(triangle, i + 1, j + 1, visited));\n            visited[i][j] = sum;\n            return sum;\n        }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\nclass solution {\n    public int minimumtotal(list<list<integer>> triangle) {\n        int layer = triangle.size();\n            for (int i = layer - 2; i >= 0; i--) {\n                for (int j = 0; j < triangle.get(i).size(); j++) {\n                    triangle.get(i).set(j, math.min(triangle.get(i + 1).get(j), triangle.get(i + 1).get(j + 1)) + triangle.get(i).get(j));\n                }\n            }\n            return triangle.get(0).get(0);\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n# 高赞题解\n# 递归，自顶向下 【超时】\nint row;\n\npublic int minimumtotal(list<list<integer>> triangle) {\n    row=triangle.size();\n    return helper(0,0, triangle);\n}\nprivate int helper(int level, int c, list<list<integer>> triangle){\n    // system.out.println("helper: level="+ level+ " c=" + c);\n    if (level==row-1){\n        return triangle.get(level).get(c);\n    }\n    int left = helper(level+1, c, triangle);\n    int right = helper(level+1, c+1, triangle);\n    return math.min(left, right) + triangle.get(level).get(c);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n改进,避免重复计算\n\n# 自顶向下, 记忆化搜索 【ac】\nint row;\ninteger[][] memo;\n\npublic int minimumtotal(list<list<integer>> triangle) {\n    row = triangle.size();\n    memo = new integer[row][row];\n    return helper(0,0, triangle);\n}\nprivate int helper(int level, int c, list<list<integer>> triangle){\n    // system.out.println("helper: level="+ level+ " c=" + c);\n    if (memo[level][c]!=null)\n        return memo[level][c];\n    if (level==row-1){\n        return memo[level][c] = triangle.get(level).get(c);\n    }\n    int left = helper(level+1, c, triangle);\n    int right = helper(level+1, c+1, triangle);\n    return memo[level][c] = math.min(left, right) + triangle.get(level).get(c);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n# 自底向上, dp 【ac】\npublic int minimumtotal(list<list<integer>> triangle) {\n    int row = triangle.size();\n    int[] minlen = new int[row+1];\n    for (int level = row-1;level>=0;level--){\n        for (int i = 0;i<=level;i++){   //第i行有i+1个数字\n            minlen[i] = math.min(minlen[i], minlen[i+1]) + triangle.get(level).get(i);\n        }\n    }\n    return minlen[0];\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-09-14 15:21:18compile error [https://leetcode-cn.com//submissions/detail/7088643/]n/an/an/ajava2018-09-14 15:20:04accepted [https://leetcode-cn.com//submissions/detail/7088565/]7 ms19.87%n/ajava2018-09-14 15:09:34accepted [https://leetcode-cn.com//submissions/detail/7087881/]15 ms6.0%n/ajava# 统计信息\n通过次数提交次数ac比率353825604563.1%'},{title:"129-求根到叶子节点数字之和(Sum Root to Leaf Numbers)",frontmatter:{title:"129-求根到叶子节点数字之和(Sum Root to Leaf Numbers)",date:"2018-09-08T00:00:00.000Z",categories:["中等"],tags:["树<Tree>","深度优先搜索<Depth-first Search>"]},regularPath:"/views/%E4%B8%AD%E7%AD%89/0129-%E6%B1%82%E6%A0%B9%E5%88%B0%E5%8F%B6%E5%AD%90%E8%8A%82%E7%82%B9%E6%95%B0%E5%AD%97%E4%B9%8B%E5%92%8C.html",relativePath:"views/中等/0129-求根到叶子节点数字之和.md",key:"v-94273df0",path:"/views/%E4%B8%AD%E7%AD%89/0129-%E6%B1%82%E6%A0%B9%E5%88%B0%E5%8F%B6%E5%AD%90%E8%8A%82%E7%82%B9%E6%95%B0%E5%AD%97%E4%B9%8B%E5%92%8C.html",headers:[{level:2,title:"中文题目",slug:"中文题目",charIndex:2},{level:2,title:"通过代码",slug:"通过代码",charIndex:436},{level:2,title:"高赞题解",slug:"高赞题解",charIndex:1337},{level:2,title:"提交历史",slug:"提交历史",charIndex:4349},{level:2,title:"统计信息",slug:"统计信息",charIndex:4477},{level:2,title:"相似题目",slug:"相似题目",charIndex:4511}],lastUpdated:"4/11/2021, 1:15:21 PM",headersStr:"中文题目 通过代码 高赞题解 提交历史 统计信息 相似题目",content:"# 中文题目\n给定一个二叉树，它的每个结点都存放一个0-9的数字，每条从根到叶子节点的路径都代表一个数字。\n\n例如，从根到叶子节点路径 1->2->3 代表数字 123。\n\n计算从根到叶子节点生成的所有数字之和。\n\n说明:叶子节点是指没有子节点的节点。\n\n示例 1:\n\n输入: [1,2,3]\n    1\n   / \\\n  2   3\n输出: 25\n解释:\n从根到叶子节点路径 1->2 代表数字 12.\n从根到叶子节点路径 1->3 代表数字 13.\n因此，数字总和 = 12 + 13 = 25.\n\n示例 2:\n\n输入: [4,9,0,5,1]\n    4\n   / \\\n  9   0\n / \\\n5   1\n输出: 1026\n解释:\n从根到叶子节点路径 4->9->5 代表数字 495.\n从根到叶子节点路径 4->9->1 代表数字 491.\n从根到叶子节点路径 4->0 代表数字 40.\n因此，数字总和 = 495 + 491 + 40 = 1026.\n\n# 通过代码\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n     public int sumNumbers(TreeNode root) {\n        int sum = 0;\n        int num = 0;\n        sum=sumNumbers(root, sum, num);\n        return sum;\n    }\n\n    private int sumNumbers(TreeNode root, int sum, int num) {\n        if (root == null) {\n            return sum;\n        }\n        num = num * 10 + root.val;\n        if (root.left == null && root.right == null) {\n            sum += num;\n            num /= 10;\n            return sum;\n        } else {\n            sum=sumNumbers(root.left, sum, num);\n            sum=sumNumbers(root.right, sum, num);\n        }\n        num /= 10;\n        return sum;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n# 高赞题解\n思路一:\n\n二叉树的题目我们首先想到的就是递归求解。递归的方式很简单，用先序遍历的变形。\n\n 1. 先遍历根节点；\n 2. 遍历左子树，遍历左子树的时候，把走当前路径的数字带到左子树的求解中；\n 3. 遍历右子树，遍历右子树的时候，把走当前路径的数字带到右子树的求解中；\n 4. 更新总的和。\n\n代码一:\n\nclass Solution {\n    private int sum = 0;\n    private void helper(TreeNode node, int father) {\n        if (node == null) return ;\n        int current = father * 10 + node.val;\n        if (node.left == null && node.right == null) {\n            sum += current;\n            return;\n        }\n        helper(node.left, current);\n        helper(node.right, current);\n    }\n\n    public int sumNumbers(TreeNode root) {\n        if (root == null) return sum;\n        helper(root, 0);\n        return sum;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n思路二:\n\n通常还可以用 stack 的思路来解递归的题目。先序非递归的代码我们知道是用 stack 来保存遍历过的元素。而因为本题要记录到叶节点的数字，所以需要一个额外的 stack 来记录数字。每次出 stack 之后，如果是叶子节点，那么加和；如果不是，那么就看左右子树，入 stack。\n\n代码二:\n\nclass Solution {\n    public int sumNumbers(TreeNode root) {\n        int sum = 0;\n        if (root == null) return sum;\n        Stack<TreeNode> nodeStack = new Stack<>();\n        Stack<Integer> numStack = new Stack<>();\n        nodeStack.add(root);\n        numStack.add(0);\n        while (!nodeStack.isEmpty()) {\n            TreeNode current = nodeStack.pop();\n            Integer currentNum = numStack.pop() * 10 + current.val;\n            if (current.left == null && current.right == null) {\n                sum += currentNum;\n            }\n            if (current.left != null) {\n                nodeStack.add(current.left);\n                numStack.add(currentNum);\n            }\n            if (current.right != null) {\n                nodeStack.add(current.right);\n                numStack.add(currentNum);\n            }\n        } \n        return sum;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n思路三:\n\n其实，我们可以看到，最关键的是找到叶子节点，然后加和这个操作。叶子节点我们同样可以用层序遍历的方式来解这道题目。层序遍历用队列来解。\n\n代码三:\n\npublic class Solution {\n    public int sumNumbers(TreeNode root) {\n        Queue<TreeNode> queue = new LinkedList<TreeNode>();\n        Queue<Integer> numQueue = new LinkedList<Integer>();\n        if(root == null) return 0;\n        int res = 0;\n        queue.add(root);\n        numQueue.add(0);\n        while(!queue.isEmpty()) {\n            int size = queue.size();\n            // 把该层的都入队，同时如果遇到叶节点，计算更新\n            while(size-- > 0) {\n                root = queue.poll();\n                int val = numQueue.poll() * 10 + root.val;\n                if(root.left == null && root.right == null)\n                    res += val;\n                if(root.left != null) {\n                    queue.add(root.left);\n                    numQueue.add(val);\n                }\n                if (root.right != null) {\n                    queue.add(root.right);\n                    numQueue.add(val);\n                }\n            }\n        }\n        return res;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n总结，二叉树的题目，大多数都是遍历的变形，面试时候看用 bfs，还是 dfs，一般来说很快就能得出答案。写非递归代码的时候，注意判断一下非空，不要把 null 节点入队或者入栈。\n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-09-08 15:58:21Accepted [https://leetcode-cn.com//submissions/detail/6746600/]1 ms42.64%N/Ajava# 统计信息\n通过次数提交次数AC比率158362605260.8%# 相似题目\n题目难度路径总和 [https://leetcode-cn.com/problems/path-sum/]简单二叉树中的最大路径和 [https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/]困难从叶结点开始的最小字符串 [https://leetcode-cn.com/problems/smallest-string-starting-from-leaf/]中等",contentLowercase:"# 中文题目\n给定一个二叉树，它的每个结点都存放一个0-9的数字，每条从根到叶子节点的路径都代表一个数字。\n\n例如，从根到叶子节点路径 1->2->3 代表数字 123。\n\n计算从根到叶子节点生成的所有数字之和。\n\n说明:叶子节点是指没有子节点的节点。\n\n示例 1:\n\n输入: [1,2,3]\n    1\n   / \\\n  2   3\n输出: 25\n解释:\n从根到叶子节点路径 1->2 代表数字 12.\n从根到叶子节点路径 1->3 代表数字 13.\n因此，数字总和 = 12 + 13 = 25.\n\n示例 2:\n\n输入: [4,9,0,5,1]\n    4\n   / \\\n  9   0\n / \\\n5   1\n输出: 1026\n解释:\n从根到叶子节点路径 4->9->5 代表数字 495.\n从根到叶子节点路径 4->9->1 代表数字 491.\n从根到叶子节点路径 4->0 代表数字 40.\n因此，数字总和 = 495 + 491 + 40 = 1026.\n\n# 通过代码\n/**\n * definition for a binary tree node.\n * public class treenode {\n *     int val;\n *     treenode left;\n *     treenode right;\n *     treenode(int x) { val = x; }\n * }\n */\nclass solution {\n     public int sumnumbers(treenode root) {\n        int sum = 0;\n        int num = 0;\n        sum=sumnumbers(root, sum, num);\n        return sum;\n    }\n\n    private int sumnumbers(treenode root, int sum, int num) {\n        if (root == null) {\n            return sum;\n        }\n        num = num * 10 + root.val;\n        if (root.left == null && root.right == null) {\n            sum += num;\n            num /= 10;\n            return sum;\n        } else {\n            sum=sumnumbers(root.left, sum, num);\n            sum=sumnumbers(root.right, sum, num);\n        }\n        num /= 10;\n        return sum;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n# 高赞题解\n思路一:\n\n二叉树的题目我们首先想到的就是递归求解。递归的方式很简单，用先序遍历的变形。\n\n 1. 先遍历根节点；\n 2. 遍历左子树，遍历左子树的时候，把走当前路径的数字带到左子树的求解中；\n 3. 遍历右子树，遍历右子树的时候，把走当前路径的数字带到右子树的求解中；\n 4. 更新总的和。\n\n代码一:\n\nclass solution {\n    private int sum = 0;\n    private void helper(treenode node, int father) {\n        if (node == null) return ;\n        int current = father * 10 + node.val;\n        if (node.left == null && node.right == null) {\n            sum += current;\n            return;\n        }\n        helper(node.left, current);\n        helper(node.right, current);\n    }\n\n    public int sumnumbers(treenode root) {\n        if (root == null) return sum;\n        helper(root, 0);\n        return sum;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n思路二:\n\n通常还可以用 stack 的思路来解递归的题目。先序非递归的代码我们知道是用 stack 来保存遍历过的元素。而因为本题要记录到叶节点的数字，所以需要一个额外的 stack 来记录数字。每次出 stack 之后，如果是叶子节点，那么加和；如果不是，那么就看左右子树，入 stack。\n\n代码二:\n\nclass solution {\n    public int sumnumbers(treenode root) {\n        int sum = 0;\n        if (root == null) return sum;\n        stack<treenode> nodestack = new stack<>();\n        stack<integer> numstack = new stack<>();\n        nodestack.add(root);\n        numstack.add(0);\n        while (!nodestack.isempty()) {\n            treenode current = nodestack.pop();\n            integer currentnum = numstack.pop() * 10 + current.val;\n            if (current.left == null && current.right == null) {\n                sum += currentnum;\n            }\n            if (current.left != null) {\n                nodestack.add(current.left);\n                numstack.add(currentnum);\n            }\n            if (current.right != null) {\n                nodestack.add(current.right);\n                numstack.add(currentnum);\n            }\n        } \n        return sum;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n思路三:\n\n其实，我们可以看到，最关键的是找到叶子节点，然后加和这个操作。叶子节点我们同样可以用层序遍历的方式来解这道题目。层序遍历用队列来解。\n\n代码三:\n\npublic class solution {\n    public int sumnumbers(treenode root) {\n        queue<treenode> queue = new linkedlist<treenode>();\n        queue<integer> numqueue = new linkedlist<integer>();\n        if(root == null) return 0;\n        int res = 0;\n        queue.add(root);\n        numqueue.add(0);\n        while(!queue.isempty()) {\n            int size = queue.size();\n            // 把该层的都入队，同时如果遇到叶节点，计算更新\n            while(size-- > 0) {\n                root = queue.poll();\n                int val = numqueue.poll() * 10 + root.val;\n                if(root.left == null && root.right == null)\n                    res += val;\n                if(root.left != null) {\n                    queue.add(root.left);\n                    numqueue.add(val);\n                }\n                if (root.right != null) {\n                    queue.add(root.right);\n                    numqueue.add(val);\n                }\n            }\n        }\n        return res;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n总结，二叉树的题目，大多数都是遍历的变形，面试时候看用 bfs，还是 dfs，一般来说很快就能得出答案。写非递归代码的时候，注意判断一下非空，不要把 null 节点入队或者入栈。\n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-09-08 15:58:21accepted [https://leetcode-cn.com//submissions/detail/6746600/]1 ms42.64%n/ajava# 统计信息\n通过次数提交次数ac比率158362605260.8%# 相似题目\n题目难度路径总和 [https://leetcode-cn.com/problems/path-sum/]简单二叉树中的最大路径和 [https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/]困难从叶结点开始的最小字符串 [https://leetcode-cn.com/problems/smallest-string-starting-from-leaf/]中等"},{title:"150-逆波兰表达式求值(Evaluate Reverse Polish Notation)",frontmatter:{title:"150-逆波兰表达式求值(Evaluate Reverse Polish Notation)",date:"2018-09-05T00:00:00.000Z",categories:["中等"],tags:["栈<Stack>"]},regularPath:"/views/%E4%B8%AD%E7%AD%89/0150-%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC.html",relativePath:"views/中等/0150-逆波兰表达式求值.md",key:"v-6fab22e5",path:"/views/%E4%B8%AD%E7%AD%89/0150-%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC.html",headers:[{level:2,title:"中文题目",slug:"中文题目",charIndex:2},{level:2,title:"通过代码",slug:"通过代码",charIndex:607},{level:2,title:"高赞题解",slug:"高赞题解",charIndex:4286},{level:2,title:"提交历史",slug:"提交历史",charIndex:5029},{level:2,title:"统计信息",slug:"统计信息",charIndex:5558},{level:2,title:"相似题目",slug:"相似题目",charIndex:5592}],lastUpdated:"4/11/2021, 1:15:21 PM",headersStr:"中文题目 通过代码 高赞题解 提交历史 统计信息 相似题目",content:'# 中文题目\n根据逆波兰表示法 [https://baike.baidu.com/item/%E9%80%86%E6%B3%A2%E5%85%B0%E5%BC%8F/128437]，求表达式的值。\n\n有效的运算符包括+,-,*,/。每个运算对象可以是整数，也可以是另一个逆波兰表达式。\n\n说明：\n\n * 整数除法只保留整数部分。\n * 给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。\n\n示例 1：\n\n输入: ["2", "1", "+", "3", "*"]\n输出: 9\n解释: ((2 + 1) * 3) = 9\n\n\n示例 2：\n\n输入: ["4", "13", "5", "/", "+"]\n输出: 6\n解释: (4 + (13 / 5)) = 6\n\n\n示例 3：\n\n输入: ["10", "6", "9", "3", "+", "-11", "*", "/", "*", "17", "+", "5", "+"]\n输出: 22\n解释: \n  ((10 * (6 / ((9 + 3) * -11))) + 17) + 5\n= ((10 * (6 / (12 * -11))) + 17) + 5\n= ((10 * (6 / -132)) + 17) + 5\n= ((10 * 0) + 17) + 5\n= (0 + 17) + 5\n= 17 + 5\n= 22\n\n# 通过代码\nclass Solution {\n    public int evalRPN(String[] tokens) {\n         if (null == tokens || tokens.length == 0) {\n                return 0;\n            }\n            Stack<Integer> stack = new Stack<Integer>();\n            for (int i = 0; i < tokens.length; i++) {\n                if (tokens[i].matches("^-?[1-9]\\\\d*|0$")) {\n                    stack.push(Integer.parseInt(tokens[i]));\n                } else {\n                    int a = stack.pop();\n                    int b = stack.pop();\n                    int res = 0;\n                    switch (tokens[i]) {\n                        case "+":\n                            res = b + a;\n                            break;\n                        case "-":\n                            res = b - a;\n                            break;\n                        case "*":\n                            res = b * a;\n                            break;\n                        case "/":\n                            res = b / a;\n                            break;\n                    }\n                    stack.push(res);\n                }\n            }\n            return stack.pop();\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\nclass Solution {\n    public int evalRPN(String[] tokens) {\n         if (null == tokens || tokens.length == 0) {\n                return 0;\n            }\n            Stack<Integer> stack = new Stack<Integer>();\n            for (int i = 0; i < tokens.length; i++) {\n                if (tokens[i].matches("^-?[1-9]\\\\d*|0$")) {\n                    stack.push(Integer.parseInt(tokens[i]));\n                } else {\n                    int a = stack.pop();\n                    int b = stack.pop();\n                    int res = 0;\n                    switch (tokens[i]) {\n                        case "+":\n                            res = b + a;\n                            break;\n                        case "-":\n                            res = b - a;\n                            break;\n                        case "*":\n                            res = b * a;\n                            break;\n                        case "/":\n                            res = b / a;\n                            break;\n                    }\n                    stack.push(res);\n                }\n            }\n            return stack.pop();\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\nclass Solution {\n    public int evalRPN(String[] tokens) {\n         if (null == tokens || tokens.length == 0) {\n                return 0;\n            }\n            Stack<Integer> stack = new Stack<Integer>();\n            for (int i = 0; i < tokens.length; i++) {\n                if (tokens[i].matches("^-?[1-9]\\\\d*|0$")) {\n                    stack.push(Integer.parseInt(tokens[i]));\n                } else {\n                    int a = stack.pop();\n                    int b = stack.pop();\n                    int res = 0;\n                    switch (tokens[i]) {\n                        case "+":\n                            res = b + a;\n                            break;\n                        case "-":\n                            res = b - a;\n                            break;\n                        case "*":\n                            res = b * a;\n                            break;\n                        case "/":\n                            res = b / a;\n                            break;\n                    }\n                    stack.push(res);\n                }\n            }\n            return stack.pop();\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n# 高赞题解\n1.逆波兰表达式求解,定义一个栈辅助计算; 2.当遇到运算符"+"、"-"、"*"、"/"时,从栈中pop出两个数字计算,否则将数字入栈; 3.完结。\n\n    public int evalRPN(String[] tokens) {\n        Stack<Integer> stack = new Stack<>();\n        for (String s : tokens) {\n            if (s.equals("+")) {\n                stack.push(stack.pop() + stack.pop());\n            } else if (s.equals("-")) {\n                stack.push(-stack.pop() + stack.pop());\n            } else if (s.equals("*")) {\n                stack.push(stack.pop() * stack.pop());\n            } else if (s.equals("/")) {\n                int num1 = stack.pop();\n                stack.push(stack.pop() / num1);\n            } else {\n                stack.push(Integer.parseInt(s));\n            }\n        }\n        return stack.pop();\n    }\n\n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-09-05 14:59:55Accepted [https://leetcode-cn.com//submissions/detail/6580031/]128 ms5.02%N/Ajava2018-09-05 14:51:44Accepted [https://leetcode-cn.com//submissions/detail/6579466/]113 ms5.02%N/Ajava2018-09-05 14:50:04Accepted [https://leetcode-cn.com//submissions/detail/6579329/]108 ms5.02%N/Ajava2018-09-05 14:49:14Compile Error [https://leetcode-cn.com//submissions/detail/6579249/]N/AN/AN/Ajava2018-09-05 14:47:56Runtime Error [https://leetcode-cn.com//submissions/detail/6579142/]N/AN/AN/Ajava# 统计信息\n通过次数提交次数AC比率237314896748.5%# 相似题目\n题目难度基本计算器 [https://leetcode-cn.com/problems/basic-calculator/]困难给表达式添加运算符 [https://leetcode-cn.com/problems/expression-add-operators/]困难',contentLowercase:'# 中文题目\n根据逆波兰表示法 [https://baike.baidu.com/item/%e9%80%86%e6%b3%a2%e5%85%b0%e5%bc%8f/128437]，求表达式的值。\n\n有效的运算符包括+,-,*,/。每个运算对象可以是整数，也可以是另一个逆波兰表达式。\n\n说明：\n\n * 整数除法只保留整数部分。\n * 给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。\n\n示例 1：\n\n输入: ["2", "1", "+", "3", "*"]\n输出: 9\n解释: ((2 + 1) * 3) = 9\n\n\n示例 2：\n\n输入: ["4", "13", "5", "/", "+"]\n输出: 6\n解释: (4 + (13 / 5)) = 6\n\n\n示例 3：\n\n输入: ["10", "6", "9", "3", "+", "-11", "*", "/", "*", "17", "+", "5", "+"]\n输出: 22\n解释: \n  ((10 * (6 / ((9 + 3) * -11))) + 17) + 5\n= ((10 * (6 / (12 * -11))) + 17) + 5\n= ((10 * (6 / -132)) + 17) + 5\n= ((10 * 0) + 17) + 5\n= (0 + 17) + 5\n= 17 + 5\n= 22\n\n# 通过代码\nclass solution {\n    public int evalrpn(string[] tokens) {\n         if (null == tokens || tokens.length == 0) {\n                return 0;\n            }\n            stack<integer> stack = new stack<integer>();\n            for (int i = 0; i < tokens.length; i++) {\n                if (tokens[i].matches("^-?[1-9]\\\\d*|0$")) {\n                    stack.push(integer.parseint(tokens[i]));\n                } else {\n                    int a = stack.pop();\n                    int b = stack.pop();\n                    int res = 0;\n                    switch (tokens[i]) {\n                        case "+":\n                            res = b + a;\n                            break;\n                        case "-":\n                            res = b - a;\n                            break;\n                        case "*":\n                            res = b * a;\n                            break;\n                        case "/":\n                            res = b / a;\n                            break;\n                    }\n                    stack.push(res);\n                }\n            }\n            return stack.pop();\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\nclass solution {\n    public int evalrpn(string[] tokens) {\n         if (null == tokens || tokens.length == 0) {\n                return 0;\n            }\n            stack<integer> stack = new stack<integer>();\n            for (int i = 0; i < tokens.length; i++) {\n                if (tokens[i].matches("^-?[1-9]\\\\d*|0$")) {\n                    stack.push(integer.parseint(tokens[i]));\n                } else {\n                    int a = stack.pop();\n                    int b = stack.pop();\n                    int res = 0;\n                    switch (tokens[i]) {\n                        case "+":\n                            res = b + a;\n                            break;\n                        case "-":\n                            res = b - a;\n                            break;\n                        case "*":\n                            res = b * a;\n                            break;\n                        case "/":\n                            res = b / a;\n                            break;\n                    }\n                    stack.push(res);\n                }\n            }\n            return stack.pop();\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\nclass solution {\n    public int evalrpn(string[] tokens) {\n         if (null == tokens || tokens.length == 0) {\n                return 0;\n            }\n            stack<integer> stack = new stack<integer>();\n            for (int i = 0; i < tokens.length; i++) {\n                if (tokens[i].matches("^-?[1-9]\\\\d*|0$")) {\n                    stack.push(integer.parseint(tokens[i]));\n                } else {\n                    int a = stack.pop();\n                    int b = stack.pop();\n                    int res = 0;\n                    switch (tokens[i]) {\n                        case "+":\n                            res = b + a;\n                            break;\n                        case "-":\n                            res = b - a;\n                            break;\n                        case "*":\n                            res = b * a;\n                            break;\n                        case "/":\n                            res = b / a;\n                            break;\n                    }\n                    stack.push(res);\n                }\n            }\n            return stack.pop();\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n# 高赞题解\n1.逆波兰表达式求解,定义一个栈辅助计算; 2.当遇到运算符"+"、"-"、"*"、"/"时,从栈中pop出两个数字计算,否则将数字入栈; 3.完结。\n\n    public int evalrpn(string[] tokens) {\n        stack<integer> stack = new stack<>();\n        for (string s : tokens) {\n            if (s.equals("+")) {\n                stack.push(stack.pop() + stack.pop());\n            } else if (s.equals("-")) {\n                stack.push(-stack.pop() + stack.pop());\n            } else if (s.equals("*")) {\n                stack.push(stack.pop() * stack.pop());\n            } else if (s.equals("/")) {\n                int num1 = stack.pop();\n                stack.push(stack.pop() / num1);\n            } else {\n                stack.push(integer.parseint(s));\n            }\n        }\n        return stack.pop();\n    }\n\n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-09-05 14:59:55accepted [https://leetcode-cn.com//submissions/detail/6580031/]128 ms5.02%n/ajava2018-09-05 14:51:44accepted [https://leetcode-cn.com//submissions/detail/6579466/]113 ms5.02%n/ajava2018-09-05 14:50:04accepted [https://leetcode-cn.com//submissions/detail/6579329/]108 ms5.02%n/ajava2018-09-05 14:49:14compile error [https://leetcode-cn.com//submissions/detail/6579249/]n/an/an/ajava2018-09-05 14:47:56runtime error [https://leetcode-cn.com//submissions/detail/6579142/]n/an/an/ajava# 统计信息\n通过次数提交次数ac比率237314896748.5%# 相似题目\n题目难度基本计算器 [https://leetcode-cn.com/problems/basic-calculator/]困难给表达式添加运算符 [https://leetcode-cn.com/problems/expression-add-operators/]困难'},{title:"200-岛屿数量(Number of Islands)",frontmatter:{title:"200-岛屿数量(Number of Islands)",date:"2018-07-22T00:00:00.000Z",categories:["中等"],tags:["深度优先搜索<Depth-first Search>","广度优先搜索<Breadth-first Search>","并查集<Union Find>"]},regularPath:"/views/%E4%B8%AD%E7%AD%89/0200-%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F.html",relativePath:"views/中等/0200-岛屿数量.md",key:"v-6ba46688",path:"/views/%E4%B8%AD%E7%AD%89/0200-%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F.html",headers:[{level:2,title:"中文题目",slug:"中文题目",charIndex:2},{level:2,title:"通过代码",slug:"通过代码",charIndex:188},{level:2,title:"官方题解",slug:"官方题解",charIndex:1690},{level:2,title:"提交历史",slug:"提交历史",charIndex:11286},{level:2,title:"统计信息",slug:"统计信息",charIndex:11513},{level:2,title:"相似题目",slug:"相似题目",charIndex:11548}],lastUpdated:"4/11/2021, 1:15:21 PM",headersStr:"中文题目 通过代码 官方题解 提交历史 统计信息 相似题目",content:"# 中文题目\n给定一个由'1'（陆地）和 '0'（水）组成的的二维网格，计算岛屿的数量。一个岛被水包围，并且它是通过水平方向或垂直方向上相邻的陆地连接而成的。你可以假设网格的四个边均被水包围。\n\n示例 1:\n\n输入:\n11110\n11010\n11000\n00000\n\n输出: 1\n\n\n示例 2:\n\n输入:\n11000\n11000\n00100\n00011\n\n输出: 3\n\n\n# 通过代码\nclass Solution {\n  int[][] d = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};\n        static int m;\n        static int n;\n        boolean[][] visited;\n\n        public int numIslands(char[][] grid) {\n            m = grid.length;\n            if (grid.length == 0) {\n                return 0;\n            }\n            n = grid[0].length;\n            visited = new boolean[m][n];\n            int res = 0;\n            for (int i = 0; i < m; i++) {\n                for (int j = 0; j < n; j++) {\n                    if (grid[i][j] == '1' && !visited[i][j]) {\n                        res++;\n                        dfs(grid, i, j);\n                    }\n                }\n            }\n            return res;\n        }\n\n        //        从grid[x][y]开始，进行floodfill\n//        这个函数的递归终止就是四个方向都遍历完，没有陆地就返回\n        private void dfs(char[][] grid, int i, int j) {\n            visited[i][j] = true;\n            for (int k = 0; k < 4; k++) {\n                int newx = i + d[k][0];\n                int newy = j + d[k][1];\n                if (inArea(newx, newy) && !visited[newx][newy] && grid[newx][newy] == '1') {\n                    dfs(grid, newx, newy);\n                }\n            }\n//            该问题不会对原来的标记状态标记为false，因为就是要比较陆地\n            return;\n        }\n\n        private boolean inArea(int newx, int newy) {\n            return newx >= 0 && newx < m && newy >= 0 && newy < n;\n        }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n# 官方题解\n# 方法一：深度优先搜索 【通过】\n直觉\n\n将二维网格看成一个无向图，竖直或水平相邻的 1 之间有边。\n\n算法\n\n线性扫描整个二维网格，如果一个结点包含 1，则以其为根结点启动深度优先搜索。在深度优先搜索过程中，每个访问过的结点被标记为 0。计数启动深度优先搜索的根结点的数量，即为岛屿的数量。\n\n下面的动画展示了整个算法。\n\n<,,,,,,,>\n\nclass Solution {\nprivate:\n  void dfs(vector<vector<char>>& grid, int r, int c) {\n    int nr = grid.size();\n    int nc = grid[0].size();\n\n    grid[r][c] = '0';\n    if (r - 1 >= 0 && grid[r-1][c] == '1') dfs(grid, r - 1, c);\n    if (r + 1 < nr && grid[r+1][c] == '1') dfs(grid, r + 1, c);\n    if (c - 1 >= 0 && grid[r][c-1] == '1') dfs(grid, r, c - 1);\n    if (c + 1 < nc && grid[r][c+1] == '1') dfs(grid, r, c + 1);\n  }\n\npublic:\n  int numIslands(vector<vector<char>>& grid) {\n    int nr = grid.size();\n    if (!nr) return 0;\n    int nc = grid[0].size();\n\n    int num_islands = 0;\n    for (int r = 0; r < nr; ++r) {\n      for (int c = 0; c < nc; ++c) {\n        if (grid[r][c] == '1') {\n          ++num_islands;\n          dfs(grid, r, c);\n        }\n      }\n    }\n\n    return num_islands;\n  }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\nclass Solution {\n  void dfs(char[][] grid, int r, int c) {\n    int nr = grid.length;\n    int nc = grid[0].length;\n\n    if (r < 0 || c < 0 || r >= nr || c >= nc || grid[r][c] == '0') {\n      return;\n    }\n\n    grid[r][c] = '0';\n    dfs(grid, r - 1, c);\n    dfs(grid, r + 1, c);\n    dfs(grid, r, c - 1);\n    dfs(grid, r, c + 1);\n  }\n\n  public int numIslands(char[][] grid) {\n    if (grid == null || grid.length == 0) {\n      return 0;\n    }\n\n    int nr = grid.length;\n    int nc = grid[0].length;\n    int num_islands = 0;\n    for (int r = 0; r < nr; ++r) {\n      for (int c = 0; c < nc; ++c) {\n        if (grid[r][c] == '1') {\n          ++num_islands;\n          dfs(grid, r, c);\n        }\n      }\n    }\n\n    return num_islands;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n复杂度分析\n\n * 时间复杂度 : O(M×N)O(M\\times N)O(M×N)，其中 MMM 和 NNN 分别为行数和列数。\n   \n   \n * 空间复杂度 : 最坏情况下为 O(M×N)O(M \\times N)O(M×N)，此时整个网格均为陆地，深度优先搜索的深度达到 M×NM \\times NM×N。\n   \n   \n\n\n\n\n# 方法二: 广度优先搜索 【通过】\n算法\n\n线性扫描整个二维网格，如果一个结点包含 1，则以其为根结点启动广度优先搜索。将其放入队列中，并将值设为 0 以标记访问过该结点。迭代地搜索队列中的每个结点，直到队列为空。\n\nclass Solution {\npublic:\n  int numIslands(vector<vector<char>>& grid) {\n    int nr = grid.size();\n    if (!nr) return 0;\n    int nc = grid[0].size();\n\n    int num_islands = 0;\n    for (int r = 0; r < nr; ++r) {\n      for (int c = 0; c < nc; ++c) {\n        if (grid[r][c] == '1') {\n          ++num_islands;\n          grid[r][c] = '0'; // mark as visited\n          queue<pair<int, int>> nei***ors;\n          nei***ors.push({r, c});\n          while (!nei***ors.empty()) {\n            auto rc = nei***ors.front();\n            nei***ors.pop();\n            int row = rc.first, col = rc.second;\n            if (row - 1 >= 0 && grid[row-1][col] == '1') {\n              nei***ors.push({row-1, col}); grid[row-1][col] = '0';\n            }\n            if (row + 1 < nr && grid[row+1][col] == '1') {\n              nei***ors.push({row+1, col}); grid[row+1][col] = '0';\n            }\n            if (col - 1 >= 0 && grid[row][col-1] == '1') {\n              nei***ors.push({row, col-1}); grid[row][col-1] = '0';\n            }\n            if (col + 1 < nc && grid[row][col+1] == '1') {\n              nei***ors.push({row, col+1}); grid[row][col+1] = '0';\n            }\n          }\n        }\n      }\n    }\n\n    return num_islands;\n  }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\nclass Solution {\n  public int numIslands(char[][] grid) {\n    if (grid == null || grid.length == 0) {\n      return 0;\n    }\n\n    int nr = grid.length;\n    int nc = grid[0].length;\n    int num_islands = 0;\n\n    for (int r = 0; r < nr; ++r) {\n      for (int c = 0; c < nc; ++c) {\n        if (grid[r][c] == '1') {\n          ++num_islands;\n          grid[r][c] = '0'; // mark as visited\n          Queue<Integer> nei***ors = new LinkedList<>();\n          nei***ors.add(r * nc + c);\n          while (!nei***ors.isEmpty()) {\n            int id = nei***ors.remove();\n            int row = id / nc;\n            int col = id % nc;\n            if (row - 1 >= 0 && grid[row-1][col] == '1') {\n              nei***ors.add((row-1) * nc + col);\n              grid[row-1][col] = '0';\n            }\n            if (row + 1 < nr && grid[row+1][col] == '1') {\n              nei***ors.add((row+1) * nc + col);\n              grid[row+1][col] = '0';\n            }\n            if (col - 1 >= 0 && grid[row][col-1] == '1') {\n              nei***ors.add(row * nc + col-1);\n              grid[row][col-1] = '0';\n            }\n            if (col + 1 < nc && grid[row][col+1] == '1') {\n              nei***ors.add(row * nc + col+1);\n              grid[row][col+1] = '0';\n            }\n          }\n        }\n      }\n    }\n\n    return num_islands;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n复杂度分析\n\n * 时间复杂度 : O(M×N)O(M \\times N)O(M×N)，其中 MMM 和 NNN 分别为行数和列数。\n   \n   \n * 空间复杂度 : O(min(M,N))O(min(M, N))O(min(M,N))，在最坏的情况下（全部为陆地），队列的大小可以达到 min(M，NM，NM，N)。\n   \n   \n\n\n\n\n# 方法三：并查集 【通过】\n算法\n\n遍历二维网格，将竖直或水平相邻的陆地联结。最终，返回并查集数据结构中相连部分的数量。\n\n下面的动画展示了整个算法。\n\n<,,,,,>\n\nclass UnionFind {\npublic:\n  UnionFind(vector<vector<char>>& grid) {\n    count = 0;\n    int m = grid.size();\n    int n = grid[0].size();\n      for (int i = 0; i < m; ++i) {\n        for (int j = 0; j < n; ++j) {\n          if (grid[i][j] == '1') {\n            parent.push_back(i * n + j);\n            ++count;\n          }\n          else parent.push_back(-1);\n          rank.push_back(0);\n        }\n    }\n  }\n\n  int find(int i) { // path compression\n    if (parent[i] != i) parent[i] = find(parent[i]);\n    return parent[i];\n  }\n\n  void Union(int x, int y) { // union with rank\n    int rootx = find(x);\n    int rooty = find(y);\n    if (rootx != rooty) {\n      if (rank[rootx] > rank[rooty]) parent[rooty] = rootx;\n      else if (rank[rootx] < rank[rooty]) parent[rootx] = rooty;\n      else {\n        parent[rooty] = rootx; rank[rootx] += 1;\n      }\n      --count;\n    }\n  }\n\n  int getCount() const {\n    return count;\n  }\n\nprivate:\n  vector<int> parent;\n  vector<int> rank;\n  int count; // # of connected components\n};\n\nclass Solution {\npublic:\n  int numIslands(vector<vector<char>>& grid) {\n    int nr = grid.size();\n    if (!nr) return 0;\n    int nc = grid[0].size();\n\n    UnionFind uf (grid);\n    int num_islands = 0;\n    for (int r = 0; r < nr; ++r) {\n      for (int c = 0; c < nc; ++c) {\n        if (grid[r][c] == '1') {\n          grid[r][c] = '0';\n          if (r - 1 >= 0 && grid[r-1][c] == '1') uf.Union(r * nc + c, (r-1) * nc + c);\n          if (r + 1 < nr && grid[r+1][c] == '1') uf.Union(r * nc + c, (r+1) * nc + c);\n          if (c - 1 >= 0 && grid[r][c-1] == '1') uf.Union(r * nc + c, r * nc + c - 1);\n          if (c + 1 < nc && grid[r][c+1] == '1') uf.Union(r * nc + c, r * nc + c + 1);\n        }\n      }\n    }\n\n    return uf.getCount();\n  }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\nclass Solution {\n  class UnionFind {\n    int count; // # of connected components\n    int[] parent;\n    int[] rank;\n\n    public UnionFind(char[][] grid) { // for problem 200\n      count = 0;\n      int m = grid.length;\n      int n = grid[0].length;\n      parent = new int[m * n];\n      rank = new int[m * n];\n      for (int i = 0; i < m; ++i) {\n        for (int j = 0; j < n; ++j) {\n          if (grid[i][j] == '1') {\n            parent[i * n + j] = i * n + j;\n            ++count;\n          }\n          rank[i * n + j] = 0;\n        }\n      }\n    }\n\n    public int find(int i) { // path compression\n      if (parent[i] != i) parent[i] = find(parent[i]);\n      return parent[i];\n    }\n\n    public void union(int x, int y) { // union with rank\n      int rootx = find(x);\n      int rooty = find(y);\n      if (rootx != rooty) {\n        if (rank[rootx] > rank[rooty]) {\n          parent[rooty] = rootx;\n        } else if (rank[rootx] < rank[rooty]) {\n          parent[rootx] = rooty;\n        } else {\n          parent[rooty] = rootx; rank[rootx] += 1;\n        }\n        --count;\n      }\n    }\n\n    public int getCount() {\n      return count;\n    }\n  }\n\n  public int numIslands(char[][] grid) {\n    if (grid == null || grid.length == 0) {\n      return 0;\n    }\n\n    int nr = grid.length;\n    int nc = grid[0].length;\n    int num_islands = 0;\n    UnionFind uf = new UnionFind(grid);\n    for (int r = 0; r < nr; ++r) {\n      for (int c = 0; c < nc; ++c) {\n        if (grid[r][c] == '1') {\n          grid[r][c] = '0';\n          if (r - 1 >= 0 && grid[r-1][c] == '1') {\n            uf.union(r * nc + c, (r-1) * nc + c);\n          }\n          if (r + 1 < nr && grid[r+1][c] == '1') {\n            uf.union(r * nc + c, (r+1) * nc + c);\n          }\n          if (c - 1 >= 0 && grid[r][c-1] == '1') {\n            uf.union(r * nc + c, r * nc + c - 1);\n          }\n          if (c + 1 < nc && grid[r][c+1] == '1') {\n            uf.union(r * nc + c, r * nc + c + 1);\n          }\n        }\n      }\n    }\n\n    return uf.getCount();\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n复杂度分析\n\n * 时间复杂度：O(M×N)O(M \\times N)O(M×N)，其中 MMM 和 NNN 分别为行数和列数。注意当使用路径压缩和排名结合并实现并查集时，并操作只需要消耗常数时间。\n   \n   \n * 空间复杂度：O(M×N)O(M \\times N)O(M×N)，这是并查集数据结构需要的空间。\n   \n   \n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-07-22 21:46:48Accepted [https://leetcode-cn.com//submissions/detail/4512310/]10 ms8.9%N/Ajava2018-07-22 21:45:58Runtime Error [https://leetcode-cn.com//submissions/detail/4512268/]N/AN/AN/Ajava# 统计信息\n通过次数提交次数AC比率4921110563646.6%# 相似题目\n题目难度被围绕的区域 [https://leetcode-cn.com/problems/surrounded-regions/]中等墙与门 [https://leetcode-cn.com/problems/walls-and-gates/]中等岛屿数量 II [https://leetcode-cn.com/problems/number-of-islands-ii/]困难无向图中连通分量的数目 [https://leetcode-cn.com/problems/number-of-connected-components-in-an-undirected-graph/]中等不同岛屿的数量 [https://leetcode-cn.com/problems/number-of-distinct-islands/]中等岛屿的最大面积 [https://leetcode-cn.com/problems/max-area-of-island/]中等",contentLowercase:"# 中文题目\n给定一个由'1'（陆地）和 '0'（水）组成的的二维网格，计算岛屿的数量。一个岛被水包围，并且它是通过水平方向或垂直方向上相邻的陆地连接而成的。你可以假设网格的四个边均被水包围。\n\n示例 1:\n\n输入:\n11110\n11010\n11000\n00000\n\n输出: 1\n\n\n示例 2:\n\n输入:\n11000\n11000\n00100\n00011\n\n输出: 3\n\n\n# 通过代码\nclass solution {\n  int[][] d = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};\n        static int m;\n        static int n;\n        boolean[][] visited;\n\n        public int numislands(char[][] grid) {\n            m = grid.length;\n            if (grid.length == 0) {\n                return 0;\n            }\n            n = grid[0].length;\n            visited = new boolean[m][n];\n            int res = 0;\n            for (int i = 0; i < m; i++) {\n                for (int j = 0; j < n; j++) {\n                    if (grid[i][j] == '1' && !visited[i][j]) {\n                        res++;\n                        dfs(grid, i, j);\n                    }\n                }\n            }\n            return res;\n        }\n\n        //        从grid[x][y]开始，进行floodfill\n//        这个函数的递归终止就是四个方向都遍历完，没有陆地就返回\n        private void dfs(char[][] grid, int i, int j) {\n            visited[i][j] = true;\n            for (int k = 0; k < 4; k++) {\n                int newx = i + d[k][0];\n                int newy = j + d[k][1];\n                if (inarea(newx, newy) && !visited[newx][newy] && grid[newx][newy] == '1') {\n                    dfs(grid, newx, newy);\n                }\n            }\n//            该问题不会对原来的标记状态标记为false，因为就是要比较陆地\n            return;\n        }\n\n        private boolean inarea(int newx, int newy) {\n            return newx >= 0 && newx < m && newy >= 0 && newy < n;\n        }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n# 官方题解\n# 方法一：深度优先搜索 【通过】\n直觉\n\n将二维网格看成一个无向图，竖直或水平相邻的 1 之间有边。\n\n算法\n\n线性扫描整个二维网格，如果一个结点包含 1，则以其为根结点启动深度优先搜索。在深度优先搜索过程中，每个访问过的结点被标记为 0。计数启动深度优先搜索的根结点的数量，即为岛屿的数量。\n\n下面的动画展示了整个算法。\n\n<,,,,,,,>\n\nclass solution {\nprivate:\n  void dfs(vector<vector<char>>& grid, int r, int c) {\n    int nr = grid.size();\n    int nc = grid[0].size();\n\n    grid[r][c] = '0';\n    if (r - 1 >= 0 && grid[r-1][c] == '1') dfs(grid, r - 1, c);\n    if (r + 1 < nr && grid[r+1][c] == '1') dfs(grid, r + 1, c);\n    if (c - 1 >= 0 && grid[r][c-1] == '1') dfs(grid, r, c - 1);\n    if (c + 1 < nc && grid[r][c+1] == '1') dfs(grid, r, c + 1);\n  }\n\npublic:\n  int numislands(vector<vector<char>>& grid) {\n    int nr = grid.size();\n    if (!nr) return 0;\n    int nc = grid[0].size();\n\n    int num_islands = 0;\n    for (int r = 0; r < nr; ++r) {\n      for (int c = 0; c < nc; ++c) {\n        if (grid[r][c] == '1') {\n          ++num_islands;\n          dfs(grid, r, c);\n        }\n      }\n    }\n\n    return num_islands;\n  }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\nclass solution {\n  void dfs(char[][] grid, int r, int c) {\n    int nr = grid.length;\n    int nc = grid[0].length;\n\n    if (r < 0 || c < 0 || r >= nr || c >= nc || grid[r][c] == '0') {\n      return;\n    }\n\n    grid[r][c] = '0';\n    dfs(grid, r - 1, c);\n    dfs(grid, r + 1, c);\n    dfs(grid, r, c - 1);\n    dfs(grid, r, c + 1);\n  }\n\n  public int numislands(char[][] grid) {\n    if (grid == null || grid.length == 0) {\n      return 0;\n    }\n\n    int nr = grid.length;\n    int nc = grid[0].length;\n    int num_islands = 0;\n    for (int r = 0; r < nr; ++r) {\n      for (int c = 0; c < nc; ++c) {\n        if (grid[r][c] == '1') {\n          ++num_islands;\n          dfs(grid, r, c);\n        }\n      }\n    }\n\n    return num_islands;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n复杂度分析\n\n * 时间复杂度 : o(m×n)o(m\\times n)o(m×n)，其中 mmm 和 nnn 分别为行数和列数。\n   \n   \n * 空间复杂度 : 最坏情况下为 o(m×n)o(m \\times n)o(m×n)，此时整个网格均为陆地，深度优先搜索的深度达到 m×nm \\times nm×n。\n   \n   \n\n\n\n\n# 方法二: 广度优先搜索 【通过】\n算法\n\n线性扫描整个二维网格，如果一个结点包含 1，则以其为根结点启动广度优先搜索。将其放入队列中，并将值设为 0 以标记访问过该结点。迭代地搜索队列中的每个结点，直到队列为空。\n\nclass solution {\npublic:\n  int numislands(vector<vector<char>>& grid) {\n    int nr = grid.size();\n    if (!nr) return 0;\n    int nc = grid[0].size();\n\n    int num_islands = 0;\n    for (int r = 0; r < nr; ++r) {\n      for (int c = 0; c < nc; ++c) {\n        if (grid[r][c] == '1') {\n          ++num_islands;\n          grid[r][c] = '0'; // mark as visited\n          queue<pair<int, int>> nei***ors;\n          nei***ors.push({r, c});\n          while (!nei***ors.empty()) {\n            auto rc = nei***ors.front();\n            nei***ors.pop();\n            int row = rc.first, col = rc.second;\n            if (row - 1 >= 0 && grid[row-1][col] == '1') {\n              nei***ors.push({row-1, col}); grid[row-1][col] = '0';\n            }\n            if (row + 1 < nr && grid[row+1][col] == '1') {\n              nei***ors.push({row+1, col}); grid[row+1][col] = '0';\n            }\n            if (col - 1 >= 0 && grid[row][col-1] == '1') {\n              nei***ors.push({row, col-1}); grid[row][col-1] = '0';\n            }\n            if (col + 1 < nc && grid[row][col+1] == '1') {\n              nei***ors.push({row, col+1}); grid[row][col+1] = '0';\n            }\n          }\n        }\n      }\n    }\n\n    return num_islands;\n  }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\nclass solution {\n  public int numislands(char[][] grid) {\n    if (grid == null || grid.length == 0) {\n      return 0;\n    }\n\n    int nr = grid.length;\n    int nc = grid[0].length;\n    int num_islands = 0;\n\n    for (int r = 0; r < nr; ++r) {\n      for (int c = 0; c < nc; ++c) {\n        if (grid[r][c] == '1') {\n          ++num_islands;\n          grid[r][c] = '0'; // mark as visited\n          queue<integer> nei***ors = new linkedlist<>();\n          nei***ors.add(r * nc + c);\n          while (!nei***ors.isempty()) {\n            int id = nei***ors.remove();\n            int row = id / nc;\n            int col = id % nc;\n            if (row - 1 >= 0 && grid[row-1][col] == '1') {\n              nei***ors.add((row-1) * nc + col);\n              grid[row-1][col] = '0';\n            }\n            if (row + 1 < nr && grid[row+1][col] == '1') {\n              nei***ors.add((row+1) * nc + col);\n              grid[row+1][col] = '0';\n            }\n            if (col - 1 >= 0 && grid[row][col-1] == '1') {\n              nei***ors.add(row * nc + col-1);\n              grid[row][col-1] = '0';\n            }\n            if (col + 1 < nc && grid[row][col+1] == '1') {\n              nei***ors.add(row * nc + col+1);\n              grid[row][col+1] = '0';\n            }\n          }\n        }\n      }\n    }\n\n    return num_islands;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n复杂度分析\n\n * 时间复杂度 : o(m×n)o(m \\times n)o(m×n)，其中 mmm 和 nnn 分别为行数和列数。\n   \n   \n * 空间复杂度 : o(min(m,n))o(min(m, n))o(min(m,n))，在最坏的情况下（全部为陆地），队列的大小可以达到 min(m，nm，nm，n)。\n   \n   \n\n\n\n\n# 方法三：并查集 【通过】\n算法\n\n遍历二维网格，将竖直或水平相邻的陆地联结。最终，返回并查集数据结构中相连部分的数量。\n\n下面的动画展示了整个算法。\n\n<,,,,,>\n\nclass unionfind {\npublic:\n  unionfind(vector<vector<char>>& grid) {\n    count = 0;\n    int m = grid.size();\n    int n = grid[0].size();\n      for (int i = 0; i < m; ++i) {\n        for (int j = 0; j < n; ++j) {\n          if (grid[i][j] == '1') {\n            parent.push_back(i * n + j);\n            ++count;\n          }\n          else parent.push_back(-1);\n          rank.push_back(0);\n        }\n    }\n  }\n\n  int find(int i) { // path compression\n    if (parent[i] != i) parent[i] = find(parent[i]);\n    return parent[i];\n  }\n\n  void union(int x, int y) { // union with rank\n    int rootx = find(x);\n    int rooty = find(y);\n    if (rootx != rooty) {\n      if (rank[rootx] > rank[rooty]) parent[rooty] = rootx;\n      else if (rank[rootx] < rank[rooty]) parent[rootx] = rooty;\n      else {\n        parent[rooty] = rootx; rank[rootx] += 1;\n      }\n      --count;\n    }\n  }\n\n  int getcount() const {\n    return count;\n  }\n\nprivate:\n  vector<int> parent;\n  vector<int> rank;\n  int count; // # of connected components\n};\n\nclass solution {\npublic:\n  int numislands(vector<vector<char>>& grid) {\n    int nr = grid.size();\n    if (!nr) return 0;\n    int nc = grid[0].size();\n\n    unionfind uf (grid);\n    int num_islands = 0;\n    for (int r = 0; r < nr; ++r) {\n      for (int c = 0; c < nc; ++c) {\n        if (grid[r][c] == '1') {\n          grid[r][c] = '0';\n          if (r - 1 >= 0 && grid[r-1][c] == '1') uf.union(r * nc + c, (r-1) * nc + c);\n          if (r + 1 < nr && grid[r+1][c] == '1') uf.union(r * nc + c, (r+1) * nc + c);\n          if (c - 1 >= 0 && grid[r][c-1] == '1') uf.union(r * nc + c, r * nc + c - 1);\n          if (c + 1 < nc && grid[r][c+1] == '1') uf.union(r * nc + c, r * nc + c + 1);\n        }\n      }\n    }\n\n    return uf.getcount();\n  }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\nclass solution {\n  class unionfind {\n    int count; // # of connected components\n    int[] parent;\n    int[] rank;\n\n    public unionfind(char[][] grid) { // for problem 200\n      count = 0;\n      int m = grid.length;\n      int n = grid[0].length;\n      parent = new int[m * n];\n      rank = new int[m * n];\n      for (int i = 0; i < m; ++i) {\n        for (int j = 0; j < n; ++j) {\n          if (grid[i][j] == '1') {\n            parent[i * n + j] = i * n + j;\n            ++count;\n          }\n          rank[i * n + j] = 0;\n        }\n      }\n    }\n\n    public int find(int i) { // path compression\n      if (parent[i] != i) parent[i] = find(parent[i]);\n      return parent[i];\n    }\n\n    public void union(int x, int y) { // union with rank\n      int rootx = find(x);\n      int rooty = find(y);\n      if (rootx != rooty) {\n        if (rank[rootx] > rank[rooty]) {\n          parent[rooty] = rootx;\n        } else if (rank[rootx] < rank[rooty]) {\n          parent[rootx] = rooty;\n        } else {\n          parent[rooty] = rootx; rank[rootx] += 1;\n        }\n        --count;\n      }\n    }\n\n    public int getcount() {\n      return count;\n    }\n  }\n\n  public int numislands(char[][] grid) {\n    if (grid == null || grid.length == 0) {\n      return 0;\n    }\n\n    int nr = grid.length;\n    int nc = grid[0].length;\n    int num_islands = 0;\n    unionfind uf = new unionfind(grid);\n    for (int r = 0; r < nr; ++r) {\n      for (int c = 0; c < nc; ++c) {\n        if (grid[r][c] == '1') {\n          grid[r][c] = '0';\n          if (r - 1 >= 0 && grid[r-1][c] == '1') {\n            uf.union(r * nc + c, (r-1) * nc + c);\n          }\n          if (r + 1 < nr && grid[r+1][c] == '1') {\n            uf.union(r * nc + c, (r+1) * nc + c);\n          }\n          if (c - 1 >= 0 && grid[r][c-1] == '1') {\n            uf.union(r * nc + c, r * nc + c - 1);\n          }\n          if (c + 1 < nc && grid[r][c+1] == '1') {\n            uf.union(r * nc + c, r * nc + c + 1);\n          }\n        }\n      }\n    }\n\n    return uf.getcount();\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n复杂度分析\n\n * 时间复杂度：o(m×n)o(m \\times n)o(m×n)，其中 mmm 和 nnn 分别为行数和列数。注意当使用路径压缩和排名结合并实现并查集时，并操作只需要消耗常数时间。\n   \n   \n * 空间复杂度：o(m×n)o(m \\times n)o(m×n)，这是并查集数据结构需要的空间。\n   \n   \n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-07-22 21:46:48accepted [https://leetcode-cn.com//submissions/detail/4512310/]10 ms8.9%n/ajava2018-07-22 21:45:58runtime error [https://leetcode-cn.com//submissions/detail/4512268/]n/an/an/ajava# 统计信息\n通过次数提交次数ac比率4921110563646.6%# 相似题目\n题目难度被围绕的区域 [https://leetcode-cn.com/problems/surrounded-regions/]中等墙与门 [https://leetcode-cn.com/problems/walls-and-gates/]中等岛屿数量 ii [https://leetcode-cn.com/problems/number-of-islands-ii/]困难无向图中连通分量的数目 [https://leetcode-cn.com/problems/number-of-connected-components-in-an-undirected-graph/]中等不同岛屿的数量 [https://leetcode-cn.com/problems/number-of-distinct-islands/]中等岛屿的最大面积 [https://leetcode-cn.com/problems/max-area-of-island/]中等"},{title:"208-实现 Trie (前缀树)(Implement Trie (Prefix Tree))",frontmatter:{title:"208-实现 Trie (前缀树)(Implement Trie (Prefix Tree))",date:"2018-08-03T00:00:00.000Z",categories:["中等"],tags:["设计<Design>","字典树<Trie>"]},regularPath:"/views/%E4%B8%AD%E7%AD%89/0208-%E5%AE%9E%E7%8E%B0%20Trie%20(%E5%89%8D%E7%BC%80%E6%A0%91).html",relativePath:"views/中等/0208-实现 Trie (前缀树).md",key:"v-2a6bb239",path:"/views/%E4%B8%AD%E7%AD%89/0208-%E5%AE%9E%E7%8E%B0%20Trie%20(%E5%89%8D%E7%BC%80%E6%A0%91).html",headers:[{level:2,title:"中文题目",slug:"中文题目",charIndex:2},{level:2,title:"通过代码",slug:"通过代码",charIndex:330},{level:2,title:"官方题解",slug:"官方题解",charIndex:4949},{level:2,title:"总结",slug:"总结",charIndex:4956},{level:2,title:"正文",slug:"正文",charIndex:5004},{level:2,title:"练习题目",slug:"练习题目",charIndex:9475},{level:2,title:"提交历史",slug:"提交历史",charIndex:9701},{level:2,title:"统计信息",slug:"统计信息",charIndex:9929},{level:2,title:"相似题目",slug:"相似题目",charIndex:9963}],lastUpdated:"4/11/2021, 1:15:21 PM",headersStr:"中文题目 通过代码 官方题解 总结 正文 练习题目 提交历史 统计信息 相似题目",content:'# 中文题目\n实现一个 Trie (前缀树)，包含insert,search, 和startsWith这三个操作。\n\n示例:\n\nTrie trie = new Trie();\n\ntrie.insert("apple");\ntrie.search("apple");   // 返回 true\ntrie.search("app");     // 返回 false\ntrie.startsWith("app"); // 返回 true\ntrie.insert("app");   \ntrie.search("app");     // 返回 true\n\n说明:\n\n * 你可以假设所有的输入都是由小写字母a-z构成的。\n * 保证所有输入均为非空字符串。\n\n# 通过代码\nclass Trie {\n\n        private class Node {\n            public boolean isWord;\n            public TreeMap<Character, Node> next;\n\n            public Node(boolean isWord) {\n                this.isWord = isWord;\n                next = new TreeMap<>();\n            }\n\n            public Node() {\n                this(false);\n            }\n        }\n        private Node root;\n        /** Initialize your data structure here. */\n        public Trie() {\n            root=new Node();\n        }\n\n        /** Inserts a word into the trie. */\n        public void insert(String word) {\n            Node cur = root;\n            for (int i = 0; i < word.length(); i++) {\n                char c = word.charAt(i);\n                if (cur.next.get(c) == null) {\n                    cur.next.put(c, new Node());\n                }\n                cur = cur.next.get(c);\n            }\n            if (!cur.isWord) {\n                cur.isWord = true;\n            }\n        }\n\n        /** Returns if the word is in the trie. */\n        public boolean search(String word) {\n            Node cur = root;\n            for (int i = 0; i < word.length(); i++) {\n                char c = word.charAt(i);\n                if (cur.next.get(c) == null) {\n                    return false;\n                }\n                cur = cur.next.get(c);\n            }\n//        注意这里应当返回的是isWord的值，而不是直接返回true\n//        因为可能一个单词里面包含了它\n            return cur.isWord;\n        }\n\n        /** Returns if there is any word in the trie that starts with the given prefix. */\n        public boolean startsWith(String prefix) {\n            Node cur = root;\n            for (int i = 0; i < prefix.length(); i++) {\n                char c = prefix.charAt(i);\n                if (cur.next.get(c) == null) {\n                    return false;\n                }\n                cur = cur.next.get(c);\n            }\n            return true;\n        }\n    }\n\n/**\n * Your Trie object will be instantiated and called as such:\n * Trie obj = new Trie();\n * obj.insert(word);\n * boolean param_2 = obj.search(word);\n * boolean param_3 = obj.startsWith(prefix);\n */\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\nclass Trie {\n\n        private class Node {\n            public boolean isWord;\n            public TreeMap<Character, Node> next;\n\n            public Node(boolean isWord) {\n                this.isWord = isWord;\n                next = new TreeMap<>();\n            }\n\n            public Node() {\n                this(false);\n            }\n        }\n        private Node root;\n        /** Initialize your data structure here. */\n        public Trie() {\n            root=new Node();\n        }\n\n        /** Inserts a word into the trie. */\n        public void insert(String word) {\n            Node cur = root;\n            for (int i = 0; i < word.length(); i++) {\n                char c = word.charAt(i);\n                if (cur.next.get(c) == null) {\n                    cur.next.put(c, new Node());\n                }\n                cur = cur.next.get(c);\n            }\n            if (!cur.isWord) {\n                cur.isWord = true;\n            }\n        }\n\n        /** Returns if the word is in the trie. */\n        public boolean search(String word) {\n            Node cur = root;\n            for (int i = 0; i < word.length(); i++) {\n                char c = word.charAt(i);\n                if (cur.next.get(c) == null) {\n                    return false;\n                }\n                cur = cur.next.get(c);\n            }\n//        注意这里应当返回的是isWord的值，而不是直接返回true\n//        因为可能一个单词里面包含了它\n            return cur.isWord;\n        }\n\n        /** Returns if there is any word in the trie that starts with the given prefix. */\n        public boolean startsWith(String prefix) {\n            Node cur = root;\n            for (int i = 0; i < prefix.length(); i++) {\n                char c = prefix.charAt(i);\n                if (cur.next.get(c) == null) {\n                    return false;\n                }\n                cur = cur.next.get(c);\n            }\n            return true;\n        }\n    }\n\n/**\n * Your Trie object will be instantiated and called as such:\n * Trie obj = new Trie();\n * obj.insert(word);\n * boolean param_2 = obj.search(word);\n * boolean param_3 = obj.startsWith(prefix);\n */\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n# 官方题解\n# 总结\n本文面向中级用户。它介绍了以下内容：数据结构 Trie（前缀树）及其最常见的操作。\n\n# 正文\n# 应用\nTrie (发音为 "try") 或前缀树是一种树数据结构，用于检索字符串数据集中的键。这一高效的数据结构有多种应用：\n\n# 1. 自动补全\n{:width=400} {:align=center}\n\n图 1. 谷歌的搜索建议{:align="center"}\n\n# 2. 拼写检查\n{:width=400} {:align=center}\n\n图2. 文字处理软件中的拼写检查{:align="center"}\n\n# 3. IP 路由 (最长前缀匹配)\n{:width=400} {:align=center}\n\n图 3. 使用Trie树的最长前缀匹配算法，Internet 协议（IP）路由中利用转发表选择路径。{:align="center"}\n\n# 4. T9 (九宫格) 打字预测\n{:width=200} {:align=center}\n\n图 4. T9（九宫格输入），在 20 世纪 90 年代常用于手机输入{:align="center"}\n\n# 5. 单词游戏\n{:width=300} {:align=center}\n\n图 5. Trie 树可通过剪枝搜索空间来高效解决 Boggle 单词游戏{:align="center"}\n\n还有其他的数据结构，如平衡树和哈希表，使我们能够在字符串数据集中搜索单词。为什么我们还需要 Trie 树呢？尽管哈希表可以在 O(1)O(1)O(1) 时间内寻找键值，却无法高效的完成以下操作：\n\n * 找到具有同一前缀的全部键值。\n * 按词典序枚举字符串的数据集。\n\nTrie 树优于哈希表的另一个理由是，随着哈希表大小增加，会出现大量的冲突，时间复杂度可能增加到 O(n)O(n)O(n)，其中 nnn 是插入的键的数量。与哈希表相比，Trie 树在存储多个具有相同前缀的键时可以使用较少的空间。此时 Trie 树只需要 O(m)O(m)O(m) 的时间复杂度，其中 mmm 为键长。而在平衡树中查找键值需要 O(mlog⁡n)O(m \\log n)O(mlogn) 时间复杂度。\n\n# Trie 树的结点结构\nTrie 树是一个有根的树，其结点具有以下字段：。\n\n * 最多 RRR 个指向子结点的链接，其中每个链接对应字母表数据集中的一个字母。 本文中假定 RRR 为 26，小写拉丁字母的数量。\n * 布尔字段，以指定节点是对应键的结尾还是只是键前缀。\n\n{:width=400} {:align=center}\n\n图 6. 单词 "leet" 在 Trie 树中的表示{:align="center"}\n\nclass TrieNode {\n\n    // R links to node children\n    private TrieNode[] links;\n\n    private final int R = 26;\n\n    private boolean isEnd;\n\n    public TrieNode() {\n        links = new TrieNode[R];\n    }\n\n    public boolean containsKey(char ch) {\n        return links[ch -\'a\'] != null;\n    }\n    public TrieNode get(char ch) {\n        return links[ch -\'a\'];\n    }\n    public void put(char ch, TrieNode node) {\n        links[ch -\'a\'] = node;\n    }\n    public void setEnd() {\n        isEnd = true;\n    }\n    public boolean isEnd() {\n        return isEnd;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\nTrie 树中最常见的两个操作是键的插入和查找。\n\n# 向 Trie 树中插入键\n我们通过搜索 Trie 树来插入一个键。我们从根开始搜索它对应于第一个键字符的链接。有两种情况：\n\n * 链接存在。沿着链接移动到树的下一个子层。算法继续搜索下一个键字符。\n * 链接不存在。创建一个新的节点，并将它与父节点的链接相连，该链接与当前的键字符相匹配。\n\n重复以上步骤，直到到达键的最后一个字符，然后将当前节点标记为结束节点，算法完成。\n\n\n\n图 7. 向 Trie 树中插入键{:align="center"}\n\nclass Trie {\n    private TrieNode root;\n\n    public Trie() {\n        root = new TrieNode();\n    }\n\n    // Inserts a word into the trie.\n    public void insert(String word) {\n        TrieNode node = root;\n        for (int i = 0; i < word.length(); i++) {\n            char currentChar = word.charAt(i);\n            if (!node.containsKey(currentChar)) {\n                node.put(currentChar, new TrieNode());\n            }\n            node = node.get(currentChar);\n        }\n        node.setEnd();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n复杂度分析\n\n * 时间复杂度：O(m)O(m)O(m)，其中 mmm 为键长。在算法的每次迭代中，我们要么检查要么创建一个节点，直到到达键尾。只需要 mmm 次操作。\n   \n   \n * 空间复杂度：O(m)O(m)O(m)。最坏的情况下，新插入的键和 Trie 树中已有的键没有公共前缀。此时需要添加 mmm 个结点，使用 O(m)O(m)O(m) 空间。\n   \n   \n\n# 在 Trie 树中查找键\n每个键在 trie 中表示为从根到内部节点或叶的路径。我们用第一个键字符从根开始，。检查当前节点中与键字符对应的链接。有两种情况：\n\n * 存在链接。我们移动到该链接后面路径中的下一个节点，并继续搜索下一个键字符。\n * 不存在链接。若已无键字符，且当前结点标记为 isEnd，则返回 true。否则有两种可能，均返回 false : * 还有键字符剩余，但无法跟随 Trie 树的键路径，找不到键。\n    * 没有键字符剩余，但当前结点没有标记为 isEnd。也就是说，待查找键只是Trie树中另一个键的前缀。\n   \n   \n\n{:width=400} {:align=center}\n\n图 8. 在 Trie 树中查找键{:align="center"}\n\nclass Trie {\n    ...\n\n    // search a prefix or whole key in trie and\n    // returns the node where search ends\n    private TrieNode searchPrefix(String word) {\n        TrieNode node = root;\n        for (int i = 0; i < word.length(); i++) {\n           char curLetter = word.charAt(i);\n           if (node.containsKey(curLetter)) {\n               node = node.get(curLetter);\n           } else {\n               return null;\n           }\n        }\n        return node;\n    }\n\n    // Returns if the word is in the trie.\n    public boolean search(String word) {\n       TrieNode node = searchPrefix(word);\n       return node != null && node.isEnd();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n复杂度分析\n\n * 时间复杂度 : O(m)O(m)O(m)。算法的每一步均搜索下一个键字符。最坏的情况下需要 mmm 次操作。\n * 空间复杂度 : O(1)O(1)O(1)。\n\n# 查找 Trie 树中的键前缀\n该方法与在 Trie 树中搜索键时使用的方法非常相似。我们从根遍历 Trie 树，直到键前缀中没有字符，或者无法用当前的键字符继续 Trie 中的路径。与上面提到的“搜索键”算法唯一的区别是，到达键前缀的末尾时，总是返回 true。我们不需要考虑当前 Trie 节点是否用 “isend” 标记，因为我们搜索的是键的前缀，而不是整个键。\n\n{:width=400} {:align=center}\n\n图 9. 查找 Trie 树中的键前缀{:align="center"}\n\nclass Trie {\n    ...\n\n    // Returns if there is any word in the trie\n    // that starts with the given prefix.\n    public boolean startsWith(String prefix) {\n        TrieNode node = searchPrefix(prefix);\n        return node != null;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n复杂度分析\n\n * 时间复杂度 : O(m)O(m)O(m)。\n * 空间复杂度 : O(1)O(1)O(1)。\n\n# 练习题目\n下面是一些很好的问题，供您练习使用 Trie 数据结构。\n\n 1. 添加与搜索单词 [https://leetcode-cn.com/problems/add-and-search-word-data-structure-design/] - 一个 Trie 树的直接应用。\n 2. 单词搜索 II [https://leetcode-cn.com/problems/word-search-ii/] - 类似 Boggle 的游戏。\n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-08-03 11:57:32Accepted [https://leetcode-cn.com//submissions/detail/5038571/]196 ms6.75%N/Ajava2018-08-03 11:56:57Accepted [https://leetcode-cn.com//submissions/detail/5038552/]190 ms6.8%N/Ajava# 统计信息\n通过次数提交次数AC比率208923277163.8%# 相似题目\n题目难度添加与搜索单词 - 数据结构设计 [https://leetcode-cn.com/problems/add-and-search-word-data-structure-design/]中等设计搜索自动补全系统 [https://leetcode-cn.com/problems/design-search-autocomplete-system/]困难单词替换 [https://leetcode-cn.com/problems/replace-words/]中等实现一个魔法字典 [https://leetcode-cn.com/problems/implement-magic-dictionary/]中等',contentLowercase:'# 中文题目\n实现一个 trie (前缀树)，包含insert,search, 和startswith这三个操作。\n\n示例:\n\ntrie trie = new trie();\n\ntrie.insert("apple");\ntrie.search("apple");   // 返回 true\ntrie.search("app");     // 返回 false\ntrie.startswith("app"); // 返回 true\ntrie.insert("app");   \ntrie.search("app");     // 返回 true\n\n说明:\n\n * 你可以假设所有的输入都是由小写字母a-z构成的。\n * 保证所有输入均为非空字符串。\n\n# 通过代码\nclass trie {\n\n        private class node {\n            public boolean isword;\n            public treemap<character, node> next;\n\n            public node(boolean isword) {\n                this.isword = isword;\n                next = new treemap<>();\n            }\n\n            public node() {\n                this(false);\n            }\n        }\n        private node root;\n        /** initialize your data structure here. */\n        public trie() {\n            root=new node();\n        }\n\n        /** inserts a word into the trie. */\n        public void insert(string word) {\n            node cur = root;\n            for (int i = 0; i < word.length(); i++) {\n                char c = word.charat(i);\n                if (cur.next.get(c) == null) {\n                    cur.next.put(c, new node());\n                }\n                cur = cur.next.get(c);\n            }\n            if (!cur.isword) {\n                cur.isword = true;\n            }\n        }\n\n        /** returns if the word is in the trie. */\n        public boolean search(string word) {\n            node cur = root;\n            for (int i = 0; i < word.length(); i++) {\n                char c = word.charat(i);\n                if (cur.next.get(c) == null) {\n                    return false;\n                }\n                cur = cur.next.get(c);\n            }\n//        注意这里应当返回的是isword的值，而不是直接返回true\n//        因为可能一个单词里面包含了它\n            return cur.isword;\n        }\n\n        /** returns if there is any word in the trie that starts with the given prefix. */\n        public boolean startswith(string prefix) {\n            node cur = root;\n            for (int i = 0; i < prefix.length(); i++) {\n                char c = prefix.charat(i);\n                if (cur.next.get(c) == null) {\n                    return false;\n                }\n                cur = cur.next.get(c);\n            }\n            return true;\n        }\n    }\n\n/**\n * your trie object will be instantiated and called as such:\n * trie obj = new trie();\n * obj.insert(word);\n * boolean param_2 = obj.search(word);\n * boolean param_3 = obj.startswith(prefix);\n */\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\nclass trie {\n\n        private class node {\n            public boolean isword;\n            public treemap<character, node> next;\n\n            public node(boolean isword) {\n                this.isword = isword;\n                next = new treemap<>();\n            }\n\n            public node() {\n                this(false);\n            }\n        }\n        private node root;\n        /** initialize your data structure here. */\n        public trie() {\n            root=new node();\n        }\n\n        /** inserts a word into the trie. */\n        public void insert(string word) {\n            node cur = root;\n            for (int i = 0; i < word.length(); i++) {\n                char c = word.charat(i);\n                if (cur.next.get(c) == null) {\n                    cur.next.put(c, new node());\n                }\n                cur = cur.next.get(c);\n            }\n            if (!cur.isword) {\n                cur.isword = true;\n            }\n        }\n\n        /** returns if the word is in the trie. */\n        public boolean search(string word) {\n            node cur = root;\n            for (int i = 0; i < word.length(); i++) {\n                char c = word.charat(i);\n                if (cur.next.get(c) == null) {\n                    return false;\n                }\n                cur = cur.next.get(c);\n            }\n//        注意这里应当返回的是isword的值，而不是直接返回true\n//        因为可能一个单词里面包含了它\n            return cur.isword;\n        }\n\n        /** returns if there is any word in the trie that starts with the given prefix. */\n        public boolean startswith(string prefix) {\n            node cur = root;\n            for (int i = 0; i < prefix.length(); i++) {\n                char c = prefix.charat(i);\n                if (cur.next.get(c) == null) {\n                    return false;\n                }\n                cur = cur.next.get(c);\n            }\n            return true;\n        }\n    }\n\n/**\n * your trie object will be instantiated and called as such:\n * trie obj = new trie();\n * obj.insert(word);\n * boolean param_2 = obj.search(word);\n * boolean param_3 = obj.startswith(prefix);\n */\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n# 官方题解\n# 总结\n本文面向中级用户。它介绍了以下内容：数据结构 trie（前缀树）及其最常见的操作。\n\n# 正文\n# 应用\ntrie (发音为 "try") 或前缀树是一种树数据结构，用于检索字符串数据集中的键。这一高效的数据结构有多种应用：\n\n# 1. 自动补全\n{:width=400} {:align=center}\n\n图 1. 谷歌的搜索建议{:align="center"}\n\n# 2. 拼写检查\n{:width=400} {:align=center}\n\n图2. 文字处理软件中的拼写检查{:align="center"}\n\n# 3. ip 路由 (最长前缀匹配)\n{:width=400} {:align=center}\n\n图 3. 使用trie树的最长前缀匹配算法，internet 协议（ip）路由中利用转发表选择路径。{:align="center"}\n\n# 4. t9 (九宫格) 打字预测\n{:width=200} {:align=center}\n\n图 4. t9（九宫格输入），在 20 世纪 90 年代常用于手机输入{:align="center"}\n\n# 5. 单词游戏\n{:width=300} {:align=center}\n\n图 5. trie 树可通过剪枝搜索空间来高效解决 boggle 单词游戏{:align="center"}\n\n还有其他的数据结构，如平衡树和哈希表，使我们能够在字符串数据集中搜索单词。为什么我们还需要 trie 树呢？尽管哈希表可以在 o(1)o(1)o(1) 时间内寻找键值，却无法高效的完成以下操作：\n\n * 找到具有同一前缀的全部键值。\n * 按词典序枚举字符串的数据集。\n\ntrie 树优于哈希表的另一个理由是，随着哈希表大小增加，会出现大量的冲突，时间复杂度可能增加到 o(n)o(n)o(n)，其中 nnn 是插入的键的数量。与哈希表相比，trie 树在存储多个具有相同前缀的键时可以使用较少的空间。此时 trie 树只需要 o(m)o(m)o(m) 的时间复杂度，其中 mmm 为键长。而在平衡树中查找键值需要 o(mlog⁡n)o(m \\log n)o(mlogn) 时间复杂度。\n\n# trie 树的结点结构\ntrie 树是一个有根的树，其结点具有以下字段：。\n\n * 最多 rrr 个指向子结点的链接，其中每个链接对应字母表数据集中的一个字母。 本文中假定 rrr 为 26，小写拉丁字母的数量。\n * 布尔字段，以指定节点是对应键的结尾还是只是键前缀。\n\n{:width=400} {:align=center}\n\n图 6. 单词 "leet" 在 trie 树中的表示{:align="center"}\n\nclass trienode {\n\n    // r links to node children\n    private trienode[] links;\n\n    private final int r = 26;\n\n    private boolean isend;\n\n    public trienode() {\n        links = new trienode[r];\n    }\n\n    public boolean containskey(char ch) {\n        return links[ch -\'a\'] != null;\n    }\n    public trienode get(char ch) {\n        return links[ch -\'a\'];\n    }\n    public void put(char ch, trienode node) {\n        links[ch -\'a\'] = node;\n    }\n    public void setend() {\n        isend = true;\n    }\n    public boolean isend() {\n        return isend;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\ntrie 树中最常见的两个操作是键的插入和查找。\n\n# 向 trie 树中插入键\n我们通过搜索 trie 树来插入一个键。我们从根开始搜索它对应于第一个键字符的链接。有两种情况：\n\n * 链接存在。沿着链接移动到树的下一个子层。算法继续搜索下一个键字符。\n * 链接不存在。创建一个新的节点，并将它与父节点的链接相连，该链接与当前的键字符相匹配。\n\n重复以上步骤，直到到达键的最后一个字符，然后将当前节点标记为结束节点，算法完成。\n\n\n\n图 7. 向 trie 树中插入键{:align="center"}\n\nclass trie {\n    private trienode root;\n\n    public trie() {\n        root = new trienode();\n    }\n\n    // inserts a word into the trie.\n    public void insert(string word) {\n        trienode node = root;\n        for (int i = 0; i < word.length(); i++) {\n            char currentchar = word.charat(i);\n            if (!node.containskey(currentchar)) {\n                node.put(currentchar, new trienode());\n            }\n            node = node.get(currentchar);\n        }\n        node.setend();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n复杂度分析\n\n * 时间复杂度：o(m)o(m)o(m)，其中 mmm 为键长。在算法的每次迭代中，我们要么检查要么创建一个节点，直到到达键尾。只需要 mmm 次操作。\n   \n   \n * 空间复杂度：o(m)o(m)o(m)。最坏的情况下，新插入的键和 trie 树中已有的键没有公共前缀。此时需要添加 mmm 个结点，使用 o(m)o(m)o(m) 空间。\n   \n   \n\n# 在 trie 树中查找键\n每个键在 trie 中表示为从根到内部节点或叶的路径。我们用第一个键字符从根开始，。检查当前节点中与键字符对应的链接。有两种情况：\n\n * 存在链接。我们移动到该链接后面路径中的下一个节点，并继续搜索下一个键字符。\n * 不存在链接。若已无键字符，且当前结点标记为 isend，则返回 true。否则有两种可能，均返回 false : * 还有键字符剩余，但无法跟随 trie 树的键路径，找不到键。\n    * 没有键字符剩余，但当前结点没有标记为 isend。也就是说，待查找键只是trie树中另一个键的前缀。\n   \n   \n\n{:width=400} {:align=center}\n\n图 8. 在 trie 树中查找键{:align="center"}\n\nclass trie {\n    ...\n\n    // search a prefix or whole key in trie and\n    // returns the node where search ends\n    private trienode searchprefix(string word) {\n        trienode node = root;\n        for (int i = 0; i < word.length(); i++) {\n           char curletter = word.charat(i);\n           if (node.containskey(curletter)) {\n               node = node.get(curletter);\n           } else {\n               return null;\n           }\n        }\n        return node;\n    }\n\n    // returns if the word is in the trie.\n    public boolean search(string word) {\n       trienode node = searchprefix(word);\n       return node != null && node.isend();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n复杂度分析\n\n * 时间复杂度 : o(m)o(m)o(m)。算法的每一步均搜索下一个键字符。最坏的情况下需要 mmm 次操作。\n * 空间复杂度 : o(1)o(1)o(1)。\n\n# 查找 trie 树中的键前缀\n该方法与在 trie 树中搜索键时使用的方法非常相似。我们从根遍历 trie 树，直到键前缀中没有字符，或者无法用当前的键字符继续 trie 中的路径。与上面提到的“搜索键”算法唯一的区别是，到达键前缀的末尾时，总是返回 true。我们不需要考虑当前 trie 节点是否用 “isend” 标记，因为我们搜索的是键的前缀，而不是整个键。\n\n{:width=400} {:align=center}\n\n图 9. 查找 trie 树中的键前缀{:align="center"}\n\nclass trie {\n    ...\n\n    // returns if there is any word in the trie\n    // that starts with the given prefix.\n    public boolean startswith(string prefix) {\n        trienode node = searchprefix(prefix);\n        return node != null;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n复杂度分析\n\n * 时间复杂度 : o(m)o(m)o(m)。\n * 空间复杂度 : o(1)o(1)o(1)。\n\n# 练习题目\n下面是一些很好的问题，供您练习使用 trie 数据结构。\n\n 1. 添加与搜索单词 [https://leetcode-cn.com/problems/add-and-search-word-data-structure-design/] - 一个 trie 树的直接应用。\n 2. 单词搜索 ii [https://leetcode-cn.com/problems/word-search-ii/] - 类似 boggle 的游戏。\n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-08-03 11:57:32accepted [https://leetcode-cn.com//submissions/detail/5038571/]196 ms6.75%n/ajava2018-08-03 11:56:57accepted [https://leetcode-cn.com//submissions/detail/5038552/]190 ms6.8%n/ajava# 统计信息\n通过次数提交次数ac比率208923277163.8%# 相似题目\n题目难度添加与搜索单词 - 数据结构设计 [https://leetcode-cn.com/problems/add-and-search-word-data-structure-design/]中等设计搜索自动补全系统 [https://leetcode-cn.com/problems/design-search-autocomplete-system/]困难单词替换 [https://leetcode-cn.com/problems/replace-words/]中等实现一个魔法字典 [https://leetcode-cn.com/problems/implement-magic-dictionary/]中等'},{title:"209-长度最小的子数组(Minimum Size Subarray Sum)",frontmatter:{title:"209-长度最小的子数组(Minimum Size Subarray Sum)",date:"2018-09-01T00:00:00.000Z",categories:["中等"],tags:["数组<Array>","双指针<Two Pointers>","二分查找<Binary Search>"]},regularPath:"/views/%E4%B8%AD%E7%AD%89/0209-%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84.html",relativePath:"views/中等/0209-长度最小的子数组.md",key:"v-78dbd082",path:"/views/%E4%B8%AD%E7%AD%89/0209-%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84.html",headers:[{level:2,title:"中文题目",slug:"中文题目",charIndex:2},{level:2,title:"通过代码",slug:"通过代码",charIndex:212},{level:2,title:"官方题解",slug:"官方题解",charIndex:3e3},{level:2,title:"提交历史",slug:"提交历史",charIndex:9464},{level:2,title:"统计信息",slug:"统计信息",charIndex:9987},{level:2,title:"相似题目",slug:"相似题目",charIndex:10021}],lastUpdated:"4/11/2021, 1:15:21 PM",headersStr:"中文题目 通过代码 官方题解 提交历史 统计信息 相似题目",content:"# 中文题目\n给定一个含有n个正整数的数组和一个正整数s ，找出该数组中满足其和 ≥ s 的长度最小的连续子数组。如果不存在符合条件的连续子数组，返回 0。\n\n示例:\n\n输入: s = 7, nums = [2,3,1,2,4,3]\n输出: 2\n解释: 子数组 [4,3] 是该条件下的长度最小的连续子数组。\n\n\n进阶:\n\n如果你已经完成了O(n) 时间复杂度的解法, 请尝试O(n log n) 时间复杂度的解法。\n\n# 通过代码\nclass Solution {\n    public int minSubArrayLen(int s, int[] nums) {\n        if (nums.length==0){\n                return 0;\n            }\n            int left=0;\n            int right=0;\n            int temp = 0;\n            int min=nums.length+1;\n            while ( left<nums.length){\n                if (temp>=s){\n                    temp-=nums[left++];\n                    if (right-left+1<min){\n                        min=right-left+1;\n                    }\n                } else if (temp<s){\n                    if (right==nums.length){\n                        break;\n                    }\n                    temp+=nums[right++];\n                }\n\n            }\n            return min==nums.length+1?0:min;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\nclass Solution {\n    public int minSubArrayLen(int s, int[] nums) {\n        if (nums.length==0){\n                return 0;\n            }\n            int left=0;\n            int right=0;\n            int temp = 0;\n            int min=nums.length+1;\n            while ( left<nums.length){\n                if (temp>=s){\n                    temp-=nums[left++];\n                    if (right-left+1<min){\n                        min=right-left+1;\n                    }\n                } else if (temp<s){\n                    if (right==nums.length){\n                        break;\n                    }\n                    temp+=nums[right++];\n                }\n\n            }\n            return min==nums.length+1?0:min;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\nclass Solution {\n    public int minSubArrayLen(int s, int[] nums) {\n        if (nums.length==0){\n                return 0;\n            }\n            int left=0;\n            int right=0;\n            int temp = 0;\n            int min=nums.length+1;\n            while ( left<nums.length){\n//                if (temp<nums[right]){\n//                    temp+=nums[left];\n//                    left++;\n//                }\n//                if (temp>=nums[right]){\n//                    temp-=nums[right];\n//                    right++;\n//                }\n//                if (temp==0 && (right-left)<min){\n//                    min=right-left;\n//                }\n                if (temp>=s){\n                    temp-=nums[left++];\n                    if (right-left+1<min){\n                        min=right-left+1;\n                    }\n                } else if (temp<s){\n                    if (right==nums.length){\n                        break;\n                    }\n                    temp+=nums[right++];\n                }\n\n            }\n            return min==nums.length+1?0:min;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n# 官方题解\n# 方法 1：暴力\n想法\n\n按照题目要求直接求。把所有可能的子数组求和并更新 ans\\text{ans}ans ，直到我们找到最优子数组且和满足 sum≥s\\text{sum} \\geq \\text{s}sum≥s 。\n\n算法\n\n * 初始化 ans=INT_MAX\\text{ans}=\\text{INT\\_MAX}ans=INT_MAX\n * 用变量 iii 从左到右遍历数组： * 用变量 jjj 从当前元素到数组尾部遍历： * 将 iii 到 jjj 这些元素求和得到 sum\\text{sum}sum\n       * 如果和 sum\\text{sum}sum 比 sss 大： * 更新 ans=min⁡(ans,(j−i+1))\\text{ans} = \\min(\\text{ans}, (j - i + 1))ans=min(ans,(j−i+1))\n          * 继续迭代\n         \n         \n      \n      \n   \n   \n\nint minSubArrayLen(int s, vector<int>& nums)\n{\n    int n = nums.size();\n    int ans = INT_MAX;\n    for (int i = 0; i < n; i++) {\n        for (int j = i; j < n; j++) {\n            int sum = 0;\n            for (int k = i; k <= j; k++) {\n                sum += nums[k];\n            }\n            if (sum >= s) {\n                ans = min(ans, (j - i + 1));\n                break; //Found the smallest subarray with sum>=s starting with index i, hence move to next index\n            }\n        }\n    }\n    return (ans != INT_MAX) ? ans : 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n复杂度分析\n\n * 时间复杂度：O(n3)O(n^3)O(n3) 。\n   \n    * 对数组里的每一个元素，我们从它开始枚举所有的子数组，需要的时间为 O(n2)O(n^2)O(n2)。\n    * 将每一个子数组求和的时间复杂度为：O(n)O(n)O(n) 。\n    * 所以总时间复杂度为：O(n2∗n)=O(n3)O(n^2 * n) = O(n^3)O(n2∗n)=O(n3) 。\n   \n   \n * 空间复杂度：O(1)O(1)O(1)。只是用了常数个额外变量。\n   \n   \n\n# 方法 2：优化的暴力\n想法\n\n在方法 1 中，我们注意到求子数组的和需要的时间为 O(n)O(n)O(n) 。我们其实可以很容易地实现 O(1)O(1)O(1) 时间的求和，只需要从开始元素用一个累加器保存和。我们将累积和保存在 sums\\text{sums}sums 中，通过这种方法，我们可以轻松求出任意子区间的和。\n\n算法\n\n * 算法流程与方法 1 类似。\n * 唯一的不同是求子数组的和： * 建立一个大小为 nums\\text{nums}nums 的向量 sums\\text{sums}sums\n    * 初始化 sums[0]=nums[0]\\text{sums}[0]=\\text{nums}[0]sums[0]=nums[0]\n    * 遍历 向量 sums\\text{sums}sums ： * 更新 sums[i]=sums[i−1]+nums[i]\\text{sums}[i] = \\text{sums}[i-1] + \\text{nums}[i]sums[i]=sums[i−1]+nums[i]\n      \n      \n    * 从 iii 到 jjj 的和计算方法：sum=sums[j]−sums[i]+nums[i]\\text{sum}=\\text{sums}[j] - \\text{sums}[i] +\\text{nums}[i]sum=sums[j]−sums[i]+nums[i] ，其中 sums[j]−sums[i]\\text{sums}[j] - \\text{sums}[i]sums[j]−sums[i] 是从第 i+1i+1i+1 个元素到第 jjj 个元素的和。\n   \n   \n\nint minSubArrayLen(int s, vector<int>& nums)\n{\n    int n = nums.size();\n    if (n == 0)\n        return 0;\n    int ans = INT_MAX;\n    vector<int> sums(n);\n    sums[0] = nums[0];\n    for (int i = 1; i < n; i++)\n        sums[i] = sums[i - 1] + nums[i];\n    for (int i = 0; i < n; i++) {\n        for (int j = i; j < n; j++) {\n            int sum = sums[j] - sums[i] + nums[i];\n            if (sum >= s) {\n                ans = min(ans, (j - i + 1));\n                break; //Found the smallest subarray with sum>=s starting with index i, hence move to next index\n            }\n        }\n    }\n    return (ans != INT_MAX) ? ans : 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n复杂度分析\n\n * 时间复杂度：O(n2)O(n^2)O(n2) 。\n   \n    * 找到所有子数组的时间复杂度为 O(n2)O(n^2)O(n2) 。\n    * 计算子数组的和为 O(1)O(1)O(1) 的时间。\n    * 因此，总时间复杂度为：O(n2∗1)=O(n2)O(n^2 * 1) = O(n^2)O(n2∗1)=O(n2) 。\n   \n   \n * 空间复杂度：O(n)O(n)O(n) 。\n   \n    * 额外的 sums\\text{sums}sums 数组空间大小为 O(n)O(n)O(n) 。\n   \n   \n\n# 方法 3：使用二分查找\n想法\n\n我们可以用二分查找的方法优化方法 2 。我们找到从下标 iii 开始满足 sum≥s\\text{sum} \\geq \\text{s}sum≥s 的子数组需要 O(n)O(n)O(n) 的时间。但是我们可以用二分查找的方法把这个时间优化到 O(log⁡(n))O(\\log(n))O(log(n)) 。在方法 2 中，我们从 iii 开始找 jjj ，直到找到 sum=sums[j]−sums[i]+nums[i]\\text{sum}=\\text{sums}[j] - \\text{sums}[i] + \\text{nums}[i]sum=sums[j]−sums[i]+nums[i] 大于等于s\\text{s}s 的。与其线性地查找这个和，我们可以使用二分搜索的方法找到 sums\\text{sums}sums 中不小于 s+sums[i]−nums[i]\\text{s}+\\text{sums[i]}-\\text{nums[i]}s+sums[i]−nums[i] 的第一个 sums[j]\\text{sums[j]}sums[j] ，可以用 C++ STL 中的 \\text{lower_bound} 函数做到。\n\n算法\n\n * 创建大小为 n+1n+1n+1 的数组 sumssumssums ：\n\nsums[0]=0, sums[i]=sums[i−1]+nums[i−1]\\text{sums}[0]=0\\text{, }\\text{sums}[i]=\\text{sums}[i-1]+\\text{nums}[i-1]sums[0]=0,sums[i]=sums[i−1]+nums[i−1]\n\n * 从 i=1i=1i=1 到 nnn 枚举： * 在 sums\\text{sums}sums 中找到值 to_find\\text{to\\_find}to_find ，满足从 iii 开始到这个位置的和大于等于 sss 且是最小子数组：\n   \n   to_find=s+sums[i−1]\\text{to\\_find}=\\text{s}+\\text{sums}[i-1]to_find=s+sums[i−1]\n   \n   +在 sums\\text{sums}sums 中找到值满足大于等于 \\text{to_find} 的下标，记作 bound\\text{bound}bound+如果我们在 sums\\text{sums}sums 中找到了值 \\text{to_find}， 那么： - 当前子数组的大小为： $$\\text{bound} - (\\text{sums.begin}()+i-1)$$ - 将 ansansans 与当前数组的大小做比较，并把较小值保存到 ansansans 中\n\nint minSubArrayLen(int s, vector<int>& nums)\n{\n    int n = nums.size();\n    if (n == 0)\n        return 0;\n    int ans = INT_MAX;\n    vector<int> sums(n + 1, 0); //size = n+1 for easier calculations\n    //sums[0]=0 : Meaning that it is the sum of first 0 elements\n    //sums[1]=A[0] : Sum of first 1 elements\n    //ans so on...\n    for (int i = 1; i <= n; i++)\n        sums[i] = sums[i - 1] + nums[i - 1];\n    for (int i = 1; i <= n; i++) {\n        int to_find = s + sums[i - 1];\n        auto bound = lower_bound(sums.begin(), sums.end(), to_find);\n        if (bound != sums.end()) {\n            ans = min(ans, static_cast<int>(bound - (sums.begin() + i - 1)));\n        }\n    }\n    return (ans != INT_MAX) ? ans : 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n复杂度分析\n\n * 时间复杂度：O(nlog⁡(n))O(n\\log(n))O(nlog(n)) 。 * 对向量中的每一个元素，从它开始用二分查找找到子数组，满足和大于 sss 。因此，遍历的时间复杂度是 O(n)O(n)O(n) ，二分查找的时间复杂度是 O(log⁡(n))O(\\log(n))O(log(n)) 。\n    * 因此，总时间复杂度是 O(n∗log⁡(n))O(n*\\log(n))O(n∗log(n))\n   \n   \n * 空间复杂度：O(n)O(n)O(n) 。sums\\text{sums}sums 需要额外的 O(n)O(n)O(n) 空间。\n\n# 方法 4：使用两个指针\n想法\n\n到现在为止，我们都保持子数组的左端点不动去找右端点。其实一旦知道这个位置开始的子数组不会是最优答案了，我们就可以移动左端点。我们用 2 个指针，一个指向数组开始的位置，一个指向数组最后的位置，并维护区间内的和 sum\\text{sum}sum 大于等于 sss 同时数组长度最小。\n\n算法\n\n * 初始化 left\\text{left}left 指向 0 且初始化 sum\\text{sum}sum 为 0\n * 遍历 nums\\text{nums}nums 数组： * 将 nums[i]\\text{nums}[i]nums[i] 添加到 sum\\text{sum}sum\n    * 当 sum\\text{sum}sum 大于等于 sss 时： * 更新 ans=min⁡(ans,i+1−left)\\text{ans}=\\min(\\text{ans},i+1-\\text{left})ans=min(ans,i+1−left) ，其中 i+1−lefti+1-\\text{left}i+1−left是当前子数组的长度\n       * 然后我们可以移动左端点，因为以它为开头的满足 sum≥s\\text{sum} \\geq ssum≥s 条件的最短子数组已经求出来了\n       * 将 sum\\text{sum}sum 减去 nums[left]\\text{nums[left]}nums[left] 然后增加 left\\text{left}left\n      \n      \n   \n   \n\nint minSubArrayLen(int s, vector<int>& nums)\n{\n    int n = nums.size();\n    int ans = INT_MAX;\n    int left = 0;\n    int sum = 0;\n    for (int i = 0; i < n; i++) {\n        sum += nums[i];\n        while (sum >= s) {\n            ans = min(ans, i + 1 - left);\n            sum -= nums[left++];\n        }\n    }\n    return (ans != INT_MAX) ? ans : 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n复杂度分析\n\n * 时间复杂度：O(n)O(n)O(n) 。每个指针移动都需要 O(n)O(n)O(n) 的时间。 * 每个元素至多被访问两次，一次被右端点访问，一次被左端点访问。\n   \n   \n * 空间复杂度： O(1)O(1)O(1) 。left\\text{left}left，sum\\text{sum}sum，ans\\text{ans}ans 以及 iii 这些变量只需要常数个空间。\n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-09-01 16:02:17Accepted [https://leetcode-cn.com//submissions/detail/6379608/]4 ms26.1%N/Ajava2018-09-01 16:00:14Accepted [https://leetcode-cn.com//submissions/detail/6379424/]3 ms34.16%N/Ajava2018-09-01 15:59:47Accepted [https://leetcode-cn.com//submissions/detail/6379386/]3 ms34.16%N/Ajava2018-09-01 15:58:11Wrong Answer [https://leetcode-cn.com//submissions/detail/6379252/]N/AN/AN/Ajava2018-09-01 15:43:34Wrong Answer [https://leetcode-cn.com//submissions/detail/6378032/]N/AN/AN/Ajava# 统计信息\n通过次数提交次数AC比率243395971240.8%# 相似题目\n题目难度最小覆盖子串 [https://leetcode-cn.com/problems/minimum-window-substring/]困难和等于 k 的最长子数组长度 [https://leetcode-cn.com/problems/maximum-size-subarray-sum-equals-k/]中等最长重复子数组 [https://leetcode-cn.com/problems/maximum-length-of-repeated-subarray/]中等",contentLowercase:"# 中文题目\n给定一个含有n个正整数的数组和一个正整数s ，找出该数组中满足其和 ≥ s 的长度最小的连续子数组。如果不存在符合条件的连续子数组，返回 0。\n\n示例:\n\n输入: s = 7, nums = [2,3,1,2,4,3]\n输出: 2\n解释: 子数组 [4,3] 是该条件下的长度最小的连续子数组。\n\n\n进阶:\n\n如果你已经完成了o(n) 时间复杂度的解法, 请尝试o(n log n) 时间复杂度的解法。\n\n# 通过代码\nclass solution {\n    public int minsubarraylen(int s, int[] nums) {\n        if (nums.length==0){\n                return 0;\n            }\n            int left=0;\n            int right=0;\n            int temp = 0;\n            int min=nums.length+1;\n            while ( left<nums.length){\n                if (temp>=s){\n                    temp-=nums[left++];\n                    if (right-left+1<min){\n                        min=right-left+1;\n                    }\n                } else if (temp<s){\n                    if (right==nums.length){\n                        break;\n                    }\n                    temp+=nums[right++];\n                }\n\n            }\n            return min==nums.length+1?0:min;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\nclass solution {\n    public int minsubarraylen(int s, int[] nums) {\n        if (nums.length==0){\n                return 0;\n            }\n            int left=0;\n            int right=0;\n            int temp = 0;\n            int min=nums.length+1;\n            while ( left<nums.length){\n                if (temp>=s){\n                    temp-=nums[left++];\n                    if (right-left+1<min){\n                        min=right-left+1;\n                    }\n                } else if (temp<s){\n                    if (right==nums.length){\n                        break;\n                    }\n                    temp+=nums[right++];\n                }\n\n            }\n            return min==nums.length+1?0:min;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\nclass solution {\n    public int minsubarraylen(int s, int[] nums) {\n        if (nums.length==0){\n                return 0;\n            }\n            int left=0;\n            int right=0;\n            int temp = 0;\n            int min=nums.length+1;\n            while ( left<nums.length){\n//                if (temp<nums[right]){\n//                    temp+=nums[left];\n//                    left++;\n//                }\n//                if (temp>=nums[right]){\n//                    temp-=nums[right];\n//                    right++;\n//                }\n//                if (temp==0 && (right-left)<min){\n//                    min=right-left;\n//                }\n                if (temp>=s){\n                    temp-=nums[left++];\n                    if (right-left+1<min){\n                        min=right-left+1;\n                    }\n                } else if (temp<s){\n                    if (right==nums.length){\n                        break;\n                    }\n                    temp+=nums[right++];\n                }\n\n            }\n            return min==nums.length+1?0:min;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n# 官方题解\n# 方法 1：暴力\n想法\n\n按照题目要求直接求。把所有可能的子数组求和并更新 ans\\text{ans}ans ，直到我们找到最优子数组且和满足 sum≥s\\text{sum} \\geq \\text{s}sum≥s 。\n\n算法\n\n * 初始化 ans=int_max\\text{ans}=\\text{int\\_max}ans=int_max\n * 用变量 iii 从左到右遍历数组： * 用变量 jjj 从当前元素到数组尾部遍历： * 将 iii 到 jjj 这些元素求和得到 sum\\text{sum}sum\n       * 如果和 sum\\text{sum}sum 比 sss 大： * 更新 ans=min⁡(ans,(j−i+1))\\text{ans} = \\min(\\text{ans}, (j - i + 1))ans=min(ans,(j−i+1))\n          * 继续迭代\n         \n         \n      \n      \n   \n   \n\nint minsubarraylen(int s, vector<int>& nums)\n{\n    int n = nums.size();\n    int ans = int_max;\n    for (int i = 0; i < n; i++) {\n        for (int j = i; j < n; j++) {\n            int sum = 0;\n            for (int k = i; k <= j; k++) {\n                sum += nums[k];\n            }\n            if (sum >= s) {\n                ans = min(ans, (j - i + 1));\n                break; //found the smallest subarray with sum>=s starting with index i, hence move to next index\n            }\n        }\n    }\n    return (ans != int_max) ? ans : 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n复杂度分析\n\n * 时间复杂度：o(n3)o(n^3)o(n3) 。\n   \n    * 对数组里的每一个元素，我们从它开始枚举所有的子数组，需要的时间为 o(n2)o(n^2)o(n2)。\n    * 将每一个子数组求和的时间复杂度为：o(n)o(n)o(n) 。\n    * 所以总时间复杂度为：o(n2∗n)=o(n3)o(n^2 * n) = o(n^3)o(n2∗n)=o(n3) 。\n   \n   \n * 空间复杂度：o(1)o(1)o(1)。只是用了常数个额外变量。\n   \n   \n\n# 方法 2：优化的暴力\n想法\n\n在方法 1 中，我们注意到求子数组的和需要的时间为 o(n)o(n)o(n) 。我们其实可以很容易地实现 o(1)o(1)o(1) 时间的求和，只需要从开始元素用一个累加器保存和。我们将累积和保存在 sums\\text{sums}sums 中，通过这种方法，我们可以轻松求出任意子区间的和。\n\n算法\n\n * 算法流程与方法 1 类似。\n * 唯一的不同是求子数组的和： * 建立一个大小为 nums\\text{nums}nums 的向量 sums\\text{sums}sums\n    * 初始化 sums[0]=nums[0]\\text{sums}[0]=\\text{nums}[0]sums[0]=nums[0]\n    * 遍历 向量 sums\\text{sums}sums ： * 更新 sums[i]=sums[i−1]+nums[i]\\text{sums}[i] = \\text{sums}[i-1] + \\text{nums}[i]sums[i]=sums[i−1]+nums[i]\n      \n      \n    * 从 iii 到 jjj 的和计算方法：sum=sums[j]−sums[i]+nums[i]\\text{sum}=\\text{sums}[j] - \\text{sums}[i] +\\text{nums}[i]sum=sums[j]−sums[i]+nums[i] ，其中 sums[j]−sums[i]\\text{sums}[j] - \\text{sums}[i]sums[j]−sums[i] 是从第 i+1i+1i+1 个元素到第 jjj 个元素的和。\n   \n   \n\nint minsubarraylen(int s, vector<int>& nums)\n{\n    int n = nums.size();\n    if (n == 0)\n        return 0;\n    int ans = int_max;\n    vector<int> sums(n);\n    sums[0] = nums[0];\n    for (int i = 1; i < n; i++)\n        sums[i] = sums[i - 1] + nums[i];\n    for (int i = 0; i < n; i++) {\n        for (int j = i; j < n; j++) {\n            int sum = sums[j] - sums[i] + nums[i];\n            if (sum >= s) {\n                ans = min(ans, (j - i + 1));\n                break; //found the smallest subarray with sum>=s starting with index i, hence move to next index\n            }\n        }\n    }\n    return (ans != int_max) ? ans : 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n复杂度分析\n\n * 时间复杂度：o(n2)o(n^2)o(n2) 。\n   \n    * 找到所有子数组的时间复杂度为 o(n2)o(n^2)o(n2) 。\n    * 计算子数组的和为 o(1)o(1)o(1) 的时间。\n    * 因此，总时间复杂度为：o(n2∗1)=o(n2)o(n^2 * 1) = o(n^2)o(n2∗1)=o(n2) 。\n   \n   \n * 空间复杂度：o(n)o(n)o(n) 。\n   \n    * 额外的 sums\\text{sums}sums 数组空间大小为 o(n)o(n)o(n) 。\n   \n   \n\n# 方法 3：使用二分查找\n想法\n\n我们可以用二分查找的方法优化方法 2 。我们找到从下标 iii 开始满足 sum≥s\\text{sum} \\geq \\text{s}sum≥s 的子数组需要 o(n)o(n)o(n) 的时间。但是我们可以用二分查找的方法把这个时间优化到 o(log⁡(n))o(\\log(n))o(log(n)) 。在方法 2 中，我们从 iii 开始找 jjj ，直到找到 sum=sums[j]−sums[i]+nums[i]\\text{sum}=\\text{sums}[j] - \\text{sums}[i] + \\text{nums}[i]sum=sums[j]−sums[i]+nums[i] 大于等于s\\text{s}s 的。与其线性地查找这个和，我们可以使用二分搜索的方法找到 sums\\text{sums}sums 中不小于 s+sums[i]−nums[i]\\text{s}+\\text{sums[i]}-\\text{nums[i]}s+sums[i]−nums[i] 的第一个 sums[j]\\text{sums[j]}sums[j] ，可以用 c++ stl 中的 \\text{lower_bound} 函数做到。\n\n算法\n\n * 创建大小为 n+1n+1n+1 的数组 sumssumssums ：\n\nsums[0]=0, sums[i]=sums[i−1]+nums[i−1]\\text{sums}[0]=0\\text{, }\\text{sums}[i]=\\text{sums}[i-1]+\\text{nums}[i-1]sums[0]=0,sums[i]=sums[i−1]+nums[i−1]\n\n * 从 i=1i=1i=1 到 nnn 枚举： * 在 sums\\text{sums}sums 中找到值 to_find\\text{to\\_find}to_find ，满足从 iii 开始到这个位置的和大于等于 sss 且是最小子数组：\n   \n   to_find=s+sums[i−1]\\text{to\\_find}=\\text{s}+\\text{sums}[i-1]to_find=s+sums[i−1]\n   \n   +在 sums\\text{sums}sums 中找到值满足大于等于 \\text{to_find} 的下标，记作 bound\\text{bound}bound+如果我们在 sums\\text{sums}sums 中找到了值 \\text{to_find}， 那么： - 当前子数组的大小为： $$\\text{bound} - (\\text{sums.begin}()+i-1)$$ - 将 ansansans 与当前数组的大小做比较，并把较小值保存到 ansansans 中\n\nint minsubarraylen(int s, vector<int>& nums)\n{\n    int n = nums.size();\n    if (n == 0)\n        return 0;\n    int ans = int_max;\n    vector<int> sums(n + 1, 0); //size = n+1 for easier calculations\n    //sums[0]=0 : meaning that it is the sum of first 0 elements\n    //sums[1]=a[0] : sum of first 1 elements\n    //ans so on...\n    for (int i = 1; i <= n; i++)\n        sums[i] = sums[i - 1] + nums[i - 1];\n    for (int i = 1; i <= n; i++) {\n        int to_find = s + sums[i - 1];\n        auto bound = lower_bound(sums.begin(), sums.end(), to_find);\n        if (bound != sums.end()) {\n            ans = min(ans, static_cast<int>(bound - (sums.begin() + i - 1)));\n        }\n    }\n    return (ans != int_max) ? ans : 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n复杂度分析\n\n * 时间复杂度：o(nlog⁡(n))o(n\\log(n))o(nlog(n)) 。 * 对向量中的每一个元素，从它开始用二分查找找到子数组，满足和大于 sss 。因此，遍历的时间复杂度是 o(n)o(n)o(n) ，二分查找的时间复杂度是 o(log⁡(n))o(\\log(n))o(log(n)) 。\n    * 因此，总时间复杂度是 o(n∗log⁡(n))o(n*\\log(n))o(n∗log(n))\n   \n   \n * 空间复杂度：o(n)o(n)o(n) 。sums\\text{sums}sums 需要额外的 o(n)o(n)o(n) 空间。\n\n# 方法 4：使用两个指针\n想法\n\n到现在为止，我们都保持子数组的左端点不动去找右端点。其实一旦知道这个位置开始的子数组不会是最优答案了，我们就可以移动左端点。我们用 2 个指针，一个指向数组开始的位置，一个指向数组最后的位置，并维护区间内的和 sum\\text{sum}sum 大于等于 sss 同时数组长度最小。\n\n算法\n\n * 初始化 left\\text{left}left 指向 0 且初始化 sum\\text{sum}sum 为 0\n * 遍历 nums\\text{nums}nums 数组： * 将 nums[i]\\text{nums}[i]nums[i] 添加到 sum\\text{sum}sum\n    * 当 sum\\text{sum}sum 大于等于 sss 时： * 更新 ans=min⁡(ans,i+1−left)\\text{ans}=\\min(\\text{ans},i+1-\\text{left})ans=min(ans,i+1−left) ，其中 i+1−lefti+1-\\text{left}i+1−left是当前子数组的长度\n       * 然后我们可以移动左端点，因为以它为开头的满足 sum≥s\\text{sum} \\geq ssum≥s 条件的最短子数组已经求出来了\n       * 将 sum\\text{sum}sum 减去 nums[left]\\text{nums[left]}nums[left] 然后增加 left\\text{left}left\n      \n      \n   \n   \n\nint minsubarraylen(int s, vector<int>& nums)\n{\n    int n = nums.size();\n    int ans = int_max;\n    int left = 0;\n    int sum = 0;\n    for (int i = 0; i < n; i++) {\n        sum += nums[i];\n        while (sum >= s) {\n            ans = min(ans, i + 1 - left);\n            sum -= nums[left++];\n        }\n    }\n    return (ans != int_max) ? ans : 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n复杂度分析\n\n * 时间复杂度：o(n)o(n)o(n) 。每个指针移动都需要 o(n)o(n)o(n) 的时间。 * 每个元素至多被访问两次，一次被右端点访问，一次被左端点访问。\n   \n   \n * 空间复杂度： o(1)o(1)o(1) 。left\\text{left}left，sum\\text{sum}sum，ans\\text{ans}ans 以及 iii 这些变量只需要常数个空间。\n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-09-01 16:02:17accepted [https://leetcode-cn.com//submissions/detail/6379608/]4 ms26.1%n/ajava2018-09-01 16:00:14accepted [https://leetcode-cn.com//submissions/detail/6379424/]3 ms34.16%n/ajava2018-09-01 15:59:47accepted [https://leetcode-cn.com//submissions/detail/6379386/]3 ms34.16%n/ajava2018-09-01 15:58:11wrong answer [https://leetcode-cn.com//submissions/detail/6379252/]n/an/an/ajava2018-09-01 15:43:34wrong answer [https://leetcode-cn.com//submissions/detail/6378032/]n/an/an/ajava# 统计信息\n通过次数提交次数ac比率243395971240.8%# 相似题目\n题目难度最小覆盖子串 [https://leetcode-cn.com/problems/minimum-window-substring/]困难和等于 k 的最长子数组长度 [https://leetcode-cn.com/problems/maximum-size-subarray-sum-equals-k/]中等最长重复子数组 [https://leetcode-cn.com/problems/maximum-length-of-repeated-subarray/]中等"},{title:"144-二叉树的前序遍历(Binary Tree Preorder Traversal)",frontmatter:{title:"144-二叉树的前序遍历(Binary Tree Preorder Traversal)",date:"2021-04-19T00:00:00.000Z",categories:["中等"],tags:["栈<Stack>","树<Tree>"]},regularPath:"/views/%E4%B8%AD%E7%AD%89/0144-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86.html",relativePath:"views/中等/0144-二叉树的前序遍历.md",key:"v-172d1308",path:"/views/%E4%B8%AD%E7%AD%89/0144-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86.html",headers:[{level:2,title:"中文题目",slug:"中文题目",charIndex:2},{level:2,title:"通过代码",slug:"通过代码",charIndex:289},{level:2,title:"高赞题解",slug:"高赞题解",charIndex:11763},{level:2,title:"递归解法",slug:"递归解法",charIndex:11912},{level:3,title:"前序遍历",slug:"前序遍历",charIndex:30},{level:3,title:"中序遍历",slug:"中序遍历",charIndex:11796},{level:3,title:"后序遍历",slug:"后序遍历",charIndex:11854},{level:3,title:"代码解释",slug:"代码解释",charIndex:12594},{level:2,title:"迭代解法",slug:"迭代解法",charIndex:12844},{level:3,title:"前序遍历",slug:"前序遍历-2",charIndex:30},{level:3,title:"中序遍历",slug:"中序遍历-2",charIndex:11796},{level:3,title:"后序遍历",slug:"后序遍历-2",charIndex:11854},{level:2,title:"Morris解法",slug:"morris解法",charIndex:15647},{level:3,title:"前序遍历",slug:"前序遍历-3",charIndex:30},{level:3,title:"中序遍历",slug:"中序遍历-3",charIndex:11796},{level:3,title:"后序遍历",slug:"后序遍历-3",charIndex:11854},{level:2,title:"提交历史",slug:"提交历史",charIndex:19353},{level:2,title:"统计信息",slug:"统计信息",charIndex:20483},{level:2,title:"相似题目",slug:"相似题目",charIndex:20519}],lastUpdated:"4/11/2021, 1:15:21 PM",headersStr:"中文题目 通过代码 高赞题解 递归解法 前序遍历 中序遍历 后序遍历 代码解释 迭代解法 前序遍历 中序遍历 后序遍历 Morris解法 前序遍历 中序遍历 后序遍历 提交历史 统计信息 相似题目",content:'# 中文题目\n给你二叉树的根节点 root ，返回它节点值的前序遍历。\n\n\n\n示例 1：\n\n\n输入：root = [1,null,2,3]\n输出：[1,2,3]\n\n\n示例 2：\n\n\n输入：root = []\n输出：[]\n\n\n示例 3：\n\n\n输入：root = [1]\n输出：[1]\n\n\n示例 4：\n\n\n输入：root = [1,2]\n输出：[1,2]\n\n\n示例 5：\n\n\n输入：root = [1,null,2]\n输出：[1,2]\n\n\n\n\n提示：\n\n * 树中节点数目在范围 [0, 100] 内\n * -100 \n\n\n\n进阶：递归算法很简单，你可以通过迭代算法完成吗？\n\n# 通过代码\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n        public List<Integer> preorderTraversal(TreeNode root) {\n            List<Integer> result = new ArrayList<>();\n            Stack<TreeNode> stack =new Stack<>();\n            while (root!=null || !stack.isEmpty()){\n                while (root!=null){\n                    result.add(root.val);\n                    stack.push(root);\n                    root=root.left;\n                }\n                root=stack.pop();\n                root=root.right;\n            }\n            return result;\n        }\n    }\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n        public List<Integer> preorderTraversal(TreeNode root) {\n            List<Integer> result = new ArrayList<>();\n            preOrder(root, result);\n            return result;\n        }\n\n        private void preOrder(TreeNode root, List<Integer> result) {\n            if (root != null) {\n                result.add(root.val);\n                preOrder(root.left, result);\n                preOrder(root.right, result);\n            }\n        }\n    }\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public List<Integer> preorderTraversal(TreeNode root) {\n        List<Integer> list=new LinkedList<>();\n            Stack<TreeNode> stack=new Stack<>();\n            if (root==null){\n                return list;\n            }\n            stack.push(root);\n            while (!stack.isEmpty()){\n                TreeNode node=stack.peek();\n                stack.pop();\n                if (node.right!=null){\n                    stack.push(node.right);\n                }\n                if (node.left!=null){\n                    stack.push(node.left);\n                }\n                list.add(node.val);\n            }\n            return list;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public List<Integer> preorderTraversal(TreeNode root) {\n        List<Integer> list=new LinkedList<>();\n            Stack<TreeNode> stack=new Stack<>();\n            if (root==null){\n                return list;\n            }\n            stack.push(root);\n            while (!stack.isEmpty()){\n                TreeNode node=stack.peek();\n                stack.pop();\n                if (node.right!=null){\n                    stack.push(node.right);\n                }\n                if (node.left!=null){\n                    stack.push(node.left);\n                }\n                list.add(node.val);\n            }\n            return list;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public List<Integer> preorderTraversal(TreeNode root) {\n        List<Integer> list=new LinkedList<>();\n            Stack<TreeNode> stack=new Stack<>();\n            if (root==null){\n                return list;\n            }\n            stack.push(root);\n            while (!stack.isEmpty()){\n                TreeNode node=stack.peek();\n                stack.pop();\n                if (node.right!=null){\n                    stack.push(node.right);\n                }\n                if (node.left!=null){\n                    stack.push(node.left);\n                }\n                list.add(node.val);\n            }\n            return list;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nimport java.util.Stack;\nclass Solution{\n     class Command{\n            String s;\n            TreeNode node;\n\n            public Command(String s, TreeNode node) {\n                this.s = s;\n                this.node = node;\n            }\n        }\n        public  List<Integer> preorderTraversal(TreeNode root) {\n            LinkedList<Integer> linkedList=new LinkedList<>();\n            if (root==null){\n                return linkedList;\n            }\n//            模拟系统栈调用\n            Stack<Command> stack=new Stack<>();\n            stack.push(new Command("go",root));\n            while (!stack.isEmpty()){\n                Command command=stack.pop();\n                if (command.s.equals("print")){\n                    linkedList.add(command.node.val);\n                }else {\n//                    与递归的相反\n                    if (command.node.right!=null){\n                        stack.push(new Command("go",command.node.right));\n                    }\n                    if (command.node.left!=null){\n                        stack.push(new Command("go",command.node.left));\n                    }\n                    stack.push(new Command("print",command.node));\n                }\n            }\n            return linkedList;\n        }\n    \n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nimport java.util.Stack;\nclass Solution{\n     class Command{\n            String s;\n            TreeNode node;\n\n            public Command(String s, TreeNode node) {\n                this.s = s;\n                this.node = node;\n            }\n        }\n        public  List<Integer> preorderTraversal(TreeNode root) {\n            LinkedList<Integer> linkedList=new LinkedList<>();\n            if (root==null){\n                return linkedList;\n            }\n//            模拟系统栈调用\n            Stack<Command> stack=new Stack<>();\n            stack.push(new Command("go",root));\n            while (!stack.isEmpty()){\n                Command command=stack.pop();\n                if (command.s.equals("print")){\n                    linkedList.add(command.node.val);\n                }else {\n//                    与递归的相反\n                    if (command.node.right!=null){\n                        stack.push(new Command("go",command.node.right));\n                    }\n                    if (command.node.left!=null){\n                        stack.push(new Command("go",command.node.left));\n                    }\n                    stack.push(new Command("print",command.node));\n                }\n            }\n            return linkedList;\n        }\n    \n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nimport java.util.Stack;\nclass Solution {\n    class Command{\n            String s;\n            TreeNode node;\n\n            public Command(String s, TreeNode node) {\n                this.s = s;\n                this.node = node;\n            }\n        }\n        public List<Integer> preorderTraversal(TreeNode root) {\n            LinkedList<Integer> linkedList=new LinkedList<>();\n            if (root==null){\n                return linkedList;\n            }\n            Stack<Command> stack=new Stack<>();\n            stack.push(new Command("go",root));\n            while (!stack.isEmpty()){\n                Command command=stack.pop();\n                if (command.s.equals("print")){\n                    linkedList.add(command.node.val);\n                }else {\n                      if (command.node.right!=null){\n                        stack.push(new Command("go",command.node.right));\n                    }\n                     if (command.node.left!=null){\n                        stack.push(new Command("go",command.node.left));\n                    }\n                   \n                    stack.push(new Command("print",command.node));\n                   \n                }\n            }\n            return linkedList;\n        }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nimport java.util.Stack;\nclass Solution {\n    class Command{\n            String s;\n            TreeNode node;\n\n            public Command(String s, TreeNode node) {\n                this.s = s;\n                this.node = node;\n            }\n        }\n        public List<Integer> preorderTraversal(TreeNode root) {\n            LinkedList<Integer> linkedList=new LinkedList<>();\n            if (root==null){\n                return linkedList;\n            }\n            Stack<Command> stack=new Stack<>();\n            stack.push(new Command("go",root));\n            while (!stack.isEmpty()){\n                Command command=stack.pop();\n                if (command.s.equals("print")){\n                    linkedList.push(command.node.val);\n                }else {\n                     stack.push(new Command("print",command.node));\n                     if (command.node.left!=null){\n                        stack.push(new Command("go",command.node.left));\n                    }\n                    if (command.node.right!=null){\n                        stack.push(new Command("go",command.node.right));\n                    }\n                   \n                }\n            }\n            return linkedList;\n        }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nimport java.util.LinkedList;\nimport java.util.List;\nclass Solution {\n    public List<Integer> preorderTraversal(TreeNode root) {\n        LinkedList<Integer> list=new LinkedList<>();\n            if (root!=null){\n                list.addLast(root.val);\n                list.addAll(preorderTraversal(root.left));\n                list.addAll(preorderTraversal(root.right));\n            }\n        return list;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n# 高赞题解\n# X.遍历二叉树的方法合集\n 1.  94. 二叉树的中序遍历\n    \n    \n 2.  144. 二叉树的前序遍历\n    \n    \n 3.  145. 二叉树的后序遍历\n    \n    \n\n文章有一点长，代码居多。会给出比较详细的动画演示以及视频讲解请大家耐心阅读。\n\n# 递归解法\n# 前序遍历\npublic static void preOrderRecur(TreeNode head) {\n    if (head == null) {\n        return;\n    }\n    System.out.print(head.value + " ");\n    preOrderRecur(head.left);\n    preOrderRecur(head.right);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n# 中序遍历\npublic static void preOrderRecur(TreeNode head) {\n    if (head == null) {\n        return;\n    }\n    preOrderRecur(head.left);\n    System.out.print(head.value + " ");\n    preOrderRecur(head.right);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n# 后序遍历\npublic static void postOrderRecur(TreeNode head) {\n    if (head == null) {\n        return;\n    }\n    postOrderRecur(head.left);\n    postOrderRecur(head.right);\n    System.out.print(head.value + " ");\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n# 代码解释\n这里没有对递归遍历做过多的解释，仅仅给出了简单的动画演示。 要理解递归的思路并且熟练的使用它，就是要想清楚你想做什么，什么时候停止。\n\n如前序遍历：我想先打印头节点对吧？那我打印完了头节点，我现在想打印左边节点了，我只是告诉计算机我想打印左边结点，之后打印右边结点。\n\n那么后序遍历呢？这个时候你应该知道了，我就是想操作左边然后右边，最后打印中间的元素。\n\n我们并不需要太过于在意具体的递归过程，而是要想清楚让计算机干什么。\n\n> 计算机都可能溢出，用人脑去遍历就不现实了。\n\n\n\n\n\n# 迭代解法\n本质上是在模拟递归，因为在递归的过程中使用了系统栈，所以在迭代的解法中常用Stack来模拟系统栈。\n\n# 前序遍历\n首先我们应该创建一个Stack用来存放节点，首先我们想要打印根节点的数据，此时Stack里面的内容为空，所以我们优先将头结点加入Stack，然后打印。\n\n之后我们应该先打印左子树，然后右子树。所以先加入Stack的就是右子树，然后左子树。 此时你能得到的流程如下:\n\n{:width="500px"}{:align="center"}\n\npublic static void preOrderIteration(TreeNode head) {\n\tif (head == null) {\n\t\treturn;\n\t}\n\tStack<TreeNode> stack = new Stack<>();\n\tstack.push(head);\n\twhile (!stack.isEmpty()) {\n\t\tTreeNode node = stack.pop();\n\t\tSystem.out.print(node.value + " ");\n\t\tif (node.right != null) {\n\t\t\tstack.push(node.right);\n\t\t}\n\t\tif (node.left != null) {\n\t\t\tstack.push(node.left);\n\t\t}\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n# 中序遍历\n 1. 同理创建一个Stack，然后按 左 中 右的顺序输出节点。\n 2. 尽可能的将这个节点的左子树压入Stack，此时栈顶的元素是最左侧的元素，其目的是找到一个最小单位的子树(也就是最左侧的一个节点)，并且在寻找的过程中记录了来源，才能返回上层,同时在返回上层的时候已经处理完毕左子树了。。\n 3. 当处理完最小单位的子树时，返回到上层处理了中间节点。（如果把整个左中右的遍历都理解成子树的话，就是处理完 左子树->中间(就是一个节点)->右子树）\n 4. 如果有右节点，其也要进行中序遍历。{:width="300px"}{:align="left"} 当整个左子树退栈的时候这个时候输出了该子树的根节点 2，之后输出中间节点 1。然后处理根节点为3右子树。\n\npublic static void inOrderIteration(TreeNode head) {\n\tif (head == null) {\n\t\treturn;\n\t}\n\tTreeNode cur = head;\n\tStack<TreeNode> stack = new Stack<>();\n\twhile (!stack.isEmpty() || cur != null) {\n\t\twhile (cur != null) {\n\t\t\tstack.push(cur);\n\t\t\tcur = cur.left;\n\t\t}\n\t\tTreeNode node = stack.pop();\n\t\tSystem.out.print(node.value + " ");\n\t\tif (node.right != null) {\n\t\t\tcur = node.right;\n\t\t}\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n# 后序遍历\n# 代码片段 1\n 1. 前序遍历的过程 是 中左右。\n 2. 将其转化成 中右左。也就是压栈的过程中优先压入左子树，在压入右子树。\n 3. 然后将这个结果返回来，这里是利用栈的先进后出倒序打印。\n\npublic static void postOrderIteration(TreeNode head) {\n\t\tif (head == null) {\n\t\t\treturn;\n\t\t}\n\t\tStack<TreeNode> stack1 = new Stack<>();\n\t\tStack<TreeNode> stack2 = new Stack<>();\n\t\tstack1.push(head);\n\t\twhile (!stack1.isEmpty()) {\n\t\t\tTreeNode node = stack1.pop();\n\t\t\tstack2.push(node);\n\t\t\tif (node.left != null) {\n\t\t\t\tstack1.push(node.left);\n\t\t\t}\n\t\t\tif (node.right != null) {\n\t\t\t\tstack1.push(node.right);\n\t\t\t}\n\t\t}\n\t\twhile (!stack2.isEmpty()) {\n\t\t\tSystem.out.print(stack2.pop().value + " ");\n\t\t}\n\t}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n# 代码片段 2\n 1. 用一个指针cur标记当前退出的节点是什么。\n 2. 后序遍历的过程中在遍历完左子树跟右子树cur都会回到根结点。所以当前不管是从左子树还是右子树回到根结点都不应该再操作了，应该退回上层。\n 3. 如果是从右边再返回根结点，应该回到上层。\n\npublic static void postOrderIteration2(TreeNode head) { 感谢[@ben-ben-niu](/u/ben-ben-niu/)指出错误，代码确实存在问题，已经在原文中修复\n\tif (head == null) {\n\t\treturn;\n\t}\n\tTreeNode cur = head;\n\tStack<TreeNode> stack = new Stack<>();\n\tstack.push(head);\n\twhile (!stack.isEmpty()) {\n\t\tTreeNode peek = stack.peek();\n\t\tif (peek.left != null && peek.left != cur && peek.right != cur) {\n\t\t\tstack.push(peek.left);\n\t\t} else if (peek.right != null && peek.right != cur) {\n\t\t\tstack.push(peek.right);\n\t\t} else {\n\t\t\tSystem.out.print(stack.pop().val + " ");\n\t\t\tcur = peek;\n\t\t}\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# Morris解法\nMorris遍历使用二叉树节点中大量指向null的指针，由Joseph Morris 于1979年发明。 时间复杂度：O(n)O(n)O(n)额外空间复杂度：O(1)O(1)O(1)\n\n在你阅读以下代码之前，在这边先讲解一下Morris的通用解法过程。\n\nMorris的整体思路就是将 以某个根结点开始，找到它左子树的最右侧节点之后与这个根结点进行连接我们可以从 图2 看到，如果这么连接之后，cur 这个指针是可以完整的从一个节点顺着下一个节点遍历，将整棵树遍历完毕，直到 7 这个节点右侧没有指向。\n\npublic static void preOrderMorris(TreeNode head) {\n\tif (head == null) {\n\t\treturn;\n\t}\n\tTreeNode cur1 = head;//当前开始遍历的节点\n\tTreeNode cur2 = null;//记录当前结点的左子树\n\twhile (cur1 != null) {\n\t\tcur2 = cur1.left;\n\t\tif (cur2 != null) {\n\t\t\twhile (cur2.right != null && cur2.right != cur1) {//找到当前左子树的最右侧节点，且这个节点应该在指向根结点之前，否则整个节点又回到了根结点。\n\t\t\t\tcur2 = cur2.right;\n\t\t\t}\n\t\t\tif (cur2.right == null) {//这个时候如果最右侧这个节点的右指针没有指向根结点，创建连接然后往下一个左子树的根结点进行连接操作。\n\t\t\t\tcur2.right = cur1;\n\t\t\t\tcur1 = cur1.left;\n\t\t\t\tcontinue;\n\t\t\t} else {//当左子树的最右侧节点有指向根结点，此时说明我们已经回到了根结点并重复了之前的操作，同时在回到根结点的时候我们应该已经处理完 左子树的最右侧节点 了，把路断开。\n\t\t\t\tcur2.right = null;\n\t\t\t}\n\t\t} \n\t\tcur1 = cur1.right;//一直往右边走，参考图\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n# 前序遍历\n 1. 在某个根结点创建连线的时候打印。因为我们是顺着左边的根节点来创建连线，且创建的过程只有一次。\n 2. 打印某些自身无法创建连线的节点，也就是叶子节点。\n\npublic static void preOrderMorris(TreeNode head) {\n\tif (head == null) {\n\t\treturn;\n\t}\n\tTreeNode cur1 = head;\n\tTreeNode cur2 = null;\n\twhile (cur1 != null) {\n\t\tcur2 = cur1.left;\n\t\tif (cur2 != null) {\n\t\t\twhile (cur2.right != null && cur2.right != cur1) {\n\t\t\t\tcur2 = cur2.right;\n\t\t\t}\n\t\t\tif (cur2.right == null) {\n\t\t\t\tcur2.right = cur1;\n\t\t\t\tSystem.out.print(cur1.value + " ");\n\t\t\t\tcur1 = cur1.left;\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\tcur2.right = null;\n\t\t\t}\n\t\t} else {\n\t\t\tSystem.out.print(cur1.value + " ");\n\t\t}\n\t\tcur1 = cur1.right;\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n# 中序遍历\n从最左侧开始顺着右节点打印。也就是在将cu1切换到上层节点的时候。\n\npublic static void inOrderMorris(TreeNode head) {\n\tif (head == null) {\n\t\treturn;\n\t}\n\tTreeNode cur1 = head;\n\tTreeNode cur2 = null;\n\twhile (cur1 != null) {\n\t\tcur2 = cur1.left;\n\t\t//构建连接线\n\t\tif (cur2 != null) {\n\t\t\twhile (cur2.right != null && cur2.right != cur1) {\n\t\t\t\tcur2 = cur2.right;\n\t\t\t}\n\t\t\tif (cur2.right == null) {\n\t\t\t\tcur2.right = cur1;\n\t\t\t\tcur1 = cur1.left;\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\tcur2.right = null;\n\t\t\t}\n\t\t}\n\t\tSystem.out.print(cur1.value + " ");\n\t\tcur1 = cur1.right;\n\t}\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n# 后序遍历\n后序遍历就比较复杂了哈，先看一下图{:width="400px"}{:align="center"}\n\n当我们到达最左侧，也就是左边连线已经创建完毕了。 打印 4 打印 5 2 打印 6 打印 7 3 1 我们将一个节点的连续右节点当成一个单链表来看待。 当我们返回上层之后，也就是将连线断开的时候，打印下层的单链表。 比如返回到 ２，此时打印 ４ 比如返回到 １，此时打印 ５ ２ 比如返回到 ３，此时打印 ６ 那么我们只需要将这个单链表逆序打印就行了，下文也给出了 单链表逆序代码这里不应该打印当前层，而是下一层，否则根结点会先与右边打印。\n\n//后序Morris\npublic static void postOrderMorris(TreeNode head) {\n\tif (head == null) {\n\t\treturn;\n\t}\n\tTreeNode cur1 = head;//遍历树的指针变量\n\tTreeNode cur2 = null;//当前子树的最右节点\n\twhile (cur1 != null) {\n\t\tcur2 = cur1.left;\n\t\tif (cur2 != null) {\n\t\t\twhile (cur2.right != null && cur2.right != cur1) {\n\t\t\t\tcur2 = cur2.right;\n\t\t\t}\n\t\t\tif (cur2.right == null) {\n\t\t\t\tcur2.right = cur1;\n\t\t\t\tcur1 = cur1.left;\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\tcur2.right = null;\n\t\t\t\tpostMorrisPrint(cur1.left);\n\t\t\t}\n\t\t}\n\t\tcur1 = cur1.right;\n\t}\n\tpostMorrisPrint(head);\n}\n//打印函数\npublic static void postMorrisPrint(TreeNode head) {\n\tTreeNode reverseList = postMorrisReverseList(head);\n\tTreeNode cur = reverseList;\n\twhile (cur != null) {\n\t\tSystem.out.print(cur.value + " ");\n\t\tcur = cur.right;\n\t}\n\tpostMorrisReverseList(reverseList);\n}\n//翻转单链表\npublic static TreeNode postMorrisReverseList(TreeNode head) {\n\tTreeNode cur = head;\n\tTreeNode pre = null;\n\twhile (cur != null) {\n\t\tTreeNode next = cur.right;\n\t\tcur.right = pre;\n\t\tpre = cur;\n\t\tcur = next;\n\t}\n\treturn pre;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n\n\n\n感谢收看\n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2021-04-19 22:55:25Accepted [https://leetcode-cn.com//submissions/detail/169790746/]1 ms100.0%36.6 MBjava2021-04-19 22:45:34Accepted [https://leetcode-cn.com//submissions/detail/169786784/]0 ms100.0%36.6 MBjava2018-09-05 16:08:40Accepted [https://leetcode-cn.com//submissions/detail/6586491/]1 ms100.0%N/Ajava2018-09-05 15:39:59Accepted [https://leetcode-cn.com//submissions/detail/6583181/]2 ms100.0%N/Ajava2018-09-05 15:39:42Accepted [https://leetcode-cn.com//submissions/detail/6583155/]2 ms100.0%N/Ajava2018-09-05 15:25:25Accepted [https://leetcode-cn.com//submissions/detail/6581987/]2 ms100.0%N/Ajava2018-07-16 20:50:15Accepted [https://leetcode-cn.com//submissions/detail/4253086/]2 ms100.0%N/Ajava2018-07-16 20:46:13Accepted [https://leetcode-cn.com//submissions/detail/4252939/]2 ms100.0%N/Ajava2018-07-16 20:32:53Accepted [https://leetcode-cn.com//submissions/detail/4252207/]3 ms100.0%N/Ajava2018-07-16 20:32:11Wrong Answer [https://leetcode-cn.com//submissions/detail/4252179/]N/AN/AN/Ajava2018-07-16 19:57:34Accepted [https://leetcode-cn.com//submissions/detail/4250832/]1 ms100.0%N/Ajava# 统计信息\n通过次数提交次数AC比率30299043524069.6%# 相似题目\n题目难度二叉树的中序遍历 [https://leetcode-cn.com/problems/binary-tree-inorder-traversal/]中等验证前序遍历序列二叉搜索树 [https://leetcode-cn.com/problems/verify-preorder-sequence-in-binary-search-tree/]中等N 叉树的前序遍历 [https://leetcode-cn.com/problems/n-ary-tree-preorder-traversal/]简单',contentLowercase:'# 中文题目\n给你二叉树的根节点 root ，返回它节点值的前序遍历。\n\n\n\n示例 1：\n\n\n输入：root = [1,null,2,3]\n输出：[1,2,3]\n\n\n示例 2：\n\n\n输入：root = []\n输出：[]\n\n\n示例 3：\n\n\n输入：root = [1]\n输出：[1]\n\n\n示例 4：\n\n\n输入：root = [1,2]\n输出：[1,2]\n\n\n示例 5：\n\n\n输入：root = [1,null,2]\n输出：[1,2]\n\n\n\n\n提示：\n\n * 树中节点数目在范围 [0, 100] 内\n * -100 \n\n\n\n进阶：递归算法很简单，你可以通过迭代算法完成吗？\n\n# 通过代码\n/**\n * definition for a binary tree node.\n * public class treenode {\n *     int val;\n *     treenode left;\n *     treenode right;\n *     treenode() {}\n *     treenode(int val) { this.val = val; }\n *     treenode(int val, treenode left, treenode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass solution {\n        public list<integer> preordertraversal(treenode root) {\n            list<integer> result = new arraylist<>();\n            stack<treenode> stack =new stack<>();\n            while (root!=null || !stack.isempty()){\n                while (root!=null){\n                    result.add(root.val);\n                    stack.push(root);\n                    root=root.left;\n                }\n                root=stack.pop();\n                root=root.right;\n            }\n            return result;\n        }\n    }\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n/**\n * definition for a binary tree node.\n * public class treenode {\n *     int val;\n *     treenode left;\n *     treenode right;\n *     treenode() {}\n *     treenode(int val) { this.val = val; }\n *     treenode(int val, treenode left, treenode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass solution {\n        public list<integer> preordertraversal(treenode root) {\n            list<integer> result = new arraylist<>();\n            preorder(root, result);\n            return result;\n        }\n\n        private void preorder(treenode root, list<integer> result) {\n            if (root != null) {\n                result.add(root.val);\n                preorder(root.left, result);\n                preorder(root.right, result);\n            }\n        }\n    }\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n/**\n * definition for a binary tree node.\n * public class treenode {\n *     int val;\n *     treenode left;\n *     treenode right;\n *     treenode(int x) { val = x; }\n * }\n */\nclass solution {\n    public list<integer> preordertraversal(treenode root) {\n        list<integer> list=new linkedlist<>();\n            stack<treenode> stack=new stack<>();\n            if (root==null){\n                return list;\n            }\n            stack.push(root);\n            while (!stack.isempty()){\n                treenode node=stack.peek();\n                stack.pop();\n                if (node.right!=null){\n                    stack.push(node.right);\n                }\n                if (node.left!=null){\n                    stack.push(node.left);\n                }\n                list.add(node.val);\n            }\n            return list;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n/**\n * definition for a binary tree node.\n * public class treenode {\n *     int val;\n *     treenode left;\n *     treenode right;\n *     treenode(int x) { val = x; }\n * }\n */\nclass solution {\n    public list<integer> preordertraversal(treenode root) {\n        list<integer> list=new linkedlist<>();\n            stack<treenode> stack=new stack<>();\n            if (root==null){\n                return list;\n            }\n            stack.push(root);\n            while (!stack.isempty()){\n                treenode node=stack.peek();\n                stack.pop();\n                if (node.right!=null){\n                    stack.push(node.right);\n                }\n                if (node.left!=null){\n                    stack.push(node.left);\n                }\n                list.add(node.val);\n            }\n            return list;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n/**\n * definition for a binary tree node.\n * public class treenode {\n *     int val;\n *     treenode left;\n *     treenode right;\n *     treenode(int x) { val = x; }\n * }\n */\nclass solution {\n    public list<integer> preordertraversal(treenode root) {\n        list<integer> list=new linkedlist<>();\n            stack<treenode> stack=new stack<>();\n            if (root==null){\n                return list;\n            }\n            stack.push(root);\n            while (!stack.isempty()){\n                treenode node=stack.peek();\n                stack.pop();\n                if (node.right!=null){\n                    stack.push(node.right);\n                }\n                if (node.left!=null){\n                    stack.push(node.left);\n                }\n                list.add(node.val);\n            }\n            return list;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n/**\n * definition for a binary tree node.\n * public class treenode {\n *     int val;\n *     treenode left;\n *     treenode right;\n *     treenode(int x) { val = x; }\n * }\n */\nimport java.util.stack;\nclass solution{\n     class command{\n            string s;\n            treenode node;\n\n            public command(string s, treenode node) {\n                this.s = s;\n                this.node = node;\n            }\n        }\n        public  list<integer> preordertraversal(treenode root) {\n            linkedlist<integer> linkedlist=new linkedlist<>();\n            if (root==null){\n                return linkedlist;\n            }\n//            模拟系统栈调用\n            stack<command> stack=new stack<>();\n            stack.push(new command("go",root));\n            while (!stack.isempty()){\n                command command=stack.pop();\n                if (command.s.equals("print")){\n                    linkedlist.add(command.node.val);\n                }else {\n//                    与递归的相反\n                    if (command.node.right!=null){\n                        stack.push(new command("go",command.node.right));\n                    }\n                    if (command.node.left!=null){\n                        stack.push(new command("go",command.node.left));\n                    }\n                    stack.push(new command("print",command.node));\n                }\n            }\n            return linkedlist;\n        }\n    \n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n/**\n * definition for a binary tree node.\n * public class treenode {\n *     int val;\n *     treenode left;\n *     treenode right;\n *     treenode(int x) { val = x; }\n * }\n */\nimport java.util.stack;\nclass solution{\n     class command{\n            string s;\n            treenode node;\n\n            public command(string s, treenode node) {\n                this.s = s;\n                this.node = node;\n            }\n        }\n        public  list<integer> preordertraversal(treenode root) {\n            linkedlist<integer> linkedlist=new linkedlist<>();\n            if (root==null){\n                return linkedlist;\n            }\n//            模拟系统栈调用\n            stack<command> stack=new stack<>();\n            stack.push(new command("go",root));\n            while (!stack.isempty()){\n                command command=stack.pop();\n                if (command.s.equals("print")){\n                    linkedlist.add(command.node.val);\n                }else {\n//                    与递归的相反\n                    if (command.node.right!=null){\n                        stack.push(new command("go",command.node.right));\n                    }\n                    if (command.node.left!=null){\n                        stack.push(new command("go",command.node.left));\n                    }\n                    stack.push(new command("print",command.node));\n                }\n            }\n            return linkedlist;\n        }\n    \n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n/**\n * definition for a binary tree node.\n * public class treenode {\n *     int val;\n *     treenode left;\n *     treenode right;\n *     treenode(int x) { val = x; }\n * }\n */\nimport java.util.stack;\nclass solution {\n    class command{\n            string s;\n            treenode node;\n\n            public command(string s, treenode node) {\n                this.s = s;\n                this.node = node;\n            }\n        }\n        public list<integer> preordertraversal(treenode root) {\n            linkedlist<integer> linkedlist=new linkedlist<>();\n            if (root==null){\n                return linkedlist;\n            }\n            stack<command> stack=new stack<>();\n            stack.push(new command("go",root));\n            while (!stack.isempty()){\n                command command=stack.pop();\n                if (command.s.equals("print")){\n                    linkedlist.add(command.node.val);\n                }else {\n                      if (command.node.right!=null){\n                        stack.push(new command("go",command.node.right));\n                    }\n                     if (command.node.left!=null){\n                        stack.push(new command("go",command.node.left));\n                    }\n                   \n                    stack.push(new command("print",command.node));\n                   \n                }\n            }\n            return linkedlist;\n        }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n/**\n * definition for a binary tree node.\n * public class treenode {\n *     int val;\n *     treenode left;\n *     treenode right;\n *     treenode(int x) { val = x; }\n * }\n */\nimport java.util.stack;\nclass solution {\n    class command{\n            string s;\n            treenode node;\n\n            public command(string s, treenode node) {\n                this.s = s;\n                this.node = node;\n            }\n        }\n        public list<integer> preordertraversal(treenode root) {\n            linkedlist<integer> linkedlist=new linkedlist<>();\n            if (root==null){\n                return linkedlist;\n            }\n            stack<command> stack=new stack<>();\n            stack.push(new command("go",root));\n            while (!stack.isempty()){\n                command command=stack.pop();\n                if (command.s.equals("print")){\n                    linkedlist.push(command.node.val);\n                }else {\n                     stack.push(new command("print",command.node));\n                     if (command.node.left!=null){\n                        stack.push(new command("go",command.node.left));\n                    }\n                    if (command.node.right!=null){\n                        stack.push(new command("go",command.node.right));\n                    }\n                   \n                }\n            }\n            return linkedlist;\n        }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n/**\n * definition for a binary tree node.\n * public class treenode {\n *     int val;\n *     treenode left;\n *     treenode right;\n *     treenode(int x) { val = x; }\n * }\n */\nimport java.util.linkedlist;\nimport java.util.list;\nclass solution {\n    public list<integer> preordertraversal(treenode root) {\n        linkedlist<integer> list=new linkedlist<>();\n            if (root!=null){\n                list.addlast(root.val);\n                list.addall(preordertraversal(root.left));\n                list.addall(preordertraversal(root.right));\n            }\n        return list;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n# 高赞题解\n# x.遍历二叉树的方法合集\n 1.  94. 二叉树的中序遍历\n    \n    \n 2.  144. 二叉树的前序遍历\n    \n    \n 3.  145. 二叉树的后序遍历\n    \n    \n\n文章有一点长，代码居多。会给出比较详细的动画演示以及视频讲解请大家耐心阅读。\n\n# 递归解法\n# 前序遍历\npublic static void preorderrecur(treenode head) {\n    if (head == null) {\n        return;\n    }\n    system.out.print(head.value + " ");\n    preorderrecur(head.left);\n    preorderrecur(head.right);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n# 中序遍历\npublic static void preorderrecur(treenode head) {\n    if (head == null) {\n        return;\n    }\n    preorderrecur(head.left);\n    system.out.print(head.value + " ");\n    preorderrecur(head.right);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n# 后序遍历\npublic static void postorderrecur(treenode head) {\n    if (head == null) {\n        return;\n    }\n    postorderrecur(head.left);\n    postorderrecur(head.right);\n    system.out.print(head.value + " ");\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n# 代码解释\n这里没有对递归遍历做过多的解释，仅仅给出了简单的动画演示。 要理解递归的思路并且熟练的使用它，就是要想清楚你想做什么，什么时候停止。\n\n如前序遍历：我想先打印头节点对吧？那我打印完了头节点，我现在想打印左边节点了，我只是告诉计算机我想打印左边结点，之后打印右边结点。\n\n那么后序遍历呢？这个时候你应该知道了，我就是想操作左边然后右边，最后打印中间的元素。\n\n我们并不需要太过于在意具体的递归过程，而是要想清楚让计算机干什么。\n\n> 计算机都可能溢出，用人脑去遍历就不现实了。\n\n\n\n\n\n# 迭代解法\n本质上是在模拟递归，因为在递归的过程中使用了系统栈，所以在迭代的解法中常用stack来模拟系统栈。\n\n# 前序遍历\n首先我们应该创建一个stack用来存放节点，首先我们想要打印根节点的数据，此时stack里面的内容为空，所以我们优先将头结点加入stack，然后打印。\n\n之后我们应该先打印左子树，然后右子树。所以先加入stack的就是右子树，然后左子树。 此时你能得到的流程如下:\n\n{:width="500px"}{:align="center"}\n\npublic static void preorderiteration(treenode head) {\n\tif (head == null) {\n\t\treturn;\n\t}\n\tstack<treenode> stack = new stack<>();\n\tstack.push(head);\n\twhile (!stack.isempty()) {\n\t\ttreenode node = stack.pop();\n\t\tsystem.out.print(node.value + " ");\n\t\tif (node.right != null) {\n\t\t\tstack.push(node.right);\n\t\t}\n\t\tif (node.left != null) {\n\t\t\tstack.push(node.left);\n\t\t}\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n# 中序遍历\n 1. 同理创建一个stack，然后按 左 中 右的顺序输出节点。\n 2. 尽可能的将这个节点的左子树压入stack，此时栈顶的元素是最左侧的元素，其目的是找到一个最小单位的子树(也就是最左侧的一个节点)，并且在寻找的过程中记录了来源，才能返回上层,同时在返回上层的时候已经处理完毕左子树了。。\n 3. 当处理完最小单位的子树时，返回到上层处理了中间节点。（如果把整个左中右的遍历都理解成子树的话，就是处理完 左子树->中间(就是一个节点)->右子树）\n 4. 如果有右节点，其也要进行中序遍历。{:width="300px"}{:align="left"} 当整个左子树退栈的时候这个时候输出了该子树的根节点 2，之后输出中间节点 1。然后处理根节点为3右子树。\n\npublic static void inorderiteration(treenode head) {\n\tif (head == null) {\n\t\treturn;\n\t}\n\ttreenode cur = head;\n\tstack<treenode> stack = new stack<>();\n\twhile (!stack.isempty() || cur != null) {\n\t\twhile (cur != null) {\n\t\t\tstack.push(cur);\n\t\t\tcur = cur.left;\n\t\t}\n\t\ttreenode node = stack.pop();\n\t\tsystem.out.print(node.value + " ");\n\t\tif (node.right != null) {\n\t\t\tcur = node.right;\n\t\t}\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n# 后序遍历\n# 代码片段 1\n 1. 前序遍历的过程 是 中左右。\n 2. 将其转化成 中右左。也就是压栈的过程中优先压入左子树，在压入右子树。\n 3. 然后将这个结果返回来，这里是利用栈的先进后出倒序打印。\n\npublic static void postorderiteration(treenode head) {\n\t\tif (head == null) {\n\t\t\treturn;\n\t\t}\n\t\tstack<treenode> stack1 = new stack<>();\n\t\tstack<treenode> stack2 = new stack<>();\n\t\tstack1.push(head);\n\t\twhile (!stack1.isempty()) {\n\t\t\ttreenode node = stack1.pop();\n\t\t\tstack2.push(node);\n\t\t\tif (node.left != null) {\n\t\t\t\tstack1.push(node.left);\n\t\t\t}\n\t\t\tif (node.right != null) {\n\t\t\t\tstack1.push(node.right);\n\t\t\t}\n\t\t}\n\t\twhile (!stack2.isempty()) {\n\t\t\tsystem.out.print(stack2.pop().value + " ");\n\t\t}\n\t}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n# 代码片段 2\n 1. 用一个指针cur标记当前退出的节点是什么。\n 2. 后序遍历的过程中在遍历完左子树跟右子树cur都会回到根结点。所以当前不管是从左子树还是右子树回到根结点都不应该再操作了，应该退回上层。\n 3. 如果是从右边再返回根结点，应该回到上层。\n\npublic static void postorderiteration2(treenode head) { 感谢[@ben-ben-niu](/u/ben-ben-niu/)指出错误，代码确实存在问题，已经在原文中修复\n\tif (head == null) {\n\t\treturn;\n\t}\n\ttreenode cur = head;\n\tstack<treenode> stack = new stack<>();\n\tstack.push(head);\n\twhile (!stack.isempty()) {\n\t\ttreenode peek = stack.peek();\n\t\tif (peek.left != null && peek.left != cur && peek.right != cur) {\n\t\t\tstack.push(peek.left);\n\t\t} else if (peek.right != null && peek.right != cur) {\n\t\t\tstack.push(peek.right);\n\t\t} else {\n\t\t\tsystem.out.print(stack.pop().val + " ");\n\t\t\tcur = peek;\n\t\t}\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# morris解法\nmorris遍历使用二叉树节点中大量指向null的指针，由joseph morris 于1979年发明。 时间复杂度：o(n)o(n)o(n)额外空间复杂度：o(1)o(1)o(1)\n\n在你阅读以下代码之前，在这边先讲解一下morris的通用解法过程。\n\nmorris的整体思路就是将 以某个根结点开始，找到它左子树的最右侧节点之后与这个根结点进行连接我们可以从 图2 看到，如果这么连接之后，cur 这个指针是可以完整的从一个节点顺着下一个节点遍历，将整棵树遍历完毕，直到 7 这个节点右侧没有指向。\n\npublic static void preordermorris(treenode head) {\n\tif (head == null) {\n\t\treturn;\n\t}\n\ttreenode cur1 = head;//当前开始遍历的节点\n\ttreenode cur2 = null;//记录当前结点的左子树\n\twhile (cur1 != null) {\n\t\tcur2 = cur1.left;\n\t\tif (cur2 != null) {\n\t\t\twhile (cur2.right != null && cur2.right != cur1) {//找到当前左子树的最右侧节点，且这个节点应该在指向根结点之前，否则整个节点又回到了根结点。\n\t\t\t\tcur2 = cur2.right;\n\t\t\t}\n\t\t\tif (cur2.right == null) {//这个时候如果最右侧这个节点的右指针没有指向根结点，创建连接然后往下一个左子树的根结点进行连接操作。\n\t\t\t\tcur2.right = cur1;\n\t\t\t\tcur1 = cur1.left;\n\t\t\t\tcontinue;\n\t\t\t} else {//当左子树的最右侧节点有指向根结点，此时说明我们已经回到了根结点并重复了之前的操作，同时在回到根结点的时候我们应该已经处理完 左子树的最右侧节点 了，把路断开。\n\t\t\t\tcur2.right = null;\n\t\t\t}\n\t\t} \n\t\tcur1 = cur1.right;//一直往右边走，参考图\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n# 前序遍历\n 1. 在某个根结点创建连线的时候打印。因为我们是顺着左边的根节点来创建连线，且创建的过程只有一次。\n 2. 打印某些自身无法创建连线的节点，也就是叶子节点。\n\npublic static void preordermorris(treenode head) {\n\tif (head == null) {\n\t\treturn;\n\t}\n\ttreenode cur1 = head;\n\ttreenode cur2 = null;\n\twhile (cur1 != null) {\n\t\tcur2 = cur1.left;\n\t\tif (cur2 != null) {\n\t\t\twhile (cur2.right != null && cur2.right != cur1) {\n\t\t\t\tcur2 = cur2.right;\n\t\t\t}\n\t\t\tif (cur2.right == null) {\n\t\t\t\tcur2.right = cur1;\n\t\t\t\tsystem.out.print(cur1.value + " ");\n\t\t\t\tcur1 = cur1.left;\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\tcur2.right = null;\n\t\t\t}\n\t\t} else {\n\t\t\tsystem.out.print(cur1.value + " ");\n\t\t}\n\t\tcur1 = cur1.right;\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n# 中序遍历\n从最左侧开始顺着右节点打印。也就是在将cu1切换到上层节点的时候。\n\npublic static void inordermorris(treenode head) {\n\tif (head == null) {\n\t\treturn;\n\t}\n\ttreenode cur1 = head;\n\ttreenode cur2 = null;\n\twhile (cur1 != null) {\n\t\tcur2 = cur1.left;\n\t\t//构建连接线\n\t\tif (cur2 != null) {\n\t\t\twhile (cur2.right != null && cur2.right != cur1) {\n\t\t\t\tcur2 = cur2.right;\n\t\t\t}\n\t\t\tif (cur2.right == null) {\n\t\t\t\tcur2.right = cur1;\n\t\t\t\tcur1 = cur1.left;\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\tcur2.right = null;\n\t\t\t}\n\t\t}\n\t\tsystem.out.print(cur1.value + " ");\n\t\tcur1 = cur1.right;\n\t}\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n# 后序遍历\n后序遍历就比较复杂了哈，先看一下图{:width="400px"}{:align="center"}\n\n当我们到达最左侧，也就是左边连线已经创建完毕了。 打印 4 打印 5 2 打印 6 打印 7 3 1 我们将一个节点的连续右节点当成一个单链表来看待。 当我们返回上层之后，也就是将连线断开的时候，打印下层的单链表。 比如返回到 ２，此时打印 ４ 比如返回到 １，此时打印 ５ ２ 比如返回到 ３，此时打印 ６ 那么我们只需要将这个单链表逆序打印就行了，下文也给出了 单链表逆序代码这里不应该打印当前层，而是下一层，否则根结点会先与右边打印。\n\n//后序morris\npublic static void postordermorris(treenode head) {\n\tif (head == null) {\n\t\treturn;\n\t}\n\ttreenode cur1 = head;//遍历树的指针变量\n\ttreenode cur2 = null;//当前子树的最右节点\n\twhile (cur1 != null) {\n\t\tcur2 = cur1.left;\n\t\tif (cur2 != null) {\n\t\t\twhile (cur2.right != null && cur2.right != cur1) {\n\t\t\t\tcur2 = cur2.right;\n\t\t\t}\n\t\t\tif (cur2.right == null) {\n\t\t\t\tcur2.right = cur1;\n\t\t\t\tcur1 = cur1.left;\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\tcur2.right = null;\n\t\t\t\tpostmorrisprint(cur1.left);\n\t\t\t}\n\t\t}\n\t\tcur1 = cur1.right;\n\t}\n\tpostmorrisprint(head);\n}\n//打印函数\npublic static void postmorrisprint(treenode head) {\n\ttreenode reverselist = postmorrisreverselist(head);\n\ttreenode cur = reverselist;\n\twhile (cur != null) {\n\t\tsystem.out.print(cur.value + " ");\n\t\tcur = cur.right;\n\t}\n\tpostmorrisreverselist(reverselist);\n}\n//翻转单链表\npublic static treenode postmorrisreverselist(treenode head) {\n\ttreenode cur = head;\n\ttreenode pre = null;\n\twhile (cur != null) {\n\t\ttreenode next = cur.right;\n\t\tcur.right = pre;\n\t\tpre = cur;\n\t\tcur = next;\n\t}\n\treturn pre;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n\n\n\n感谢收看\n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2021-04-19 22:55:25accepted [https://leetcode-cn.com//submissions/detail/169790746/]1 ms100.0%36.6 mbjava2021-04-19 22:45:34accepted [https://leetcode-cn.com//submissions/detail/169786784/]0 ms100.0%36.6 mbjava2018-09-05 16:08:40accepted [https://leetcode-cn.com//submissions/detail/6586491/]1 ms100.0%n/ajava2018-09-05 15:39:59accepted [https://leetcode-cn.com//submissions/detail/6583181/]2 ms100.0%n/ajava2018-09-05 15:39:42accepted [https://leetcode-cn.com//submissions/detail/6583155/]2 ms100.0%n/ajava2018-09-05 15:25:25accepted [https://leetcode-cn.com//submissions/detail/6581987/]2 ms100.0%n/ajava2018-07-16 20:50:15accepted [https://leetcode-cn.com//submissions/detail/4253086/]2 ms100.0%n/ajava2018-07-16 20:46:13accepted [https://leetcode-cn.com//submissions/detail/4252939/]2 ms100.0%n/ajava2018-07-16 20:32:53accepted [https://leetcode-cn.com//submissions/detail/4252207/]3 ms100.0%n/ajava2018-07-16 20:32:11wrong answer [https://leetcode-cn.com//submissions/detail/4252179/]n/an/an/ajava2018-07-16 19:57:34accepted [https://leetcode-cn.com//submissions/detail/4250832/]1 ms100.0%n/ajava# 统计信息\n通过次数提交次数ac比率30299043524069.6%# 相似题目\n题目难度二叉树的中序遍历 [https://leetcode-cn.com/problems/binary-tree-inorder-traversal/]中等验证前序遍历序列二叉搜索树 [https://leetcode-cn.com/problems/verify-preorder-sequence-in-binary-search-tree/]中等n 叉树的前序遍历 [https://leetcode-cn.com/problems/n-ary-tree-preorder-traversal/]简单'},{title:"211-添加与搜索单词 - 数据结构设计(Design Add and Search Words Data Structure)",frontmatter:{title:"211-添加与搜索单词 - 数据结构设计(Design Add and Search Words Data Structure)",date:"2018-08-03T00:00:00.000Z",categories:["中等"],tags:["深度优先搜索<Depth-first Search>","设计<Design>","字典树<Trie>","回溯算法<Backtracking>"]},regularPath:"/views/%E4%B8%AD%E7%AD%89/0211-%E6%B7%BB%E5%8A%A0%E4%B8%8E%E6%90%9C%E7%B4%A2%E5%8D%95%E8%AF%8D%20-%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1.html",relativePath:"views/中等/0211-添加与搜索单词 - 数据结构设计.md",key:"v-f54f2200",path:"/views/%E4%B8%AD%E7%AD%89/0211-%E6%B7%BB%E5%8A%A0%E4%B8%8E%E6%90%9C%E7%B4%A2%E5%8D%95%E8%AF%8D%20-%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1.html",headers:[{level:2,title:"中文题目",slug:"中文题目",charIndex:2},{level:2,title:"通过代码",slug:"通过代码",charIndex:907},{level:2,title:"高赞题解",slug:"高赞题解",charIndex:3118},{level:2,title:"提交历史",slug:"提交历史",charIndex:11913},{level:2,title:"统计信息",slug:"统计信息",charIndex:12043},{level:2,title:"相似题目",slug:"相似题目",charIndex:12077}],lastUpdated:"4/11/2021, 1:15:21 PM",headersStr:"中文题目 通过代码 高赞题解 提交历史 统计信息 相似题目",content:'# 中文题目\n请你设计一个数据结构，支持 添加新单词 和 查找字符串是否与任何先前添加的字符串匹配 。\n\n实现词典类 WordDictionary ：\n\n * WordDictionary() 初始化词典对象\n * void addWord(word) 将 word 添加到数据结构中，之后可以对它进行匹配\n * bool search(word) 如果数据结构中存在字符串与word 匹配，则返回 true ；否则，返回 false 。word 中可能包含一些 \'.\' ，每个. 都可以表示任何一个字母。\n\n\n\n示例：\n\n\n输入：\n["WordDictionary","addWord","addWord","addWord","search","search","search","search"]\n[[],["bad"],["dad"],["mad"],["pad"],["bad"],[".ad"],["b.."]]\n输出：\n[null,null,null,null,false,true,true,true]\n\n解释：\nWordDictionary wordDictionary = new WordDictionary();\nwordDictionary.addWord("bad");\nwordDictionary.addWord("dad");\nwordDictionary.addWord("mad");\nwordDictionary.search("pad"); // return False\nwordDictionary.search("bad"); // return True\nwordDictionary.search(".ad"); // return True\nwordDictionary.search("b.."); // return True\n\n\n\n\n提示：\n\n * 1 \n * addWord 中的 word 由小写英文字母组成\n * search 中的 word 由 \'.\' 或小写英文字母组成\n * 最多调用 50000 次 addWord 和 search\n\n# 通过代码\nclass WordDictionary {\n\n        private class Node {\n            public boolean isWord;\n            public TreeMap<Character, Node> next;\n\n            public Node(boolean isWord) {\n                this.isWord = isWord;\n                next = new TreeMap<>();\n            }\n\n            public Node() {\n                this(false);\n            }\n        }\n\n        private Node root;\n\n        /** Initialize your data structure here. */\n        public WordDictionary() {\n            root=new Node();\n        }\n\n        /** Adds a word into the data structure. */\n        public void addWord(String word) {\n            Node cur = root;\n            for (int i = 0; i < word.length(); i++) {\n                char c = word.charAt(i);\n                if (cur.next.get(c) == null) {\n                    cur.next.put(c, new Node());\n                }\n                cur = cur.next.get(c);\n            }\n            cur.isWord = true;\n        }\n\n        /** Returns if the word is in the data structure. A word could contain the dot character \'.\' to represent any one letter. */\n        public boolean search(String word) {\n            return match(root,word,0);\n        }\n\n        private boolean match(Node node,String word,int index){\n            if (index == word.length()){\n                return node.isWord;\n            }\n            char c=word.charAt(index);\n            if (c != \'.\'){\n                if (node.next.get(c)==null){\n                    return false;\n                }\n                return match(node.next.get(c),word,index+1);\n            }else {\n                for (char nextChar:node.next.keySet()){\n                    if (match(node.next.get(nextChar),word,index+1)){\n                        return true;\n                    }\n                }\n                return false;\n            }\n        }\n    }\n/**\n * Your WordDictionary object will be instantiated and called as such:\n * WordDictionary obj = new WordDictionary();\n * obj.addWord(word);\n * boolean param_2 = obj.search(word);\n */\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n# 高赞题解\nTrie 树又称“前缀树”，它的典型应用对象是字符串，可以用于保存、统计。其特点是：用边表示字符，当走到叶子结点的时候，沿途所经过的边组成了一个字符串。其优点是：利用字符串的公共前缀来减少查询时间，最大限度地减少无谓的字符串比较，查询效率比哈希表高。\n\n以下是根据题目示例："bad"、"dad"、"mad" 组件的 Trie 树，结点值为“1” 表示这是一个单词的结尾。\n\n{:width=500} {:align=center}\n\n关于这道问题的难点是通配符 "." 的处理，其实也不难：在遇到 "." 的时候，使用递归方法，将该结点的每一个分支都看过去，只要有一个分支返回 true 就可以了，全部分支都走过去，都没有返回 true 的才返回 false。\n\n对于 Trie 树还不太熟悉的朋友可以先完成 LeetCode 第 208 题：实现 Trie (前缀树) [https://leetcode-cn.com/problems/implement-trie-prefix-tree/]，这里要注意的是，一个结点指向孩子结点的“指针”（一般情况下多于 1 个），可以使用数组表示，也可以使用哈希表表示，如果题目中限制了测试用例“所有的输入都是由小写字母 a-z 构成的”，则可以使用数组表示。\n\n1、一个结点指向孩子结点的“指针”们用数组表示；\n\nclass WordDictionary:\n    class Node:\n        def __init__(self):\n            self.is_word = False\n            self.next = [None for _ in range(26)]\n\n    def __init__(self):\n        """\n        Initialize your data structure here.\n        """\n        self.root = WordDictionary.Node()\n\n    def addWord(self, word: str) -> None:\n        """\n        Adds a word into the data structure.\n        """\n        size = len(word)\n        cur_node = self.root\n        for i in range(size):\n            alpha = word[i]\n            next = cur_node.next[ord(alpha) - ord(\'a\')]\n            if next is None:\n                cur_node.next[ord(alpha) - ord(\'a\')] = WordDictionary.Node()\n            cur_node = cur_node.next[ord(alpha) - ord(\'a\')]\n\n        if not cur_node.is_word:\n            cur_node.is_word = True\n\n    def search(self, word: str) -> bool:\n        """\n        Returns if the word is in the data structure. A word could contain the dot character \'.\' to represent any one letter.\n        """\n        return self.__match(word, self.root, 0)\n\n    def __match(self, word, node, start):\n        if start == len(word):\n            return node.is_word\n        alpha = word[start]\n        # 关键在这里，如果当前字母是 "." ，每一个分支都要走一遍\n        if alpha == \'.\':\n            # print(node.next)\n            for i in range(26):\n                if node.next[i] and self.__match(word, node.next[i], start + 1):\n                    return True\n            return False\n        else:\n            if not node.next[ord(alpha)-ord(\'a\')]:\n                return False\n            return self.__match(word, node.next[ord(alpha) - ord(\'a\')], start + 1)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\npublic class WordDictionary {\n\n    class Node {\n        private Node[] next;\n        private boolean isWord;\n\n        public Node() {\n            next = new Node[26];\n            isWord = false;\n        }\n    }\n\n    private Node root;\n\n    /**\n     * Initialize your data structure here.\n     */\n    public WordDictionary() {\n        root = new Node();\n    }\n\n    /**\n     * Adds a word into the data structure.\n     */\n    public void addWord(String word) {\n        int len = word.length();\n        Node curNode = root;\n        for (int i = 0; i < len; i++) {\n            char curChar = word.charAt(i);\n            Node next = curNode.next[curChar - \'a\'];\n            if (next == null) {\n                curNode.next[curChar - \'a\'] = new Node();\n            }\n            curNode = curNode.next[curChar - \'a\'];\n        }\n        if (!curNode.isWord) {\n            curNode.isWord = true;\n        }\n    }\n\n    /**\n     * Returns if the word is in the data structure. A word could contain the dot character \'.\' to represent any one letter.\n     */\n    public boolean search(String word) {\n        return match(word, root, 0);\n    }\n\n    private boolean match(String word, Node node, int start) {\n        if (start == word.length()) {\n            return node.isWord;\n        }\n        char alpha = word.charAt(start);\n        if (alpha == \'.\') {\n            for (int i = 0; i < 26; i++) {\n                if (node.next[i] != null && match(word, node.next[i], start + 1)) {\n                    return true;\n                }\n            }\n            return false;\n        } else {\n            if (node.next[alpha - \'a\'] == null) {\n                return false;\n\n            }\n            return match(word, node.next[alpha - \'a\'], start + 1);\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n2、一个结点指向孩子结点的“指针”们用哈希表表示。\n\nclass WordDictionary(object):\n    class Node:\n        def __init__(self):\n            self.is_word = False\n            self.next = dict()\n\n    def __init__(self):\n        """\n        Initialize your data structure here.\n        """\n        self.root = WordDictionary.Node()\n\n    def addWord(self, word):\n        """\n        Adds a word into the data structure.\n        :type word: str\n        :rtype: void\n        """\n        cur_node = self.root\n        for alpha in word:\n            if alpha not in cur_node.next:\n                cur_node.next[alpha] = WordDictionary.Node()\n            cur_node = cur_node.next[alpha]\n        if not cur_node.is_word:\n            cur_node.is_word = True\n\n    def search(self, word):\n        """\n        Returns if the word is in the data structure. A word could contain the dot character \'.\' to represent any one letter.\n        :type word: str\n        :rtype: bool\n        """\n        # 注意：这里要设置辅助函数\n        return self.match(self.root, word, 0)\n\n    def match(self, node, word, index):\n        if index == len(word):\n            return node.is_word\n        alpha = word[index]\n        if alpha == \'.\':\n            for next in node.next:\n                if self.match(node.next[next], word, index + 1):\n                    return True\n            # 注意：这里要返回\n            return False\n        else:\n            # 注意：这里要使用 else\n            if alpha not in node.next:\n                return False\n            # 注意：这里要使用 return 返回\n            return self.match(node.next[alpha], word, index + 1)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\nimport java.util.HashMap;\nimport java.util.Set;\n\npublic class WordDictionary {\n\n    private Node root;\n\n    private class Node {\n        private boolean isWord;\n        private HashMap<Character, Node> next;\n\n        public Node() {\n            this.next = new HashMap<>();\n        }\n    }\n\n    /**\n     * Initialize your data structure here.\n     */\n    public WordDictionary() {\n        root = new Node();\n    }\n\n    /**\n     * Adds a word into the data structure.\n     */\n    public void addWord(String word) {\n        Node curNode = root;\n        for (int i = 0; i < word.length(); i++) {\n            Character c = word.charAt(i);\n            if (!curNode.next.containsKey(c)) {\n                curNode.next.put(c, new Node());\n            }\n            curNode = curNode.next.get(c);\n        }\n        if (!curNode.isWord) {\n            curNode.isWord = true;\n        }\n    }\n\n    /**\n     * Returns if the word is in the data structure. A word could contain the dot character \'.\' to represent any one letter.\n     */\n    public boolean search(String word) {\n        return search(root, word, 0);\n    }\n\n    private boolean search(Node node, String word, int depth) {\n        if (depth == word.length()) {\n            // 只要能搜索到最后，就表示文本与模式匹配\n            // 这一步很容易被忽视\n            return node.isWord;\n        }\n        Character c = word.charAt(depth);\n        if (c == \'.\') {\n            Set<Character> keys = node.next.keySet();\n            for (Character key : keys) {\n                Node nextNode = node.next.get(key);\n                if (search(nextNode, word, depth + 1)) {\n                    return true;\n                }\n            }\n            // 循环都走完都没有找到，那就说明没有\n            return false;\n        } else {\n            if (!node.next.containsKey(c)) {\n                return false;\n            }\n            return search(node.next.get(c), word, depth + 1);\n        }\n    }\n\n    public static void main(String[] args) {\n        WordDictionary wordDictionary = new WordDictionary();\n        wordDictionary.addWord("bad");\n        wordDictionary.addWord("dad");\n        wordDictionary.addWord("mad");\n        boolean search1 = wordDictionary.search("pad");// -> false\n        System.out.println(search1);\n        boolean search2 = wordDictionary.search("bad"); // -> true\n        System.out.println(search2);\n        boolean search3 = wordDictionary.search(".ad"); // -> true\n        System.out.println(search3);\n        boolean search4 = wordDictionary.search("b.."); //-> true\n        System.out.println(search4);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-08-03 12:23:34Accepted [https://leetcode-cn.com//submissions/detail/5039388/]263 ms100.0%N/Ajava# 统计信息\n通过次数提交次数AC比率223684662348.0%# 相似题目\n题目难度实现 Trie (前缀树) [https://leetcode-cn.com/problems/implement-trie-prefix-tree/]中等前缀和后缀搜索 [https://leetcode-cn.com/problems/prefix-and-suffix-search/]困难',contentLowercase:'# 中文题目\n请你设计一个数据结构，支持 添加新单词 和 查找字符串是否与任何先前添加的字符串匹配 。\n\n实现词典类 worddictionary ：\n\n * worddictionary() 初始化词典对象\n * void addword(word) 将 word 添加到数据结构中，之后可以对它进行匹配\n * bool search(word) 如果数据结构中存在字符串与word 匹配，则返回 true ；否则，返回 false 。word 中可能包含一些 \'.\' ，每个. 都可以表示任何一个字母。\n\n\n\n示例：\n\n\n输入：\n["worddictionary","addword","addword","addword","search","search","search","search"]\n[[],["bad"],["dad"],["mad"],["pad"],["bad"],[".ad"],["b.."]]\n输出：\n[null,null,null,null,false,true,true,true]\n\n解释：\nworddictionary worddictionary = new worddictionary();\nworddictionary.addword("bad");\nworddictionary.addword("dad");\nworddictionary.addword("mad");\nworddictionary.search("pad"); // return false\nworddictionary.search("bad"); // return true\nworddictionary.search(".ad"); // return true\nworddictionary.search("b.."); // return true\n\n\n\n\n提示：\n\n * 1 \n * addword 中的 word 由小写英文字母组成\n * search 中的 word 由 \'.\' 或小写英文字母组成\n * 最多调用 50000 次 addword 和 search\n\n# 通过代码\nclass worddictionary {\n\n        private class node {\n            public boolean isword;\n            public treemap<character, node> next;\n\n            public node(boolean isword) {\n                this.isword = isword;\n                next = new treemap<>();\n            }\n\n            public node() {\n                this(false);\n            }\n        }\n\n        private node root;\n\n        /** initialize your data structure here. */\n        public worddictionary() {\n            root=new node();\n        }\n\n        /** adds a word into the data structure. */\n        public void addword(string word) {\n            node cur = root;\n            for (int i = 0; i < word.length(); i++) {\n                char c = word.charat(i);\n                if (cur.next.get(c) == null) {\n                    cur.next.put(c, new node());\n                }\n                cur = cur.next.get(c);\n            }\n            cur.isword = true;\n        }\n\n        /** returns if the word is in the data structure. a word could contain the dot character \'.\' to represent any one letter. */\n        public boolean search(string word) {\n            return match(root,word,0);\n        }\n\n        private boolean match(node node,string word,int index){\n            if (index == word.length()){\n                return node.isword;\n            }\n            char c=word.charat(index);\n            if (c != \'.\'){\n                if (node.next.get(c)==null){\n                    return false;\n                }\n                return match(node.next.get(c),word,index+1);\n            }else {\n                for (char nextchar:node.next.keyset()){\n                    if (match(node.next.get(nextchar),word,index+1)){\n                        return true;\n                    }\n                }\n                return false;\n            }\n        }\n    }\n/**\n * your worddictionary object will be instantiated and called as such:\n * worddictionary obj = new worddictionary();\n * obj.addword(word);\n * boolean param_2 = obj.search(word);\n */\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n# 高赞题解\ntrie 树又称“前缀树”，它的典型应用对象是字符串，可以用于保存、统计。其特点是：用边表示字符，当走到叶子结点的时候，沿途所经过的边组成了一个字符串。其优点是：利用字符串的公共前缀来减少查询时间，最大限度地减少无谓的字符串比较，查询效率比哈希表高。\n\n以下是根据题目示例："bad"、"dad"、"mad" 组件的 trie 树，结点值为“1” 表示这是一个单词的结尾。\n\n{:width=500} {:align=center}\n\n关于这道问题的难点是通配符 "." 的处理，其实也不难：在遇到 "." 的时候，使用递归方法，将该结点的每一个分支都看过去，只要有一个分支返回 true 就可以了，全部分支都走过去，都没有返回 true 的才返回 false。\n\n对于 trie 树还不太熟悉的朋友可以先完成 leetcode 第 208 题：实现 trie (前缀树) [https://leetcode-cn.com/problems/implement-trie-prefix-tree/]，这里要注意的是，一个结点指向孩子结点的“指针”（一般情况下多于 1 个），可以使用数组表示，也可以使用哈希表表示，如果题目中限制了测试用例“所有的输入都是由小写字母 a-z 构成的”，则可以使用数组表示。\n\n1、一个结点指向孩子结点的“指针”们用数组表示；\n\nclass worddictionary:\n    class node:\n        def __init__(self):\n            self.is_word = false\n            self.next = [none for _ in range(26)]\n\n    def __init__(self):\n        """\n        initialize your data structure here.\n        """\n        self.root = worddictionary.node()\n\n    def addword(self, word: str) -> none:\n        """\n        adds a word into the data structure.\n        """\n        size = len(word)\n        cur_node = self.root\n        for i in range(size):\n            alpha = word[i]\n            next = cur_node.next[ord(alpha) - ord(\'a\')]\n            if next is none:\n                cur_node.next[ord(alpha) - ord(\'a\')] = worddictionary.node()\n            cur_node = cur_node.next[ord(alpha) - ord(\'a\')]\n\n        if not cur_node.is_word:\n            cur_node.is_word = true\n\n    def search(self, word: str) -> bool:\n        """\n        returns if the word is in the data structure. a word could contain the dot character \'.\' to represent any one letter.\n        """\n        return self.__match(word, self.root, 0)\n\n    def __match(self, word, node, start):\n        if start == len(word):\n            return node.is_word\n        alpha = word[start]\n        # 关键在这里，如果当前字母是 "." ，每一个分支都要走一遍\n        if alpha == \'.\':\n            # print(node.next)\n            for i in range(26):\n                if node.next[i] and self.__match(word, node.next[i], start + 1):\n                    return true\n            return false\n        else:\n            if not node.next[ord(alpha)-ord(\'a\')]:\n                return false\n            return self.__match(word, node.next[ord(alpha) - ord(\'a\')], start + 1)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\npublic class worddictionary {\n\n    class node {\n        private node[] next;\n        private boolean isword;\n\n        public node() {\n            next = new node[26];\n            isword = false;\n        }\n    }\n\n    private node root;\n\n    /**\n     * initialize your data structure here.\n     */\n    public worddictionary() {\n        root = new node();\n    }\n\n    /**\n     * adds a word into the data structure.\n     */\n    public void addword(string word) {\n        int len = word.length();\n        node curnode = root;\n        for (int i = 0; i < len; i++) {\n            char curchar = word.charat(i);\n            node next = curnode.next[curchar - \'a\'];\n            if (next == null) {\n                curnode.next[curchar - \'a\'] = new node();\n            }\n            curnode = curnode.next[curchar - \'a\'];\n        }\n        if (!curnode.isword) {\n            curnode.isword = true;\n        }\n    }\n\n    /**\n     * returns if the word is in the data structure. a word could contain the dot character \'.\' to represent any one letter.\n     */\n    public boolean search(string word) {\n        return match(word, root, 0);\n    }\n\n    private boolean match(string word, node node, int start) {\n        if (start == word.length()) {\n            return node.isword;\n        }\n        char alpha = word.charat(start);\n        if (alpha == \'.\') {\n            for (int i = 0; i < 26; i++) {\n                if (node.next[i] != null && match(word, node.next[i], start + 1)) {\n                    return true;\n                }\n            }\n            return false;\n        } else {\n            if (node.next[alpha - \'a\'] == null) {\n                return false;\n\n            }\n            return match(word, node.next[alpha - \'a\'], start + 1);\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n2、一个结点指向孩子结点的“指针”们用哈希表表示。\n\nclass worddictionary(object):\n    class node:\n        def __init__(self):\n            self.is_word = false\n            self.next = dict()\n\n    def __init__(self):\n        """\n        initialize your data structure here.\n        """\n        self.root = worddictionary.node()\n\n    def addword(self, word):\n        """\n        adds a word into the data structure.\n        :type word: str\n        :rtype: void\n        """\n        cur_node = self.root\n        for alpha in word:\n            if alpha not in cur_node.next:\n                cur_node.next[alpha] = worddictionary.node()\n            cur_node = cur_node.next[alpha]\n        if not cur_node.is_word:\n            cur_node.is_word = true\n\n    def search(self, word):\n        """\n        returns if the word is in the data structure. a word could contain the dot character \'.\' to represent any one letter.\n        :type word: str\n        :rtype: bool\n        """\n        # 注意：这里要设置辅助函数\n        return self.match(self.root, word, 0)\n\n    def match(self, node, word, index):\n        if index == len(word):\n            return node.is_word\n        alpha = word[index]\n        if alpha == \'.\':\n            for next in node.next:\n                if self.match(node.next[next], word, index + 1):\n                    return true\n            # 注意：这里要返回\n            return false\n        else:\n            # 注意：这里要使用 else\n            if alpha not in node.next:\n                return false\n            # 注意：这里要使用 return 返回\n            return self.match(node.next[alpha], word, index + 1)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\nimport java.util.hashmap;\nimport java.util.set;\n\npublic class worddictionary {\n\n    private node root;\n\n    private class node {\n        private boolean isword;\n        private hashmap<character, node> next;\n\n        public node() {\n            this.next = new hashmap<>();\n        }\n    }\n\n    /**\n     * initialize your data structure here.\n     */\n    public worddictionary() {\n        root = new node();\n    }\n\n    /**\n     * adds a word into the data structure.\n     */\n    public void addword(string word) {\n        node curnode = root;\n        for (int i = 0; i < word.length(); i++) {\n            character c = word.charat(i);\n            if (!curnode.next.containskey(c)) {\n                curnode.next.put(c, new node());\n            }\n            curnode = curnode.next.get(c);\n        }\n        if (!curnode.isword) {\n            curnode.isword = true;\n        }\n    }\n\n    /**\n     * returns if the word is in the data structure. a word could contain the dot character \'.\' to represent any one letter.\n     */\n    public boolean search(string word) {\n        return search(root, word, 0);\n    }\n\n    private boolean search(node node, string word, int depth) {\n        if (depth == word.length()) {\n            // 只要能搜索到最后，就表示文本与模式匹配\n            // 这一步很容易被忽视\n            return node.isword;\n        }\n        character c = word.charat(depth);\n        if (c == \'.\') {\n            set<character> keys = node.next.keyset();\n            for (character key : keys) {\n                node nextnode = node.next.get(key);\n                if (search(nextnode, word, depth + 1)) {\n                    return true;\n                }\n            }\n            // 循环都走完都没有找到，那就说明没有\n            return false;\n        } else {\n            if (!node.next.containskey(c)) {\n                return false;\n            }\n            return search(node.next.get(c), word, depth + 1);\n        }\n    }\n\n    public static void main(string[] args) {\n        worddictionary worddictionary = new worddictionary();\n        worddictionary.addword("bad");\n        worddictionary.addword("dad");\n        worddictionary.addword("mad");\n        boolean search1 = worddictionary.search("pad");// -> false\n        system.out.println(search1);\n        boolean search2 = worddictionary.search("bad"); // -> true\n        system.out.println(search2);\n        boolean search3 = worddictionary.search(".ad"); // -> true\n        system.out.println(search3);\n        boolean search4 = worddictionary.search("b.."); //-> true\n        system.out.println(search4);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-08-03 12:23:34accepted [https://leetcode-cn.com//submissions/detail/5039388/]263 ms100.0%n/ajava# 统计信息\n通过次数提交次数ac比率223684662348.0%# 相似题目\n题目难度实现 trie (前缀树) [https://leetcode-cn.com/problems/implement-trie-prefix-tree/]中等前缀和后缀搜索 [https://leetcode-cn.com/problems/prefix-and-suffix-search/]困难'},{title:"213-打家劫舍 II(House Robber II)",frontmatter:{title:"213-打家劫舍 II(House Robber II)",date:"2018-09-15T00:00:00.000Z",categories:["中等"],tags:["动态规划<Dynamic Programming>"]},regularPath:"/views/%E4%B8%AD%E7%AD%89/0213-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D%20II.html",relativePath:"views/中等/0213-打家劫舍 II.md",key:"v-7d3d3b3c",path:"/views/%E4%B8%AD%E7%AD%89/0213-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D%20II.html",headers:[{level:2,title:"中文题目",slug:"中文题目",charIndex:2},{level:2,title:"通过代码",slug:"通过代码",charIndex:363},{level:2,title:"高赞题解",slug:"高赞题解",charIndex:1300},{level:3,title:"解题思路：",slug:"解题思路：",charIndex:1307},{level:3,title:"复杂度分析：",slug:"复杂度分析：",charIndex:3480},{level:3,title:"代码：",slug:"代码：",charIndex:3589},{level:2,title:"提交历史",slug:"提交历史",charIndex:4477},{level:2,title:"统计信息",slug:"统计信息",charIndex:4902},{level:2,title:"相似题目",slug:"相似题目",charIndex:4936}],lastUpdated:"4/11/2021, 1:15:21 PM",headersStr:"中文题目 通过代码 高赞题解 解题思路： 复杂度分析： 代码： 提交历史 统计信息 相似题目",content:"# 中文题目\n你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都围成一圈，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。\n\n给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。\n\n示例 1:\n\n输入: [2,3,2]\n输出: 3\n解释: 你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。\n\n\n示例 2:\n\n输入: [1,2,3,1]\n输出: 4\n解释: 你可以先偷窃 1 号房屋（金额 = 1），然后偷窃 3 号房屋（金额 = 3）。\n     偷窃到的最高金额 = 1 + 3 = 4 。\n\n# 通过代码\nclass Solution {\n    public int rob(int[] nums) {\n        if (nums.length == 0)\n            return 0;\n        if (nums.length < 2)\n            return nums[0];\n        \n        int[] startFromFirstHouse = new int[nums.length + 1];\n        int[] startFromSecondHouse = new int[nums.length + 1];\n        \n        startFromFirstHouse[0]  = 0;\n        startFromFirstHouse[1]  = nums[0];\n        startFromSecondHouse[0] = 0;\n        startFromSecondHouse[1] = 0;\n        \n        for (int i = 2; i <= nums.length; i++) {\n            startFromFirstHouse[i] = Math.max(startFromFirstHouse[i - 1], startFromFirstHouse[i - 2] + nums[i-1]);\n            startFromSecondHouse[i] = Math.max(startFromSecondHouse[i - 1], startFromSecondHouse[i - 2] + nums[i-1]);\n        }\n        \n        return Math.max(startFromFirstHouse[nums.length - 1], startFromSecondHouse[nums.length]);\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n# 高赞题解\n# 解题思路：\n# 总体思路：\n * 此题是 198. 打家劫舍 [https://leetcode-cn.com/problems/house-robber/solution/da-jia-jie-she-dong-tai-gui-hua-jie-gou-hua-si-lu-/] 的拓展版： 唯一的区别是此题中的房间是环状排列的（即首尾相接），而 198.198.198. 题中的房间是单排排列的；而这也是此题的难点。\n   \n   \n * 环状排列意味着第一个房子和最后一个房子中只能选择一个偷窃，因此可以把此环状排列房间问题约化为两个单排排列房间子问题：\n   \n    1. 在不偷窃第一个房子的情况下（即 nums[1:]nums[1:]nums[1:]），最大金额是 p1p_1p1​ ；\n    2. 在不偷窃最后一个房子的情况下（即 nums[:n−1]nums[:n-1]nums[:n−1]），最大金额是 p2p_2p2​ 。\n   \n    * 综合偷窃最大金额： 为以上两种情况的较大值，即 max(p1,p2)max(p1,p2)max(p1,p2) 。\n   \n   \n * 下面的任务则是解决 单排排列房间（即 198. 打家劫舍 [https://leetcode-cn.com/problems/house-robber/solution/da-jia-jie-she-dong-tai-gui-hua-jie-gou-hua-si-lu-/]） 问题。推荐可以先把 198.198.198. 做完再做这道题。\n   \n   \n\n# 198. 解题思路：\n典型的动态规划，以下按照标准流程解题。\n\n * 状态定义： * 设动态规划列表 dpdpdp ，dp[i]dp[i]dp[i] 代表前 iii 个房子在满足条件下的能偷窃到的最高金额。\n   \n   \n * 转移方程： * 设： 有 nnn 个房子，前 nnn 间能偷窃到的最高金额是 dp[n]dp[n]dp[n] ，前 n−1n-1n−1 间能偷窃到的最高金额是 dp[n−1]dp[n-1]dp[n−1] ，此时向这些房子后加一间房，此房间价值为 numnumnum ；\n    * 加一间房间后： 由于不能抢相邻的房子，意味着抢第 n+1n+1n+1 间就不能抢第 nnn 间；那么前 n+1n+1n+1 间房能偷取到的最高金额 dp[n+1]dp[n+1]dp[n+1] 一定是以下两种情况的 较大值 ： 1. 不抢第 n+1n+1n+1 个房间，因此等于前 nnn 个房子的最高金额，即 dp[n+1]=dp[n]dp[n+1] = dp[n]dp[n+1]=dp[n] ；\n       2. 抢第 n+1n+1n+1 个房间，此时不能抢第 nnn 个房间；因此等于前 n−1n-1n−1 个房子的最高金额加上当前房间价值，即 dp[n+1]=dp[n−1]+numdp[n+1] = dp[n-1] + numdp[n+1]=dp[n−1]+num ；\n      \n      \n    * 细心的我们发现： 难道在前 nnn 间的最高金额 dp[n]dp[n]dp[n] 情况下，第 nnn 间一定被偷了吗？假设没有被偷，那 n+1n+1n+1 间的最大值应该也可能是 dp[n+1]=dp[n]+numdp[n+1] = dp[n] + numdp[n+1]=dp[n]+num 吧？其实这种假设的情况可以被省略，这是因为： 1. 假设第 nnn 间没有被偷，那么此时 dp[n]=dp[n−1]dp[n] = dp[n-1]dp[n]=dp[n−1] ，此时 dp[n+1]=dp[n]+num=dp[n−1]+numdp[n+1] = dp[n] + num = dp[n-1] + numdp[n+1]=dp[n]+num=dp[n−1]+num ，即可以将 两种情况合并为一种情况 考虑；\n       2. 假设第 nnn 间被偷，那么此时 dp[n+1]=dp[n]+numdp[n+1] = dp[n] + numdp[n+1]=dp[n]+num 不可取 ，因为偷了第 nnn 间就不能偷第 n+1n+1n+1 间。\n      \n      \n    * 最终的转移方程： dp[n+1]=max(dp[n],dp[n−1]+num)dp[n+1] = max(dp[n],dp[n-1]+num)dp[n+1]=max(dp[n],dp[n−1]+num)\n   \n   \n * 初始状态： * 前 000 间房子的最大偷窃价值为 000 ，即 dp[0]=0dp[0] = 0dp[0]=0 。\n   \n   \n * 返回值： * 返回 dpdpdp 列表最后一个元素值，即所有房间的最大偷窃价值。\n   \n   \n * 简化空间复杂度： * 我们发现 dp[n]dp[n]dp[n] 只与 dp[n−1]dp[n-1]dp[n−1] 和 dp[n−2]dp[n-2]dp[n−2] 有关系，因此我们可以设两个变量 cur和 pre 交替记录，将空间复杂度降到 O(1)O(1)O(1) 。\n   \n   \n\n# 复杂度分析：\n * 时间复杂度 O(N)O(N)O(N) ： 两次遍历 nums 需要线性时间；\n * 空间复杂度 O(1)O(1)O(1) ： cur和 pre 使用常数大小的额外空间。\n\n<,,,,,,,>\n\n# 代码：\nclass Solution:\n    def rob(self, nums: [int]) -> int:\n        def my_rob(nums):\n            cur, pre = 0, 0\n            for num in nums:\n                cur, pre = max(pre + num, cur), cur\n            return cur\n        return max(my_rob(nums[:-1]),my_rob(nums[1:])) if len(nums) != 1 else nums[0]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\nclass Solution {\n    public int rob(int[] nums) {\n        if(nums.length == 0) return 0;\n        if(nums.length == 1) return nums[0];\n        return Math.max(myRob(Arrays.copyOfRange(nums, 0, nums.length - 1)), \n                        myRob(Arrays.copyOfRange(nums, 1, nums.length)));\n    }\n    private int myRob(int[] nums) {\n        int pre = 0, cur = 0, tmp;\n        for(int num : nums) {\n            tmp = cur;\n            cur = Math.max(pre + num, cur);\n            pre = tmp;\n        }\n        return cur;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-09-15 17:58:07Accepted [https://leetcode-cn.com//submissions/detail/7138467/]6 ms22.92%N/Ajava2018-09-15 17:42:17Wrong Answer [https://leetcode-cn.com//submissions/detail/7137518/]N/AN/AN/Ajava2018-09-15 17:39:42Wrong Answer [https://leetcode-cn.com//submissions/detail/7137369/]N/AN/AN/Ajava2018-09-15 17:39:22Wrong Answer [https://leetcode-cn.com//submissions/detail/7137342/]N/AN/AN/Ajava# 统计信息\n通过次数提交次数AC比率177794963535.8%# 相似题目\n题目难度打家劫舍 [https://leetcode-cn.com/problems/house-robber/]简单粉刷房子 [https://leetcode-cn.com/problems/paint-house/]简单栅栏涂色 [https://leetcode-cn.com/problems/paint-fence/]简单打家劫舍 III [https://leetcode-cn.com/problems/house-robber-iii/]中等不含连续1的非负整数 [https://leetcode-cn.com/problems/non-negative-integers-without-consecutive-ones/]困难金币路径 [https://leetcode-cn.com/problems/coin-path/]困难",contentLowercase:"# 中文题目\n你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都围成一圈，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。\n\n给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。\n\n示例 1:\n\n输入: [2,3,2]\n输出: 3\n解释: 你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。\n\n\n示例 2:\n\n输入: [1,2,3,1]\n输出: 4\n解释: 你可以先偷窃 1 号房屋（金额 = 1），然后偷窃 3 号房屋（金额 = 3）。\n     偷窃到的最高金额 = 1 + 3 = 4 。\n\n# 通过代码\nclass solution {\n    public int rob(int[] nums) {\n        if (nums.length == 0)\n            return 0;\n        if (nums.length < 2)\n            return nums[0];\n        \n        int[] startfromfirsthouse = new int[nums.length + 1];\n        int[] startfromsecondhouse = new int[nums.length + 1];\n        \n        startfromfirsthouse[0]  = 0;\n        startfromfirsthouse[1]  = nums[0];\n        startfromsecondhouse[0] = 0;\n        startfromsecondhouse[1] = 0;\n        \n        for (int i = 2; i <= nums.length; i++) {\n            startfromfirsthouse[i] = math.max(startfromfirsthouse[i - 1], startfromfirsthouse[i - 2] + nums[i-1]);\n            startfromsecondhouse[i] = math.max(startfromsecondhouse[i - 1], startfromsecondhouse[i - 2] + nums[i-1]);\n        }\n        \n        return math.max(startfromfirsthouse[nums.length - 1], startfromsecondhouse[nums.length]);\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n# 高赞题解\n# 解题思路：\n# 总体思路：\n * 此题是 198. 打家劫舍 [https://leetcode-cn.com/problems/house-robber/solution/da-jia-jie-she-dong-tai-gui-hua-jie-gou-hua-si-lu-/] 的拓展版： 唯一的区别是此题中的房间是环状排列的（即首尾相接），而 198.198.198. 题中的房间是单排排列的；而这也是此题的难点。\n   \n   \n * 环状排列意味着第一个房子和最后一个房子中只能选择一个偷窃，因此可以把此环状排列房间问题约化为两个单排排列房间子问题：\n   \n    1. 在不偷窃第一个房子的情况下（即 nums[1:]nums[1:]nums[1:]），最大金额是 p1p_1p1​ ；\n    2. 在不偷窃最后一个房子的情况下（即 nums[:n−1]nums[:n-1]nums[:n−1]），最大金额是 p2p_2p2​ 。\n   \n    * 综合偷窃最大金额： 为以上两种情况的较大值，即 max(p1,p2)max(p1,p2)max(p1,p2) 。\n   \n   \n * 下面的任务则是解决 单排排列房间（即 198. 打家劫舍 [https://leetcode-cn.com/problems/house-robber/solution/da-jia-jie-she-dong-tai-gui-hua-jie-gou-hua-si-lu-/]） 问题。推荐可以先把 198.198.198. 做完再做这道题。\n   \n   \n\n# 198. 解题思路：\n典型的动态规划，以下按照标准流程解题。\n\n * 状态定义： * 设动态规划列表 dpdpdp ，dp[i]dp[i]dp[i] 代表前 iii 个房子在满足条件下的能偷窃到的最高金额。\n   \n   \n * 转移方程： * 设： 有 nnn 个房子，前 nnn 间能偷窃到的最高金额是 dp[n]dp[n]dp[n] ，前 n−1n-1n−1 间能偷窃到的最高金额是 dp[n−1]dp[n-1]dp[n−1] ，此时向这些房子后加一间房，此房间价值为 numnumnum ；\n    * 加一间房间后： 由于不能抢相邻的房子，意味着抢第 n+1n+1n+1 间就不能抢第 nnn 间；那么前 n+1n+1n+1 间房能偷取到的最高金额 dp[n+1]dp[n+1]dp[n+1] 一定是以下两种情况的 较大值 ： 1. 不抢第 n+1n+1n+1 个房间，因此等于前 nnn 个房子的最高金额，即 dp[n+1]=dp[n]dp[n+1] = dp[n]dp[n+1]=dp[n] ；\n       2. 抢第 n+1n+1n+1 个房间，此时不能抢第 nnn 个房间；因此等于前 n−1n-1n−1 个房子的最高金额加上当前房间价值，即 dp[n+1]=dp[n−1]+numdp[n+1] = dp[n-1] + numdp[n+1]=dp[n−1]+num ；\n      \n      \n    * 细心的我们发现： 难道在前 nnn 间的最高金额 dp[n]dp[n]dp[n] 情况下，第 nnn 间一定被偷了吗？假设没有被偷，那 n+1n+1n+1 间的最大值应该也可能是 dp[n+1]=dp[n]+numdp[n+1] = dp[n] + numdp[n+1]=dp[n]+num 吧？其实这种假设的情况可以被省略，这是因为： 1. 假设第 nnn 间没有被偷，那么此时 dp[n]=dp[n−1]dp[n] = dp[n-1]dp[n]=dp[n−1] ，此时 dp[n+1]=dp[n]+num=dp[n−1]+numdp[n+1] = dp[n] + num = dp[n-1] + numdp[n+1]=dp[n]+num=dp[n−1]+num ，即可以将 两种情况合并为一种情况 考虑；\n       2. 假设第 nnn 间被偷，那么此时 dp[n+1]=dp[n]+numdp[n+1] = dp[n] + numdp[n+1]=dp[n]+num 不可取 ，因为偷了第 nnn 间就不能偷第 n+1n+1n+1 间。\n      \n      \n    * 最终的转移方程： dp[n+1]=max(dp[n],dp[n−1]+num)dp[n+1] = max(dp[n],dp[n-1]+num)dp[n+1]=max(dp[n],dp[n−1]+num)\n   \n   \n * 初始状态： * 前 000 间房子的最大偷窃价值为 000 ，即 dp[0]=0dp[0] = 0dp[0]=0 。\n   \n   \n * 返回值： * 返回 dpdpdp 列表最后一个元素值，即所有房间的最大偷窃价值。\n   \n   \n * 简化空间复杂度： * 我们发现 dp[n]dp[n]dp[n] 只与 dp[n−1]dp[n-1]dp[n−1] 和 dp[n−2]dp[n-2]dp[n−2] 有关系，因此我们可以设两个变量 cur和 pre 交替记录，将空间复杂度降到 o(1)o(1)o(1) 。\n   \n   \n\n# 复杂度分析：\n * 时间复杂度 o(n)o(n)o(n) ： 两次遍历 nums 需要线性时间；\n * 空间复杂度 o(1)o(1)o(1) ： cur和 pre 使用常数大小的额外空间。\n\n<,,,,,,,>\n\n# 代码：\nclass solution:\n    def rob(self, nums: [int]) -> int:\n        def my_rob(nums):\n            cur, pre = 0, 0\n            for num in nums:\n                cur, pre = max(pre + num, cur), cur\n            return cur\n        return max(my_rob(nums[:-1]),my_rob(nums[1:])) if len(nums) != 1 else nums[0]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\nclass solution {\n    public int rob(int[] nums) {\n        if(nums.length == 0) return 0;\n        if(nums.length == 1) return nums[0];\n        return math.max(myrob(arrays.copyofrange(nums, 0, nums.length - 1)), \n                        myrob(arrays.copyofrange(nums, 1, nums.length)));\n    }\n    private int myrob(int[] nums) {\n        int pre = 0, cur = 0, tmp;\n        for(int num : nums) {\n            tmp = cur;\n            cur = math.max(pre + num, cur);\n            pre = tmp;\n        }\n        return cur;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-09-15 17:58:07accepted [https://leetcode-cn.com//submissions/detail/7138467/]6 ms22.92%n/ajava2018-09-15 17:42:17wrong answer [https://leetcode-cn.com//submissions/detail/7137518/]n/an/an/ajava2018-09-15 17:39:42wrong answer [https://leetcode-cn.com//submissions/detail/7137369/]n/an/an/ajava2018-09-15 17:39:22wrong answer [https://leetcode-cn.com//submissions/detail/7137342/]n/an/an/ajava# 统计信息\n通过次数提交次数ac比率177794963535.8%# 相似题目\n题目难度打家劫舍 [https://leetcode-cn.com/problems/house-robber/]简单粉刷房子 [https://leetcode-cn.com/problems/paint-house/]简单栅栏涂色 [https://leetcode-cn.com/problems/paint-fence/]简单打家劫舍 iii [https://leetcode-cn.com/problems/house-robber-iii/]中等不含连续1的非负整数 [https://leetcode-cn.com/problems/non-negative-integers-without-consecutive-ones/]困难金币路径 [https://leetcode-cn.com/problems/coin-path/]困难"},{title:"215-数组中的第K个最大元素(Kth Largest Element in an Array)",frontmatter:{title:"215-数组中的第K个最大元素(Kth Largest Element in an Array)",date:"2018-05-15T00:00:00.000Z",categories:["中等"],tags:["堆<Heap>","分治算法<Divide and Conquer>"]},regularPath:"/views/%E4%B8%AD%E7%AD%89/0215-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACK%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0.html",relativePath:"views/中等/0215-数组中的第K个最大元素.md",key:"v-5cfb85d7",path:"/views/%E4%B8%AD%E7%AD%89/0215-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACK%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0.html",headers:[{level:2,title:"中文题目",slug:"中文题目",charIndex:2},{level:2,title:"通过代码",slug:"通过代码",charIndex:198},{level:2,title:"官方题解",slug:"官方题解",charIndex:2929},{level:2,title:"提交历史",slug:"提交历史",charIndex:8807},{level:2,title:"统计信息",slug:"统计信息",charIndex:9135},{level:2,title:"相似题目",slug:"相似题目",charIndex:9170}],lastUpdated:"4/11/2021, 1:15:21 PM",headersStr:"中文题目 通过代码 官方题解 提交历史 统计信息 相似题目",content:'# 中文题目\n在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。\n\n示例 1:\n\n输入: [3,2,1,5,6,4] 和 k = 2\n输出: 5\n\n\n示例 2:\n\n输入: [3,2,3,1,2,4,5,5,6] 和 k = 4\n输出: 4\n\n说明: \n\n你可以假设 k 总是有效的，且 1 ≤ k ≤ 数组的长度。\n\n# 通过代码\nimport java.util.TreeSet;\nclass Solution {\n    public  int findKthLargest(int[] nums, int k) {\n            k = nums.length - k;\n            int lo = 0;\n            int hi = nums.length - 1;\n            while (lo < hi) {\n                int j = partition(nums, lo, hi);\n                if (j < k) {\n                    lo = j + 1;\n                } else if (j > k) {\n                    hi = j - 1;\n                } else {\n                    break;\n                }\n            }\n            return nums[k];\n        }\n\n        private static int partition(int[] nums, int lo, int hi) {\n            int i = lo;\n            int j = hi + 1;\n            while (true) {\n                while (i < hi && less(nums[++i], nums[lo])) ;\n                while (j > lo && less(nums[lo], nums[--j])) ;\n                if (i >= j) {\n                    break;\n                }\n                exch(nums, i, j);\n            }\n            exch(nums, lo, j);\n            return j;\n        }\n\n        private static boolean less(int num, int num1) {\n            return num < num1;\n        }\n\n        private static void exch(int[] nums, int i, int j) {\n            int temp = nums[i];\n            nums[i] = nums[j];\n            nums[j] = temp;\n        }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\nimport java.util.TreeSet;\nclass Solution {\n    public  int findKthLargest(int[] nums, int k) {\n            k = nums.length - k;\n            int lo = 0;\n            int hi = nums.length - 1;\n            while (lo < hi) {\n                int j = partition(nums, lo, hi);\n                if (j < k) {\n                    lo = j + 1;\n                } else if (j > k) {\n                    hi = j - 1;\n                } else {\n                    break;\n                }\n            }\n            return nums[k];\n        }\n\n        private static int partition(int[] nums, int lo, int hi) {\n            int i = lo;\n            int j = hi + 1;\n            while (true) {\n                while (i < hi && less(nums[++i], nums[lo])) ;\n                while (j > lo && less(nums[lo], nums[--j])) ;\n                if (i >= j) {\n                    break;\n                }\n                exch(nums, i, j);\n            }\n            exch(nums, lo, j);\n            return j;\n        }\n\n        private static boolean less(int num, int num1) {\n            return num < num1;\n        }\n\n        private static void exch(int[] nums, int i, int j) {\n            int temp = nums[i];\n            nums[i] = nums[j];\n            nums[j] = temp;\n        }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n# 官方题解\n# 方法零：排序\n最朴素的方法是先对数组进行排序，再返回倒数第 k 个元素，就像 Python 中的 sorted(nums)[-k]。 算法的时间复杂度为 O(Nlog⁡N)O(N \\log N)O(NlogN)，空间复杂度为 O(1)O(1)O(1)。这个时间复杂度并不令人满意，让我们试着用额外空间来优化时间复杂度。\n\n# 方法一：堆\n思路是创建一个大顶堆，将所有数组中的元素加入堆中，并保持堆的大小小于等于 k。这样，堆中就保留了前 k 个最大的元素。这样，堆顶的元素就是正确答案。\n\n像大小为 k 的堆中添加元素的时间复杂度为 O(log⁡k){O}(\\log k)O(logk)，我们将重复该操作 N 次，故总时间复杂度为 O(Nlog⁡k){O}(N \\log k)O(Nlogk)。\n\n在 Python 的 heapq 库中有一个 nlargest 方法，具有同样的时间复杂度，能将代码简化到只有一行。\n\n本方法优化了时间复杂度，但需要 O(k){O}(k)O(k) 的空间复杂度。\n\n<,,,,,,,,,,>\n\nclass Solution {\n    public int findKthLargest(int[] nums, int k) {\n        // init heap \'the smallest element first\'\n        PriorityQueue<Integer> heap =\n            new PriorityQueue<Integer>((n1, n2) -> n1 - n2);\n\n        // keep k largest elements in the heap\n        for (int n: nums) {\n          heap.add(n);\n          if (heap.size() > k)\n            heap.poll();\n        }\n\n        // output\n        return heap.poll();        \n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\nclass Solution:\n    def findKthLargest(self, nums, k):\n        """\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        """\n        return heapq.nlargest(k, nums)[-1]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n复杂度分析\n\n * 时间复杂度 : O(Nlog⁡k){O}(N \\log k)O(Nlogk)。\n * 空间复杂度 : O(k){O}(k)O(k)，用于存储堆元素。\n   \n   \n\n\n\n\n# 方法二：快速选择\n快速选择算法 [https://en.wikipedia.org/wiki/Quickselect] 的平均时间复杂度为 O(N){O}(N)O(N)。就像快速排序那样，本算法也是 Tony Hoare 发明的，因此也被称为 Hoare选择算法。\n\n本方法大致上与快速排序相同。简便起见，注意到第 k 个最大元素也就是第 N - k 个最小元素，因此可以用第 k 小算法来解决本问题。\n\n首先，我们选择一个枢轴，并在线性时间内定义其在排序数组中的位置。这可以通过 划分算法 的帮助来完成。\n\n> 为了实现划分，沿着数组移动，将每个元素与枢轴进行比较，并将小于枢轴的所有元素移动到枢轴的左侧。\n\n\n这样，在输出的数组中，枢轴达到其合适位置。所有小于枢轴的元素都在其左侧，所有大于或等于的元素都在其右侧。\n\n这样，数组就被分成了两部分。如果是快速排序算法，会在这里递归地对两部分进行快速排序，时间复杂度为 O(Nlog⁡N){O}(N \\log N)O(NlogN)。\n\n而在这里，由于知道要找的第 N - k 小的元素在哪部分中，我们不需要对两部分都做处理，这样就将平均时间复杂度下降到 O(N){O}(N)O(N)。\n\n最终的算法十分直接了当 :\n\n * 随机选择一个枢轴。\n   \n   \n * 使用划分算法将枢轴放在数组中的合适位置 pos。将小于枢轴的元素移到左边，大于等于枢轴的元素移到右边。\n   \n   \n * 比较 pos 和 N - k 以决定在哪边继续递归处理。\n   \n   \n\n> ! 注意，本算法也适用于有重复的数组\n\n\n\n\nimport java.util.Random;\nclass Solution {\n  int [] nums;\n\n  public void swap(int a, int b) {\n    int tmp = this.nums[a];\n    this.nums[a] = this.nums[b];\n    this.nums[b] = tmp;\n  }\n\n\n  public int partition(int left, int right, int pivot_index) {\n    int pivot = this.nums[pivot_index];\n    // 1. move pivot to end\n    swap(pivot_index, right);\n    int store_index = left;\n\n    // 2. move all smaller elements to the left\n    for (int i = left; i <= right; i++) {\n      if (this.nums[i] < pivot) {\n        swap(store_index, i);\n        store_index++;\n      }\n    }\n\n    // 3. move pivot to its final place\n    swap(store_index, right);\n\n    return store_index;\n  }\n\n  public int quickselect(int left, int right, int k_smallest) {\n    /*\n    Returns the k-th smallest element of list within left..right.\n    */\n\n    if (left == right) // If the list contains only one element,\n      return this.nums[left];  // return that element\n\n    // select a random pivot_index\n    Random random_num = new Random();\n    int pivot_index = left + random_num.nextInt(right - left); \n    \n    pivot_index = partition(left, right, pivot_index);\n\n    // the pivot is on (N - k)th smallest position\n    if (k_smallest == pivot_index)\n      return this.nums[k_smallest];\n    // go left side\n    else if (k_smallest < pivot_index)\n      return quickselect(left, pivot_index - 1, k_smallest);\n    // go right side\n    return quickselect(pivot_index + 1, right, k_smallest);\n  }\n\n  public int findKthLargest(int[] nums, int k) {\n    this.nums = nums;\n    int size = nums.length;\n    // kth largest is (N - k)th smallest\n    return quickselect(0, size - 1, size - k);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\nclass Solution:\n    def findKthLargest(self, nums, k):\n        """\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        """\n        def partition(left, right, pivot_index):\n            pivot = nums[pivot_index]\n            # 1. move pivot to end\n            nums[pivot_index], nums[right] = nums[right], nums[pivot_index]  \n            \n            # 2. move all smaller elements to the left\n            store_index = left\n            for i in range(left, right):\n                if nums[i] < pivot:\n                    nums[store_index], nums[i] = nums[i], nums[store_index]\n                    store_index += 1\n\n            # 3. move pivot to its final place\n            nums[right], nums[store_index] = nums[store_index], nums[right]  \n            \n            return store_index\n        \n        def select(left, right, k_smallest):\n            """\n            Returns the k-th smallest element of list within left..right\n            """\n            if left == right:       # If the list contains only one element,\n                return nums[left]   # return that element\n            \n            # select a random pivot_index between \n            pivot_index = random.randint(left, right)     \n                            \n            # find the pivot position in a sorted list   \n            pivot_index = partition(left, right, pivot_index)\n            \n            # the pivot is in its final sorted position\n            if k_smallest == pivot_index:\n                 return nums[k_smallest]\n            # go left\n            elif k_smallest < pivot_index:\n                return select(left, pivot_index - 1, k_smallest)\n            # go right\n            else:\n                return select(pivot_index + 1, right, k_smallest)\n\n        # kth largest is (n - k)th smallest \n        return select(0, len(nums) - 1, len(nums) - k)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n复杂度分析\n\n * 时间复杂度 : 平均情况 O(N){O}(N)O(N)，最坏情况 O(N2){O}(N^2)O(N2)。\n * 空间复杂度 : O(1){O}(1)O(1)。\n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-05-15 23:58:42Accepted [https://leetcode-cn.com//submissions/detail/2310860/]62 ms6.83%N/Ajava2018-05-15 23:57:37Accepted [https://leetcode-cn.com//submissions/detail/2310840/]45 ms14.05%N/Ajava2018-05-14 23:26:08Runtime Error [https://leetcode-cn.com//submissions/detail/2276286/]N/AN/AN/Ajava# 统计信息\n通过次数提交次数AC比率7034011637160.4%# 相似题目\n题目难度摆动排序 II [https://leetcode-cn.com/problems/wiggle-sort-ii/]中等前 K 个高频元素 [https://leetcode-cn.com/problems/top-k-frequent-elements/]中等第三大的数 [https://leetcode-cn.com/problems/third-maximum-number/]简单数据流中的第K大元素 [https://leetcode-cn.com/problems/kth-largest-element-in-a-stream/]简单最接近原点的 K 个点 [https://leetcode-cn.com/problems/k-closest-points-to-origin/]中等',contentLowercase:'# 中文题目\n在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。\n\n示例 1:\n\n输入: [3,2,1,5,6,4] 和 k = 2\n输出: 5\n\n\n示例 2:\n\n输入: [3,2,3,1,2,4,5,5,6] 和 k = 4\n输出: 4\n\n说明: \n\n你可以假设 k 总是有效的，且 1 ≤ k ≤ 数组的长度。\n\n# 通过代码\nimport java.util.treeset;\nclass solution {\n    public  int findkthlargest(int[] nums, int k) {\n            k = nums.length - k;\n            int lo = 0;\n            int hi = nums.length - 1;\n            while (lo < hi) {\n                int j = partition(nums, lo, hi);\n                if (j < k) {\n                    lo = j + 1;\n                } else if (j > k) {\n                    hi = j - 1;\n                } else {\n                    break;\n                }\n            }\n            return nums[k];\n        }\n\n        private static int partition(int[] nums, int lo, int hi) {\n            int i = lo;\n            int j = hi + 1;\n            while (true) {\n                while (i < hi && less(nums[++i], nums[lo])) ;\n                while (j > lo && less(nums[lo], nums[--j])) ;\n                if (i >= j) {\n                    break;\n                }\n                exch(nums, i, j);\n            }\n            exch(nums, lo, j);\n            return j;\n        }\n\n        private static boolean less(int num, int num1) {\n            return num < num1;\n        }\n\n        private static void exch(int[] nums, int i, int j) {\n            int temp = nums[i];\n            nums[i] = nums[j];\n            nums[j] = temp;\n        }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\nimport java.util.treeset;\nclass solution {\n    public  int findkthlargest(int[] nums, int k) {\n            k = nums.length - k;\n            int lo = 0;\n            int hi = nums.length - 1;\n            while (lo < hi) {\n                int j = partition(nums, lo, hi);\n                if (j < k) {\n                    lo = j + 1;\n                } else if (j > k) {\n                    hi = j - 1;\n                } else {\n                    break;\n                }\n            }\n            return nums[k];\n        }\n\n        private static int partition(int[] nums, int lo, int hi) {\n            int i = lo;\n            int j = hi + 1;\n            while (true) {\n                while (i < hi && less(nums[++i], nums[lo])) ;\n                while (j > lo && less(nums[lo], nums[--j])) ;\n                if (i >= j) {\n                    break;\n                }\n                exch(nums, i, j);\n            }\n            exch(nums, lo, j);\n            return j;\n        }\n\n        private static boolean less(int num, int num1) {\n            return num < num1;\n        }\n\n        private static void exch(int[] nums, int i, int j) {\n            int temp = nums[i];\n            nums[i] = nums[j];\n            nums[j] = temp;\n        }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n# 官方题解\n# 方法零：排序\n最朴素的方法是先对数组进行排序，再返回倒数第 k 个元素，就像 python 中的 sorted(nums)[-k]。 算法的时间复杂度为 o(nlog⁡n)o(n \\log n)o(nlogn)，空间复杂度为 o(1)o(1)o(1)。这个时间复杂度并不令人满意，让我们试着用额外空间来优化时间复杂度。\n\n# 方法一：堆\n思路是创建一个大顶堆，将所有数组中的元素加入堆中，并保持堆的大小小于等于 k。这样，堆中就保留了前 k 个最大的元素。这样，堆顶的元素就是正确答案。\n\n像大小为 k 的堆中添加元素的时间复杂度为 o(log⁡k){o}(\\log k)o(logk)，我们将重复该操作 n 次，故总时间复杂度为 o(nlog⁡k){o}(n \\log k)o(nlogk)。\n\n在 python 的 heapq 库中有一个 nlargest 方法，具有同样的时间复杂度，能将代码简化到只有一行。\n\n本方法优化了时间复杂度，但需要 o(k){o}(k)o(k) 的空间复杂度。\n\n<,,,,,,,,,,>\n\nclass solution {\n    public int findkthlargest(int[] nums, int k) {\n        // init heap \'the smallest element first\'\n        priorityqueue<integer> heap =\n            new priorityqueue<integer>((n1, n2) -> n1 - n2);\n\n        // keep k largest elements in the heap\n        for (int n: nums) {\n          heap.add(n);\n          if (heap.size() > k)\n            heap.poll();\n        }\n\n        // output\n        return heap.poll();        \n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\nclass solution:\n    def findkthlargest(self, nums, k):\n        """\n        :type nums: list[int]\n        :type k: int\n        :rtype: int\n        """\n        return heapq.nlargest(k, nums)[-1]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n复杂度分析\n\n * 时间复杂度 : o(nlog⁡k){o}(n \\log k)o(nlogk)。\n * 空间复杂度 : o(k){o}(k)o(k)，用于存储堆元素。\n   \n   \n\n\n\n\n# 方法二：快速选择\n快速选择算法 [https://en.wikipedia.org/wiki/quickselect] 的平均时间复杂度为 o(n){o}(n)o(n)。就像快速排序那样，本算法也是 tony hoare 发明的，因此也被称为 hoare选择算法。\n\n本方法大致上与快速排序相同。简便起见，注意到第 k 个最大元素也就是第 n - k 个最小元素，因此可以用第 k 小算法来解决本问题。\n\n首先，我们选择一个枢轴，并在线性时间内定义其在排序数组中的位置。这可以通过 划分算法 的帮助来完成。\n\n> 为了实现划分，沿着数组移动，将每个元素与枢轴进行比较，并将小于枢轴的所有元素移动到枢轴的左侧。\n\n\n这样，在输出的数组中，枢轴达到其合适位置。所有小于枢轴的元素都在其左侧，所有大于或等于的元素都在其右侧。\n\n这样，数组就被分成了两部分。如果是快速排序算法，会在这里递归地对两部分进行快速排序，时间复杂度为 o(nlog⁡n){o}(n \\log n)o(nlogn)。\n\n而在这里，由于知道要找的第 n - k 小的元素在哪部分中，我们不需要对两部分都做处理，这样就将平均时间复杂度下降到 o(n){o}(n)o(n)。\n\n最终的算法十分直接了当 :\n\n * 随机选择一个枢轴。\n   \n   \n * 使用划分算法将枢轴放在数组中的合适位置 pos。将小于枢轴的元素移到左边，大于等于枢轴的元素移到右边。\n   \n   \n * 比较 pos 和 n - k 以决定在哪边继续递归处理。\n   \n   \n\n> ! 注意，本算法也适用于有重复的数组\n\n\n\n\nimport java.util.random;\nclass solution {\n  int [] nums;\n\n  public void swap(int a, int b) {\n    int tmp = this.nums[a];\n    this.nums[a] = this.nums[b];\n    this.nums[b] = tmp;\n  }\n\n\n  public int partition(int left, int right, int pivot_index) {\n    int pivot = this.nums[pivot_index];\n    // 1. move pivot to end\n    swap(pivot_index, right);\n    int store_index = left;\n\n    // 2. move all smaller elements to the left\n    for (int i = left; i <= right; i++) {\n      if (this.nums[i] < pivot) {\n        swap(store_index, i);\n        store_index++;\n      }\n    }\n\n    // 3. move pivot to its final place\n    swap(store_index, right);\n\n    return store_index;\n  }\n\n  public int quickselect(int left, int right, int k_smallest) {\n    /*\n    returns the k-th smallest element of list within left..right.\n    */\n\n    if (left == right) // if the list contains only one element,\n      return this.nums[left];  // return that element\n\n    // select a random pivot_index\n    random random_num = new random();\n    int pivot_index = left + random_num.nextint(right - left); \n    \n    pivot_index = partition(left, right, pivot_index);\n\n    // the pivot is on (n - k)th smallest position\n    if (k_smallest == pivot_index)\n      return this.nums[k_smallest];\n    // go left side\n    else if (k_smallest < pivot_index)\n      return quickselect(left, pivot_index - 1, k_smallest);\n    // go right side\n    return quickselect(pivot_index + 1, right, k_smallest);\n  }\n\n  public int findkthlargest(int[] nums, int k) {\n    this.nums = nums;\n    int size = nums.length;\n    // kth largest is (n - k)th smallest\n    return quickselect(0, size - 1, size - k);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\nclass solution:\n    def findkthlargest(self, nums, k):\n        """\n        :type nums: list[int]\n        :type k: int\n        :rtype: int\n        """\n        def partition(left, right, pivot_index):\n            pivot = nums[pivot_index]\n            # 1. move pivot to end\n            nums[pivot_index], nums[right] = nums[right], nums[pivot_index]  \n            \n            # 2. move all smaller elements to the left\n            store_index = left\n            for i in range(left, right):\n                if nums[i] < pivot:\n                    nums[store_index], nums[i] = nums[i], nums[store_index]\n                    store_index += 1\n\n            # 3. move pivot to its final place\n            nums[right], nums[store_index] = nums[store_index], nums[right]  \n            \n            return store_index\n        \n        def select(left, right, k_smallest):\n            """\n            returns the k-th smallest element of list within left..right\n            """\n            if left == right:       # if the list contains only one element,\n                return nums[left]   # return that element\n            \n            # select a random pivot_index between \n            pivot_index = random.randint(left, right)     \n                            \n            # find the pivot position in a sorted list   \n            pivot_index = partition(left, right, pivot_index)\n            \n            # the pivot is in its final sorted position\n            if k_smallest == pivot_index:\n                 return nums[k_smallest]\n            # go left\n            elif k_smallest < pivot_index:\n                return select(left, pivot_index - 1, k_smallest)\n            # go right\n            else:\n                return select(pivot_index + 1, right, k_smallest)\n\n        # kth largest is (n - k)th smallest \n        return select(0, len(nums) - 1, len(nums) - k)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n复杂度分析\n\n * 时间复杂度 : 平均情况 o(n){o}(n)o(n)，最坏情况 o(n2){o}(n^2)o(n2)。\n * 空间复杂度 : o(1){o}(1)o(1)。\n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-05-15 23:58:42accepted [https://leetcode-cn.com//submissions/detail/2310860/]62 ms6.83%n/ajava2018-05-15 23:57:37accepted [https://leetcode-cn.com//submissions/detail/2310840/]45 ms14.05%n/ajava2018-05-14 23:26:08runtime error [https://leetcode-cn.com//submissions/detail/2276286/]n/an/an/ajava# 统计信息\n通过次数提交次数ac比率7034011637160.4%# 相似题目\n题目难度摆动排序 ii [https://leetcode-cn.com/problems/wiggle-sort-ii/]中等前 k 个高频元素 [https://leetcode-cn.com/problems/top-k-frequent-elements/]中等第三大的数 [https://leetcode-cn.com/problems/third-maximum-number/]简单数据流中的第k大元素 [https://leetcode-cn.com/problems/kth-largest-element-in-a-stream/]简单最接近原点的 k 个点 [https://leetcode-cn.com/problems/k-closest-points-to-origin/]中等'},{title:"216-组合总和 III(Combination Sum III)",frontmatter:{title:"216-组合总和 III(Combination Sum III)",date:"2018-09-13T00:00:00.000Z",categories:["中等"],tags:["数组<Array>","回溯算法<Backtracking>"]},regularPath:"/views/%E4%B8%AD%E7%AD%89/0216-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C%20III.html",relativePath:"views/中等/0216-组合总和 III.md",key:"v-3e57534e",path:"/views/%E4%B8%AD%E7%AD%89/0216-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C%20III.html",headers:[{level:2,title:"中文题目",slug:"中文题目",charIndex:2},{level:2,title:"通过代码",slug:"通过代码",charIndex:200},{level:2,title:"高赞题解",slug:"高赞题解",charIndex:3079},{level:2,title:"解题方案",slug:"解题方案",charIndex:3086},{level:3,title:"思路",slug:"思路",charIndex:3093},{level:3,title:"代码",slug:"代码",charIndex:202},{level:2,title:"提交历史",slug:"提交历史",charIndex:3926},{level:2,title:"统计信息",slug:"统计信息",charIndex:4349},{level:2,title:"相似题目",slug:"相似题目",charIndex:4383}],lastUpdated:"4/11/2021, 1:15:21 PM",headersStr:"中文题目 通过代码 高赞题解 解题方案 思路 代码 提交历史 统计信息 相似题目",content:"# 中文题目\n找出所有相加之和为n 的k个数的组合。组合中只允许含有 1 - 9 的正整数，并且每种组合中不存在重复的数字。\n\n说明：\n\n * 所有数字都是正整数。\n * 解集不能包含重复的组合。\n\n示例 1:\n\n输入: k = 3, n = 7\n输出: [[1,2,4]]\n\n\n示例 2:\n\n输入: k = 3, n = 9\n输出: [[1,2,6], [1,3,5], [2,3,4]]\n\n\n# 通过代码\nclass Solution {\n    public List<List<Integer>> combinationSum3(int k, int n) {\n            List<List<Integer>> res=new LinkedList<List<Integer>>();\n            LinkedList<Integer> list=new LinkedList<Integer>();\n            dfs(list,res,n,k,1);\n            return res;\n        }\n\n        private void dfs( LinkedList<Integer> list, List<List<Integer>> res, int n, int k,int start) {\n            if (n==0 && k==0){\n                res.add(new LinkedList<Integer>(list));\n                return;\n            }\n            for (int i = start; i <= 9; i++) {\n                if (i<=n){\n                    list.addLast(i);\n                    k--;\n                    dfs(list,res,n-i,k,i+1);\n                    k++;\n                    list.removeLast();\n                }\n            }\n        }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\nclass Solution {\n    public List<List<Integer>> combinationSum3(int k, int n) {\n            List<List<Integer>> res=new LinkedList<List<Integer>>();\n            LinkedList<Integer> list=new LinkedList<Integer>();\n            dfs(list,res,n,k,1);\n            return res;\n        }\n\n        private void dfs( LinkedList<Integer> list, List<List<Integer>> res, int n, int k,int start) {\n            if (n==0 && k==0){\n                res.add(new LinkedList<Integer>(list));\n                return;\n            }\n            for (int i = start; i <= 9; i++) {\n                if (i<=n){\n                    list.addLast(i);\n                    k--;\n                    dfs(list,res,n-i,k,i+1);\n                    k++;\n                    list.removeLast();\n                }\n            }\n        }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\nclass Solution {\n    public List<List<Integer>> combinationSum3(int k, int n) {\n            int[] candidates={1,2,3,4,5,6,7,8,9};\n            List<List<Integer>> res=new LinkedList<List<Integer>>();\n            if (candidates==null || candidates.length==0){\n                return res;\n            }\n            LinkedList<Integer> list=new LinkedList<Integer>();\n//            对于这种存在顺序的，可以把其实位置放在一起递归\n            dfs(candidates,list,res,n,k,-1);\n            return res;\n        }\n\n        private void dfs(int[] candidates, LinkedList<Integer> list, List<List<Integer>> res, int n, int k,int start) {\n            if (n==0 && k==0){\n                res.add(new LinkedList<Integer>(list));\n                return;\n            }\n            for (int i = start+1; i < candidates.length; i++) {\n                if (candidates[i]<=n){\n                    list.addLast(candidates[i]);\n                    k--;\n                    dfs(candidates,list,res,n-candidates[i],k,i);\n                    k++;\n                    list.removeLast();\n                }\n            }\n        }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n# 高赞题解\n# 解题方案\n# 思路\n * 标签：递归回溯\n * 递归终止条件：数组中包含k个数，如果和为n则加入结果集，否则直接返回终止递归\n * 递归过程：循环遍历1-9，将新数字加入临时数组中进入下一层递归，出来后再将其移除\n * 回溯的关键在于，添加和移除，保证所有可能性都遍历到，整体结构和栈类似\n\n\n\n# 代码\nclass Solution {\n    private List<List<Integer>> ans = new ArrayList<>();\n    \n    public List<List<Integer>> combinationSum3(int k, int n) {\n        traceBack(k, n, 0, 1, new LinkedList<>());\n        return ans;\n    }\n    \n    public void traceBack(int k, int n, int sum, int begin, LinkedList<Integer> list) {\n        if(k == 0) {\n            if(n == sum)\n                ans.add(new ArrayList<>(list));\n            return;\n        }\n        for(int i = begin; i < 10; i++) {\n            list.add(i);\n            traceBack(k - 1, n, sum + i ,i + 1, list);\n            list.removeLast();\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n点击我的头像加关注，和我一起打卡天天算法\n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-09-13 17:25:54Accepted [https://leetcode-cn.com//submissions/detail/7040007/]1 ms99.2%N/Ajava2018-09-13 17:25:41Accepted [https://leetcode-cn.com//submissions/detail/7039992/]4 ms5.19%N/Ajava2018-09-13 17:25:16Wrong Answer [https://leetcode-cn.com//submissions/detail/7039967/]N/AN/AN/Ajava2018-09-13 17:23:45Accepted [https://leetcode-cn.com//submissions/detail/7039874/]2 ms18.91%N/Ajava# 统计信息\n通过次数提交次数AC比率123871776169.7%# 相似题目\n题目难度组合总和 [https://leetcode-cn.com/problems/combination-sum/]中等",contentLowercase:"# 中文题目\n找出所有相加之和为n 的k个数的组合。组合中只允许含有 1 - 9 的正整数，并且每种组合中不存在重复的数字。\n\n说明：\n\n * 所有数字都是正整数。\n * 解集不能包含重复的组合。\n\n示例 1:\n\n输入: k = 3, n = 7\n输出: [[1,2,4]]\n\n\n示例 2:\n\n输入: k = 3, n = 9\n输出: [[1,2,6], [1,3,5], [2,3,4]]\n\n\n# 通过代码\nclass solution {\n    public list<list<integer>> combinationsum3(int k, int n) {\n            list<list<integer>> res=new linkedlist<list<integer>>();\n            linkedlist<integer> list=new linkedlist<integer>();\n            dfs(list,res,n,k,1);\n            return res;\n        }\n\n        private void dfs( linkedlist<integer> list, list<list<integer>> res, int n, int k,int start) {\n            if (n==0 && k==0){\n                res.add(new linkedlist<integer>(list));\n                return;\n            }\n            for (int i = start; i <= 9; i++) {\n                if (i<=n){\n                    list.addlast(i);\n                    k--;\n                    dfs(list,res,n-i,k,i+1);\n                    k++;\n                    list.removelast();\n                }\n            }\n        }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\nclass solution {\n    public list<list<integer>> combinationsum3(int k, int n) {\n            list<list<integer>> res=new linkedlist<list<integer>>();\n            linkedlist<integer> list=new linkedlist<integer>();\n            dfs(list,res,n,k,1);\n            return res;\n        }\n\n        private void dfs( linkedlist<integer> list, list<list<integer>> res, int n, int k,int start) {\n            if (n==0 && k==0){\n                res.add(new linkedlist<integer>(list));\n                return;\n            }\n            for (int i = start; i <= 9; i++) {\n                if (i<=n){\n                    list.addlast(i);\n                    k--;\n                    dfs(list,res,n-i,k,i+1);\n                    k++;\n                    list.removelast();\n                }\n            }\n        }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\nclass solution {\n    public list<list<integer>> combinationsum3(int k, int n) {\n            int[] candidates={1,2,3,4,5,6,7,8,9};\n            list<list<integer>> res=new linkedlist<list<integer>>();\n            if (candidates==null || candidates.length==0){\n                return res;\n            }\n            linkedlist<integer> list=new linkedlist<integer>();\n//            对于这种存在顺序的，可以把其实位置放在一起递归\n            dfs(candidates,list,res,n,k,-1);\n            return res;\n        }\n\n        private void dfs(int[] candidates, linkedlist<integer> list, list<list<integer>> res, int n, int k,int start) {\n            if (n==0 && k==0){\n                res.add(new linkedlist<integer>(list));\n                return;\n            }\n            for (int i = start+1; i < candidates.length; i++) {\n                if (candidates[i]<=n){\n                    list.addlast(candidates[i]);\n                    k--;\n                    dfs(candidates,list,res,n-candidates[i],k,i);\n                    k++;\n                    list.removelast();\n                }\n            }\n        }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n# 高赞题解\n# 解题方案\n# 思路\n * 标签：递归回溯\n * 递归终止条件：数组中包含k个数，如果和为n则加入结果集，否则直接返回终止递归\n * 递归过程：循环遍历1-9，将新数字加入临时数组中进入下一层递归，出来后再将其移除\n * 回溯的关键在于，添加和移除，保证所有可能性都遍历到，整体结构和栈类似\n\n\n\n# 代码\nclass solution {\n    private list<list<integer>> ans = new arraylist<>();\n    \n    public list<list<integer>> combinationsum3(int k, int n) {\n        traceback(k, n, 0, 1, new linkedlist<>());\n        return ans;\n    }\n    \n    public void traceback(int k, int n, int sum, int begin, linkedlist<integer> list) {\n        if(k == 0) {\n            if(n == sum)\n                ans.add(new arraylist<>(list));\n            return;\n        }\n        for(int i = begin; i < 10; i++) {\n            list.add(i);\n            traceback(k - 1, n, sum + i ,i + 1, list);\n            list.removelast();\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n点击我的头像加关注，和我一起打卡天天算法\n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-09-13 17:25:54accepted [https://leetcode-cn.com//submissions/detail/7040007/]1 ms99.2%n/ajava2018-09-13 17:25:41accepted [https://leetcode-cn.com//submissions/detail/7039992/]4 ms5.19%n/ajava2018-09-13 17:25:16wrong answer [https://leetcode-cn.com//submissions/detail/7039967/]n/an/an/ajava2018-09-13 17:23:45accepted [https://leetcode-cn.com//submissions/detail/7039874/]2 ms18.91%n/ajava# 统计信息\n通过次数提交次数ac比率123871776169.7%# 相似题目\n题目难度组合总和 [https://leetcode-cn.com/problems/combination-sum/]中等"},{title:"220-存在重复元素 III(Contains Duplicate III)",frontmatter:{title:"220-存在重复元素 III(Contains Duplicate III)",date:"2018-09-02T00:00:00.000Z",categories:["中等"],tags:["排序<Sort>","Ordered Map"]},regularPath:"/views/%E4%B8%AD%E7%AD%89/0220-%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0%20III.html",relativePath:"views/中等/0220-存在重复元素 III.md",key:"v-0c1dc4cd",path:"/views/%E4%B8%AD%E7%AD%89/0220-%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0%20III.html",headers:[{level:2,title:"中文题目",slug:"中文题目",charIndex:2},{level:2,title:"通过代码",slug:"通过代码",charIndex:258},{level:2,title:"官方题解",slug:"官方题解",charIndex:2899},{level:2,title:"概述",slug:"概述",charIndex:2906},{level:2,title:"提交历史",slug:"提交历史",charIndex:9152},{level:2,title:"统计信息",slug:"统计信息",charIndex:10976},{level:2,title:"相似题目",slug:"相似题目",charIndex:11010}],lastUpdated:"4/11/2021, 1:15:21 PM",headersStr:"中文题目 通过代码 官方题解 概述 提交历史 统计信息 相似题目",content:"# 中文题目\n给定一个整数数组，判断数组中是否有两个不同的索引 i 和 j，使得nums [i] 和nums [j]的差的绝对值最大为 t，并且 i 和 j 之间的差的绝对值最大为 ķ。\n\n示例 1:\n\n输入: nums = [1,2,3,1], k = 3, t = 0\n输出: true\n\n示例 2:\n\n输入: nums = [1,0,1,1], k = 1, t = 2\n输出: true\n\n示例 3:\n\n输入: nums = [1,5,9,1,5,9], k = 2, t = 3\n输出: false\n\n# 通过代码\nclass Solution {\n    public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {\n     \n            if (t < 0) {\n                return false;\n            }\n\n            TreeSet<Long> record = new TreeSet<Long>();\n            for (int i = 0; i < nums.length; i++) {\n\n                if (record.ceiling((long) nums[i] - (long) t) != null &&\n                        record.ceiling((long) nums[i] - (long) t) <= (long) nums[i] + (long) t) {\n                    return true;\n                }\n\n                record.add((long) nums[i]);\n\n                if (record.size() == k + 1) {\n                    record.remove((long) nums[i - k]);\n                }\n            }\n\n            return false;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\nclass Solution {\n    public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {\n            if(k == 10000 && t == 0) return false;\n        for(int i = 0; i < nums.length - 1; i++) {\n            int limit=i+k;\n            for(int j = i + 1; j < limit+1 && j<nums.length; j++) {\n                if(Math.abs((long)nums[i] - nums[j]) <= t) return true;\n            }\n        }\n        return false;\n         }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\nclass Solution {\n    public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {\n            if(k == 10000 && t == 0) return false;\n        for(int i = 0; i < nums.length - 1; i++) {\n            int limit=i+k;\n            for(int j = i + 1; j < limit+1 && j<nums.length; j++) {\n                if(Math.abs((long)nums[i] - nums[j]) <= t) return true;\n            }\n        }\n        return false;\n         }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\npublic class Solution {\n    public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {\n        if (k < 1 || t < 0) return false;\n        Map<Long, Long> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            long remappedNum = (long) nums[i] - Integer.MIN_VALUE;\n            long bucket = remappedNum / ((long) t + 1);\n            if (map.containsKey(bucket)\n                    || (map.containsKey(bucket - 1) && remappedNum - map.get(bucket - 1) <= t)\n                        || (map.containsKey(bucket + 1) && map.get(bucket + 1) - remappedNum <= t))\n                            return true;\n            if (map.entrySet().size() >= k) {\n                long lastBucket = ((long) nums[i - k] - Integer.MIN_VALUE) / ((long) t + 1);\n                map.remove(lastBucket);\n            }\n            map.put(bucket, remappedNum);\n        }\n        return false;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n# 官方题解\n# 概述\n这篇文章是为中级读者准备的，文章中会介绍了以下几种方法： 二叉搜索树，散列表和桶。\n\n# 方法一 （线性搜索） 【超时】\n思路\n\n将每个元素与它之前的 kkk 个元素比较，查看它们的数值之差是不是在 ttt 以内。\n\n算法\n\n解决这个问题需要找到一组满足以下条件的 iii 和 jjj：\n\n 1. ∣i−j∣≤k\\bigl| i-j \\bigr| \\le k∣∣​i−j∣∣​≤k\n 2. ∣nums[i]−nums[j]∣≤t\\bigl| \\mathrm{nums}[i] - \\mathrm{nums}[j] \\bigr| \\le t∣∣​nums[i]−nums[j]∣∣​≤t\n\n我们需要维护了一个kkk大小的滑动窗口。这种情况下，第一个条件始终是满足的，只需要通过线性搜索来检查第二个条件是否满足就可以了。\n\npublic boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {\n    for (int i = 0; i < nums.length; ++i) {\n        for (int j = Math.max(i - k, 0); j < i; ++j) {\n            if (Math.abs(nums[i] - nums[j]) <= t) return true;\n        }\n    }\n    return false;\n}\n// Time limit exceeded.\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n复杂度分析\n\n * 时间复杂度：O(nmin⁡(k,n))O(n \\min(k,n))O(nmin(k,n))每次搜索都将花费 O(min⁡(k,n))O(\\min(k, n))O(min(k,n)) 的时间，需要注意的是一次搜索中我们最多比较 nnn 次，哪怕 kkk 比 nnn 大。\n   \n   \n * 空间复杂度：O(1)O(1)O(1)额外开辟的空间为常数个\n   \n   \n\n# 方法二 （二叉搜索树） 【通过】\n思路\n\n * 如果窗口中维护的元素是有序的，只需要用二分搜索检查条件二是否是满足的就可以了。\n * 利用自平衡二叉搜索树，可以在对数时间内通过 插入 和 删除 来对滑动窗口内元素排序。\n\n算法\n\n方法一真正的瓶颈在于检查第二个条件是否满足需要扫描滑动窗口中所有的元素。因此我们需要考虑的是有没有比全扫描更好的方法。\n\n如果窗口内的元素是有序的，那么用两次二分搜索就可以找到 x+tx+tx+t 和 x−tx-tx−t 这两个边界值了。\n\n然而不幸的是，窗口中的元素是无序的。这里有一个初学者非常容易犯的错误，那就是将滑动窗口维护成一个有序的数组。虽然在有序数组中 搜索 只需要花费对数时间，但是为了让数组保持有序，我们不得不做插入和删除的操作，而这些操作是非常不高效的。想象一下，如果你有一个kkk大小的有序数组，当你插入一个新元素xxx的时候。虽然可以在O(log⁡k)O(\\log k)O(logk)时间内找到这个元素应该插入的位置，但最后还是需要O(k)O(k)O(k)的时间来将xxx插入这个有序数组。因为必须得把当前元素应该插入的位置之后的所有元素往后移一位。当你要删除一个元素的时候也是同样的道理。在删除了下标为iii的元素之后，还需要把下标iii之后的所有元素往前移一位。因此，这种做法并不会比方法一更好。\n\n为了能让算法的效率得到真正的提升，我们需要引入一个支持 插入，搜索，删除 操作的 动态 数据结构，那就是自平衡二叉搜索树。自平衡 这个词的意思是，这个树在随机进行插入,删除操作之后，它会自动保证树的高度最小。为什么一棵树需要自平衡呢？这是因为在二叉搜索树上的大部分操作需要花费的时间跟这颗树的高度直接相关。可以看一下下面这棵严重左偏的非平衡二叉搜索树。\n\n            6\n           /\n          5\n         /\n        4\n       /\n      3\n     /\n    2\n   /\n  1\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n图 1. 一个严重左偏的非平衡二叉搜索树。\n\n在上面这棵二叉搜索树上查找一个元素需要花费 线性 时间复杂度，这跟在链表中搜索的速度是一样的。现在我们来比较一下下面这棵平衡二叉搜索树。\n\n          4\n        /   \\\n       2     6\n      / \\   /\n     1   3  5\n\n\n1\n2\n3\n4\n5\n图2. 一颗平衡的二叉搜索树\n\n假设这棵树上节点总数为 nnn，一个平衡树能把高度维持在 h=log⁡nh = \\log nh=logn。因此这棵树上支持在 O(h)=O(log⁡n)O(h) = O(\\log n)O(h)=O(logn) 时间内完成 插入，搜索，删除 操作。\n\n下面给出整个算法的伪代码：\n\n * 初始化一颗空的二叉搜索树 set\n * 对于每个元素xxx，遍历整个数组 * 在 set 上查找大于等于xxx的最小的数，如果s−x≤ts - x \\leq ts−x≤t则返回 true\n    * 在 set 上查找小于等于xxx的最大的数，如果x−g≤tx - g \\leq tx−g≤t则返回 true\n    * 在 set 中插入xxx\n    * 如果树的大小超过了kkk, 则移除最早加入树的那个数。\n   \n   \n * 返回 false\n\n我们把大于等于 xxx 的最小的数 sss 当做 xxx 在 BST 中的后继节点。同样的，我们能把小于等于 xxx 最大的数 ggg 当做 xxx 在 BST 中的前继节点。sss 和 ggg 这两个数是距离 xxx 最近的数。因此只需要检查它们和 xxx 的距离就能知道条件二是否满足了。\n\npublic boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {\n    TreeSet<Integer> set = new TreeSet<>();\n    for (int i = 0; i < nums.length; ++i) {\n        // Find the successor of current element\n        Integer s = set.ceiling(nums[i]);\n        if (s != null && s <= nums[i] + t) return true;\n\n        // Find the predecessor of current element\n        Integer g = set.floor(nums[i]);\n        if (g != null && nums[i] <= g + t) return true;\n\n        set.add(nums[i]);\n        if (set.size() > k) {\n            set.remove(nums[i - k]);\n        }\n    }\n    return false;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n复杂度分析\n\n * 时间复杂度：O(nlog⁡(min⁡(n,k)))O(n \\log (\\min(n,k)))O(nlog(min(n,k)))我们需要遍历这个 nnn 长度的数组。对于每次遍历，在 BST 中 搜索，插入 或者 删除 都需要花费 O(log⁡min⁡(k,n))O(\\log \\min(k, n))O(logmin(k,n)) 的时间。\n   \n   \n * 空间复杂度：O(min⁡(n,k))O(\\min(n,k))O(min(n,k))空间复杂度由 BST 的大小决定，其大小的上限由 kkk 和 nnn 共同决定。\n   \n   \n\n笔记\n\n * 当数组中的元素非常大的时候，进行数学运算可能造成溢出。所以可以考虑使用支持大数的数据类型，例如 long。\n   \n   \n * C++ 中的 std::set，std::set::upper_bound 和 std::set::lower_bound 分别等价于 Java 中的 TreeSet，TreeSet::ceiling 和 TreeSet::floor。Python 标准库不提供自平衡 BST。\n   \n   \n\n# 方法三 （桶） 【通过】\n思路\n\n受 桶排序 的启发，我们可以把 桶 当做窗口来实现一个线性复杂度的解法。\n\n算法\n\n桶排序是一种把元素分散到不同桶中的排序算法。接着把每个桶再独立地用不同的排序算法进行排序。桶排序的概览如下所示：\n\n在上面的例子中，我们有 8 个未排序的整数。我们首先来创建五个桶，这五个桶分别包含 [0,9],[10,19],[20,29],[30,39],[40,49][0,9], [10,19], [20, 29], [30, 39], [40, 49][0,9],[10,19],[20,29],[30,39],[40,49] 这几个区间。这 8 个元素中的任何一个元素都在一个桶里面。对于值为 xxx 的元素来说，它所属桶的标签为 x/wx/wx/w，在这里我们让 w=10w = 10w=10。对于每个桶我们单独用其他排序算法进行排序，最后按照桶的顺序收集所有的元素就可以得到一个有序的数组了。\n\n回到这个问题，我们尝试去解决的最大的问题在于：\n\n>  1. 对于给定的元素 xxx, 在窗口中是否有存在区间 [x−t,x+t][x-t, x+t][x−t,x+t] 内的元素？\n 2. 我们能在常量时间内完成以上判断嘛？\n\n\n我们不妨把把每个元素当做一个人的生日来考虑一下吧。假设你是班上新来的一位学生，你的生日在 三月 的某一天，你想知道班上是否有人生日跟你生日在 t=30t=30t=30 天以内。在这里我们先假设每个月都是303030天，很明显，我们只需要检查所有生日在 二月，三月，四月 的同学就可以了。\n\n之所以能这么做的原因在于，我们知道每个人的生日都属于一个桶，我们把这个桶称作月份！每个桶所包含的区间范围都是 ttt，这能极大的简化我们的问题。很显然，任何不在同一个桶或相邻桶的两个元素之间的距离一定是大于 ttt 的。\n\n我们把上面提到的桶的思想应用到这个问题里面来，我们设计一些桶，让他们分别包含区间 ...,[0,t],[t+1,2t+1],......, [0,t], [t+1, 2t+1], ......,[0,t],[t+1,2t+1],...。我们把桶来当做窗口，于是每次我们只需要检查 xxx 所属的那个桶和相邻桶中的元素就可以了。终于，我们可以在常量时间解决在窗口中搜索的问题了。\n\n还有一件值得注意的事，这个问题和桶排序的不同之处在于每次我们的桶里只需要包含最多一个元素就可以了，因为如果任意一个桶中包含了两个元素，那么这也就是意味着这两个元素是 足够接近的 了，这时候我们就直接得到答案了。因此，我们只需使用一个标签为桶序号的散列表就可以了。\n\npublic class Solution {\n    // Get the ID of the bucket from element value x and bucket width w\n    // In Java, `-3 / 5 = 0` and but we need `-3 / 5 = -1`.\n    private long getID(long x, long w) {\n        return x < 0 ? (x + 1) / w - 1 : x / w;\n    }\n\n    public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {\n        if (t < 0) return false;\n        Map<Long, Long> d = new HashMap<>();\n        long w = (long)t + 1;\n        for (int i = 0; i < nums.length; ++i) {\n            long m = getID(nums[i], w);\n            // check if bucket m is empty, each bucket may contain at most one element\n            if (d.containsKey(m))\n                return true;\n            // check the nei***or buckets for almost duplicate\n            if (d.containsKey(m - 1) && Math.abs(nums[i] - d.get(m - 1)) < w)\n                return true;\n            if (d.containsKey(m + 1) && Math.abs(nums[i] - d.get(m + 1)) < w)\n                return true;\n            // now bucket m is empty and no almost duplicate in nei***or buckets\n            d.put(m, (long)nums[i]);\n            if (i >= k) d.remove(getID(nums[i - k], w));\n        }\n        return false;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n复杂度分析\n\n * 时间复杂度：O(n)O(n)O(n)\n\n对于这 nnn 个元素中的任意一个元素来说，我们最多只需要在散列表中做三次 搜索，一次 插入 和一次 删除。这些操作是常量时间复杂度的。因此，整个算法的时间复杂度为 O(n)O(n)O(n)。\n\n * 空间复杂度：O(min⁡(n,k))O(\\min(n, k))O(min(n,k))需要开辟的额外空间取决了散列表的大小，其大小跟它所包含的元素数量成线性关系。散列表的大小的上限同时由 nnn 和 kkk 决定。因此，空间复杂度为 O(min⁡(n,k))O(\\min(n, k))O(min(n,k))。\n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-09-02 22:56:09Accepted [https://leetcode-cn.com//submissions/detail/6441882/]49 ms22.3%N/Ajava2018-09-02 22:36:56Accepted [https://leetcode-cn.com//submissions/detail/6440829/]0 ms100.0%N/Ajava2018-09-02 22:36:24Time Limit Exceeded [https://leetcode-cn.com//submissions/detail/6440807/]N/AN/AN/Ajava2018-09-02 22:28:04Accepted [https://leetcode-cn.com//submissions/detail/6440443/]0 ms100.0%N/Ajava2018-09-02 22:27:25Accepted [https://leetcode-cn.com//submissions/detail/6440419/]27 ms60.34%N/Ajava2018-09-02 22:26:49Wrong Answer [https://leetcode-cn.com//submissions/detail/6440392/]N/AN/AN/Ajava2018-09-02 22:22:09Wrong Answer [https://leetcode-cn.com//submissions/detail/6440181/]N/AN/AN/Ajava2018-09-02 22:20:48Runtime Error [https://leetcode-cn.com//submissions/detail/6440086/]N/AN/AN/Ajava2018-09-02 21:32:57Runtime Error [https://leetcode-cn.com//submissions/detail/6437834/]N/AN/AN/Ajava2018-09-02 21:32:26Compile Error [https://leetcode-cn.com//submissions/detail/6437809/]N/AN/AN/Ajava2018-09-02 21:31:27Wrong Answer [https://leetcode-cn.com//submissions/detail/6437769/]N/AN/AN/Ajava2018-09-02 21:28:34Wrong Answer [https://leetcode-cn.com//submissions/detail/6437646/]N/AN/AN/Ajava2018-09-02 21:24:08Runtime Error [https://leetcode-cn.com//submissions/detail/6437465/]N/AN/AN/Ajava2018-09-02 20:56:53Wrong Answer [https://leetcode-cn.com//submissions/detail/6436181/]N/AN/AN/Ajava2018-09-02 20:54:56Wrong Answer [https://leetcode-cn.com//submissions/detail/6436076/]N/AN/AN/Ajava2018-09-02 20:51:45Wrong Answer [https://leetcode-cn.com//submissions/detail/6435923/]N/AN/AN/Ajava2018-09-02 20:48:55Runtime Error [https://leetcode-cn.com//submissions/detail/6435770/]N/AN/AN/Ajava2018-09-02 20:34:59Wrong Answer [https://leetcode-cn.com//submissions/detail/6435045/]N/AN/AN/Ajava# 统计信息\n通过次数提交次数AC比率114624460225.7%# 相似题目\n题目难度存在重复元素 [https://leetcode-cn.com/problems/contains-duplicate/]简单存在重复元素 II [https://leetcode-cn.com/problems/contains-duplicate-ii/]简单",contentLowercase:"# 中文题目\n给定一个整数数组，判断数组中是否有两个不同的索引 i 和 j，使得nums [i] 和nums [j]的差的绝对值最大为 t，并且 i 和 j 之间的差的绝对值最大为 ķ。\n\n示例 1:\n\n输入: nums = [1,2,3,1], k = 3, t = 0\n输出: true\n\n示例 2:\n\n输入: nums = [1,0,1,1], k = 1, t = 2\n输出: true\n\n示例 3:\n\n输入: nums = [1,5,9,1,5,9], k = 2, t = 3\n输出: false\n\n# 通过代码\nclass solution {\n    public boolean containsnearbyalmostduplicate(int[] nums, int k, int t) {\n     \n            if (t < 0) {\n                return false;\n            }\n\n            treeset<long> record = new treeset<long>();\n            for (int i = 0; i < nums.length; i++) {\n\n                if (record.ceiling((long) nums[i] - (long) t) != null &&\n                        record.ceiling((long) nums[i] - (long) t) <= (long) nums[i] + (long) t) {\n                    return true;\n                }\n\n                record.add((long) nums[i]);\n\n                if (record.size() == k + 1) {\n                    record.remove((long) nums[i - k]);\n                }\n            }\n\n            return false;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\nclass solution {\n    public boolean containsnearbyalmostduplicate(int[] nums, int k, int t) {\n            if(k == 10000 && t == 0) return false;\n        for(int i = 0; i < nums.length - 1; i++) {\n            int limit=i+k;\n            for(int j = i + 1; j < limit+1 && j<nums.length; j++) {\n                if(math.abs((long)nums[i] - nums[j]) <= t) return true;\n            }\n        }\n        return false;\n         }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\nclass solution {\n    public boolean containsnearbyalmostduplicate(int[] nums, int k, int t) {\n            if(k == 10000 && t == 0) return false;\n        for(int i = 0; i < nums.length - 1; i++) {\n            int limit=i+k;\n            for(int j = i + 1; j < limit+1 && j<nums.length; j++) {\n                if(math.abs((long)nums[i] - nums[j]) <= t) return true;\n            }\n        }\n        return false;\n         }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\npublic class solution {\n    public boolean containsnearbyalmostduplicate(int[] nums, int k, int t) {\n        if (k < 1 || t < 0) return false;\n        map<long, long> map = new hashmap<>();\n        for (int i = 0; i < nums.length; i++) {\n            long remappednum = (long) nums[i] - integer.min_value;\n            long bucket = remappednum / ((long) t + 1);\n            if (map.containskey(bucket)\n                    || (map.containskey(bucket - 1) && remappednum - map.get(bucket - 1) <= t)\n                        || (map.containskey(bucket + 1) && map.get(bucket + 1) - remappednum <= t))\n                            return true;\n            if (map.entryset().size() >= k) {\n                long lastbucket = ((long) nums[i - k] - integer.min_value) / ((long) t + 1);\n                map.remove(lastbucket);\n            }\n            map.put(bucket, remappednum);\n        }\n        return false;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n# 官方题解\n# 概述\n这篇文章是为中级读者准备的，文章中会介绍了以下几种方法： 二叉搜索树，散列表和桶。\n\n# 方法一 （线性搜索） 【超时】\n思路\n\n将每个元素与它之前的 kkk 个元素比较，查看它们的数值之差是不是在 ttt 以内。\n\n算法\n\n解决这个问题需要找到一组满足以下条件的 iii 和 jjj：\n\n 1. ∣i−j∣≤k\\bigl| i-j \\bigr| \\le k∣∣​i−j∣∣​≤k\n 2. ∣nums[i]−nums[j]∣≤t\\bigl| \\mathrm{nums}[i] - \\mathrm{nums}[j] \\bigr| \\le t∣∣​nums[i]−nums[j]∣∣​≤t\n\n我们需要维护了一个kkk大小的滑动窗口。这种情况下，第一个条件始终是满足的，只需要通过线性搜索来检查第二个条件是否满足就可以了。\n\npublic boolean containsnearbyalmostduplicate(int[] nums, int k, int t) {\n    for (int i = 0; i < nums.length; ++i) {\n        for (int j = math.max(i - k, 0); j < i; ++j) {\n            if (math.abs(nums[i] - nums[j]) <= t) return true;\n        }\n    }\n    return false;\n}\n// time limit exceeded.\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n复杂度分析\n\n * 时间复杂度：o(nmin⁡(k,n))o(n \\min(k,n))o(nmin(k,n))每次搜索都将花费 o(min⁡(k,n))o(\\min(k, n))o(min(k,n)) 的时间，需要注意的是一次搜索中我们最多比较 nnn 次，哪怕 kkk 比 nnn 大。\n   \n   \n * 空间复杂度：o(1)o(1)o(1)额外开辟的空间为常数个\n   \n   \n\n# 方法二 （二叉搜索树） 【通过】\n思路\n\n * 如果窗口中维护的元素是有序的，只需要用二分搜索检查条件二是否是满足的就可以了。\n * 利用自平衡二叉搜索树，可以在对数时间内通过 插入 和 删除 来对滑动窗口内元素排序。\n\n算法\n\n方法一真正的瓶颈在于检查第二个条件是否满足需要扫描滑动窗口中所有的元素。因此我们需要考虑的是有没有比全扫描更好的方法。\n\n如果窗口内的元素是有序的，那么用两次二分搜索就可以找到 x+tx+tx+t 和 x−tx-tx−t 这两个边界值了。\n\n然而不幸的是，窗口中的元素是无序的。这里有一个初学者非常容易犯的错误，那就是将滑动窗口维护成一个有序的数组。虽然在有序数组中 搜索 只需要花费对数时间，但是为了让数组保持有序，我们不得不做插入和删除的操作，而这些操作是非常不高效的。想象一下，如果你有一个kkk大小的有序数组，当你插入一个新元素xxx的时候。虽然可以在o(log⁡k)o(\\log k)o(logk)时间内找到这个元素应该插入的位置，但最后还是需要o(k)o(k)o(k)的时间来将xxx插入这个有序数组。因为必须得把当前元素应该插入的位置之后的所有元素往后移一位。当你要删除一个元素的时候也是同样的道理。在删除了下标为iii的元素之后，还需要把下标iii之后的所有元素往前移一位。因此，这种做法并不会比方法一更好。\n\n为了能让算法的效率得到真正的提升，我们需要引入一个支持 插入，搜索，删除 操作的 动态 数据结构，那就是自平衡二叉搜索树。自平衡 这个词的意思是，这个树在随机进行插入,删除操作之后，它会自动保证树的高度最小。为什么一棵树需要自平衡呢？这是因为在二叉搜索树上的大部分操作需要花费的时间跟这颗树的高度直接相关。可以看一下下面这棵严重左偏的非平衡二叉搜索树。\n\n            6\n           /\n          5\n         /\n        4\n       /\n      3\n     /\n    2\n   /\n  1\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n图 1. 一个严重左偏的非平衡二叉搜索树。\n\n在上面这棵二叉搜索树上查找一个元素需要花费 线性 时间复杂度，这跟在链表中搜索的速度是一样的。现在我们来比较一下下面这棵平衡二叉搜索树。\n\n          4\n        /   \\\n       2     6\n      / \\   /\n     1   3  5\n\n\n1\n2\n3\n4\n5\n图2. 一颗平衡的二叉搜索树\n\n假设这棵树上节点总数为 nnn，一个平衡树能把高度维持在 h=log⁡nh = \\log nh=logn。因此这棵树上支持在 o(h)=o(log⁡n)o(h) = o(\\log n)o(h)=o(logn) 时间内完成 插入，搜索，删除 操作。\n\n下面给出整个算法的伪代码：\n\n * 初始化一颗空的二叉搜索树 set\n * 对于每个元素xxx，遍历整个数组 * 在 set 上查找大于等于xxx的最小的数，如果s−x≤ts - x \\leq ts−x≤t则返回 true\n    * 在 set 上查找小于等于xxx的最大的数，如果x−g≤tx - g \\leq tx−g≤t则返回 true\n    * 在 set 中插入xxx\n    * 如果树的大小超过了kkk, 则移除最早加入树的那个数。\n   \n   \n * 返回 false\n\n我们把大于等于 xxx 的最小的数 sss 当做 xxx 在 bst 中的后继节点。同样的，我们能把小于等于 xxx 最大的数 ggg 当做 xxx 在 bst 中的前继节点。sss 和 ggg 这两个数是距离 xxx 最近的数。因此只需要检查它们和 xxx 的距离就能知道条件二是否满足了。\n\npublic boolean containsnearbyalmostduplicate(int[] nums, int k, int t) {\n    treeset<integer> set = new treeset<>();\n    for (int i = 0; i < nums.length; ++i) {\n        // find the successor of current element\n        integer s = set.ceiling(nums[i]);\n        if (s != null && s <= nums[i] + t) return true;\n\n        // find the predecessor of current element\n        integer g = set.floor(nums[i]);\n        if (g != null && nums[i] <= g + t) return true;\n\n        set.add(nums[i]);\n        if (set.size() > k) {\n            set.remove(nums[i - k]);\n        }\n    }\n    return false;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n复杂度分析\n\n * 时间复杂度：o(nlog⁡(min⁡(n,k)))o(n \\log (\\min(n,k)))o(nlog(min(n,k)))我们需要遍历这个 nnn 长度的数组。对于每次遍历，在 bst 中 搜索，插入 或者 删除 都需要花费 o(log⁡min⁡(k,n))o(\\log \\min(k, n))o(logmin(k,n)) 的时间。\n   \n   \n * 空间复杂度：o(min⁡(n,k))o(\\min(n,k))o(min(n,k))空间复杂度由 bst 的大小决定，其大小的上限由 kkk 和 nnn 共同决定。\n   \n   \n\n笔记\n\n * 当数组中的元素非常大的时候，进行数学运算可能造成溢出。所以可以考虑使用支持大数的数据类型，例如 long。\n   \n   \n * c++ 中的 std::set，std::set::upper_bound 和 std::set::lower_bound 分别等价于 java 中的 treeset，treeset::ceiling 和 treeset::floor。python 标准库不提供自平衡 bst。\n   \n   \n\n# 方法三 （桶） 【通过】\n思路\n\n受 桶排序 的启发，我们可以把 桶 当做窗口来实现一个线性复杂度的解法。\n\n算法\n\n桶排序是一种把元素分散到不同桶中的排序算法。接着把每个桶再独立地用不同的排序算法进行排序。桶排序的概览如下所示：\n\n在上面的例子中，我们有 8 个未排序的整数。我们首先来创建五个桶，这五个桶分别包含 [0,9],[10,19],[20,29],[30,39],[40,49][0,9], [10,19], [20, 29], [30, 39], [40, 49][0,9],[10,19],[20,29],[30,39],[40,49] 这几个区间。这 8 个元素中的任何一个元素都在一个桶里面。对于值为 xxx 的元素来说，它所属桶的标签为 x/wx/wx/w，在这里我们让 w=10w = 10w=10。对于每个桶我们单独用其他排序算法进行排序，最后按照桶的顺序收集所有的元素就可以得到一个有序的数组了。\n\n回到这个问题，我们尝试去解决的最大的问题在于：\n\n>  1. 对于给定的元素 xxx, 在窗口中是否有存在区间 [x−t,x+t][x-t, x+t][x−t,x+t] 内的元素？\n 2. 我们能在常量时间内完成以上判断嘛？\n\n\n我们不妨把把每个元素当做一个人的生日来考虑一下吧。假设你是班上新来的一位学生，你的生日在 三月 的某一天，你想知道班上是否有人生日跟你生日在 t=30t=30t=30 天以内。在这里我们先假设每个月都是303030天，很明显，我们只需要检查所有生日在 二月，三月，四月 的同学就可以了。\n\n之所以能这么做的原因在于，我们知道每个人的生日都属于一个桶，我们把这个桶称作月份！每个桶所包含的区间范围都是 ttt，这能极大的简化我们的问题。很显然，任何不在同一个桶或相邻桶的两个元素之间的距离一定是大于 ttt 的。\n\n我们把上面提到的桶的思想应用到这个问题里面来，我们设计一些桶，让他们分别包含区间 ...,[0,t],[t+1,2t+1],......, [0,t], [t+1, 2t+1], ......,[0,t],[t+1,2t+1],...。我们把桶来当做窗口，于是每次我们只需要检查 xxx 所属的那个桶和相邻桶中的元素就可以了。终于，我们可以在常量时间解决在窗口中搜索的问题了。\n\n还有一件值得注意的事，这个问题和桶排序的不同之处在于每次我们的桶里只需要包含最多一个元素就可以了，因为如果任意一个桶中包含了两个元素，那么这也就是意味着这两个元素是 足够接近的 了，这时候我们就直接得到答案了。因此，我们只需使用一个标签为桶序号的散列表就可以了。\n\npublic class solution {\n    // get the id of the bucket from element value x and bucket width w\n    // in java, `-3 / 5 = 0` and but we need `-3 / 5 = -1`.\n    private long getid(long x, long w) {\n        return x < 0 ? (x + 1) / w - 1 : x / w;\n    }\n\n    public boolean containsnearbyalmostduplicate(int[] nums, int k, int t) {\n        if (t < 0) return false;\n        map<long, long> d = new hashmap<>();\n        long w = (long)t + 1;\n        for (int i = 0; i < nums.length; ++i) {\n            long m = getid(nums[i], w);\n            // check if bucket m is empty, each bucket may contain at most one element\n            if (d.containskey(m))\n                return true;\n            // check the nei***or buckets for almost duplicate\n            if (d.containskey(m - 1) && math.abs(nums[i] - d.get(m - 1)) < w)\n                return true;\n            if (d.containskey(m + 1) && math.abs(nums[i] - d.get(m + 1)) < w)\n                return true;\n            // now bucket m is empty and no almost duplicate in nei***or buckets\n            d.put(m, (long)nums[i]);\n            if (i >= k) d.remove(getid(nums[i - k], w));\n        }\n        return false;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n复杂度分析\n\n * 时间复杂度：o(n)o(n)o(n)\n\n对于这 nnn 个元素中的任意一个元素来说，我们最多只需要在散列表中做三次 搜索，一次 插入 和一次 删除。这些操作是常量时间复杂度的。因此，整个算法的时间复杂度为 o(n)o(n)o(n)。\n\n * 空间复杂度：o(min⁡(n,k))o(\\min(n, k))o(min(n,k))需要开辟的额外空间取决了散列表的大小，其大小跟它所包含的元素数量成线性关系。散列表的大小的上限同时由 nnn 和 kkk 决定。因此，空间复杂度为 o(min⁡(n,k))o(\\min(n, k))o(min(n,k))。\n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-09-02 22:56:09accepted [https://leetcode-cn.com//submissions/detail/6441882/]49 ms22.3%n/ajava2018-09-02 22:36:56accepted [https://leetcode-cn.com//submissions/detail/6440829/]0 ms100.0%n/ajava2018-09-02 22:36:24time limit exceeded [https://leetcode-cn.com//submissions/detail/6440807/]n/an/an/ajava2018-09-02 22:28:04accepted [https://leetcode-cn.com//submissions/detail/6440443/]0 ms100.0%n/ajava2018-09-02 22:27:25accepted [https://leetcode-cn.com//submissions/detail/6440419/]27 ms60.34%n/ajava2018-09-02 22:26:49wrong answer [https://leetcode-cn.com//submissions/detail/6440392/]n/an/an/ajava2018-09-02 22:22:09wrong answer [https://leetcode-cn.com//submissions/detail/6440181/]n/an/an/ajava2018-09-02 22:20:48runtime error [https://leetcode-cn.com//submissions/detail/6440086/]n/an/an/ajava2018-09-02 21:32:57runtime error [https://leetcode-cn.com//submissions/detail/6437834/]n/an/an/ajava2018-09-02 21:32:26compile error [https://leetcode-cn.com//submissions/detail/6437809/]n/an/an/ajava2018-09-02 21:31:27wrong answer [https://leetcode-cn.com//submissions/detail/6437769/]n/an/an/ajava2018-09-02 21:28:34wrong answer [https://leetcode-cn.com//submissions/detail/6437646/]n/an/an/ajava2018-09-02 21:24:08runtime error [https://leetcode-cn.com//submissions/detail/6437465/]n/an/an/ajava2018-09-02 20:56:53wrong answer [https://leetcode-cn.com//submissions/detail/6436181/]n/an/an/ajava2018-09-02 20:54:56wrong answer [https://leetcode-cn.com//submissions/detail/6436076/]n/an/an/ajava2018-09-02 20:51:45wrong answer [https://leetcode-cn.com//submissions/detail/6435923/]n/an/an/ajava2018-09-02 20:48:55runtime error [https://leetcode-cn.com//submissions/detail/6435770/]n/an/an/ajava2018-09-02 20:34:59wrong answer [https://leetcode-cn.com//submissions/detail/6435045/]n/an/an/ajava# 统计信息\n通过次数提交次数ac比率114624460225.7%# 相似题目\n题目难度存在重复元素 [https://leetcode-cn.com/problems/contains-duplicate/]简单存在重复元素 ii [https://leetcode-cn.com/problems/contains-duplicate-ii/]简单"},{title:"230-二叉搜索树中第K小的元素(Kth Smallest Element in a BST)",frontmatter:{title:"230-二叉搜索树中第K小的元素(Kth Smallest Element in a BST)",date:"2018-09-08T00:00:00.000Z",categories:["中等"],tags:["树<Tree>","二分查找<Binary Search>"]},regularPath:"/views/%E4%B8%AD%E7%AD%89/0230-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%AC%ACK%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0.html",relativePath:"views/中等/0230-二叉搜索树中第K小的元素.md",key:"v-239b7bef",path:"/views/%E4%B8%AD%E7%AD%89/0230-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%AC%ACK%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0.html",headers:[{level:2,title:"中文题目",slug:"中文题目",charIndex:2},{level:2,title:"通过代码",slug:"通过代码",charIndex:339},{level:2,title:"官方题解",slug:"官方题解",charIndex:1648},{level:2,title:"提交历史",slug:"提交历史",charIndex:4055},{level:2,title:"统计信息",slug:"统计信息",charIndex:4382},{level:2,title:"相似题目",slug:"相似题目",charIndex:4416}],lastUpdated:"4/11/2021, 1:15:21 PM",headersStr:"中文题目 通过代码 官方题解 提交历史 统计信息 相似题目",content:'# 中文题目\n给定一个二叉搜索树，编写一个函数kthSmallest来查找其中第k个最小的元素。\n\n说明：\n你可以假设 k 总是有效的，1 ≤ k ≤ 二叉搜索树元素个数。\n\n示例 1:\n\n输入: root = [3,1,4,null,2], k = 1\n   3\n  / \\\n 1   4\n  \\\n   2\n输出: 1\n\n示例 2:\n\n输入: root = [5,3,6,2,4,null,null,1], k = 3\n       5\n      / \\\n     3   6\n    / \\\n   2   4\n  /\n 1\n输出: 3\n\n进阶：\n如果二叉搜索树经常被修改（插入/删除操作）并且你需要频繁地查找第 k 小的值，你将如何优化kthSmallest函数？\n\n# 通过代码\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public int kthSmallest(TreeNode root, int k) {\n        LinkedList<Integer> list=new LinkedList<Integer>();\n        inOrder(root,list);\n        return list.get(k-1);\n    }\n\n    private void inOrder(TreeNode root, LinkedList<Integer> list) {\n        if (root!=null){\n            inOrder(root.left,list);\n            list.addLast(root.val);\n            inOrder(root.right,list);\n        }\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public int kthSmallest(TreeNode root, int k) {\n        LinkedList<Integer> list=new LinkedList<Integer>();\n        inOrder(root,list);\n        return list.get(k-1);\n    }\n\n    private void inOrder(TreeNode root, LinkedList<Integer> list) {\n        if (root!=null){\n            inOrder(root.left,list);\n            list.addLast(root.val);\n            inOrder(root.right,list);\n        }\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n# 官方题解\n# 概述：\n怎么遍历树：\n\n * 深度优先搜索（DFS）\n\n在这个策略中，我们从根延伸到某一片叶子，然后再返回另一个分支。根据根节点，左节点，右节点的相对顺序，DFS 还可以分为前序，中序，后序。\n\n * 广度优先搜索（BFS）\n\n在这个策略中，我们逐层，从上到下扫描整个树。\n\n下图展示了不同的遍历策略：{:width=500} {:align=center}\n\n为了解决这个问题，可以使用 BST 的特性：BST 的中序遍历是升序序列。\n\n# 方法一：递归\n算法：\n\n通过构造 BST 的中序遍历序列，则第 k-1 个元素就是第 k 小的元素。\n\n{:width=500} {:align=center}\n\nclass Solution:\n    def kthSmallest(self, root, k):\n        """\n        :type root: TreeNode\n        :type k: int\n        :rtype: int\n        """\n        def inorder(r):\n            return inorder(r.left) + [r.val] + inorder(r.right) if r else []\n    \n        return inorder(root)[k - 1]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\nclass Solution {\n  public ArrayList<Integer> inorder(TreeNode root, ArrayList<Integer> arr) {\n    if (root == null) return arr;\n    inorder(root.left, arr);\n    arr.add(root.val);\n    inorder(root.right, arr);\n    return arr;\n  }\n\n  public int kthSmallest(TreeNode root, int k) {\n    ArrayList<Integer> nums = inorder(root, new ArrayList<Integer>());\n    return nums.get(k - 1);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n复杂度分析\n\n * 时间复杂度：O(N)O(N)O(N)，遍历了整个树。\n * 空间复杂度：O(N)O(N)O(N)，用了一个数组存储中序序列。\n\n# 方法二：迭代\n算法：\n\n在栈的帮助下，可以将方法一的递归转换为迭代，这样可以加快速度，因为这样可以不用遍历整个树，可以在找到答案后停止。\n\n{:width=500} {:align=center}\n\nclass Solution:\n    def kthSmallest(self, root, k):\n        """\n        :type root: TreeNode\n        :type k: int\n        :rtype: int\n        """\n        stack = []\n        \n        while True:\n            while root:\n                stack.append(root)\n                root = root.left\n            root = stack.pop()\n            k -= 1\n            if not k:\n                return root.val\n            root = root.right\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\nclass Solution {\n  public int kthSmallest(TreeNode root, int k) {\n    LinkedList<TreeNode> stack = new LinkedList<TreeNode>();\n\n    while (true) {\n      while (root != null) {\n        stack.add(root);\n        root = root.left;\n      }\n      root = stack.removeLast();\n      if (--k == 0) return root.val;\n      root = root.right;\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n复杂度分析\n\n * 时间复杂度：O(H+k)\\mathcal{O}(H + k)O(H+k)，其中 HHH 指的是树的高度，由于我们开始遍历之前，要先向下达到叶，当树是一个平衡树时：复杂度为 O(log⁡N+k)\\mathcal{O}(\\log N + k)O(logN+k)。当树是一个不平衡树时：复杂度为 O(N+k)\\mathcal{O}(N + k)O(N+k)，此时所有的节点都在左子树。\n * 空间复杂度：O(H+k)\\mathcal{O}(H + k)O(H+k)。当树是一个平衡树时：O(log⁡N+k)\\mathcal{O}(\\log N + k)O(logN+k)。当树是一个非平衡树时：O(N+k)\\mathcal{O}(N + k)O(N+k)。\n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-09-08 17:23:11Accepted [https://leetcode-cn.com//submissions/detail/6750757/]3 ms11.78%N/Ajava2018-09-08 17:22:43Accepted [https://leetcode-cn.com//submissions/detail/6750743/]2 ms19.13%N/Ajava2018-09-08 17:22:41Compile Error [https://leetcode-cn.com//submissions/detail/6750740/]N/AN/AN/Ajava# 统计信息\n通过次数提交次数AC比率321304739167.8%# 相似题目\n题目难度二叉树的中序遍历 [https://leetcode-cn.com/problems/binary-tree-inorder-traversal/]中等二叉树中第二小的节点 [https://leetcode-cn.com/problems/second-minimum-node-in-a-binary-tree/]简单',contentLowercase:'# 中文题目\n给定一个二叉搜索树，编写一个函数kthsmallest来查找其中第k个最小的元素。\n\n说明：\n你可以假设 k 总是有效的，1 ≤ k ≤ 二叉搜索树元素个数。\n\n示例 1:\n\n输入: root = [3,1,4,null,2], k = 1\n   3\n  / \\\n 1   4\n  \\\n   2\n输出: 1\n\n示例 2:\n\n输入: root = [5,3,6,2,4,null,null,1], k = 3\n       5\n      / \\\n     3   6\n    / \\\n   2   4\n  /\n 1\n输出: 3\n\n进阶：\n如果二叉搜索树经常被修改（插入/删除操作）并且你需要频繁地查找第 k 小的值，你将如何优化kthsmallest函数？\n\n# 通过代码\n/**\n * definition for a binary tree node.\n * public class treenode {\n *     int val;\n *     treenode left;\n *     treenode right;\n *     treenode(int x) { val = x; }\n * }\n */\nclass solution {\n    public int kthsmallest(treenode root, int k) {\n        linkedlist<integer> list=new linkedlist<integer>();\n        inorder(root,list);\n        return list.get(k-1);\n    }\n\n    private void inorder(treenode root, linkedlist<integer> list) {\n        if (root!=null){\n            inorder(root.left,list);\n            list.addlast(root.val);\n            inorder(root.right,list);\n        }\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n/**\n * definition for a binary tree node.\n * public class treenode {\n *     int val;\n *     treenode left;\n *     treenode right;\n *     treenode(int x) { val = x; }\n * }\n */\nclass solution {\n    public int kthsmallest(treenode root, int k) {\n        linkedlist<integer> list=new linkedlist<integer>();\n        inorder(root,list);\n        return list.get(k-1);\n    }\n\n    private void inorder(treenode root, linkedlist<integer> list) {\n        if (root!=null){\n            inorder(root.left,list);\n            list.addlast(root.val);\n            inorder(root.right,list);\n        }\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n# 官方题解\n# 概述：\n怎么遍历树：\n\n * 深度优先搜索（dfs）\n\n在这个策略中，我们从根延伸到某一片叶子，然后再返回另一个分支。根据根节点，左节点，右节点的相对顺序，dfs 还可以分为前序，中序，后序。\n\n * 广度优先搜索（bfs）\n\n在这个策略中，我们逐层，从上到下扫描整个树。\n\n下图展示了不同的遍历策略：{:width=500} {:align=center}\n\n为了解决这个问题，可以使用 bst 的特性：bst 的中序遍历是升序序列。\n\n# 方法一：递归\n算法：\n\n通过构造 bst 的中序遍历序列，则第 k-1 个元素就是第 k 小的元素。\n\n{:width=500} {:align=center}\n\nclass solution:\n    def kthsmallest(self, root, k):\n        """\n        :type root: treenode\n        :type k: int\n        :rtype: int\n        """\n        def inorder(r):\n            return inorder(r.left) + [r.val] + inorder(r.right) if r else []\n    \n        return inorder(root)[k - 1]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\nclass solution {\n  public arraylist<integer> inorder(treenode root, arraylist<integer> arr) {\n    if (root == null) return arr;\n    inorder(root.left, arr);\n    arr.add(root.val);\n    inorder(root.right, arr);\n    return arr;\n  }\n\n  public int kthsmallest(treenode root, int k) {\n    arraylist<integer> nums = inorder(root, new arraylist<integer>());\n    return nums.get(k - 1);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n复杂度分析\n\n * 时间复杂度：o(n)o(n)o(n)，遍历了整个树。\n * 空间复杂度：o(n)o(n)o(n)，用了一个数组存储中序序列。\n\n# 方法二：迭代\n算法：\n\n在栈的帮助下，可以将方法一的递归转换为迭代，这样可以加快速度，因为这样可以不用遍历整个树，可以在找到答案后停止。\n\n{:width=500} {:align=center}\n\nclass solution:\n    def kthsmallest(self, root, k):\n        """\n        :type root: treenode\n        :type k: int\n        :rtype: int\n        """\n        stack = []\n        \n        while true:\n            while root:\n                stack.append(root)\n                root = root.left\n            root = stack.pop()\n            k -= 1\n            if not k:\n                return root.val\n            root = root.right\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\nclass solution {\n  public int kthsmallest(treenode root, int k) {\n    linkedlist<treenode> stack = new linkedlist<treenode>();\n\n    while (true) {\n      while (root != null) {\n        stack.add(root);\n        root = root.left;\n      }\n      root = stack.removelast();\n      if (--k == 0) return root.val;\n      root = root.right;\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n复杂度分析\n\n * 时间复杂度：o(h+k)\\mathcal{o}(h + k)o(h+k)，其中 hhh 指的是树的高度，由于我们开始遍历之前，要先向下达到叶，当树是一个平衡树时：复杂度为 o(log⁡n+k)\\mathcal{o}(\\log n + k)o(logn+k)。当树是一个不平衡树时：复杂度为 o(n+k)\\mathcal{o}(n + k)o(n+k)，此时所有的节点都在左子树。\n * 空间复杂度：o(h+k)\\mathcal{o}(h + k)o(h+k)。当树是一个平衡树时：o(log⁡n+k)\\mathcal{o}(\\log n + k)o(logn+k)。当树是一个非平衡树时：o(n+k)\\mathcal{o}(n + k)o(n+k)。\n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-09-08 17:23:11accepted [https://leetcode-cn.com//submissions/detail/6750757/]3 ms11.78%n/ajava2018-09-08 17:22:43accepted [https://leetcode-cn.com//submissions/detail/6750743/]2 ms19.13%n/ajava2018-09-08 17:22:41compile error [https://leetcode-cn.com//submissions/detail/6750740/]n/an/an/ajava# 统计信息\n通过次数提交次数ac比率321304739167.8%# 相似题目\n题目难度二叉树的中序遍历 [https://leetcode-cn.com/problems/binary-tree-inorder-traversal/]中等二叉树中第二小的节点 [https://leetcode-cn.com/problems/second-minimum-node-in-a-binary-tree/]简单'},{title:"307-区域和检索 - 数组可修改(Range Sum Query - Mutable)",frontmatter:{title:"307-区域和检索 - 数组可修改(Range Sum Query - Mutable)",date:"2018-08-02T00:00:00.000Z",categories:["中等"],tags:["树状数组<Binary Indexed Tree>","线段树<Segment Tree>"]},regularPath:"/views/%E4%B8%AD%E7%AD%89/0307-%E5%8C%BA%E5%9F%9F%E5%92%8C%E6%A3%80%E7%B4%A2%20-%20%E6%95%B0%E7%BB%84%E5%8F%AF%E4%BF%AE%E6%94%B9.html",relativePath:"views/中等/0307-区域和检索 - 数组可修改.md",key:"v-a8cd2084",path:"/views/%E4%B8%AD%E7%AD%89/0307-%E5%8C%BA%E5%9F%9F%E5%92%8C%E6%A3%80%E7%B4%A2%20-%20%E6%95%B0%E7%BB%84%E5%8F%AF%E4%BF%AE%E6%94%B9.html",headers:[{level:2,title:"中文题目",slug:"中文题目",charIndex:2},{level:2,title:"通过代码",slug:"通过代码",charIndex:266},{level:2,title:"官方题解",slug:"官方题解",charIndex:15473},{level:2,title:"摘要：",slug:"摘要：",charIndex:15480},{level:2,title:"解决方法：",slug:"解决方法：",charIndex:15524},{level:2,title:"提交历史",slug:"提交历史",charIndex:20733},{level:2,title:"统计信息",slug:"统计信息",charIndex:20964},{level:2,title:"相似题目",slug:"相似题目",charIndex:20997}],lastUpdated:"4/11/2021, 1:15:21 PM",headersStr:"中文题目 通过代码 官方题解 摘要： 解决方法： 提交历史 统计信息 相似题目",content:'# 中文题目\n给定一个整数数组nums，求出数组从索引i到j(i≤j) 范围内元素的总和，包含i, j两点。\n\nupdate(i, val) 函数可以通过将下标为i的数值更新为val，从而对数列进行修改。\n\n示例:\n\nGiven nums = [1, 3, 5]\n\nsumRange(0, 2) -> 9\nupdate(1, 2)\nsumRange(0, 2) -> 8\n\n\n说明:\n\n 1. 数组仅可以在update函数下进行修改。\n 2. 你可以假设 update 函数与 sumRange 函数的调用次数是均匀分布的。\n\n# 通过代码\n\n\nclass NumArray {\n\n        private SegmentTree<Integer> segmentTree;\n\n        private interface Merger<E> {\n            public E merge(E a, E b);\n        }\n\n        private class SegmentTree<E> {\n            private E[] tree;\n            private E[] data;\n            private Merger<E> merger;\n\n            public SegmentTree(E[] arr, Merger<E> merger) {\n                this.merger = merger;\n                data = (E[]) new Object[arr.length];\n                for (int i = 0; i < arr.length; i++) {\n                    data[i] = arr[i];\n                }\n                tree = (E[]) new Object[4 * arr.length];\n                buildSegmentTree(0, 0, arr.length - 1);\n            }\n\n            /**\n             * 构造线段树\n             *\n             * @param treeIndex\n             * @param l\n             * @param r\n             */\n            private void buildSegmentTree(int treeIndex, int l, int r) {\n                // 递归截止条件，最后只左右相等，将当前的元素赋给tree[treeIndex]\n                if (l == r) {\n                    tree[treeIndex] = data[l];\n                    return;\n                }\n\n                int leftTreeIndex = leftChild(treeIndex);\n                int rightTreeIndex = rightChild(treeIndex);\n\n                int mid = l + (r - l) / 2;\n                buildSegmentTree(leftTreeIndex, l, mid);\n                buildSegmentTree(rightTreeIndex, mid + 1, r);\n\n                tree[treeIndex] = merger.merge(tree[leftTreeIndex], tree[rightTreeIndex]);\n            }\n\n            /**\n             * 获得数组中的元素个数\n             *\n             * @return\n             */\n            public int getSize() {\n                return data.length;\n            }\n\n            /**\n             * 根据索引返回相应的数组中的值\n             *\n             * @param index 索引\n             * @return\n             */\n            public E get(int index) {\n                if (index < 0 || index >= data.length) {\n                    throw new IllegalArgumentException("Index is illegal");\n                }\n                return data[index];\n            }\n\n            /**\n             * 返回一棵完全二叉树的数组表示中，ä¸ä¸ª索引æè¡¨ç¤ºçåç´ çå·¦å­©å­èç¹ç索引\n             *\n             * @param index\n             * @return\n             */\n            public int leftChild(int index) {\n                return 2 * index + 1;\n            }\n\n            /**\n             * 返回一棵完全二叉树的数组表示中，ä¸ä¸ª索引æè¡¨ç¤ºçåç´ çå³å­©å­èç¹ç索引\n             *\n             * @param index\n             * @return\n             */\n            public int rightChild(int index) {\n                return 2 * index + 2;\n            }\n\n            /**\n             * 返回区间[queryL,queryR]的值\n             *\n             * @param queryL\n             * @param queryR\n             * @return\n             */\n            public E query(int queryL, int queryR) {\n                if (queryL < 0 || queryL >= data.length || queryR < 0 || queryR >= data.length || queryL > queryR) {\n                    throw new IllegalArgumentException("Index is illegal");\n                }\n                return query(0, 0, data.length - 1, queryL, queryR);\n            }\n\n            /**\n             * 在以treeIndex为根的线段树中[l...r]的范围里，搜索区间[query...queryR]的值\n             *\n             * @param treeIndex\n             * @param l\n             * @param r\n             * @param queryL\n             * @param queryR\n             * @return\n             */\n            private E query(int treeIndex, int l, int r, int queryL, int queryR) {\n                if (l == queryL && r == queryR) {\n                    return tree[treeIndex];\n                }\n                int mid = l + (r - l) / 2;\n        //        找到以treeIndexä¸ºæ ¹å·¦å³ä¸¤ä¸ªå­©å­ç索引\n                int leftTreeIndex = leftChild(treeIndex);\n                int rightTreeIndex = rightChild(treeIndex);\n\n                if (queryL >= mid + 1) {\n                    return query(rightTreeIndex, mid + 1, r, queryL, queryR);\n                } else if (queryR <= mid) {\n                    return query(leftTreeIndex, l, mid, queryL, queryR);\n                }\n\n                E leftResult = query(leftTreeIndex, l, mid, queryL, mid);\n                E rightResult = query(rightTreeIndex, mid + 1, r, mid + 1, queryR);\n                return merger.merge(leftResult, rightResult);\n            }\n\n            /**\n             *  将indexä½ç½®的值，更新为e\n             * @param index\n             * @param e\n             */\n            public void set(int index,E e){\n                if (index < 0 || index >= data.length){\n                    throw new IllegalArgumentException("Index is illegal");\n                }\n                data[index]=e;\n                set(0,0,data.length-1,index,e);\n            }\n\n            /**\n             * 在以treeIndex为根的线段树中æ´æ°index的值ä¸ºe\n             * @param treeIndex\n             * @param l\n             * @param r\n             * @param index\n             * @param e\n             */\n            private void set(int treeIndex,int l,int r,int index,E e){\n                if (l == r){\n                    tree[treeIndex]=e;\n                    return;\n                }\n                int mid=l+(r-l)/2;\n                int leftTreeIndex=leftChild(treeIndex);\n                int rightTreeIndex=rightChild(treeIndex);\n                if (index >= mid+1){\n                    set(rightTreeIndex,mid+1,r,index,e);\n                }else {\n                    set(leftTreeIndex,l,mid,index,e);\n                }\n                tree[treeIndex]=merger.merge(tree[leftTreeIndex],tree[rightTreeIndex]);\n            }\n\n            @Override\n            public String toString() {\n                StringBuilder res = new StringBuilder();\n                res.append(\'[\');\n                for (int i = 0; i < tree.length; i++) {\n                    if (tree[i] != null) {\n                        res.append(tree[i]);\n                    } else {\n                        res.append("null");\n                    }\n                    if (i != tree.length - 1) {\n                        res.append(", ");\n                    }\n                }\n                res.append(\']\');\n                return res.toString();\n            }\n        }\n    \n        public NumArray(int[] nums) {\n            if (nums.length!=0){\n                Integer[] data=new Integer[nums.length];\n                for (int i = 0; i < nums.length; i++) {\n                    data[i]=nums[i];\n                }\n                segmentTree=new SegmentTree<>(data,(a,b)->a+b);\n            }\n        }\n\n        public void update(int i, int val) {\n            segmentTree.set(i,val);\n        }\n\n        public int sumRange(int i, int j) {\n            return segmentTree.query(i,j);\n        }\n    }\n\n/**\n * Your NumArray object will be instantiated and called as such:\n * NumArray obj = new NumArray(nums);\n * obj.update(i,val);\n * int param_2 = obj.sumRange(i,j);\n */\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n202\n203\n204\n205\n206\n207\n208\n209\n210\n211\n212\n213\n214\n215\n\n\nclass NumArray {\n\n        private SegmentTree<Integer> segmentTree;\n\n        private interface Merger<E> {\n            public E merge(E a, E b);\n        }\n\n        private class SegmentTree<E> {\n            private E[] tree;\n            private E[] data;\n            private Merger<E> merger;\n\n            public SegmentTree(E[] arr, Merger<E> merger) {\n                this.merger = merger;\n                data = (E[]) new Object[arr.length];\n                for (int i = 0; i < arr.length; i++) {\n                    data[i] = arr[i];\n                }\n                tree = (E[]) new Object[4 * arr.length];\n                buildSegmentTree(0, 0, arr.length - 1);\n            }\n\n            /**\n             * 构造线段树\n             *\n             * @param treeIndex\n             * @param l\n             * @param r\n             */\n            private void buildSegmentTree(int treeIndex, int l, int r) {\n                // 递归截止条件，最后只左右相等，将当前的元素赋给tree[treeIndex]\n                if (l == r) {\n                    tree[treeIndex] = data[l];\n                    return;\n                }\n\n                int leftTreeIndex = leftChild(treeIndex);\n                int rightTreeIndex = rightChild(treeIndex);\n\n                int mid = l + (r - l) / 2;\n                buildSegmentTree(leftTreeIndex, l, mid);\n                buildSegmentTree(rightTreeIndex, mid + 1, r);\n\n                tree[treeIndex] = merger.merge(tree[leftTreeIndex], tree[rightTreeIndex]);\n            }\n\n            /**\n             * 获得数组中的元素个数\n             *\n             * @return\n             */\n            public int getSize() {\n                return data.length;\n            }\n\n            /**\n             * 根据索引返回相应的数组中的值\n             *\n             * @param index 索引\n             * @return\n             */\n            public E get(int index) {\n                if (index < 0 || index >= data.length) {\n                    throw new IllegalArgumentException("Index is illegal");\n                }\n                return data[index];\n            }\n\n            /**\n             * 返回一棵完全二叉树的数组表示中，ä¸ä¸ª索引æè¡¨ç¤ºçåç´ çå·¦å­©å­èç¹ç索引\n             *\n             * @param index\n             * @return\n             */\n            public int leftChild(int index) {\n                return 2 * index + 1;\n            }\n\n            /**\n             * 返回一棵完全二叉树的数组表示中，ä¸ä¸ª索引æè¡¨ç¤ºçåç´ çå³å­©å­èç¹ç索引\n             *\n             * @param index\n             * @return\n             */\n            public int rightChild(int index) {\n                return 2 * index + 2;\n            }\n\n            /**\n             * 返回区间[queryL,queryR]的值\n             *\n             * @param queryL\n             * @param queryR\n             * @return\n             */\n            public E query(int queryL, int queryR) {\n                if (queryL < 0 || queryL >= data.length || queryR < 0 || queryR >= data.length || queryL > queryR) {\n                    throw new IllegalArgumentException("Index is illegal");\n                }\n                return query(0, 0, data.length - 1, queryL, queryR);\n            }\n\n            /**\n             * 在以treeIndex为根的线段树中[l...r]的范围里，搜索区间[query...queryR]的值\n             *\n             * @param treeIndex\n             * @param l\n             * @param r\n             * @param queryL\n             * @param queryR\n             * @return\n             */\n            private E query(int treeIndex, int l, int r, int queryL, int queryR) {\n                if (l == queryL && r == queryR) {\n                    return tree[treeIndex];\n                }\n                int mid = l + (r - l) / 2;\n        //        找到以treeIndexä¸ºæ ¹å·¦å³ä¸¤ä¸ªå­©å­ç索引\n                int leftTreeIndex = leftChild(treeIndex);\n                int rightTreeIndex = rightChild(treeIndex);\n\n                if (queryL >= mid + 1) {\n                    return query(rightTreeIndex, mid + 1, r, queryL, queryR);\n                } else if (queryR <= mid) {\n                    return query(leftTreeIndex, l, mid, queryL, queryR);\n                }\n\n                E leftResult = query(leftTreeIndex, l, mid, queryL, mid);\n                E rightResult = query(rightTreeIndex, mid + 1, r, mid + 1, queryR);\n                return merger.merge(leftResult, rightResult);\n            }\n\n            /**\n             *  将indexä½ç½®的值，更新为e\n             * @param index\n             * @param e\n             */\n            public void set(int index,E e){\n                if (index < 0 || index >= data.length){\n                    throw new IllegalArgumentException("Index is illegal");\n                }\n                data[index]=e;\n                set(0,0,data.length-1,index,e);\n            }\n\n            /**\n             * 在以treeIndex为根的线段树中æ´æ°index的值ä¸ºe\n             * @param treeIndex\n             * @param l\n             * @param r\n             * @param index\n             * @param e\n             */\n            private void set(int treeIndex,int l,int r,int index,E e){\n                if (l == r){\n                    tree[treeIndex]=e;\n                    return;\n                }\n                int mid=l+(r-l)/2;\n                int leftTreeIndex=leftChild(treeIndex);\n                int rightTreeIndex=rightChild(treeIndex);\n                if (index >= mid+1){\n                    set(rightTreeIndex,mid+1,r,index,e);\n                }else {\n                    set(leftTreeIndex,l,mid,index,e);\n                }\n                tree[treeIndex]=merger.merge(tree[leftTreeIndex],tree[rightTreeIndex]);\n            }\n\n            @Override\n            public String toString() {\n                StringBuilder res = new StringBuilder();\n                res.append(\'[\');\n                for (int i = 0; i < tree.length; i++) {\n                    if (tree[i] != null) {\n                        res.append(tree[i]);\n                    } else {\n                        res.append("null");\n                    }\n                    if (i != tree.length - 1) {\n                        res.append(", ");\n                    }\n                }\n                res.append(\']\');\n                return res.toString();\n            }\n        }\n    \n        public NumArray(int[] nums) {\n            if (nums.length!=0){\n                Integer[] data=new Integer[nums.length];\n                for (int i = 0; i < nums.length; i++) {\n                    data[i]=nums[i];\n                }\n                segmentTree=new SegmentTree<>(data,(a,b)->a+b);\n            }\n        }\n\n        public void update(int i, int val) {\n            segmentTree.set(i,val);\n        }\n\n        public int sumRange(int i, int j) {\n            return segmentTree.query(i,j);\n        }\n    }\n\n/**\n * Your NumArray object will be instantiated and called as such:\n * NumArray obj = new NumArray(nums);\n * obj.update(i,val);\n * int param_2 = obj.sumRange(i,j);\n */\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n202\n203\n204\n205\n206\n207\n208\n209\n210\n211\n212\n213\n214\n215\n# 官方题解\n# 摘要：\n本文面向中级读者。它引入了以下概念：区域和检索、sqrt 分解、线段树。\n\n# 解决方法：\n# 方法一：\n区域和检索的一个简单的解决方案 - RSQ(i, j) 是将数组从索引 iii 迭代到 jjj 并对每个元素求和。\n\nprivate int[] nums;\npublic int sumRange(int i, int j) {\n    int sum = 0;\n    for (int l = i; l <= j; l++) {\n        sum += data[l];\n    }\n    return sum;\n}\n\npublic int update(int i, int val) {\n    nums[i] = val;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n复杂度分析\n\n * 时间复杂度：O(n)O(n)O(n)。区域和检索 O(1)O(1)O(1) 的更新查询 对于区域和检索，我们从数组中访问每个元素的时间是固定的，在最坏的情况下，我们访问 nnn 元素。因此，时间复杂度为 O(n)O(n)O(n)。更新查询的时间复杂度为 O(1)O(1)O(1)。\n * 空间复杂度：O(1)O(1)O(1)\n\n# 方法二：sqrt 分解\n其思想是将数组分割成块，块的长度为 n\\sqrt nn​。然后我们计算每个块的和，并将其存储在辅助存储器 b 中。要查询 RSQ(i, j)，我们将添加位于内部的所有块和部分在范围 [i…j][i\\ldots j][i…j] 重叠的块的总和。\n\n算法：\n\n{:width="500"} {:align=center}\n\n在上面的示例中，数组 nums 的长度为 9，它被拆分为大小为 9\\sqrt 99​ 的块。为了得到 RSQ(1, 7)，我们添加 b[1]。它存储范围 [3，5] 的和，以及 块0 和 块2 的部分和，它们是重叠的边界块。\n\nprivate int[] b;\nprivate int len;\nprivate int[] nums;\n\npublic NumArray(int[] nums) {\n    this.nums = nums;\n    double l = Math.sqrt(nums.length);\n    len = (int) Math.ceil(nums.length/l);\n    b = new int [len];\n    for (int i = 0; i < nums.length; i++)\n        b[i / len] += nums[i];\n}\n\npublic int sumRange(int i, int j) {\n    int sum = 0;\n    int startBlock = i / len;\n    int endBlock = j / len;\n    if (startBlock == endBlock) {\n        for (int k = i; k <= j; k++)\n            sum += nums[k];\n    } else {\n        for (int k = i; k <= (startBlock + 1) * len - 1; k++)\n            sum += nums[k];\n        for (int k = startBlock + 1; k <= endBlock - 1; k++)\n            sum += b[k];\n        for (int k = endBlock * len; k <= j; k++)\n            sum += nums[k];\n    }\n    return sum;\n}\n\npublic void update(int i, int val) {\n    int b_l = i / len;\n    b[b_l] = b[b_l] - nums[i] + val;\n    nums[i] = val;\n}\n// Accepted\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n复杂度分析\n\n * 时间复杂度：O(n)O(n)O(n) 预处理，O(n)O(\\sqrt n)O(n​) 区域和检索，O(1)O(1)O(1) 更新查询\n * 空间复杂度：O(n)O(\\sqrt{n})O(n​)，我们需要额外的 n\\sqrt {n}n​ 内存来存储所有块和。\n\n# 方法三：线段树\n算法：线段树是一种非常灵活的数据结构，它可以用于解决多种范围查询问题，比如在对数时间内从数组中找到最小值、最大值、总和、最大公约数、最小公倍数等。\n\n{:width="350"} {:align=center}\n\n数组 A[0,1,…,n−1]A[0,1,\\ldots,n-1]A[0,1,…,n−1] 的线段树是一个二叉树，其中每个节点都包含数组的一个子范围 [i…j][i\\ldots j][i…j] 上的聚合信息（最小值、最大值、总和等），其左、右子节点分别包含范围 [i…i+j2][i \\ldots \\frac{i+j}{2}][i…2i+j​] 和 [i+j2+1,j][\\frac{i + j}{2} + 1, j][2i+j​+1,j] 上的信息。\n\n线段树既可以用数组也可以用树来实现。对于数组实现，如果索引 iii 处的元素不是一个叶节点，那么其左子节点和右子节点分别存储在索引为 2i2i2i 和 2i+12i+12i+1 的元素处。\n\n在上图所给出的示例中，每个叶节点都包含初始的数组元素 {2,4,5,7,8,9}。内部节点包含范围内相应元素的总和 - (11) 是从索引 0 到索引 2 的元素之和。而根节点 (35) 是它的两个子节点 (6) 和 (29) 的和,也是整个数组的和。\n\n线段树可以分为以下三个步骤：\n\n 1. 从给定数组构建线段树的预处理步骤。\n 2. 修改元素时更新线段树。\n 3. 使用线段树进行区域和检索。\n\n构建线段树 :我们将使用一种非常有效的自下而上的方法来构建线段树。从上面我们已经知道，如果某个节点 ppp 包含范围 [i…j][i\\ldots j][i…j] 的和，那么其左、右子节点分别包含范围 [i…i+j2][i \\ldots \\frac{i + j}{2}][i…2i+j​] 和 [i+j2+1,j][\\frac{i + j}{2} + 1, j][2i+j​+1,j] 上的和。\n\n因此，为了找到节点 ppp 的和，我们需要提前计算其左、右子节点的和。\n\n我们从叶节点开始，用输入数组的元素 a[0,1,…,n−1]a[0,1,\\ldots,n-1]a[0,1,…,n−1] 初始化它们。然后我们逐步向上移动到更高一层来计算父节点的和，直到最后到达线段树的根节点。\n\nint[] tree;\nint n;\npublic NumArray(int[] nums) {\n    if (nums.length > 0) {\n        n = nums.length;\n        tree = new int[n * 2];\n        buildTree(nums);\n    }\n}\nprivate void buildTree(int[] nums) {\n    for (int i = n, j = 0;  i < 2 * n; i++,  j++)\n        tree[i] = nums[j];\n    for (int i = n - 1; i > 0; --i)\n        tree[i] = tree[i * 2] + tree[i * 2 + 1];\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n复杂度分析\n\n * 时间复杂度：O(n)O(n)O(n)。\n\n 1. 因为我们在 for 循环的每次迭代中计算一个节点的和。而一个线段树中大约有 2n2n2n 个节点。\n 2. 这可以通过以下方式证明：具有 nnn 个元素的数组线段树有 nnn 个叶节点（数组元素本身）。每一层中的节点数是下面一层中节点数的一半。\n 3. 因此，如果我们按层对节点数求和，我们将得到：\n\nn+n/2+n/4+n/8+…+1≈2nn + n/2 + n/4 + n/8 + \\ldots + 1 \\approx 2nn+n/2+n/4+n/8+…+1≈2n\n\n * 空间复杂度：O(n)O(n)O(n)，我们用了 2n2n2n 的额外空间来存储整个线段树。\n\n更新线段树 :当我们更新数组中某个索引 iii 处的元素时，我们需要重建线段树，因为一些树节点上的和值也会随之产生变化。我们将再次使用自下而上的方法。首先更新存储 a[i]a[i]a[i] 元素的叶节点。从那里我们将一路向上，直到根节点，并用其子节点值的总和来更新每个父节点的值。\n\nvoid update(int pos, int val) {\n    pos += n;\n    tree[pos] = val;\n    while (pos > 0) {\n        int left = pos;\n        int right = pos;\n        if (pos % 2 == 0) {\n            right = pos + 1;\n        } else {\n            left = pos - 1;\n        }\n        // parent is updated after child is updated\n        tree[pos / 2] = tree[left] + tree[right];\n        pos /= 2;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n复杂度分析\n\n * 时间复杂度：O(log⁡n)O(\\log n)O(logn)。算法的时间复杂度为 O(log⁡n)O(\\log n)O(logn)，因为有几个树节点的范围包括第 iii 个数组元素，每个层上都有一个。共有 log⁡(n)\\log(n)log(n) 层。\n * 空间复杂度：O(1)O(1)O(1)。\n\n区域和检索：\n\n我们可以通过以下方式使用线段树进行区域和检索 [L,R][L, R][L,R]：算法保持循环不变：l≤rl \\le rl≤r 以及已经算出 [L…l][L \\ldots l][L…l] 和 [r…R][r \\ldots R][r…R] 的总和，其中 lll 和 rrr 分别是计算总和时的左边界和右边界。每次迭代的范围 [l,r][l,r][l,r] 都会缩小，直到在算法的大约 lognlog nlogn 次迭代后两个边界相遇为止。\n\npublic int sumRange(int l, int r) {\n    // get leaf with value \'l\'\n    l += n;\n    // get leaf with value \'r\'\n    r += n;\n    int sum = 0;\n    while (l <= r) {\n        if ((l % 2) == 1) {\n           sum += tree[l];\n           l++;\n        }\n        if ((r % 2) == 0) {\n           sum += tree[r];\n           r--;\n        }\n        l /= 2;\n        r /= 2;\n    }\n    return sum;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n复杂度分析\n\n * 时间复杂度：O(log⁡n)O(\\log n)O(logn)。因为在算法的每次迭代中，我们会向上移动一层，要么移动到当前节点的父节点，要么移动到父节点的左侧或者右侧的兄弟节点，直到两个边界相交为止。在最坏的情况下，这种情况会在算法进行 log⁡n\\log nlogn 次迭代后发生在根节点。\n * 空间复杂度：O(1)O(1)O(1)。\n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-08-02 22:46:34Accepted [https://leetcode-cn.com//submissions/detail/5021616/]134 ms48.69%N/Ajava2018-08-02 22:42:06Accepted [https://leetcode-cn.com//submissions/detail/5021363/]142 ms48.14%N/Ajava# 统计信息\n通过次数提交次数AC比率63371195753.0%# 相似题目\n题目难度区域和检索 - 数组不可变 [https://leetcode-cn.com/problems/range-sum-query-immutable/]简单二维区域和检索 - 可变 [https://leetcode-cn.com/problems/range-sum-query-2d-mutable/]困难',contentLowercase:'# 中文题目\n给定一个整数数组nums，求出数组从索引i到j(i≤j) 范围内元素的总和，包含i, j两点。\n\nupdate(i, val) 函数可以通过将下标为i的数值更新为val，从而对数列进行修改。\n\n示例:\n\ngiven nums = [1, 3, 5]\n\nsumrange(0, 2) -> 9\nupdate(1, 2)\nsumrange(0, 2) -> 8\n\n\n说明:\n\n 1. 数组仅可以在update函数下进行修改。\n 2. 你可以假设 update 函数与 sumrange 函数的调用次数是均匀分布的。\n\n# 通过代码\n\n\nclass numarray {\n\n        private segmenttree<integer> segmenttree;\n\n        private interface merger<e> {\n            public e merge(e a, e b);\n        }\n\n        private class segmenttree<e> {\n            private e[] tree;\n            private e[] data;\n            private merger<e> merger;\n\n            public segmenttree(e[] arr, merger<e> merger) {\n                this.merger = merger;\n                data = (e[]) new object[arr.length];\n                for (int i = 0; i < arr.length; i++) {\n                    data[i] = arr[i];\n                }\n                tree = (e[]) new object[4 * arr.length];\n                buildsegmenttree(0, 0, arr.length - 1);\n            }\n\n            /**\n             * 构造线段树\n             *\n             * @param treeindex\n             * @param l\n             * @param r\n             */\n            private void buildsegmenttree(int treeindex, int l, int r) {\n                // 递归截止条件，最后只左右相等，将当前的元素赋给tree[treeindex]\n                if (l == r) {\n                    tree[treeindex] = data[l];\n                    return;\n                }\n\n                int lefttreeindex = leftchild(treeindex);\n                int righttreeindex = rightchild(treeindex);\n\n                int mid = l + (r - l) / 2;\n                buildsegmenttree(lefttreeindex, l, mid);\n                buildsegmenttree(righttreeindex, mid + 1, r);\n\n                tree[treeindex] = merger.merge(tree[lefttreeindex], tree[righttreeindex]);\n            }\n\n            /**\n             * 获得数组中的元素个数\n             *\n             * @return\n             */\n            public int getsize() {\n                return data.length;\n            }\n\n            /**\n             * 根据索引返回相应的数组中的值\n             *\n             * @param index 索引\n             * @return\n             */\n            public e get(int index) {\n                if (index < 0 || index >= data.length) {\n                    throw new illegalargumentexception("index is illegal");\n                }\n                return data[index];\n            }\n\n            /**\n             * 返回一棵完全二叉树的数组表示中，ä¸ä¸ª索引æè¡¨ç¤ºçåç´ çå·¦å­©å­èç¹ç索引\n             *\n             * @param index\n             * @return\n             */\n            public int leftchild(int index) {\n                return 2 * index + 1;\n            }\n\n            /**\n             * 返回一棵完全二叉树的数组表示中，ä¸ä¸ª索引æè¡¨ç¤ºçåç´ çå³å­©å­èç¹ç索引\n             *\n             * @param index\n             * @return\n             */\n            public int rightchild(int index) {\n                return 2 * index + 2;\n            }\n\n            /**\n             * 返回区间[queryl,queryr]的值\n             *\n             * @param queryl\n             * @param queryr\n             * @return\n             */\n            public e query(int queryl, int queryr) {\n                if (queryl < 0 || queryl >= data.length || queryr < 0 || queryr >= data.length || queryl > queryr) {\n                    throw new illegalargumentexception("index is illegal");\n                }\n                return query(0, 0, data.length - 1, queryl, queryr);\n            }\n\n            /**\n             * 在以treeindex为根的线段树中[l...r]的范围里，搜索区间[query...queryr]的值\n             *\n             * @param treeindex\n             * @param l\n             * @param r\n             * @param queryl\n             * @param queryr\n             * @return\n             */\n            private e query(int treeindex, int l, int r, int queryl, int queryr) {\n                if (l == queryl && r == queryr) {\n                    return tree[treeindex];\n                }\n                int mid = l + (r - l) / 2;\n        //        找到以treeindexä¸ºæ ¹å·¦å³ä¸¤ä¸ªå­©å­ç索引\n                int lefttreeindex = leftchild(treeindex);\n                int righttreeindex = rightchild(treeindex);\n\n                if (queryl >= mid + 1) {\n                    return query(righttreeindex, mid + 1, r, queryl, queryr);\n                } else if (queryr <= mid) {\n                    return query(lefttreeindex, l, mid, queryl, queryr);\n                }\n\n                e leftresult = query(lefttreeindex, l, mid, queryl, mid);\n                e rightresult = query(righttreeindex, mid + 1, r, mid + 1, queryr);\n                return merger.merge(leftresult, rightresult);\n            }\n\n            /**\n             *  将indexä½ç½®的值，更新为e\n             * @param index\n             * @param e\n             */\n            public void set(int index,e e){\n                if (index < 0 || index >= data.length){\n                    throw new illegalargumentexception("index is illegal");\n                }\n                data[index]=e;\n                set(0,0,data.length-1,index,e);\n            }\n\n            /**\n             * 在以treeindex为根的线段树中æ´æ°index的值ä¸ºe\n             * @param treeindex\n             * @param l\n             * @param r\n             * @param index\n             * @param e\n             */\n            private void set(int treeindex,int l,int r,int index,e e){\n                if (l == r){\n                    tree[treeindex]=e;\n                    return;\n                }\n                int mid=l+(r-l)/2;\n                int lefttreeindex=leftchild(treeindex);\n                int righttreeindex=rightchild(treeindex);\n                if (index >= mid+1){\n                    set(righttreeindex,mid+1,r,index,e);\n                }else {\n                    set(lefttreeindex,l,mid,index,e);\n                }\n                tree[treeindex]=merger.merge(tree[lefttreeindex],tree[righttreeindex]);\n            }\n\n            @override\n            public string tostring() {\n                stringbuilder res = new stringbuilder();\n                res.append(\'[\');\n                for (int i = 0; i < tree.length; i++) {\n                    if (tree[i] != null) {\n                        res.append(tree[i]);\n                    } else {\n                        res.append("null");\n                    }\n                    if (i != tree.length - 1) {\n                        res.append(", ");\n                    }\n                }\n                res.append(\']\');\n                return res.tostring();\n            }\n        }\n    \n        public numarray(int[] nums) {\n            if (nums.length!=0){\n                integer[] data=new integer[nums.length];\n                for (int i = 0; i < nums.length; i++) {\n                    data[i]=nums[i];\n                }\n                segmenttree=new segmenttree<>(data,(a,b)->a+b);\n            }\n        }\n\n        public void update(int i, int val) {\n            segmenttree.set(i,val);\n        }\n\n        public int sumrange(int i, int j) {\n            return segmenttree.query(i,j);\n        }\n    }\n\n/**\n * your numarray object will be instantiated and called as such:\n * numarray obj = new numarray(nums);\n * obj.update(i,val);\n * int param_2 = obj.sumrange(i,j);\n */\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n202\n203\n204\n205\n206\n207\n208\n209\n210\n211\n212\n213\n214\n215\n\n\nclass numarray {\n\n        private segmenttree<integer> segmenttree;\n\n        private interface merger<e> {\n            public e merge(e a, e b);\n        }\n\n        private class segmenttree<e> {\n            private e[] tree;\n            private e[] data;\n            private merger<e> merger;\n\n            public segmenttree(e[] arr, merger<e> merger) {\n                this.merger = merger;\n                data = (e[]) new object[arr.length];\n                for (int i = 0; i < arr.length; i++) {\n                    data[i] = arr[i];\n                }\n                tree = (e[]) new object[4 * arr.length];\n                buildsegmenttree(0, 0, arr.length - 1);\n            }\n\n            /**\n             * 构造线段树\n             *\n             * @param treeindex\n             * @param l\n             * @param r\n             */\n            private void buildsegmenttree(int treeindex, int l, int r) {\n                // 递归截止条件，最后只左右相等，将当前的元素赋给tree[treeindex]\n                if (l == r) {\n                    tree[treeindex] = data[l];\n                    return;\n                }\n\n                int lefttreeindex = leftchild(treeindex);\n                int righttreeindex = rightchild(treeindex);\n\n                int mid = l + (r - l) / 2;\n                buildsegmenttree(lefttreeindex, l, mid);\n                buildsegmenttree(righttreeindex, mid + 1, r);\n\n                tree[treeindex] = merger.merge(tree[lefttreeindex], tree[righttreeindex]);\n            }\n\n            /**\n             * 获得数组中的元素个数\n             *\n             * @return\n             */\n            public int getsize() {\n                return data.length;\n            }\n\n            /**\n             * 根据索引返回相应的数组中的值\n             *\n             * @param index 索引\n             * @return\n             */\n            public e get(int index) {\n                if (index < 0 || index >= data.length) {\n                    throw new illegalargumentexception("index is illegal");\n                }\n                return data[index];\n            }\n\n            /**\n             * 返回一棵完全二叉树的数组表示中，ä¸ä¸ª索引æè¡¨ç¤ºçåç´ çå·¦å­©å­èç¹ç索引\n             *\n             * @param index\n             * @return\n             */\n            public int leftchild(int index) {\n                return 2 * index + 1;\n            }\n\n            /**\n             * 返回一棵完全二叉树的数组表示中，ä¸ä¸ª索引æè¡¨ç¤ºçåç´ çå³å­©å­èç¹ç索引\n             *\n             * @param index\n             * @return\n             */\n            public int rightchild(int index) {\n                return 2 * index + 2;\n            }\n\n            /**\n             * 返回区间[queryl,queryr]的值\n             *\n             * @param queryl\n             * @param queryr\n             * @return\n             */\n            public e query(int queryl, int queryr) {\n                if (queryl < 0 || queryl >= data.length || queryr < 0 || queryr >= data.length || queryl > queryr) {\n                    throw new illegalargumentexception("index is illegal");\n                }\n                return query(0, 0, data.length - 1, queryl, queryr);\n            }\n\n            /**\n             * 在以treeindex为根的线段树中[l...r]的范围里，搜索区间[query...queryr]的值\n             *\n             * @param treeindex\n             * @param l\n             * @param r\n             * @param queryl\n             * @param queryr\n             * @return\n             */\n            private e query(int treeindex, int l, int r, int queryl, int queryr) {\n                if (l == queryl && r == queryr) {\n                    return tree[treeindex];\n                }\n                int mid = l + (r - l) / 2;\n        //        找到以treeindexä¸ºæ ¹å·¦å³ä¸¤ä¸ªå­©å­ç索引\n                int lefttreeindex = leftchild(treeindex);\n                int righttreeindex = rightchild(treeindex);\n\n                if (queryl >= mid + 1) {\n                    return query(righttreeindex, mid + 1, r, queryl, queryr);\n                } else if (queryr <= mid) {\n                    return query(lefttreeindex, l, mid, queryl, queryr);\n                }\n\n                e leftresult = query(lefttreeindex, l, mid, queryl, mid);\n                e rightresult = query(righttreeindex, mid + 1, r, mid + 1, queryr);\n                return merger.merge(leftresult, rightresult);\n            }\n\n            /**\n             *  将indexä½ç½®的值，更新为e\n             * @param index\n             * @param e\n             */\n            public void set(int index,e e){\n                if (index < 0 || index >= data.length){\n                    throw new illegalargumentexception("index is illegal");\n                }\n                data[index]=e;\n                set(0,0,data.length-1,index,e);\n            }\n\n            /**\n             * 在以treeindex为根的线段树中æ´æ°index的值ä¸ºe\n             * @param treeindex\n             * @param l\n             * @param r\n             * @param index\n             * @param e\n             */\n            private void set(int treeindex,int l,int r,int index,e e){\n                if (l == r){\n                    tree[treeindex]=e;\n                    return;\n                }\n                int mid=l+(r-l)/2;\n                int lefttreeindex=leftchild(treeindex);\n                int righttreeindex=rightchild(treeindex);\n                if (index >= mid+1){\n                    set(righttreeindex,mid+1,r,index,e);\n                }else {\n                    set(lefttreeindex,l,mid,index,e);\n                }\n                tree[treeindex]=merger.merge(tree[lefttreeindex],tree[righttreeindex]);\n            }\n\n            @override\n            public string tostring() {\n                stringbuilder res = new stringbuilder();\n                res.append(\'[\');\n                for (int i = 0; i < tree.length; i++) {\n                    if (tree[i] != null) {\n                        res.append(tree[i]);\n                    } else {\n                        res.append("null");\n                    }\n                    if (i != tree.length - 1) {\n                        res.append(", ");\n                    }\n                }\n                res.append(\']\');\n                return res.tostring();\n            }\n        }\n    \n        public numarray(int[] nums) {\n            if (nums.length!=0){\n                integer[] data=new integer[nums.length];\n                for (int i = 0; i < nums.length; i++) {\n                    data[i]=nums[i];\n                }\n                segmenttree=new segmenttree<>(data,(a,b)->a+b);\n            }\n        }\n\n        public void update(int i, int val) {\n            segmenttree.set(i,val);\n        }\n\n        public int sumrange(int i, int j) {\n            return segmenttree.query(i,j);\n        }\n    }\n\n/**\n * your numarray object will be instantiated and called as such:\n * numarray obj = new numarray(nums);\n * obj.update(i,val);\n * int param_2 = obj.sumrange(i,j);\n */\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n202\n203\n204\n205\n206\n207\n208\n209\n210\n211\n212\n213\n214\n215\n# 官方题解\n# 摘要：\n本文面向中级读者。它引入了以下概念：区域和检索、sqrt 分解、线段树。\n\n# 解决方法：\n# 方法一：\n区域和检索的一个简单的解决方案 - rsq(i, j) 是将数组从索引 iii 迭代到 jjj 并对每个元素求和。\n\nprivate int[] nums;\npublic int sumrange(int i, int j) {\n    int sum = 0;\n    for (int l = i; l <= j; l++) {\n        sum += data[l];\n    }\n    return sum;\n}\n\npublic int update(int i, int val) {\n    nums[i] = val;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n复杂度分析\n\n * 时间复杂度：o(n)o(n)o(n)。区域和检索 o(1)o(1)o(1) 的更新查询 对于区域和检索，我们从数组中访问每个元素的时间是固定的，在最坏的情况下，我们访问 nnn 元素。因此，时间复杂度为 o(n)o(n)o(n)。更新查询的时间复杂度为 o(1)o(1)o(1)。\n * 空间复杂度：o(1)o(1)o(1)\n\n# 方法二：sqrt 分解\n其思想是将数组分割成块，块的长度为 n\\sqrt nn​。然后我们计算每个块的和，并将其存储在辅助存储器 b 中。要查询 rsq(i, j)，我们将添加位于内部的所有块和部分在范围 [i…j][i\\ldots j][i…j] 重叠的块的总和。\n\n算法：\n\n{:width="500"} {:align=center}\n\n在上面的示例中，数组 nums 的长度为 9，它被拆分为大小为 9\\sqrt 99​ 的块。为了得到 rsq(1, 7)，我们添加 b[1]。它存储范围 [3，5] 的和，以及 块0 和 块2 的部分和，它们是重叠的边界块。\n\nprivate int[] b;\nprivate int len;\nprivate int[] nums;\n\npublic numarray(int[] nums) {\n    this.nums = nums;\n    double l = math.sqrt(nums.length);\n    len = (int) math.ceil(nums.length/l);\n    b = new int [len];\n    for (int i = 0; i < nums.length; i++)\n        b[i / len] += nums[i];\n}\n\npublic int sumrange(int i, int j) {\n    int sum = 0;\n    int startblock = i / len;\n    int endblock = j / len;\n    if (startblock == endblock) {\n        for (int k = i; k <= j; k++)\n            sum += nums[k];\n    } else {\n        for (int k = i; k <= (startblock + 1) * len - 1; k++)\n            sum += nums[k];\n        for (int k = startblock + 1; k <= endblock - 1; k++)\n            sum += b[k];\n        for (int k = endblock * len; k <= j; k++)\n            sum += nums[k];\n    }\n    return sum;\n}\n\npublic void update(int i, int val) {\n    int b_l = i / len;\n    b[b_l] = b[b_l] - nums[i] + val;\n    nums[i] = val;\n}\n// accepted\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n复杂度分析\n\n * 时间复杂度：o(n)o(n)o(n) 预处理，o(n)o(\\sqrt n)o(n​) 区域和检索，o(1)o(1)o(1) 更新查询\n * 空间复杂度：o(n)o(\\sqrt{n})o(n​)，我们需要额外的 n\\sqrt {n}n​ 内存来存储所有块和。\n\n# 方法三：线段树\n算法：线段树是一种非常灵活的数据结构，它可以用于解决多种范围查询问题，比如在对数时间内从数组中找到最小值、最大值、总和、最大公约数、最小公倍数等。\n\n{:width="350"} {:align=center}\n\n数组 a[0,1,…,n−1]a[0,1,\\ldots,n-1]a[0,1,…,n−1] 的线段树是一个二叉树，其中每个节点都包含数组的一个子范围 [i…j][i\\ldots j][i…j] 上的聚合信息（最小值、最大值、总和等），其左、右子节点分别包含范围 [i…i+j2][i \\ldots \\frac{i+j}{2}][i…2i+j​] 和 [i+j2+1,j][\\frac{i + j}{2} + 1, j][2i+j​+1,j] 上的信息。\n\n线段树既可以用数组也可以用树来实现。对于数组实现，如果索引 iii 处的元素不是一个叶节点，那么其左子节点和右子节点分别存储在索引为 2i2i2i 和 2i+12i+12i+1 的元素处。\n\n在上图所给出的示例中，每个叶节点都包含初始的数组元素 {2,4,5,7,8,9}。内部节点包含范围内相应元素的总和 - (11) 是从索引 0 到索引 2 的元素之和。而根节点 (35) 是它的两个子节点 (6) 和 (29) 的和,也是整个数组的和。\n\n线段树可以分为以下三个步骤：\n\n 1. 从给定数组构建线段树的预处理步骤。\n 2. 修改元素时更新线段树。\n 3. 使用线段树进行区域和检索。\n\n构建线段树 :我们将使用一种非常有效的自下而上的方法来构建线段树。从上面我们已经知道，如果某个节点 ppp 包含范围 [i…j][i\\ldots j][i…j] 的和，那么其左、右子节点分别包含范围 [i…i+j2][i \\ldots \\frac{i + j}{2}][i…2i+j​] 和 [i+j2+1,j][\\frac{i + j}{2} + 1, j][2i+j​+1,j] 上的和。\n\n因此，为了找到节点 ppp 的和，我们需要提前计算其左、右子节点的和。\n\n我们从叶节点开始，用输入数组的元素 a[0,1,…,n−1]a[0,1,\\ldots,n-1]a[0,1,…,n−1] 初始化它们。然后我们逐步向上移动到更高一层来计算父节点的和，直到最后到达线段树的根节点。\n\nint[] tree;\nint n;\npublic numarray(int[] nums) {\n    if (nums.length > 0) {\n        n = nums.length;\n        tree = new int[n * 2];\n        buildtree(nums);\n    }\n}\nprivate void buildtree(int[] nums) {\n    for (int i = n, j = 0;  i < 2 * n; i++,  j++)\n        tree[i] = nums[j];\n    for (int i = n - 1; i > 0; --i)\n        tree[i] = tree[i * 2] + tree[i * 2 + 1];\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n复杂度分析\n\n * 时间复杂度：o(n)o(n)o(n)。\n\n 1. 因为我们在 for 循环的每次迭代中计算一个节点的和。而一个线段树中大约有 2n2n2n 个节点。\n 2. 这可以通过以下方式证明：具有 nnn 个元素的数组线段树有 nnn 个叶节点（数组元素本身）。每一层中的节点数是下面一层中节点数的一半。\n 3. 因此，如果我们按层对节点数求和，我们将得到：\n\nn+n/2+n/4+n/8+…+1≈2nn + n/2 + n/4 + n/8 + \\ldots + 1 \\approx 2nn+n/2+n/4+n/8+…+1≈2n\n\n * 空间复杂度：o(n)o(n)o(n)，我们用了 2n2n2n 的额外空间来存储整个线段树。\n\n更新线段树 :当我们更新数组中某个索引 iii 处的元素时，我们需要重建线段树，因为一些树节点上的和值也会随之产生变化。我们将再次使用自下而上的方法。首先更新存储 a[i]a[i]a[i] 元素的叶节点。从那里我们将一路向上，直到根节点，并用其子节点值的总和来更新每个父节点的值。\n\nvoid update(int pos, int val) {\n    pos += n;\n    tree[pos] = val;\n    while (pos > 0) {\n        int left = pos;\n        int right = pos;\n        if (pos % 2 == 0) {\n            right = pos + 1;\n        } else {\n            left = pos - 1;\n        }\n        // parent is updated after child is updated\n        tree[pos / 2] = tree[left] + tree[right];\n        pos /= 2;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n复杂度分析\n\n * 时间复杂度：o(log⁡n)o(\\log n)o(logn)。算法的时间复杂度为 o(log⁡n)o(\\log n)o(logn)，因为有几个树节点的范围包括第 iii 个数组元素，每个层上都有一个。共有 log⁡(n)\\log(n)log(n) 层。\n * 空间复杂度：o(1)o(1)o(1)。\n\n区域和检索：\n\n我们可以通过以下方式使用线段树进行区域和检索 [l,r][l, r][l,r]：算法保持循环不变：l≤rl \\le rl≤r 以及已经算出 [l…l][l \\ldots l][l…l] 和 [r…r][r \\ldots r][r…r] 的总和，其中 lll 和 rrr 分别是计算总和时的左边界和右边界。每次迭代的范围 [l,r][l,r][l,r] 都会缩小，直到在算法的大约 lognlog nlogn 次迭代后两个边界相遇为止。\n\npublic int sumrange(int l, int r) {\n    // get leaf with value \'l\'\n    l += n;\n    // get leaf with value \'r\'\n    r += n;\n    int sum = 0;\n    while (l <= r) {\n        if ((l % 2) == 1) {\n           sum += tree[l];\n           l++;\n        }\n        if ((r % 2) == 0) {\n           sum += tree[r];\n           r--;\n        }\n        l /= 2;\n        r /= 2;\n    }\n    return sum;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n复杂度分析\n\n * 时间复杂度：o(log⁡n)o(\\log n)o(logn)。因为在算法的每次迭代中，我们会向上移动一层，要么移动到当前节点的父节点，要么移动到父节点的左侧或者右侧的兄弟节点，直到两个边界相交为止。在最坏的情况下，这种情况会在算法进行 log⁡n\\log nlogn 次迭代后发生在根节点。\n * 空间复杂度：o(1)o(1)o(1)。\n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-08-02 22:46:34accepted [https://leetcode-cn.com//submissions/detail/5021616/]134 ms48.69%n/ajava2018-08-02 22:42:06accepted [https://leetcode-cn.com//submissions/detail/5021363/]142 ms48.14%n/ajava# 统计信息\n通过次数提交次数ac比率63371195753.0%# 相似题目\n题目难度区域和检索 - 数组不可变 [https://leetcode-cn.com/problems/range-sum-query-immutable/]简单二维区域和检索 - 可变 [https://leetcode-cn.com/problems/range-sum-query-2d-mutable/]困难'},{title:"279-完全平方数(Perfect Squares)",frontmatter:{title:"279-完全平方数(Perfect Squares)",date:"2018-09-14T00:00:00.000Z",categories:["中等"],tags:["广度优先搜索<Breadth-first Search>","数学<Math>","动态规划<Dynamic Programming>"]},regularPath:"/views/%E4%B8%AD%E7%AD%89/0279-%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0.html",relativePath:"views/中等/0279-完全平方数.md",key:"v-39824ad2",path:"/views/%E4%B8%AD%E7%AD%89/0279-%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0.html",headers:[{level:2,title:"中文题目",slug:"中文题目",charIndex:2},{level:2,title:"通过代码",slug:"通过代码",charIndex:165},{level:2,title:"高赞题解",slug:"高赞题解",charIndex:11438},{level:2,title:"解题方案",slug:"解题方案",charIndex:11445},{level:3,title:"思路：",slug:"思路：",charIndex:11452},{level:3,title:"代码：",slug:"代码：",charIndex:11680},{level:3,title:"画解：",slug:"画解：",charIndex:12462},{level:2,title:"提交历史",slug:"提交历史",charIndex:12484},{level:2,title:"统计信息",slug:"统计信息",charIndex:13513},{level:2,title:"相似题目",slug:"相似题目",charIndex:13547}],lastUpdated:"4/11/2021, 1:15:21 PM",headersStr:"中文题目 通过代码 高赞题解 解题方案 思路： 代码： 画解： 提交历史 统计信息 相似题目",content:"# 中文题目\n给定正整数n，找到若干个完全平方数（比如1, 4, 9, 16, ...）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。\n\n示例 1:\n\n输入: n = 12\n输出: 3 \n解释: 12 = 4 + 4 + 4.\n\n示例 2:\n\n输入: n = 13\n输出: 2\n解释: 13 = 4 + 9.\n\n# 通过代码\nimport java.util.LinkedList;\nimport java.util.Queue;\n\nclass Solution {\n//    public  int numSquares(int n) {\n//             //利用队列进行广度优先遍历\n//             Queue<LinkedList<Integer>> queue=new LinkedList<>();\n// //            设置数组避免对重复的再次遍历\n//             boolean[] arr=new boolean[n+1];\n//             LinkedList<Integer> list=new LinkedList<>();\n//             arr[n]=true;\n//             list.add(n);\n//             list.add(0);\n//             queue.add(list);\n//             while (!queue.isEmpty()){\n//                 int num=queue.peek().get(0);\n//                 int step=queue.peek().get(1);\n//                 queue.poll();\n// //                if (num==0){\n// //                    return step;\n// //                }\n//                 for (int i = 1;  ; i++) {\n//                     int a=num-i*i;\n//                     if (a<0)\n//                         break;\n//                     if (a==0) //当a=0的时候表示找到了一条路径\n//                         return step+1;\n//                    if (!arr[a]){\n//                        LinkedList<Integer> list1=new LinkedList<>();\n//                        list1.add(a);\n//                        list1.add(step+1);\n//                        arr[a]=true;\n//                        queue.add(list1);\n//                    }\n//                 }\n//             }\n//             return 0;\n//         }\n    \n    //=========动态规划\n    // public  int numSquares(int n){\n    //         if (n<=0){\n    //             return 0;\n    //         }\n    //         int[] memo=new int[n+1];\n    //         Arrays.fill(memo,Integer.MAX_VALUE);\n    //         memo[0]=0;\n    //         for (int i = 1; i <= n; i++) {\n    //             for (int j = 1; j*j <=i ; j++) {\n    //                 memo[i]=Math.min(memo[i],memo[i-j*j]+1);\n    //             }\n    //         }\n    //         return memo[n];\n    //     }\n    \n    //==== 记忆化搜索\n        private  int memo[];\n        public  int numSquaresHelp(int n){\n            if (n==0){\n                return 0;\n            }\n            if (memo[n]!=-1){\n                return memo[n];\n            }\n            int res=Integer.MAX_VALUE;\n            for (int i = 1; i*i <= n; i++) {\n                res=Math.min(res,numSquaresHelp(n-i*i)+1);\n            }\n            memo[n]=res;\n            return res;\n        }\n\n        public  int numSquares(int n){\n            memo=new int[n+1];\n            Arrays.fill(memo,-1);\n            return numSquaresHelp(n);\n        }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\nimport java.util.LinkedList;\nimport java.util.Queue;\n\nclass Solution {\n//    public  int numSquares(int n) {\n//             //利用队列进行广度优先遍历\n//             Queue<LinkedList<Integer>> queue=new LinkedList<>();\n// //            设置数组避免对重复的再次遍历\n//             boolean[] arr=new boolean[n+1];\n//             LinkedList<Integer> list=new LinkedList<>();\n//             arr[n]=true;\n//             list.add(n);\n//             list.add(0);\n//             queue.add(list);\n//             while (!queue.isEmpty()){\n//                 int num=queue.peek().get(0);\n//                 int step=queue.peek().get(1);\n//                 queue.poll();\n// //                if (num==0){\n// //                    return step;\n// //                }\n//                 for (int i = 1;  ; i++) {\n//                     int a=num-i*i;\n//                     if (a<0)\n//                         break;\n//                     if (a==0) //当a=0的时候表示找到了一条路径\n//                         return step+1;\n//                    if (!arr[a]){\n//                        LinkedList<Integer> list1=new LinkedList<>();\n//                        list1.add(a);\n//                        list1.add(step+1);\n//                        arr[a]=true;\n//                        queue.add(list1);\n//                    }\n//                 }\n//             }\n//             return 0;\n//         }\n    \n    //=========动态规划\n    // public  int numSquares(int n){\n    //         if (n<=0){\n    //             return 0;\n    //         }\n    //         int[] memo=new int[n+1];\n    //         Arrays.fill(memo,Integer.MAX_VALUE);\n    //         memo[0]=0;\n    //         for (int i = 1; i <= n; i++) {\n    //             for (int j = 1; j*j <=i ; j++) {\n    //                 memo[i]=Math.min(memo[i],memo[i-j*j]+1);\n    //             }\n    //         }\n    //         return memo[n];\n    //     }\n    \n        private  int memo[];\n        public  int numSquaresHelp(int n){\n            if (n==0){\n                return 0;\n            }\n            if (memo[n]!=-1){\n                return memo[n];\n            }\n            int res=Integer.MAX_VALUE;\n            for (int i = 1; i*i <= n; i++) {\n                res=Math.min(res,numSquaresHelp(n-i*i)+1);\n            }\n            memo[n]=res;\n            return res;\n        }\n\n        public  int numSquares(int n){\n            memo=new int[n+1];\n            Arrays.fill(memo,-1);\n            return numSquaresHelp(n);\n        }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\nimport java.util.LinkedList;\nimport java.util.Queue;\n\nclass Solution {\n//         public  int numSquares(int n) {\n//             //利用队列进行广度优先遍历\n//             Queue<LinkedList<Integer>> queue=new LinkedList<>();\n// //            设置数组避免对重复的再次遍历\n//             boolean[] arr=new boolean[n+1];\n//             LinkedList<Integer> list=new LinkedList<>();\n//             arr[n]=true;\n//             list.add(n);\n//             list.add(0);\n//             queue.add(list);\n//             while (!queue.isEmpty()){\n//                 int num=queue.peek().get(0);\n//                 int step=queue.peek().get(1);\n//                 queue.poll();\n// //                if (num==0){\n// //                    return step;\n// //                }\n//                 for (int i = 1;  ; i++) {\n//                     int a=num-i*i;\n//                     if (a<0)\n//                         break;\n//                     if (a==0) //当a=0的时候表示找到了一条路径\n//                         return step+1;\n//                    if (!arr[a]){\n//                        LinkedList<Integer> list1=new LinkedList<>();\n//                        list1.add(a);\n//                        list1.add(step+1);\n//                        arr[a]=true;\n//                        queue.add(list1);\n//                    }\n//                 }\n//             }\n//             return 0;\n//         }\n    \n    //=========动态规划\n    public  int numSquares(int n){\n            if (n<=0){\n                return 0;\n            }\n            int[] memo=new int[n+1];\n            Arrays.fill(memo,Integer.MAX_VALUE);\n            memo[0]=0;\n            for (int i = 1; i <= n; i++) {\n                for (int j = 1; j*j <=i ; j++) {\n                    memo[i]=Math.min(memo[i],memo[i-j*j]+1);\n                }\n            }\n            return memo[n];\n        }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\nimport java.util.LinkedList;\nimport java.util.Queue;\n\nclass Solution {\n        public  int numSquares(int n) {\n            //利用队列进行广度优先遍历\n            Queue<LinkedList<Integer>> queue=new LinkedList<>();\n//            设置数组避免对重复的再次遍历\n            boolean[] arr=new boolean[n+1];\n            LinkedList<Integer> list=new LinkedList<>();\n            arr[n]=true;\n            list.add(n);\n            list.add(0);\n            queue.add(list);\n            while (!queue.isEmpty()){\n                int num=queue.peek().get(0);\n                int step=queue.peek().get(1);\n                queue.poll();\n//                if (num==0){\n//                    return step;\n//                }\n                for (int i = 1;  ; i++) {\n                    int a=num-i*i;\n                    if (a<0)\n                        break;\n                    if (a==0) //当a=0的时候表示找到了一条路径\n                        return step+1;\n                   if (!arr[a]){\n                       LinkedList<Integer> list1=new LinkedList<>();\n                       list1.add(a);\n                       list1.add(step+1);\n                       arr[a]=true;\n                       queue.add(list1);\n                   }\n                }\n            }\n            return 0;\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\nimport java.util.LinkedList;\nimport java.util.Queue;\nclass Solution {\n    public int numSquares(int n) {\n         //利用队列进行广度优先遍历\n            Queue<LinkedList<Integer>> queue=new LinkedList<>();\n//            设置数组避免对重复的再次遍历\n            boolean[] arr=new boolean[n+1];\n            LinkedList<Integer> list=new LinkedList<>();\n            arr[n]=true;\n            list.add(n);\n            list.add(0);\n            queue.add(list);\n            while (!queue.isEmpty()){\n                int num=queue.peek().get(0);\n                int step=queue.peek().get(1);\n                queue.poll();\n//                if (num==0){\n//                    return step;\n//                }\n                for (int i = 1;  ; i++) {\n                    int a=num-i*i;\n                    if (a<0)\n                        break;\n                    if (a==0) //当a=0的时候表示找到了一条路径\n                        return step+1;\n                   if (!arr[a]){\n                       LinkedList<Integer> list1=new LinkedList<>();\n                       list1.add(a);\n                       list1.add(step+1);\n                       arr[a]=true;\n                       queue.add(list1);\n                   }\n                }\n            }\n            return 0;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\nimport java.util.LinkedList;\nimport java.util.Queue;\nclass Solution {\n    public int numSquares(int n) {\n         Queue<LinkedList<Integer>> queue=new LinkedList<>();\n            boolean[] arr=new boolean[n+1];\n            LinkedList<Integer> list=new LinkedList<>();\n            arr[n]=true;\n            list.add(n);\n            list.add(0);\n            queue.add(list);\n            while (!queue.isEmpty()){\n                int num=queue.peek().get(0);\n                int step=queue.peek().get(1);\n                queue.poll();\n//                if (num==0){\n//                    return step;\n//                }\n                for (int i = 1;  ; i++) {\n                    int a=num-i*i;\n                    if (a<0)\n                        break;\n                    if (a==0)\n                        return step+1;\n                   if (!arr[a]){\n                       LinkedList<Integer> list1=new LinkedList<>();\n                       list1.add(a);\n                       list1.add(step+1);\n                       arr[a]=true;\n                       queue.add(list1);\n                   }\n                }\n            }\n            return 0;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n# 高赞题解\n# 解题方案\n# 思路：\n * 标签：动态规划\n * 首先初始化长度为n+1的数组dp，每个位置都为0\n * 如果n为0，则结果为0\n * 对数组进行遍历，下标为i，每次都将当前数字先更新为最大的结果，即dp[i]=i，比如i=4，最坏结果为4=1+1+1+1即为4个数字\n * 动态转移方程为：dp[i] = MIN(dp[i], dp[i - j * j] + 1)，i表示当前数字，j*j表示平方数\n * 时间复杂度：O(n*sqrt(n))，sqrt为平方根\n\n# 代码：\nclass Solution {\n    public int numSquares(int n) {\n        int[] dp = new int[n + 1]; // 默认初始化值都为0\n        for (int i = 1; i <= n; i++) {\n            dp[i] = i; // 最坏的情况就是每次+1\n            for (int j = 1; i - j * j >= 0; j++) { \n                dp[i] = Math.min(dp[i], dp[i - j * j] + 1); // 动态转移方程\n            }\n        }\n        return dp[n];\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n/**\n * @param {number} n\n * @return {number}\n */\nvar numSquares = function(n) {\n    const dp = [...Array(n+1)].map(_=>0); // 数组长度为n+1，值均为0\n    for (let i = 1; i <= n; i++) {\n        dp[i] = i; // 最坏的情况就是每次+1\n        for (let j = 1; i - j * j >= 0; j++) { \n            dp[i] = Math.min(dp[i], dp[i - j * j] + 1); // 动态转移方程\n        }\n    }\n    return dp[n];\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n# 画解：\n<,,,,,,,,,,,,>\n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-09-14 22:43:04Accepted [https://leetcode-cn.com//submissions/detail/7110219/]56 ms24.14%N/Ajava2018-09-14 22:42:49Accepted [https://leetcode-cn.com//submissions/detail/7110202/]56 ms24.14%N/Ajava2018-09-14 22:41:02Compile Error [https://leetcode-cn.com//submissions/detail/7110148/]N/AN/AN/Ajava2018-09-14 22:39:14Compile Error [https://leetcode-cn.com//submissions/detail/7110106/]N/AN/AN/Ajava2018-09-14 22:37:31Compile Error [https://leetcode-cn.com//submissions/detail/7110050/]N/AN/AN/Ajava2018-09-14 22:36:41Accepted [https://leetcode-cn.com//submissions/detail/7110034/]37 ms68.36%N/Ajava2018-09-14 22:36:30Compile Error [https://leetcode-cn.com//submissions/detail/7110028/]N/AN/AN/Ajava2018-07-17 08:37:23Accepted [https://leetcode-cn.com//submissions/detail/4263457/]34 ms70.85%N/Ajava2018-07-16 22:57:38Accepted [https://leetcode-cn.com//submissions/detail/4259050/]50 ms29.34%N/Ajava2018-07-16 22:18:29Accepted [https://leetcode-cn.com//submissions/detail/4256977/]50 ms29.34%N/Ajava# 统计信息\n通过次数提交次数AC比率322986129452.7%# 相似题目\n题目难度计数质数 [https://leetcode-cn.com/problems/count-primes/]简单丑数 II [https://leetcode-cn.com/problems/ugly-number-ii/]中等",contentLowercase:"# 中文题目\n给定正整数n，找到若干个完全平方数（比如1, 4, 9, 16, ...）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。\n\n示例 1:\n\n输入: n = 12\n输出: 3 \n解释: 12 = 4 + 4 + 4.\n\n示例 2:\n\n输入: n = 13\n输出: 2\n解释: 13 = 4 + 9.\n\n# 通过代码\nimport java.util.linkedlist;\nimport java.util.queue;\n\nclass solution {\n//    public  int numsquares(int n) {\n//             //利用队列进行广度优先遍历\n//             queue<linkedlist<integer>> queue=new linkedlist<>();\n// //            设置数组避免对重复的再次遍历\n//             boolean[] arr=new boolean[n+1];\n//             linkedlist<integer> list=new linkedlist<>();\n//             arr[n]=true;\n//             list.add(n);\n//             list.add(0);\n//             queue.add(list);\n//             while (!queue.isempty()){\n//                 int num=queue.peek().get(0);\n//                 int step=queue.peek().get(1);\n//                 queue.poll();\n// //                if (num==0){\n// //                    return step;\n// //                }\n//                 for (int i = 1;  ; i++) {\n//                     int a=num-i*i;\n//                     if (a<0)\n//                         break;\n//                     if (a==0) //当a=0的时候表示找到了一条路径\n//                         return step+1;\n//                    if (!arr[a]){\n//                        linkedlist<integer> list1=new linkedlist<>();\n//                        list1.add(a);\n//                        list1.add(step+1);\n//                        arr[a]=true;\n//                        queue.add(list1);\n//                    }\n//                 }\n//             }\n//             return 0;\n//         }\n    \n    //=========动态规划\n    // public  int numsquares(int n){\n    //         if (n<=0){\n    //             return 0;\n    //         }\n    //         int[] memo=new int[n+1];\n    //         arrays.fill(memo,integer.max_value);\n    //         memo[0]=0;\n    //         for (int i = 1; i <= n; i++) {\n    //             for (int j = 1; j*j <=i ; j++) {\n    //                 memo[i]=math.min(memo[i],memo[i-j*j]+1);\n    //             }\n    //         }\n    //         return memo[n];\n    //     }\n    \n    //==== 记忆化搜索\n        private  int memo[];\n        public  int numsquareshelp(int n){\n            if (n==0){\n                return 0;\n            }\n            if (memo[n]!=-1){\n                return memo[n];\n            }\n            int res=integer.max_value;\n            for (int i = 1; i*i <= n; i++) {\n                res=math.min(res,numsquareshelp(n-i*i)+1);\n            }\n            memo[n]=res;\n            return res;\n        }\n\n        public  int numsquares(int n){\n            memo=new int[n+1];\n            arrays.fill(memo,-1);\n            return numsquareshelp(n);\n        }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\nimport java.util.linkedlist;\nimport java.util.queue;\n\nclass solution {\n//    public  int numsquares(int n) {\n//             //利用队列进行广度优先遍历\n//             queue<linkedlist<integer>> queue=new linkedlist<>();\n// //            设置数组避免对重复的再次遍历\n//             boolean[] arr=new boolean[n+1];\n//             linkedlist<integer> list=new linkedlist<>();\n//             arr[n]=true;\n//             list.add(n);\n//             list.add(0);\n//             queue.add(list);\n//             while (!queue.isempty()){\n//                 int num=queue.peek().get(0);\n//                 int step=queue.peek().get(1);\n//                 queue.poll();\n// //                if (num==0){\n// //                    return step;\n// //                }\n//                 for (int i = 1;  ; i++) {\n//                     int a=num-i*i;\n//                     if (a<0)\n//                         break;\n//                     if (a==0) //当a=0的时候表示找到了一条路径\n//                         return step+1;\n//                    if (!arr[a]){\n//                        linkedlist<integer> list1=new linkedlist<>();\n//                        list1.add(a);\n//                        list1.add(step+1);\n//                        arr[a]=true;\n//                        queue.add(list1);\n//                    }\n//                 }\n//             }\n//             return 0;\n//         }\n    \n    //=========动态规划\n    // public  int numsquares(int n){\n    //         if (n<=0){\n    //             return 0;\n    //         }\n    //         int[] memo=new int[n+1];\n    //         arrays.fill(memo,integer.max_value);\n    //         memo[0]=0;\n    //         for (int i = 1; i <= n; i++) {\n    //             for (int j = 1; j*j <=i ; j++) {\n    //                 memo[i]=math.min(memo[i],memo[i-j*j]+1);\n    //             }\n    //         }\n    //         return memo[n];\n    //     }\n    \n        private  int memo[];\n        public  int numsquareshelp(int n){\n            if (n==0){\n                return 0;\n            }\n            if (memo[n]!=-1){\n                return memo[n];\n            }\n            int res=integer.max_value;\n            for (int i = 1; i*i <= n; i++) {\n                res=math.min(res,numsquareshelp(n-i*i)+1);\n            }\n            memo[n]=res;\n            return res;\n        }\n\n        public  int numsquares(int n){\n            memo=new int[n+1];\n            arrays.fill(memo,-1);\n            return numsquareshelp(n);\n        }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\nimport java.util.linkedlist;\nimport java.util.queue;\n\nclass solution {\n//         public  int numsquares(int n) {\n//             //利用队列进行广度优先遍历\n//             queue<linkedlist<integer>> queue=new linkedlist<>();\n// //            设置数组避免对重复的再次遍历\n//             boolean[] arr=new boolean[n+1];\n//             linkedlist<integer> list=new linkedlist<>();\n//             arr[n]=true;\n//             list.add(n);\n//             list.add(0);\n//             queue.add(list);\n//             while (!queue.isempty()){\n//                 int num=queue.peek().get(0);\n//                 int step=queue.peek().get(1);\n//                 queue.poll();\n// //                if (num==0){\n// //                    return step;\n// //                }\n//                 for (int i = 1;  ; i++) {\n//                     int a=num-i*i;\n//                     if (a<0)\n//                         break;\n//                     if (a==0) //当a=0的时候表示找到了一条路径\n//                         return step+1;\n//                    if (!arr[a]){\n//                        linkedlist<integer> list1=new linkedlist<>();\n//                        list1.add(a);\n//                        list1.add(step+1);\n//                        arr[a]=true;\n//                        queue.add(list1);\n//                    }\n//                 }\n//             }\n//             return 0;\n//         }\n    \n    //=========动态规划\n    public  int numsquares(int n){\n            if (n<=0){\n                return 0;\n            }\n            int[] memo=new int[n+1];\n            arrays.fill(memo,integer.max_value);\n            memo[0]=0;\n            for (int i = 1; i <= n; i++) {\n                for (int j = 1; j*j <=i ; j++) {\n                    memo[i]=math.min(memo[i],memo[i-j*j]+1);\n                }\n            }\n            return memo[n];\n        }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\nimport java.util.linkedlist;\nimport java.util.queue;\n\nclass solution {\n        public  int numsquares(int n) {\n            //利用队列进行广度优先遍历\n            queue<linkedlist<integer>> queue=new linkedlist<>();\n//            设置数组避免对重复的再次遍历\n            boolean[] arr=new boolean[n+1];\n            linkedlist<integer> list=new linkedlist<>();\n            arr[n]=true;\n            list.add(n);\n            list.add(0);\n            queue.add(list);\n            while (!queue.isempty()){\n                int num=queue.peek().get(0);\n                int step=queue.peek().get(1);\n                queue.poll();\n//                if (num==0){\n//                    return step;\n//                }\n                for (int i = 1;  ; i++) {\n                    int a=num-i*i;\n                    if (a<0)\n                        break;\n                    if (a==0) //当a=0的时候表示找到了一条路径\n                        return step+1;\n                   if (!arr[a]){\n                       linkedlist<integer> list1=new linkedlist<>();\n                       list1.add(a);\n                       list1.add(step+1);\n                       arr[a]=true;\n                       queue.add(list1);\n                   }\n                }\n            }\n            return 0;\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\nimport java.util.linkedlist;\nimport java.util.queue;\nclass solution {\n    public int numsquares(int n) {\n         //利用队列进行广度优先遍历\n            queue<linkedlist<integer>> queue=new linkedlist<>();\n//            设置数组避免对重复的再次遍历\n            boolean[] arr=new boolean[n+1];\n            linkedlist<integer> list=new linkedlist<>();\n            arr[n]=true;\n            list.add(n);\n            list.add(0);\n            queue.add(list);\n            while (!queue.isempty()){\n                int num=queue.peek().get(0);\n                int step=queue.peek().get(1);\n                queue.poll();\n//                if (num==0){\n//                    return step;\n//                }\n                for (int i = 1;  ; i++) {\n                    int a=num-i*i;\n                    if (a<0)\n                        break;\n                    if (a==0) //当a=0的时候表示找到了一条路径\n                        return step+1;\n                   if (!arr[a]){\n                       linkedlist<integer> list1=new linkedlist<>();\n                       list1.add(a);\n                       list1.add(step+1);\n                       arr[a]=true;\n                       queue.add(list1);\n                   }\n                }\n            }\n            return 0;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\nimport java.util.linkedlist;\nimport java.util.queue;\nclass solution {\n    public int numsquares(int n) {\n         queue<linkedlist<integer>> queue=new linkedlist<>();\n            boolean[] arr=new boolean[n+1];\n            linkedlist<integer> list=new linkedlist<>();\n            arr[n]=true;\n            list.add(n);\n            list.add(0);\n            queue.add(list);\n            while (!queue.isempty()){\n                int num=queue.peek().get(0);\n                int step=queue.peek().get(1);\n                queue.poll();\n//                if (num==0){\n//                    return step;\n//                }\n                for (int i = 1;  ; i++) {\n                    int a=num-i*i;\n                    if (a<0)\n                        break;\n                    if (a==0)\n                        return step+1;\n                   if (!arr[a]){\n                       linkedlist<integer> list1=new linkedlist<>();\n                       list1.add(a);\n                       list1.add(step+1);\n                       arr[a]=true;\n                       queue.add(list1);\n                   }\n                }\n            }\n            return 0;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n# 高赞题解\n# 解题方案\n# 思路：\n * 标签：动态规划\n * 首先初始化长度为n+1的数组dp，每个位置都为0\n * 如果n为0，则结果为0\n * 对数组进行遍历，下标为i，每次都将当前数字先更新为最大的结果，即dp[i]=i，比如i=4，最坏结果为4=1+1+1+1即为4个数字\n * 动态转移方程为：dp[i] = min(dp[i], dp[i - j * j] + 1)，i表示当前数字，j*j表示平方数\n * 时间复杂度：o(n*sqrt(n))，sqrt为平方根\n\n# 代码：\nclass solution {\n    public int numsquares(int n) {\n        int[] dp = new int[n + 1]; // 默认初始化值都为0\n        for (int i = 1; i <= n; i++) {\n            dp[i] = i; // 最坏的情况就是每次+1\n            for (int j = 1; i - j * j >= 0; j++) { \n                dp[i] = math.min(dp[i], dp[i - j * j] + 1); // 动态转移方程\n            }\n        }\n        return dp[n];\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n/**\n * @param {number} n\n * @return {number}\n */\nvar numsquares = function(n) {\n    const dp = [...array(n+1)].map(_=>0); // 数组长度为n+1，值均为0\n    for (let i = 1; i <= n; i++) {\n        dp[i] = i; // 最坏的情况就是每次+1\n        for (let j = 1; i - j * j >= 0; j++) { \n            dp[i] = math.min(dp[i], dp[i - j * j] + 1); // 动态转移方程\n        }\n    }\n    return dp[n];\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n# 画解：\n<,,,,,,,,,,,,>\n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-09-14 22:43:04accepted [https://leetcode-cn.com//submissions/detail/7110219/]56 ms24.14%n/ajava2018-09-14 22:42:49accepted [https://leetcode-cn.com//submissions/detail/7110202/]56 ms24.14%n/ajava2018-09-14 22:41:02compile error [https://leetcode-cn.com//submissions/detail/7110148/]n/an/an/ajava2018-09-14 22:39:14compile error [https://leetcode-cn.com//submissions/detail/7110106/]n/an/an/ajava2018-09-14 22:37:31compile error [https://leetcode-cn.com//submissions/detail/7110050/]n/an/an/ajava2018-09-14 22:36:41accepted [https://leetcode-cn.com//submissions/detail/7110034/]37 ms68.36%n/ajava2018-09-14 22:36:30compile error [https://leetcode-cn.com//submissions/detail/7110028/]n/an/an/ajava2018-07-17 08:37:23accepted [https://leetcode-cn.com//submissions/detail/4263457/]34 ms70.85%n/ajava2018-07-16 22:57:38accepted [https://leetcode-cn.com//submissions/detail/4259050/]50 ms29.34%n/ajava2018-07-16 22:18:29accepted [https://leetcode-cn.com//submissions/detail/4256977/]50 ms29.34%n/ajava# 统计信息\n通过次数提交次数ac比率322986129452.7%# 相似题目\n题目难度计数质数 [https://leetcode-cn.com/problems/count-primes/]简单丑数 ii [https://leetcode-cn.com/problems/ugly-number-ii/]中等"},{title:"240-搜索二维矩阵 II(Search a 2D Matrix II)",frontmatter:{title:"240-搜索二维矩阵 II(Search a 2D Matrix II)",date:"2021-04-08T00:00:00.000Z",categories:["中等"],tags:["二分查找<Binary Search>","分治算法<Divide and Conquer>"]},regularPath:"/views/%E4%B8%AD%E7%AD%89/0240-%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5%20II.html",relativePath:"views/中等/0240-搜索二维矩阵 II.md",key:"v-49ca1f81",path:"/views/%E4%B8%AD%E7%AD%89/0240-%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5%20II.html",headers:[{level:2,title:"中文题目",slug:"中文题目",charIndex:2},{level:2,title:"通过代码",slug:"通过代码",charIndex:460},{level:2,title:"官方题解",slug:"官方题解",charIndex:1038},{level:2,title:"提交历史",slug:"提交历史",charIndex:12569},{level:2,title:"统计信息",slug:"统计信息",charIndex:12907},{level:2,title:"相似题目",slug:"相似题目",charIndex:12943}],lastUpdated:"4/11/2021, 1:15:21 PM",headersStr:"中文题目 通过代码 官方题解 提交历史 统计信息 相似题目",content:'# 中文题目\n编写一个高效的算法来搜索mxn矩阵 matrix 中的一个目标值 target 。该矩阵具有以下特性：\n\n * 每行的元素从左到右升序排列。\n * 每列的元素从上到下升序排列。\n\n\n\n示例 1：\n\n\n输入：matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 5\n输出：true\n\n\n示例 2：\n\n\n输入：matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 20\n输出：false\n\n\n\n\n提示：\n\n * m == matrix.length\n * n == matrix[i].length\n * 1 \n * -1099\n * 每行的所有元素从左到右升序排列\n * 每列的所有元素从上到下升序排列\n * -1099\n\n# 通过代码\n    class Solution {\n        public boolean searchMatrix(int[][] matrix, int target) {\n            // 行数\n            int row = matrix.length;\n            if (row == 0) {\n                return false;\n            }\n            // 列数\n            int col = matrix[0].length;\n            for (int i = row - 1, j = 0; i >= 0 && j < col; ) {\n                if (matrix[i][j] > target) i--;\n                else if (matrix[i][j] < target) j++;\n                else return true;\n            }\n            return false;\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n# 官方题解\n# 方法一：暴力法\n对于每一行我们可以像搜索未排序的一维数组——通过检查每个元素来判断是否有目标值。\n\n算法：这个算法并没有做到聪明的事情。我们循环数组，依次检查每个元素。如果，我们找到了，我们返回 true。否则，对于搜索到末尾都没有返回的循环，我们返回 false。此算法在所有情况下都是正确的答案，因为我们耗尽了整个搜索空间。\n\nclass Solution {\n    public boolean searchMatrix(int[][] matrix, int target) {\n        for (int i = 0; i < matrix.length; i++) {\n            for (int j = 0; j < matrix[0].length; j++) {\n                if (matrix[i][j] == target) {\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\nclass Solution:\n    def searchMatrix(self, matrix, target):\n        for row in matrix:\n            if target in row:\n                return True\n        \n        return False\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n复杂度分析\n\n * 时间复杂度：O(mn)O(mn)O(mn)。因为我们在 n×mn\\times mn×m 矩阵上操作，总的时间复杂度为矩阵的大小\n * 空间复杂度：O(1)O(1)O(1)，暴力法分配的额外空间不超过少量指针，因此内存占用是恒定的。\n\n# 方法二：二分法搜索\n矩阵已经排过序，就需要使用二分法搜索以加快我们的算法。\n\n算法：首先，我们确保矩阵不为空。那么，如果我们迭代矩阵对角线，从当前元素对列和行搜索，我们可以保持从当前 (row,col)(row,col)(row,col) 对开始的行和列为已排序。 因此，我们总是可以二分搜索这些行和列切片。我们以如下逻辑的方式进行 : 在对角线上迭代，二分搜索行和列，直到对角线的迭代元素用完为止（意味着我们可以返回 false ）或者找到目标（意味着我们可以返回 true ）。binary search 函数的工作原理和普通的二分搜索一样,但需要同时搜索二维数组的行和列。\n\nclass Solution {\n    private boolean binarySearch(int[][] matrix, int target, int start, boolean vertical) {\n        int lo = start;\n        int hi = vertical ? matrix[0].length-1 : matrix.length-1;\n\n        while (hi >= lo) {\n            int mid = (lo + hi)/2;\n            if (vertical) { // searching a column\n                if (matrix[start][mid] < target) {\n                    lo = mid + 1;\n                } else if (matrix[start][mid] > target) {\n                    hi = mid - 1;\n                } else {\n                    return true;\n                }\n            } else { // searching a row\n                if (matrix[mid][start] < target) {\n                    lo = mid + 1;\n                } else if (matrix[mid][start] > target) {\n                    hi = mid - 1;\n                } else {\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }\n\n    public boolean searchMatrix(int[][] matrix, int target) {\n        // an empty matrix obviously does not contain `target`\n        if (matrix == null || matrix.length == 0) {\n            return false;\n        }\n\n        // iterate over matrix diagonals\n        int shorterDim = Math.min(matrix.length, matrix[0].length);\n        for (int i = 0; i < shorterDim; i++) {\n            boolean verticalFound = binarySearch(matrix, target, i, true);\n            boolean horizontalFound = binarySearch(matrix, target, i, false);\n            if (verticalFound || horizontalFound) {\n                return true;\n            }\n        }\n        \n        return false; \n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\nclass Solution:\n    def binary_search(self, matrix, target, start, vertical):\n        lo = start\n        hi = len(matrix[0])-1 if vertical else len(matrix)-1\n\n        while hi >= lo:\n            mid = (lo + hi)//2\n            if vertical: # searching a column\n                if matrix[start][mid] < target:\n                    lo = mid + 1\n                elif matrix[start][mid] > target:\n                    hi = mid - 1\n                else:\n                    return True\n            else: # searching a row\n                if matrix[mid][start] < target:\n                    lo = mid + 1\n                elif matrix[mid][start] > target:\n                    hi = mid - 1\n                else:\n                    return True\n        \n        return False\n\n    def searchMatrix(self, matrix, target):\n        # an empty matrix obviously does not contain `target`\n        if not matrix:\n            return False\n\n        # iterate over matrix diagonals starting in bottom left.\n        for i in range(min(len(matrix), len(matrix[0]))):\n            vertical_found = self.binary_search(matrix, target, i, True)\n            horizontal_found = self.binary_search(matrix, target, i, False)\n            if vertical_found or horizontal_found:\n                return True\n        \n        return False\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n复杂度分析\n\n * 时间复杂度：O(lg(n!))O(lg(n!))O(lg(n!))。 这个算法产生的时间复杂度并不是特别明显的是 O(lg(n!))O(lg(n!))O(lg(n!)) ，所以让我们一步一步地分析它。在主循环中执行的工作量逐渐最大，它运行 min(m,n)min(m,n)min(m,n) 次迭代，其中 mmm 表示行数，nnn 表示列数。在每次迭代中，我们对长度为 m−im-im−i 和 n−in-in−i 的数组片执行两次二分搜索。因此，循环的每一次迭代都以 O(lg(m−i)+lg(n−i))O(lg(m-i)+lg(n-i))O(lg(m−i)+lg(n−i)) 时间运行，其中 iii 表示当前迭代。我们可以将其简化为 O(2⋅lg(n−i))=O(lg(n−i))O(2 \\cdot lg(n-i))= O(lg(n-i))O(2⋅lg(n−i))=O(lg(n−i)) 在最坏的情况是 n≈mn\\approx mn≈m 。当 n≪mn \\ll mn≪m 时会发生什么（不损失一般性）；nnn 将在渐近分析中占主导地位。通过汇总所有迭代的运行时间，我们得到以下表达式：\n\nO(lg(n)+lg(n−1)+lg(n−2)+…+lg(1))\\quad {O}(lg(n) + lg(n-1) + lg(n-2) + \\ldots + lg(1))O(lg(n)+lg(n−1)+lg(n−2)+…+lg(1))\n\n然后，我们可以利用对数乘法规则（lg(a)+lg(b)=lg(ab)lg(a)+lg(b)=lg(ab)lg(a)+lg(b)=lg(ab)）将复杂度改写为：\n\nO(lg(n)+lg(n−1)+lg(n−2)+…+lg(1)){O}(lg(n) + lg(n-1) + lg(n-2) + \\ldots + lg(1))O(lg(n)+lg(n−1)+lg(n−2)+…+lg(1))\n=O(lg(n⋅(n−1)⋅(n−2)⋅…⋅1))={O}(lg(n \\cdot (n-1) \\cdot (n-2) \\cdot \\ldots \\cdot 1))=O(lg(n⋅(n−1)⋅(n−2)⋅…⋅1))\n=O(lg(1⋅…⋅(n−2)⋅(n−1)⋅n))= {O}(lg(1 \\cdot \\ldots \\cdot (n-2) \\cdot (n-1) \\cdot n))=O(lg(1⋅…⋅(n−2)⋅(n−1)⋅n))\n=O(lg(n!))= {O}(lg(n!))=O(lg(n!))\n\n * 空间复杂度：O(1)O(1)O(1)，因为我们的二分搜索实现并没有真正地切掉矩阵中的行和列的副本，我们可以避免分配大于常量内存。\n\n# 方法三：搜索空间的缩减\n我们可以将已排序的二维矩阵划分为四个子矩阵，其中两个可能包含目标，其中两个肯定不包含。\n\n算法：由于该算法是递归操作的，因此可以通过它的基本情况和递归情况的正确性来判断它的正确性。\n\n基本情况 ： 对于已排序的二维数组，有两种方法可以确定一个任意元素目标是否可以用常数时间判断。第一，如果数组的区域为零，则它不包含元素，因此不能包含目标。其次，如果目标小于数组的最小值或大于数组的最大值，那么矩阵肯定不包含目标值。\n\n递归情况： 如果目标值包含在数组内，因此我们沿着索引行的矩阵中间列 ，matrix[row−1][mid]<target<matrix[row][mid]matrix[row-1][mid] < target < matrix[row][mid]matrix[row−1][mid]<target<matrix[row][mid] ，（很明显，如果我们找到 target ，我们立即返回 true）。现有的矩阵可以围绕这个索引分为四个子矩阵；左上和右下子矩阵不能包含目标（通过基本情况部分来判断），所以我们可以从搜索空间中删除它们 。另外，左下角和右上角的子矩阵是二维矩阵，因此我们可以递归地将此算法应用于它们。\n\nclass Solution {\n    private int[][] matrix;\n    private int target;\n\n    private boolean searchRec(int left, int up, int right, int down) {\n        // this submatrix has no height or no width.\n        if (left > right || up > down) {\n            return false;\n        // `target` is already larger than the largest element or smaller\n        // than the smallest element in this submatrix.\n        } else if (target < matrix[up][left] || target > matrix[down][right]) {\n            return false;\n        }\n\n        int mid = left + (right-left)/2;\n\n        // Locate `row` such that matrix[row-1][mid] < target < matrix[row][mid]\n        int row = up;\n        while (row <= down && matrix[row][mid] <= target) {\n            if (matrix[row][mid] == target) {\n                return true;\n            }\n            row++;\n        }\n\n        return searchRec(left, row, mid-1, down) || searchRec(mid+1, up, right, row-1);\n    }\n\n    public boolean searchMatrix(int[][] mat, int targ) {\n        // cache input values in object to avoid passing them unnecessarily\n        // to `searchRec`\n        matrix = mat;\n        target = targ;\n\n        // an empty matrix obviously does not contain `target`\n        if (matrix == null || matrix.length == 0) {\n            return false;\n        }\n\n        return searchRec(0, 0, matrix[0].length-1, matrix.length-1);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\nclass Solution:\n    def searchMatrix(self, matrix, target):\n        # an empty matrix obviously does not contain `target`\n        if not matrix:\n            return False\n\n        def search_rec(left, up, right, down):\n            # this submatrix has no height or no width.\n            if left > right or up > down:\n                return False\n            # `target` is already larger than the largest element or smaller\n            # than the smallest element in this submatrix.\n            elif target < matrix[up][left] or target > matrix[down][right]:\n                return False\n\n            mid = left + (right-left)//2\n\n            # Locate `row` such that matrix[row-1][mid] < target < matrix[row][mid]\n            row = up\n            while row <= down and matrix[row][mid] <= target:\n                if matrix[row][mid] == target:\n                    return True\n                row += 1\n            \n            return search_rec(left, row, mid-1, down) or search_rec(mid+1, up, right, row-1)\n\n        return search_rec(0, 0, len(matrix[0])-1, len(matrix)-1)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n复杂度分析\n\n * 时间复杂度：O(nlgn)O(nlgn)O(nlgn)。 首先，为了便于分析，假设 n≈mn \\approx mn≈m 如方法 2 的分析中所述。另外，指定 x=n2=matrixx=n^2=matrixx=n2=matrix；这将使主方法更容易应用。现在，让我们将分治方法的运行时建模为循环关系：\n\nT(x)=2⋅T(x4)+xT(x) = 2 \\cdot T(\\frac{x}{4}) + \\sqrt{x}T(x)=2⋅T(4x​)+x​\n\n第一个式子(2⋅t(x4)2\\cdot t(\\frac x 4)2⋅t(4x​))源于我们在大约为原矩阵的四分之一大小的两个子矩阵上递归，而 x\\sqrt xx​ 源于沿着 O(n)O(n)O(n)长度列查找所花费的时间。假设变量（A=2;B=4;C=0.5A=2;B=4;C=0.5A=2;B=4;C=0.5）之后，我们注意到 log⁡ba=c\\log_b{a}=clogb​a=c。因此，这种情况属于方法二，并出现以下情况：\n\nT(x)T(x)T(x)\n=O(xc⋅lgx)= {O}(x^c \\cdot lgx)=O(xc⋅lgx)\n=O(x0.5⋅lgx)= {O}(x^{0.5} \\cdot lgx)=O(x0.5⋅lgx)\n=O((n2)0.5⋅lg(n2))= {O}((n^2)^{0.5} \\cdot lg(n^2))=O((n2)0.5⋅lg(n2))\n=O(n⋅lg(n2))= {O}(n \\cdot lg(n^2))=O(n⋅lg(n2))\n=O(2n⋅lgn)= {O}(2n \\cdot lgn)=O(2n⋅lgn)\n=O(n⋅lgn)= {O}(n \\cdot lgn)=O(n⋅lgn)\n\n扩展：如果我们用二分搜索分割点，而不是用线性扫描，那么复杂度会怎样呢？\n\n * 空间复杂度：O(lgn)O(lgn)O(lgn)，虽然这种方法从根本上不需要大于常量的附加内存，但是它使用递归意味着它将使用与其递归树高度成比例的内存。因为这种方法丢弃了每一级递归一半的矩阵（并进行了两次递归调用），所以树的高度由 lgnlgnlgn 限定。\n\n# 方法四：\n因为矩阵的行和列是排序的（分别从左到右和从上到下），所以在查看任何特定值时，我们可以修剪O(m)O(m)O(m)或O(n)O(n)O(n)元素。\n\n算法：首先，我们初始化一个指向矩阵左下角的 (row，col)(row，col)(row，col) 指针。然后，直到找到目标并返回 true（或者指针指向矩阵维度之外的 (row，col)(row，col)(row，col) 为止，我们执行以下操作：如果当前指向的值大于目标值，则可以 “向上” 移动一行。 否则，如果当前指向的值小于目标值，则可以移动一列。不难理解为什么这样做永远不会删减正确的答案；因为行是从左到右排序的，所以我们知道当前值右侧的每个值都较大。 因此，如果当前值已经大于目标值，我们知道它右边的每个值会比较大。也可以对列进行非常类似的论证，因此这种搜索方式将始终在矩阵中找到目标（如果存在）。\n\n在下面的动画中查看算法的一些示例运行：\n\n<,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,>\n\nclass Solution {\n    public boolean searchMatrix(int[][] matrix, int target) {\n        // start our "pointer" in the bottom-left\n        int row = matrix.length-1;\n        int col = 0;\n\n        while (row >= 0 && col < matrix[0].length) {\n            if (matrix[row][col] > target) {\n                row--;\n            } else if (matrix[row][col] < target) {\n                col++;\n            } else { // found it\n                return true;\n            }\n        }\n\n        return false;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\nclass Solution:\n    def searchMatrix(self, matrix, target):\n        # an empty matrix obviously does not contain `target` (make this check\n        # because we want to cache `width` for efficiency\'s sake)\n        if len(matrix) == 0 or len(matrix[0]) == 0:\n            return False\n\n        # cache these, as they won\'t change.\n        height = len(matrix)\n        width = len(matrix[0])\n\n        # start our "pointer" in the bottom-left\n        row = height-1\n        col = 0\n\n        while col < width and row >= 0:\n            if matrix[row][col] > target:\n                row -= 1\n            elif matrix[row][col] < target:\n                col += 1\n            else: # found it\n                return True\n        \n        return False\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n复杂度分析\n\n * 时间复杂度：O(n+m)O(n+m)O(n+m)。 时间复杂度分析的关键是注意到在每次迭代（我们不返回 true）时，行或列都会精确地递减/递增一次。由于行只能减少 mmm 次，而列只能增加 nnn 次，因此在导致 while 循环终止之前，循环不能运行超过 n+mn+mn+m 次。因为所有其他的工作都是常数，所以总的时间复杂度在矩阵维数之和中是线性的。\n * 空间复杂度：O(1)O(1)O(1)，因为这种方法只处理几个指针，所以它的内存占用是恒定的。\n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2021-04-08 17:37:15Accepted [https://leetcode-cn.com//submissions/detail/165345388/]6 ms100.0%44.4 MBjava2021-04-08 17:35:54Compile Error [https://leetcode-cn.com//submissions/detail/165344848/]N/AN/AN/Ajava2021-04-08 17:35:27Compile Error [https://leetcode-cn.com//submissions/detail/165344657/]N/AN/AN/Ajava# 统计信息\n通过次数提交次数AC比率11991726530045.2%# 相似题目\n题目难度搜索二维矩阵 [https://leetcode-cn.com/problems/search-a-2d-matrix/]中等',contentLowercase:'# 中文题目\n编写一个高效的算法来搜索mxn矩阵 matrix 中的一个目标值 target 。该矩阵具有以下特性：\n\n * 每行的元素从左到右升序排列。\n * 每列的元素从上到下升序排列。\n\n\n\n示例 1：\n\n\n输入：matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 5\n输出：true\n\n\n示例 2：\n\n\n输入：matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 20\n输出：false\n\n\n\n\n提示：\n\n * m == matrix.length\n * n == matrix[i].length\n * 1 \n * -1099\n * 每行的所有元素从左到右升序排列\n * 每列的所有元素从上到下升序排列\n * -1099\n\n# 通过代码\n    class solution {\n        public boolean searchmatrix(int[][] matrix, int target) {\n            // 行数\n            int row = matrix.length;\n            if (row == 0) {\n                return false;\n            }\n            // 列数\n            int col = matrix[0].length;\n            for (int i = row - 1, j = 0; i >= 0 && j < col; ) {\n                if (matrix[i][j] > target) i--;\n                else if (matrix[i][j] < target) j++;\n                else return true;\n            }\n            return false;\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n# 官方题解\n# 方法一：暴力法\n对于每一行我们可以像搜索未排序的一维数组——通过检查每个元素来判断是否有目标值。\n\n算法：这个算法并没有做到聪明的事情。我们循环数组，依次检查每个元素。如果，我们找到了，我们返回 true。否则，对于搜索到末尾都没有返回的循环，我们返回 false。此算法在所有情况下都是正确的答案，因为我们耗尽了整个搜索空间。\n\nclass solution {\n    public boolean searchmatrix(int[][] matrix, int target) {\n        for (int i = 0; i < matrix.length; i++) {\n            for (int j = 0; j < matrix[0].length; j++) {\n                if (matrix[i][j] == target) {\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\nclass solution:\n    def searchmatrix(self, matrix, target):\n        for row in matrix:\n            if target in row:\n                return true\n        \n        return false\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n复杂度分析\n\n * 时间复杂度：o(mn)o(mn)o(mn)。因为我们在 n×mn\\times mn×m 矩阵上操作，总的时间复杂度为矩阵的大小\n * 空间复杂度：o(1)o(1)o(1)，暴力法分配的额外空间不超过少量指针，因此内存占用是恒定的。\n\n# 方法二：二分法搜索\n矩阵已经排过序，就需要使用二分法搜索以加快我们的算法。\n\n算法：首先，我们确保矩阵不为空。那么，如果我们迭代矩阵对角线，从当前元素对列和行搜索，我们可以保持从当前 (row,col)(row,col)(row,col) 对开始的行和列为已排序。 因此，我们总是可以二分搜索这些行和列切片。我们以如下逻辑的方式进行 : 在对角线上迭代，二分搜索行和列，直到对角线的迭代元素用完为止（意味着我们可以返回 false ）或者找到目标（意味着我们可以返回 true ）。binary search 函数的工作原理和普通的二分搜索一样,但需要同时搜索二维数组的行和列。\n\nclass solution {\n    private boolean binarysearch(int[][] matrix, int target, int start, boolean vertical) {\n        int lo = start;\n        int hi = vertical ? matrix[0].length-1 : matrix.length-1;\n\n        while (hi >= lo) {\n            int mid = (lo + hi)/2;\n            if (vertical) { // searching a column\n                if (matrix[start][mid] < target) {\n                    lo = mid + 1;\n                } else if (matrix[start][mid] > target) {\n                    hi = mid - 1;\n                } else {\n                    return true;\n                }\n            } else { // searching a row\n                if (matrix[mid][start] < target) {\n                    lo = mid + 1;\n                } else if (matrix[mid][start] > target) {\n                    hi = mid - 1;\n                } else {\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }\n\n    public boolean searchmatrix(int[][] matrix, int target) {\n        // an empty matrix obviously does not contain `target`\n        if (matrix == null || matrix.length == 0) {\n            return false;\n        }\n\n        // iterate over matrix diagonals\n        int shorterdim = math.min(matrix.length, matrix[0].length);\n        for (int i = 0; i < shorterdim; i++) {\n            boolean verticalfound = binarysearch(matrix, target, i, true);\n            boolean horizontalfound = binarysearch(matrix, target, i, false);\n            if (verticalfound || horizontalfound) {\n                return true;\n            }\n        }\n        \n        return false; \n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\nclass solution:\n    def binary_search(self, matrix, target, start, vertical):\n        lo = start\n        hi = len(matrix[0])-1 if vertical else len(matrix)-1\n\n        while hi >= lo:\n            mid = (lo + hi)//2\n            if vertical: # searching a column\n                if matrix[start][mid] < target:\n                    lo = mid + 1\n                elif matrix[start][mid] > target:\n                    hi = mid - 1\n                else:\n                    return true\n            else: # searching a row\n                if matrix[mid][start] < target:\n                    lo = mid + 1\n                elif matrix[mid][start] > target:\n                    hi = mid - 1\n                else:\n                    return true\n        \n        return false\n\n    def searchmatrix(self, matrix, target):\n        # an empty matrix obviously does not contain `target`\n        if not matrix:\n            return false\n\n        # iterate over matrix diagonals starting in bottom left.\n        for i in range(min(len(matrix), len(matrix[0]))):\n            vertical_found = self.binary_search(matrix, target, i, true)\n            horizontal_found = self.binary_search(matrix, target, i, false)\n            if vertical_found or horizontal_found:\n                return true\n        \n        return false\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n复杂度分析\n\n * 时间复杂度：o(lg(n!))o(lg(n!))o(lg(n!))。 这个算法产生的时间复杂度并不是特别明显的是 o(lg(n!))o(lg(n!))o(lg(n!)) ，所以让我们一步一步地分析它。在主循环中执行的工作量逐渐最大，它运行 min(m,n)min(m,n)min(m,n) 次迭代，其中 mmm 表示行数，nnn 表示列数。在每次迭代中，我们对长度为 m−im-im−i 和 n−in-in−i 的数组片执行两次二分搜索。因此，循环的每一次迭代都以 o(lg(m−i)+lg(n−i))o(lg(m-i)+lg(n-i))o(lg(m−i)+lg(n−i)) 时间运行，其中 iii 表示当前迭代。我们可以将其简化为 o(2⋅lg(n−i))=o(lg(n−i))o(2 \\cdot lg(n-i))= o(lg(n-i))o(2⋅lg(n−i))=o(lg(n−i)) 在最坏的情况是 n≈mn\\approx mn≈m 。当 n≪mn \\ll mn≪m 时会发生什么（不损失一般性）；nnn 将在渐近分析中占主导地位。通过汇总所有迭代的运行时间，我们得到以下表达式：\n\no(lg(n)+lg(n−1)+lg(n−2)+…+lg(1))\\quad {o}(lg(n) + lg(n-1) + lg(n-2) + \\ldots + lg(1))o(lg(n)+lg(n−1)+lg(n−2)+…+lg(1))\n\n然后，我们可以利用对数乘法规则（lg(a)+lg(b)=lg(ab)lg(a)+lg(b)=lg(ab)lg(a)+lg(b)=lg(ab)）将复杂度改写为：\n\no(lg(n)+lg(n−1)+lg(n−2)+…+lg(1)){o}(lg(n) + lg(n-1) + lg(n-2) + \\ldots + lg(1))o(lg(n)+lg(n−1)+lg(n−2)+…+lg(1))\n=o(lg(n⋅(n−1)⋅(n−2)⋅…⋅1))={o}(lg(n \\cdot (n-1) \\cdot (n-2) \\cdot \\ldots \\cdot 1))=o(lg(n⋅(n−1)⋅(n−2)⋅…⋅1))\n=o(lg(1⋅…⋅(n−2)⋅(n−1)⋅n))= {o}(lg(1 \\cdot \\ldots \\cdot (n-2) \\cdot (n-1) \\cdot n))=o(lg(1⋅…⋅(n−2)⋅(n−1)⋅n))\n=o(lg(n!))= {o}(lg(n!))=o(lg(n!))\n\n * 空间复杂度：o(1)o(1)o(1)，因为我们的二分搜索实现并没有真正地切掉矩阵中的行和列的副本，我们可以避免分配大于常量内存。\n\n# 方法三：搜索空间的缩减\n我们可以将已排序的二维矩阵划分为四个子矩阵，其中两个可能包含目标，其中两个肯定不包含。\n\n算法：由于该算法是递归操作的，因此可以通过它的基本情况和递归情况的正确性来判断它的正确性。\n\n基本情况 ： 对于已排序的二维数组，有两种方法可以确定一个任意元素目标是否可以用常数时间判断。第一，如果数组的区域为零，则它不包含元素，因此不能包含目标。其次，如果目标小于数组的最小值或大于数组的最大值，那么矩阵肯定不包含目标值。\n\n递归情况： 如果目标值包含在数组内，因此我们沿着索引行的矩阵中间列 ，matrix[row−1][mid]<target<matrix[row][mid]matrix[row-1][mid] < target < matrix[row][mid]matrix[row−1][mid]<target<matrix[row][mid] ，（很明显，如果我们找到 target ，我们立即返回 true）。现有的矩阵可以围绕这个索引分为四个子矩阵；左上和右下子矩阵不能包含目标（通过基本情况部分来判断），所以我们可以从搜索空间中删除它们 。另外，左下角和右上角的子矩阵是二维矩阵，因此我们可以递归地将此算法应用于它们。\n\nclass solution {\n    private int[][] matrix;\n    private int target;\n\n    private boolean searchrec(int left, int up, int right, int down) {\n        // this submatrix has no height or no width.\n        if (left > right || up > down) {\n            return false;\n        // `target` is already larger than the largest element or smaller\n        // than the smallest element in this submatrix.\n        } else if (target < matrix[up][left] || target > matrix[down][right]) {\n            return false;\n        }\n\n        int mid = left + (right-left)/2;\n\n        // locate `row` such that matrix[row-1][mid] < target < matrix[row][mid]\n        int row = up;\n        while (row <= down && matrix[row][mid] <= target) {\n            if (matrix[row][mid] == target) {\n                return true;\n            }\n            row++;\n        }\n\n        return searchrec(left, row, mid-1, down) || searchrec(mid+1, up, right, row-1);\n    }\n\n    public boolean searchmatrix(int[][] mat, int targ) {\n        // cache input values in object to avoid passing them unnecessarily\n        // to `searchrec`\n        matrix = mat;\n        target = targ;\n\n        // an empty matrix obviously does not contain `target`\n        if (matrix == null || matrix.length == 0) {\n            return false;\n        }\n\n        return searchrec(0, 0, matrix[0].length-1, matrix.length-1);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\nclass solution:\n    def searchmatrix(self, matrix, target):\n        # an empty matrix obviously does not contain `target`\n        if not matrix:\n            return false\n\n        def search_rec(left, up, right, down):\n            # this submatrix has no height or no width.\n            if left > right or up > down:\n                return false\n            # `target` is already larger than the largest element or smaller\n            # than the smallest element in this submatrix.\n            elif target < matrix[up][left] or target > matrix[down][right]:\n                return false\n\n            mid = left + (right-left)//2\n\n            # locate `row` such that matrix[row-1][mid] < target < matrix[row][mid]\n            row = up\n            while row <= down and matrix[row][mid] <= target:\n                if matrix[row][mid] == target:\n                    return true\n                row += 1\n            \n            return search_rec(left, row, mid-1, down) or search_rec(mid+1, up, right, row-1)\n\n        return search_rec(0, 0, len(matrix[0])-1, len(matrix)-1)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n复杂度分析\n\n * 时间复杂度：o(nlgn)o(nlgn)o(nlgn)。 首先，为了便于分析，假设 n≈mn \\approx mn≈m 如方法 2 的分析中所述。另外，指定 x=n2=matrixx=n^2=matrixx=n2=matrix；这将使主方法更容易应用。现在，让我们将分治方法的运行时建模为循环关系：\n\nt(x)=2⋅t(x4)+xt(x) = 2 \\cdot t(\\frac{x}{4}) + \\sqrt{x}t(x)=2⋅t(4x​)+x​\n\n第一个式子(2⋅t(x4)2\\cdot t(\\frac x 4)2⋅t(4x​))源于我们在大约为原矩阵的四分之一大小的两个子矩阵上递归，而 x\\sqrt xx​ 源于沿着 o(n)o(n)o(n)长度列查找所花费的时间。假设变量（a=2;b=4;c=0.5a=2;b=4;c=0.5a=2;b=4;c=0.5）之后，我们注意到 log⁡ba=c\\log_b{a}=clogb​a=c。因此，这种情况属于方法二，并出现以下情况：\n\nt(x)t(x)t(x)\n=o(xc⋅lgx)= {o}(x^c \\cdot lgx)=o(xc⋅lgx)\n=o(x0.5⋅lgx)= {o}(x^{0.5} \\cdot lgx)=o(x0.5⋅lgx)\n=o((n2)0.5⋅lg(n2))= {o}((n^2)^{0.5} \\cdot lg(n^2))=o((n2)0.5⋅lg(n2))\n=o(n⋅lg(n2))= {o}(n \\cdot lg(n^2))=o(n⋅lg(n2))\n=o(2n⋅lgn)= {o}(2n \\cdot lgn)=o(2n⋅lgn)\n=o(n⋅lgn)= {o}(n \\cdot lgn)=o(n⋅lgn)\n\n扩展：如果我们用二分搜索分割点，而不是用线性扫描，那么复杂度会怎样呢？\n\n * 空间复杂度：o(lgn)o(lgn)o(lgn)，虽然这种方法从根本上不需要大于常量的附加内存，但是它使用递归意味着它将使用与其递归树高度成比例的内存。因为这种方法丢弃了每一级递归一半的矩阵（并进行了两次递归调用），所以树的高度由 lgnlgnlgn 限定。\n\n# 方法四：\n因为矩阵的行和列是排序的（分别从左到右和从上到下），所以在查看任何特定值时，我们可以修剪o(m)o(m)o(m)或o(n)o(n)o(n)元素。\n\n算法：首先，我们初始化一个指向矩阵左下角的 (row，col)(row，col)(row，col) 指针。然后，直到找到目标并返回 true（或者指针指向矩阵维度之外的 (row，col)(row，col)(row，col) 为止，我们执行以下操作：如果当前指向的值大于目标值，则可以 “向上” 移动一行。 否则，如果当前指向的值小于目标值，则可以移动一列。不难理解为什么这样做永远不会删减正确的答案；因为行是从左到右排序的，所以我们知道当前值右侧的每个值都较大。 因此，如果当前值已经大于目标值，我们知道它右边的每个值会比较大。也可以对列进行非常类似的论证，因此这种搜索方式将始终在矩阵中找到目标（如果存在）。\n\n在下面的动画中查看算法的一些示例运行：\n\n<,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,>\n\nclass solution {\n    public boolean searchmatrix(int[][] matrix, int target) {\n        // start our "pointer" in the bottom-left\n        int row = matrix.length-1;\n        int col = 0;\n\n        while (row >= 0 && col < matrix[0].length) {\n            if (matrix[row][col] > target) {\n                row--;\n            } else if (matrix[row][col] < target) {\n                col++;\n            } else { // found it\n                return true;\n            }\n        }\n\n        return false;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\nclass solution:\n    def searchmatrix(self, matrix, target):\n        # an empty matrix obviously does not contain `target` (make this check\n        # because we want to cache `width` for efficiency\'s sake)\n        if len(matrix) == 0 or len(matrix[0]) == 0:\n            return false\n\n        # cache these, as they won\'t change.\n        height = len(matrix)\n        width = len(matrix[0])\n\n        # start our "pointer" in the bottom-left\n        row = height-1\n        col = 0\n\n        while col < width and row >= 0:\n            if matrix[row][col] > target:\n                row -= 1\n            elif matrix[row][col] < target:\n                col += 1\n            else: # found it\n                return true\n        \n        return false\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n复杂度分析\n\n * 时间复杂度：o(n+m)o(n+m)o(n+m)。 时间复杂度分析的关键是注意到在每次迭代（我们不返回 true）时，行或列都会精确地递减/递增一次。由于行只能减少 mmm 次，而列只能增加 nnn 次，因此在导致 while 循环终止之前，循环不能运行超过 n+mn+mn+m 次。因为所有其他的工作都是常数，所以总的时间复杂度在矩阵维数之和中是线性的。\n * 空间复杂度：o(1)o(1)o(1)，因为这种方法只处理几个指针，所以它的内存占用是恒定的。\n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2021-04-08 17:37:15accepted [https://leetcode-cn.com//submissions/detail/165345388/]6 ms100.0%44.4 mbjava2021-04-08 17:35:54compile error [https://leetcode-cn.com//submissions/detail/165344848/]n/an/an/ajava2021-04-08 17:35:27compile error [https://leetcode-cn.com//submissions/detail/165344657/]n/an/an/ajava# 统计信息\n通过次数提交次数ac比率11991726530045.2%# 相似题目\n题目难度搜索二维矩阵 [https://leetcode-cn.com/problems/search-a-2d-matrix/]中等'},{title:"300-最长上升子序列(Longest Increasing Subsequence)",frontmatter:{title:"300-最长上升子序列(Longest Increasing Subsequence)",date:"2018-07-24T00:00:00.000Z",categories:["中等"],tags:["二分查找<Binary Search>","动态规划<Dynamic Programming>"]},regularPath:"/views/%E4%B8%AD%E7%AD%89/0300-%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97.html",relativePath:"views/中等/0300-最长上升子序列.md",key:"v-4f2683df",path:"/views/%E4%B8%AD%E7%AD%89/0300-%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97.html",headers:[{level:2,title:"中文题目",slug:"中文题目",charIndex:2},{level:2,title:"通过代码",slug:"通过代码",charIndex:211},{level:2,title:"官方题解",slug:"官方题解",charIndex:920},{level:2,title:"提交历史",slug:"提交历史",charIndex:6190},{level:2,title:"统计信息",slug:"统计信息",charIndex:6318},{level:2,title:"相似题目",slug:"相似题目",charIndex:6352}],lastUpdated:"4/11/2021, 1:15:21 PM",headersStr:"中文题目 通过代码 官方题解 提交历史 统计信息 相似题目",content:"# 中文题目\n给定一个无序的整数数组，找到其中最长上升子序列的长度。\n\n示例:\n\n输入: [10,9,2,5,3,7,101,18]\n输出: 4 \n解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。\n\n说明:\n\n * 可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。\n * 你算法的时间复杂度应该为 O(n2) 。\n\n进阶: 你能将算法的时间复杂度降低到 O(n log n) 吗?\n\n# 通过代码\nclass Solution {\n           public int lengthOfLIS(int[] nums) {\n            if (nums.length==0){\n                return  0;\n            }\n            int[] memo=new int[nums.length+1];\n            Arrays.fill(memo,1);\n            for (int i = 1; i < nums.length; i++) {\n                for (int j = 0; j < i; j++) {\n                    if (nums[j]<nums[i]){\n                        memo[i]=Math.max(memo[i],memo[j]+1);\n                    }\n                }\n            }\n\n            int res=1;\n            for (int i = 0; i < memo.length; i++) {\n                res=Math.max(res,memo[i]);\n            }\n            return res;\n        }\n\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n# 官方题解\n# 方法一：暴力法\n算法：最简单的方法是找到所有增加的子序列，然后返回最长增加的子序列的最大长度。为了做到这一点，我们使用递归函数 lengthoflis\\text length of lislengthoflis 返回从当前元素（对应于 curposcurposcurpos）开始可能的 lis 长度（包括当前元素）。在每个函数调用中，我们考虑两种情况：\n\n 1. 当前元素大于包含在 lis 中的前一个元素。在这种情况下，我们可以在 lis 中包含当前元素。因此，我们通过将其包含在内，得出了 lis 的长度。此外，我们还通过不在 lis 中包含当前元素来找出 lis 的长度。因此，当前函数调用返回的值是两个长度中的最大值。\n 2. 当前元素小于包含在 lis 中的前一个元素。在这种情况下，我们不能在 lis 中包含当前元素。因此，我们只通过不在 lis 中包含当前元素（由当前函数调用返回）来确定 lis 的长度。\n\npublic class Solution {\n\n    public int lengthOfLIS(int[] nums) {\n        return lengthofLIS(nums, Integer.MIN_VALUE, 0);\n    }\n\n    public int lengthofLIS(int[] nums, int prev, int curpos) {\n        if (curpos == nums.length) {\n            return 0;\n        }\n        int taken = 0;\n        if (nums[curpos] > prev) {\n            taken = 1 + lengthofLIS(nums, nums[curpos], curpos + 1);\n        }\n        int nottaken = lengthofLIS(nums, prev, curpos + 1);\n        return Math.max(taken, nottaken);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n复杂度分析\n\n * 时间复杂度：O(2n)O(2^n)O(2n)。递归树的大小将为 2n2^n2n。\n * 空间复杂度：O(n2)O(n^2)O(n2)，使用大小为 n∗nn*nn∗n 的 memomemomemo 数组。\n\n# 方法二：带记忆的递归\n算法：在前面的方法中，许多递归调用必须使用相同的参数进行一次又一次的调用。通过将为特定调用获得的结果存储在二维记忆数组 memomemomemo 中，可以消除这种冗余。memo[i][j]memo[i][j]memo[i][j] 表示使用 nums[i]nums[i]nums[i] 作为上一个被认为包含/不包含在 lis 中的元素的 lis 可能的长度，其中 nums[j]nums[j]nums[j] 作为当前被认为包含/不包含在 lis 中的元素。这里，numsnumsnums 表示给定的数组。\n\npublic class Solution {\n    public int lengthOfLIS(int[] nums) {\n        int memo[][] = new int[nums.length + 1][nums.length];\n        for (int[] l : memo) {\n            Arrays.fill(l, -1);\n        }\n        return lengthofLIS(nums, -1, 0, memo);\n    }\n    public int lengthofLIS(int[] nums, int previndex, int curpos, int[][] memo) {\n        if (curpos == nums.length) {\n            return 0;\n        }\n        if (memo[previndex + 1][curpos] >= 0) {\n            return memo[previndex + 1][curpos];\n        }\n        int taken = 0;\n        if (previndex < 0 || nums[curpos] > nums[previndex]) {\n            taken = 1 + lengthofLIS(nums, curpos, curpos + 1, memo);\n        }\n\n        int nottaken = lengthofLIS(nums, previndex, curpos + 1, memo);\n        memo[previndex + 1][curpos] = Math.max(taken, nottaken);\n        return memo[previndex + 1][curpos];\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n复杂度分析\n\n * 时间复杂度：O(n2)O(n^2)O(n2)。递归树的大小可以达到 n2n^2n2。\n * 空间复杂度：O(n2)O(n^2)O(n2)，使用 n∗nn*nn∗n 的 memomemomemo 数组。\n\n# 方法四：动态规划\n算法：他的方法依赖于这样一个事实，在给定数组中最长上升子序列可能达到 ithi^{th}ith 独立于后面在数组中出现的元素。因此，如果我们知道 lis 的长度不超过 ithi^{th}ith ，我们可以根据索引为 jjj 的元素包括 (i+1)th(i+1)^{th}(i+1)th 元素来计算 lis 的长度，其中 0≤j≤（i+1）0\\leq j\\leq（i+1）0≤j≤（i+1）。\n\n我们使用 dpdpdp 数组来存储所需的数据。 dp[i]dp[i]dp[i] 表示考虑到数组元素一直到 ithi^{th}ith 的情况下可能的最长上升子序列的长度，必须包括 ithi^{th}ith 元素。为了找出 dp[i]dp[i]dp[i]，我们需要尝试在每个可能的最长上升子序列中附加当前元素（nums[i]nums[i]nums[i]）到 (i−1)th(i-1)^{th}(i−1)th（包括 (i−1)th(i-1)^{th}(i−1)th），这样通过添加当前元素形成的新序列也是一个上升子序列。因此，我们可以很容易地确定 dp[i]dp[i]dp[i] 使用：\n\ndp[i]=max(dp[j])+1,∀0≤j<idp[i] = \\text{max}(dp[j]) + 1, \\forall 0\\leq j < idp[i]=max(dp[j])+1,∀0≤j<i\n\n最后，确定最终结果的所有 dp[i]dp[i]dp[i] 中的最大值。\n\nLISlength=max(dp[i]),∀0≤i<nLIS_{length}= \\text{max}(dp[i]), \\forall 0\\leq i < nLISlength​=max(dp[i]),∀0≤i<n\n\n以下动画演示了该方法：\n\n<,,,,,,,,,,,,,,,,,,,,,,>\n\npublic class Solution {\n    public int lengthOfLIS(int[] nums) {\n        if (nums.length == 0) {\n            return 0;\n        }\n        int[] dp = new int[nums.length];\n        dp[0] = 1;\n        int maxans = 1;\n        for (int i = 1; i < dp.length; i++) {\n            int maxval = 0;\n            for (int j = 0; j < i; j++) {\n                if (nums[i] > nums[j]) {\n                    maxval = Math.max(maxval, dp[j]);\n                }\n            }\n            dp[i] = maxval + 1;\n            maxans = Math.max(maxans, dp[i]);\n        }\n        return maxans;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n复杂度分析\n\n * 时间复杂度：O(n2)O(n^2)O(n2)。有两个 nnn 的循环。\n * 空间复杂度：O(n)O(n)O(n)，用了大小为 nnn 的矩阵 dp。\n\n# 方法四：动态规划和二分搜索\n算法：在这种方法中，我们从左到右扫描数组。我们还使用了 0 初始化的 dpdpdp 数组。此 dpdpdp 数组用于存储当前遇到的元素形成的上升子序列。当遍历 numsnumsnums 数组时，我们继续用到目前为止遇到的元素填充 dpdpdp 数组。对应与jthj^{th}jth（nums[j]nums[j]nums[j]）对应的元素，我们通过使用二分搜索（由于 dpdpdp 数组存储递增的子序列，因此可以使用二分搜索）来确定其在 dpdpdp 数组中的正确位置，需要注意的一个重要点是，对于二分搜索，我们只考虑 dpdpdp 数组中通过在其正确位置插入一些元素（始终保持排序）进行更新的那部分。因此，只有到 dpdpdp 数组中的 ithi^{th}ith 的元素才能确定当前元素在其中的位置。因为，元素在 dpdpdp 数组中以升序输入其正确的位置（iii）。到目前为止形成的子序列肯定是一个不断增加的子序列。只要这个位置索引 iii 等于到目前为止形成的 lis 的长度（lenlenlen），就意味着我们需要将 len 更新为 len=len+1len = len + 1len=len+1。\n\n注意：dpdpdp 数组不会导致子序列的最长增加，但 dpdpdp 数组的长度将为您提供 lis 的长度。\n\n我们来看下面的例子：\n\ninput: [0, 8, 4, 12, 2]\ndp: [0]\ndp: [0, 8]\ndp: [0, 4]\ndp: [0, 4, 12]\n\n\n1\n2\n3\n4\n5\ndp:[0，2，12]这不是最长上升子序列，但 dpdpdp 数组的长度会导致最长上升子序列的长度。\n\npublic class Solution {\n    public int lengthOfLIS(int[] nums) {\n        int[] dp = new int[nums.length];\n        int len = 0;\n        for (int num : nums) {\n            int i = Arrays.binarySearch(dp, 0, len, num);\n            if (i < 0) {\n                i = -(i + 1);\n            }\n            dp[i] = num;\n            if (i == len) {\n                len++;\n            }\n        }\n        return len;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n注意：Arrays.binarySearch() 方法返回搜索键的索引，如果它包含在数组中，则返回(（插入点）-1）。\n\n复杂度分析\n\n * 时间复杂度：O(nlog⁡n)O(n\\log n)O(nlogn)。二分搜索需要花费 log⁡n\\log nlogn 的时间且调用 nnn 次。\n * 空间复杂度：O(n)O(n)O(n)，用了大小为 nnn 的矩阵 dpdpdp。\n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-07-24 20:44:14Accepted [https://leetcode-cn.com//submissions/detail/4600654/]31 ms9.11%N/Ajava# 统计信息\n通过次数提交次数AC比率434909955743.7%# 相似题目\n题目难度递增的三元子序列 [https://leetcode-cn.com/problems/increasing-triplet-subsequence/]中等俄罗斯套娃信封问题 [https://leetcode-cn.com/problems/russian-doll-envelopes/]困难最长数对链 [https://leetcode-cn.com/problems/maximum-length-of-pair-chain/]中等最长递增子序列的个数 [https://leetcode-cn.com/problems/number-of-longest-increasing-subsequence/]中等两个字符串的最小ASCII删除和 [https://leetcode-cn.com/problems/minimum-ascii-delete-sum-for-two-strings/]中等",contentLowercase:"# 中文题目\n给定一个无序的整数数组，找到其中最长上升子序列的长度。\n\n示例:\n\n输入: [10,9,2,5,3,7,101,18]\n输出: 4 \n解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。\n\n说明:\n\n * 可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。\n * 你算法的时间复杂度应该为 o(n2) 。\n\n进阶: 你能将算法的时间复杂度降低到 o(n log n) 吗?\n\n# 通过代码\nclass solution {\n           public int lengthoflis(int[] nums) {\n            if (nums.length==0){\n                return  0;\n            }\n            int[] memo=new int[nums.length+1];\n            arrays.fill(memo,1);\n            for (int i = 1; i < nums.length; i++) {\n                for (int j = 0; j < i; j++) {\n                    if (nums[j]<nums[i]){\n                        memo[i]=math.max(memo[i],memo[j]+1);\n                    }\n                }\n            }\n\n            int res=1;\n            for (int i = 0; i < memo.length; i++) {\n                res=math.max(res,memo[i]);\n            }\n            return res;\n        }\n\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n# 官方题解\n# 方法一：暴力法\n算法：最简单的方法是找到所有增加的子序列，然后返回最长增加的子序列的最大长度。为了做到这一点，我们使用递归函数 lengthoflis\\text length of lislengthoflis 返回从当前元素（对应于 curposcurposcurpos）开始可能的 lis 长度（包括当前元素）。在每个函数调用中，我们考虑两种情况：\n\n 1. 当前元素大于包含在 lis 中的前一个元素。在这种情况下，我们可以在 lis 中包含当前元素。因此，我们通过将其包含在内，得出了 lis 的长度。此外，我们还通过不在 lis 中包含当前元素来找出 lis 的长度。因此，当前函数调用返回的值是两个长度中的最大值。\n 2. 当前元素小于包含在 lis 中的前一个元素。在这种情况下，我们不能在 lis 中包含当前元素。因此，我们只通过不在 lis 中包含当前元素（由当前函数调用返回）来确定 lis 的长度。\n\npublic class solution {\n\n    public int lengthoflis(int[] nums) {\n        return lengthoflis(nums, integer.min_value, 0);\n    }\n\n    public int lengthoflis(int[] nums, int prev, int curpos) {\n        if (curpos == nums.length) {\n            return 0;\n        }\n        int taken = 0;\n        if (nums[curpos] > prev) {\n            taken = 1 + lengthoflis(nums, nums[curpos], curpos + 1);\n        }\n        int nottaken = lengthoflis(nums, prev, curpos + 1);\n        return math.max(taken, nottaken);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n复杂度分析\n\n * 时间复杂度：o(2n)o(2^n)o(2n)。递归树的大小将为 2n2^n2n。\n * 空间复杂度：o(n2)o(n^2)o(n2)，使用大小为 n∗nn*nn∗n 的 memomemomemo 数组。\n\n# 方法二：带记忆的递归\n算法：在前面的方法中，许多递归调用必须使用相同的参数进行一次又一次的调用。通过将为特定调用获得的结果存储在二维记忆数组 memomemomemo 中，可以消除这种冗余。memo[i][j]memo[i][j]memo[i][j] 表示使用 nums[i]nums[i]nums[i] 作为上一个被认为包含/不包含在 lis 中的元素的 lis 可能的长度，其中 nums[j]nums[j]nums[j] 作为当前被认为包含/不包含在 lis 中的元素。这里，numsnumsnums 表示给定的数组。\n\npublic class solution {\n    public int lengthoflis(int[] nums) {\n        int memo[][] = new int[nums.length + 1][nums.length];\n        for (int[] l : memo) {\n            arrays.fill(l, -1);\n        }\n        return lengthoflis(nums, -1, 0, memo);\n    }\n    public int lengthoflis(int[] nums, int previndex, int curpos, int[][] memo) {\n        if (curpos == nums.length) {\n            return 0;\n        }\n        if (memo[previndex + 1][curpos] >= 0) {\n            return memo[previndex + 1][curpos];\n        }\n        int taken = 0;\n        if (previndex < 0 || nums[curpos] > nums[previndex]) {\n            taken = 1 + lengthoflis(nums, curpos, curpos + 1, memo);\n        }\n\n        int nottaken = lengthoflis(nums, previndex, curpos + 1, memo);\n        memo[previndex + 1][curpos] = math.max(taken, nottaken);\n        return memo[previndex + 1][curpos];\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n复杂度分析\n\n * 时间复杂度：o(n2)o(n^2)o(n2)。递归树的大小可以达到 n2n^2n2。\n * 空间复杂度：o(n2)o(n^2)o(n2)，使用 n∗nn*nn∗n 的 memomemomemo 数组。\n\n# 方法四：动态规划\n算法：他的方法依赖于这样一个事实，在给定数组中最长上升子序列可能达到 ithi^{th}ith 独立于后面在数组中出现的元素。因此，如果我们知道 lis 的长度不超过 ithi^{th}ith ，我们可以根据索引为 jjj 的元素包括 (i+1)th(i+1)^{th}(i+1)th 元素来计算 lis 的长度，其中 0≤j≤（i+1）0\\leq j\\leq（i+1）0≤j≤（i+1）。\n\n我们使用 dpdpdp 数组来存储所需的数据。 dp[i]dp[i]dp[i] 表示考虑到数组元素一直到 ithi^{th}ith 的情况下可能的最长上升子序列的长度，必须包括 ithi^{th}ith 元素。为了找出 dp[i]dp[i]dp[i]，我们需要尝试在每个可能的最长上升子序列中附加当前元素（nums[i]nums[i]nums[i]）到 (i−1)th(i-1)^{th}(i−1)th（包括 (i−1)th(i-1)^{th}(i−1)th），这样通过添加当前元素形成的新序列也是一个上升子序列。因此，我们可以很容易地确定 dp[i]dp[i]dp[i] 使用：\n\ndp[i]=max(dp[j])+1,∀0≤j<idp[i] = \\text{max}(dp[j]) + 1, \\forall 0\\leq j < idp[i]=max(dp[j])+1,∀0≤j<i\n\n最后，确定最终结果的所有 dp[i]dp[i]dp[i] 中的最大值。\n\nlislength=max(dp[i]),∀0≤i<nlis_{length}= \\text{max}(dp[i]), \\forall 0\\leq i < nlislength​=max(dp[i]),∀0≤i<n\n\n以下动画演示了该方法：\n\n<,,,,,,,,,,,,,,,,,,,,,,>\n\npublic class solution {\n    public int lengthoflis(int[] nums) {\n        if (nums.length == 0) {\n            return 0;\n        }\n        int[] dp = new int[nums.length];\n        dp[0] = 1;\n        int maxans = 1;\n        for (int i = 1; i < dp.length; i++) {\n            int maxval = 0;\n            for (int j = 0; j < i; j++) {\n                if (nums[i] > nums[j]) {\n                    maxval = math.max(maxval, dp[j]);\n                }\n            }\n            dp[i] = maxval + 1;\n            maxans = math.max(maxans, dp[i]);\n        }\n        return maxans;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n复杂度分析\n\n * 时间复杂度：o(n2)o(n^2)o(n2)。有两个 nnn 的循环。\n * 空间复杂度：o(n)o(n)o(n)，用了大小为 nnn 的矩阵 dp。\n\n# 方法四：动态规划和二分搜索\n算法：在这种方法中，我们从左到右扫描数组。我们还使用了 0 初始化的 dpdpdp 数组。此 dpdpdp 数组用于存储当前遇到的元素形成的上升子序列。当遍历 numsnumsnums 数组时，我们继续用到目前为止遇到的元素填充 dpdpdp 数组。对应与jthj^{th}jth（nums[j]nums[j]nums[j]）对应的元素，我们通过使用二分搜索（由于 dpdpdp 数组存储递增的子序列，因此可以使用二分搜索）来确定其在 dpdpdp 数组中的正确位置，需要注意的一个重要点是，对于二分搜索，我们只考虑 dpdpdp 数组中通过在其正确位置插入一些元素（始终保持排序）进行更新的那部分。因此，只有到 dpdpdp 数组中的 ithi^{th}ith 的元素才能确定当前元素在其中的位置。因为，元素在 dpdpdp 数组中以升序输入其正确的位置（iii）。到目前为止形成的子序列肯定是一个不断增加的子序列。只要这个位置索引 iii 等于到目前为止形成的 lis 的长度（lenlenlen），就意味着我们需要将 len 更新为 len=len+1len = len + 1len=len+1。\n\n注意：dpdpdp 数组不会导致子序列的最长增加，但 dpdpdp 数组的长度将为您提供 lis 的长度。\n\n我们来看下面的例子：\n\ninput: [0, 8, 4, 12, 2]\ndp: [0]\ndp: [0, 8]\ndp: [0, 4]\ndp: [0, 4, 12]\n\n\n1\n2\n3\n4\n5\ndp:[0，2，12]这不是最长上升子序列，但 dpdpdp 数组的长度会导致最长上升子序列的长度。\n\npublic class solution {\n    public int lengthoflis(int[] nums) {\n        int[] dp = new int[nums.length];\n        int len = 0;\n        for (int num : nums) {\n            int i = arrays.binarysearch(dp, 0, len, num);\n            if (i < 0) {\n                i = -(i + 1);\n            }\n            dp[i] = num;\n            if (i == len) {\n                len++;\n            }\n        }\n        return len;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n注意：arrays.binarysearch() 方法返回搜索键的索引，如果它包含在数组中，则返回(（插入点）-1）。\n\n复杂度分析\n\n * 时间复杂度：o(nlog⁡n)o(n\\log n)o(nlogn)。二分搜索需要花费 log⁡n\\log nlogn 的时间且调用 nnn 次。\n * 空间复杂度：o(n)o(n)o(n)，用了大小为 nnn 的矩阵 dpdpdp。\n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-07-24 20:44:14accepted [https://leetcode-cn.com//submissions/detail/4600654/]31 ms9.11%n/ajava# 统计信息\n通过次数提交次数ac比率434909955743.7%# 相似题目\n题目难度递增的三元子序列 [https://leetcode-cn.com/problems/increasing-triplet-subsequence/]中等俄罗斯套娃信封问题 [https://leetcode-cn.com/problems/russian-doll-envelopes/]困难最长数对链 [https://leetcode-cn.com/problems/maximum-length-of-pair-chain/]中等最长递增子序列的个数 [https://leetcode-cn.com/problems/number-of-longest-increasing-subsequence/]中等两个字符串的最小ascii删除和 [https://leetcode-cn.com/problems/minimum-ascii-delete-sum-for-two-strings/]中等"},{title:"322-零钱兑换(Coin Change)",frontmatter:{title:"322-零钱兑换(Coin Change)",date:"2018-09-25T00:00:00.000Z",categories:["中等"],tags:["动态规划<Dynamic Programming>"]},regularPath:"/views/%E4%B8%AD%E7%AD%89/0322-%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2.html",relativePath:"views/中等/0322-零钱兑换.md",key:"v-59e03967",path:"/views/%E4%B8%AD%E7%AD%89/0322-%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2.html",headers:[{level:2,title:"中文题目",slug:"中文题目",charIndex:2},{level:2,title:"通过代码",slug:"通过代码",charIndex:227},{level:2,title:"提交历史",slug:"提交历史",charIndex:1448},{level:2,title:"统计信息",slug:"统计信息",charIndex:1675},{level:2,title:"相似题目",slug:"相似题目",charIndex:1709}],lastUpdated:"4/11/2021, 1:15:21 PM",headersStr:"中文题目 通过代码 提交历史 统计信息 相似题目",content:"# 中文题目\n给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回-1。\n\n示例 1:\n\n输入: coins = [1, 2, 5], amount = 11\n输出: 3 \n解释: 11 = 5 + 5 + 1\n\n示例 2:\n\n输入: coins = [2], amount = 3\n输出: -1\n\n说明:\n你可以认为每种硬币的数量是无限的。\n\n# 通过代码\nclass Solution {\n    public int coinChange(int[] coins, int amount) {\n        if(coins==null || coins.length==0){\n                return 0;\n        }\n        int[] dp=new int[amount+1];\n        Arrays.fill(dp,amount+1);\n        dp[0]=0;        \n        for (int i = 1; i < dp.length; i++) {\n                for (int j = 0; j < coins.length; j++) {\n                    if (coins[j]<=i){\n                        dp[i]=Math.min(dp[i],dp[i-coins[j]]+1);\n                    }\n                }\n            }\n            return dp[amount]>amount?-1:dp[amount];\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\nclass Solution {\n    public int coinChange(int[] coins, int amount) {\n        if(coins==null || coins.length==0){\n                return 0;\n        }\n        int[] dp=new int[amount+1];\n        Arrays.fill(dp,amount+1);\n        dp[0]=0;        \n        for (int i = 1; i < dp.length; i++) {\n                for (int j = 0; j < coins.length; j++) {\n                    if (coins[j]<=i){\n                        dp[i]=Math.min(dp[i],dp[i-coins[j]]+1);\n                    }\n                }\n            }\n            return dp[amount]>amount?-1:dp[amount];\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-09-25 22:13:48Accepted [https://leetcode-cn.com//submissions/detail/7560487/]44 ms7.72%N/Ajava2018-09-25 22:13:28Accepted [https://leetcode-cn.com//submissions/detail/7560465/]48 ms7.08%N/Ajava# 统计信息\n通过次数提交次数AC比率364769857637.0%# 相似题目\n题目难度最低票价 [https://leetcode-cn.com/problems/minimum-cost-for-tickets/]中等",contentLowercase:"# 中文题目\n给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回-1。\n\n示例 1:\n\n输入: coins = [1, 2, 5], amount = 11\n输出: 3 \n解释: 11 = 5 + 5 + 1\n\n示例 2:\n\n输入: coins = [2], amount = 3\n输出: -1\n\n说明:\n你可以认为每种硬币的数量是无限的。\n\n# 通过代码\nclass solution {\n    public int coinchange(int[] coins, int amount) {\n        if(coins==null || coins.length==0){\n                return 0;\n        }\n        int[] dp=new int[amount+1];\n        arrays.fill(dp,amount+1);\n        dp[0]=0;        \n        for (int i = 1; i < dp.length; i++) {\n                for (int j = 0; j < coins.length; j++) {\n                    if (coins[j]<=i){\n                        dp[i]=math.min(dp[i],dp[i-coins[j]]+1);\n                    }\n                }\n            }\n            return dp[amount]>amount?-1:dp[amount];\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\nclass solution {\n    public int coinchange(int[] coins, int amount) {\n        if(coins==null || coins.length==0){\n                return 0;\n        }\n        int[] dp=new int[amount+1];\n        arrays.fill(dp,amount+1);\n        dp[0]=0;        \n        for (int i = 1; i < dp.length; i++) {\n                for (int j = 0; j < coins.length; j++) {\n                    if (coins[j]<=i){\n                        dp[i]=math.min(dp[i],dp[i-coins[j]]+1);\n                    }\n                }\n            }\n            return dp[amount]>amount?-1:dp[amount];\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-09-25 22:13:48accepted [https://leetcode-cn.com//submissions/detail/7560487/]44 ms7.72%n/ajava2018-09-25 22:13:28accepted [https://leetcode-cn.com//submissions/detail/7560465/]48 ms7.08%n/ajava# 统计信息\n通过次数提交次数ac比率364769857637.0%# 相似题目\n题目难度最低票价 [https://leetcode-cn.com/problems/minimum-cost-for-tickets/]中等"},{title:"309-最佳买卖股票时机含冷冻期(Best Time to Buy and Sell Stock with Cooldown)",frontmatter:{title:"309-最佳买卖股票时机含冷冻期(Best Time to Buy and Sell Stock with Cooldown)",date:"2018-09-18T00:00:00.000Z",categories:["中等"],tags:["动态规划<Dynamic Programming>"]},regularPath:"/views/%E4%B8%AD%E7%AD%89/0309-%E6%9C%80%E4%BD%B3%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E6%97%B6%E6%9C%BA%E5%90%AB%E5%86%B7%E5%86%BB%E6%9C%9F.html",relativePath:"views/中等/0309-最佳买卖股票时机含冷冻期.md",key:"v-36ec1cda",path:"/views/%E4%B8%AD%E7%AD%89/0309-%E6%9C%80%E4%BD%B3%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E6%97%B6%E6%9C%BA%E5%90%AB%E5%86%B7%E5%86%BB%E6%9C%9F.html",headers:[{level:2,title:"中文题目",slug:"中文题目",charIndex:2},{level:2,title:"通过代码",slug:"通过代码",charIndex:228},{level:2,title:"高赞题解",slug:"高赞题解",charIndex:1449},{level:3,title:"一、穷举框架",slug:"一、穷举框架",charIndex:2390},{level:3,title:"二、状态转移框架",slug:"二、状态转移框架",charIndex:3740},{level:3,title:"三、秒杀题目",slug:"三、秒杀题目",charIndex:5210},{level:3,title:"四、最后总结",slug:"四、最后总结",charIndex:12117},{level:2,title:"提交历史",slug:"提交历史",charIndex:13611},{level:2,title:"统计信息",slug:"统计信息",charIndex:13838},{level:2,title:"相似题目",slug:"相似题目",charIndex:13872}],lastUpdated:"4/11/2021, 1:15:21 PM",headersStr:"中文题目 通过代码 高赞题解 一、穷举框架 二、状态转移框架 三、秒杀题目 四、最后总结 提交历史 统计信息 相似题目",content:"# 中文题目\n给定一个整数数组，其中第i个元素代表了第i天的股票价格 。​\n\n设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:\n\n * 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。\n * 卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。\n\n示例:\n\n输入: [1,2,3,0,2]\n输出: 3 \n解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]\n\n# 通过代码\nclass Solution {\n    public int maxProfit(int[] prices) {\n         if (prices==null || prices.length==0){\n                return 0;\n            }\n            int s0=0;\n            int s1=-prices[0];\n            int s2=Integer.MIN_VALUE;\n            for (int i = 1; i < prices.length; i++) {\n                int pre0=s0;\n                int pre1=s1;\n                int pre2=s2;\n                s0=Math.max(pre0,pre2);\n                s1=Math.max(pre0-prices[i],pre1);\n                s2=pre1+prices[i];\n            }\n            return Math.max(s0,s2);\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\nclass Solution {\n    public int maxProfit(int[] prices) {\n         if (prices==null || prices.length==0){\n                return 0;\n            }\n            int s0=0;\n            int s1=-prices[0];\n            int s2=Integer.MIN_VALUE;\n            for (int i = 1; i < prices.length; i++) {\n                int pre0=s0;\n                int pre1=s1;\n                int pre2=s2;\n                s0=Math.max(pre0,pre2);\n                s1=Math.max(pre0-prices[i],pre1);\n                s2=pre1+prices[i];\n            }\n            return Math.max(s0,s2);\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n# 高赞题解\n很多读者抱怨股票系列问题奇技淫巧太多，如果面试真的遇到这类问题，基本不会想到那些巧妙的办法，怎么办？所以本文拒绝奇技淫巧，而是稳扎稳打，只用一种通用方法解决所用问题，以不变应万变。\n\n这篇文章用状态机的技巧来解决，可以全部提交通过。不要觉得这个名词高大上，文学词汇而已，实际上就是 DP table，看一眼就明白了。\n\n先随便抽出一道题，看看别人的解法：\n\nint maxProfit(vector<int>& prices) {\n    if(prices.empty()) return 0;\n    int s1=-prices[0],s2=INT_MIN,s3=INT_MIN,s4=INT_MIN;\n        \n    for(int i=1;i<prices.size();++i) {            \n        s1 = max(s1, -prices[i]);\n        s2 = max(s2, s1+prices[i]);\n        s3 = max(s3, s2-prices[i]);\n        s4 = max(s4, s3+prices[i]);\n    }\n    return max(0,s4);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n能看懂吧？会做了吗？不可能的，你看不懂，这才正常。就算你勉强看懂了，下一个问题你还是做不出来。为什么别人能写出这么诡异却又高效的解法呢？因为这类问题是有框架的，但是人家不会告诉你的，因为一旦告诉你，你五分钟就学会了，该算法题就不再神秘，变得不堪一击了。\n\n本文就来告诉你这个框架，然后带着你一道一道秒杀。\n\n这 6 道股票买卖问题是有共性的，我们通过对第四题（限制最大交易次数为 k）的分析一道一道解决。因为第四题是一个最泛化的形式，其他的问题都是这个形式的简化。\n\n第一题是只进行一次交易，相当于 k = 1；第二题是不限交易次数，相当于 k = +infinity（正无穷）；第三题是只进行 2 次交易，相当于 k = 2；剩下两道也是不限次数，但是加了交易「冷冻期」和「手续费」的额外条件，其实就是第二题的变种，都很容易处理。\n\n# 一、穷举框架\n首先，还是一样的思路：如何穷举？这里的穷举思路和上篇文章递归的思想不太一样。\n\n递归其实是符合我们思考的逻辑的，一步步推进，遇到无法解决的就丢给递归，一不小心就做出来了，可读性还很好。缺点就是一旦出错，你也不容易找到错误出现的原因。比如上篇文章的递归解法，肯定还有计算冗余，但确实不容易找到。\n\n而这里，我们不用递归思想进行穷举，而是利用「状态」进行穷举。我们具体到每一天，看看总共有几种可能的「状态」，再找出每个「状态」对应的「选择」。我们要穷举所有「状态」，穷举的目的是根据对应的「选择」更新状态。听起来抽象，你只要记住「状态」和「选择」两个词就行，下面实操一下就很容易明白了。\n\nfor 状态1 in 状态1的所有取值：\n    for 状态2 in 状态2的所有取值：\n        for ...\n            dp[状态1][状态2][...] = 择优(选择1，选择2...)\n\n\n1\n2\n3\n4\n比如说这个问题，每天都有三种「选择」：买入、卖出、无操作，我们用 buy, sell, rest 表示这三种选择。但问题是，并不是每天都可以任意选择这三种选择的，因为 sell 必须在 buy 之后，buy 必须在 sell 之后。那么 rest 操作还应该分两种状态，一种是 buy 之后的 rest（持有了股票），一种是 sell 之后的 rest（没有持有股票）。而且别忘了，我们还有交易次数 k 的限制，就是说你 buy 还只能在 k > 0 的前提下操作。\n\n很复杂对吧，不要怕，我们现在的目的只是穷举，你有再多的状态，老夫要做的就是一把梭全部列举出来。这个问题的「状态」有三个，第一个是天数，第二个是允许交易的最大次数，第三个是当前的持有状态（即之前说的 rest 的状态，我们不妨用 1 表示持有，0 表示没有持有）。然后我们用一个三维数组就可以装下这几种状态的全部组合：\n\ndp[i][k][0 or 1]\n0 <= i <= n-1, 1 <= k <= K\nn 为天数，大 K 为最多交易数\n此问题共 n × K × 2 种状态，全部穷举就能搞定。\n\nfor 0 <= i < n:\n    for 1 <= k <= K:\n        for s in {0, 1}:\n            dp[i][k][s] = max(buy, sell, rest)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n而且我们可以用自然语言描述出每一个状态的含义，比如说 dp[3][2][1] 的含义就是：今天是第三天，我现在手上持有着股票，至今最多进行 2 次交易。再比如 dp[2][3][0] 的含义：今天是第二天，我现在手上没有持有股票，至今最多进行 3 次交易。很容易理解，对吧？\n\n我们想求的最终答案是 dp[n - 1][K][0]，即最后一天，最多允许 K 次交易，最多获得多少利润。读者可能问为什么不是 dp[n - 1][K][1]？因为 [1] 代表手上还持有股票，[0] 表示手上的股票已经卖出去了，很显然后者得到的利润一定大于前者。\n\n记住如何解释「状态」，一旦你觉得哪里不好理解，把它翻译成自然语言就容易理解了。\n\n# 二、状态转移框架\n现在，我们完成了「状态」的穷举，我们开始思考每种「状态」有哪些「选择」，应该如何更新「状态」。只看「持有状态」，可以画个状态转移图。\n\n{:width=350} {:align=center}\n\n通过这个图可以很清楚地看到，每种状态（0 和 1）是如何转移而来的。根据这个图，我们来写一下状态转移方程：\n\ndp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])\n              max(   选择 rest  ,           选择 sell      )\n\n解释：今天我没有持有股票，有两种可能：\n要么是我昨天就没有持有，然后今天选择 rest，所以我今天还是没有持有；\n要么是我昨天持有股票，但是今天我 sell 了，所以我今天没有持有股票了。\n\ndp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])\n              max(   选择 rest  ,           选择 buy         )\n\n解释：今天我持有着股票，有两种可能：\n要么我昨天就持有着股票，然后今天选择 rest，所以我今天还持有着股票；\n要么我昨天本没有持有，但今天我选择 buy，所以今天我就持有股票了。\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n这个解释应该很清楚了，如果 buy，就要从利润中减去 prices[i]，如果 sell，就要给利润增加 prices[i]。今天的最大利润就是这两种可能选择中较大的那个。而且注意 k 的限制，我们在选择 buy 的时候，把 k 减小了 1，很好理解吧，当然你也可以在 sell 的时候减 1，一样的。\n\n现在，我们已经完成了动态规划中最困难的一步：状态转移方程。如果之前的内容你都可以理解，那么你已经可以秒杀所有问题了，只要套这个框架就行了。不过还差最后一点点，就是定义 base case，即最简单的情况。\n\ndp[-1][k][0] = 0\n解释：因为 i 是从 0 开始的，所以 i = -1 意味着还没有开始，这时候的利润当然是 0 。\ndp[-1][k][1] = -infinity\n解释：还没开始的时候，是不可能持有股票的，用负无穷表示这种不可能。\ndp[i][0][0] = 0\n解释：因为 k 是从 1 开始的，所以 k = 0 意味着根本不允许交易，这时候利润当然是 0 。\ndp[i][0][1] = -infinity\n解释：不允许交易的情况下，是不可能持有股票的，用负无穷表示这种不可能。\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n把上面的状态转移方程总结一下：\n\nbase case：\ndp[-1][k][0] = dp[i][0][0] = 0\ndp[-1][k][1] = dp[i][0][1] = -infinity\n\n状态转移方程：\ndp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])\ndp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])\n\n\n1\n2\n3\n4\n5\n6\n7\n读者可能会问，这个数组索引是 -1 怎么编程表示出来呢，负无穷怎么表示呢？这都是细节问题，有很多方法实现。现在完整的框架已经完成，下面开始具体化。\n\n# 三、秒杀题目\n第一题，k = 1\n\n直接套状态转移方程，根据 base case，可以做一些化简：\n\ndp[i][1][0] = max(dp[i-1][1][0], dp[i-1][1][1] + prices[i])\ndp[i][1][1] = max(dp[i-1][1][1], dp[i-1][0][0] - prices[i]) \n            = max(dp[i-1][1][1], -prices[i])\n解释：k = 0 的 base case，所以 dp[i-1][0][0] = 0。\n\n现在发现 k 都是 1，不会改变，即 k 对状态转移已经没有影响了。\n可以进行进一步化简去掉所有 k：\ndp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])\ndp[i][1] = max(dp[i-1][1], -prices[i])\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n直接写出代码：\n\nint n = prices.length;\nint[][] dp = new int[n][2];\nfor (int i = 0; i < n; i++) {\n    dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1] + prices[i]);\n    dp[i][1] = Math.max(dp[i-1][1], -prices[i]);\n}\nreturn dp[n - 1][0];\n\n\n1\n2\n3\n4\n5\n6\n7\n显然 i = 0 时 dp[i-1] 是不合法的。这是因为我们没有对 i 的 base case 进行处理。可以这样处理：\n\nfor (int i = 0; i < n; i++) {\n    if (i - 1 == -1) {\n        dp[i][0] = 0;\n        // 解释：\n        //   dp[i][0] \n        // = max(dp[-1][0], dp[-1][1] + prices[i])\n        // = max(0, -infinity + prices[i]) = 0\n        dp[i][1] = -prices[i];\n        //解释：\n        //   dp[i][1] \n        // = max(dp[-1][1], dp[-1][0] - prices[i])\n        // = max(-infinity, 0 - prices[i]) \n        // = -prices[i]\n        continue;\n    }\n    dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1] + prices[i]);\n    dp[i][1] = Math.max(dp[i-1][1], -prices[i]);\n}\nreturn dp[n - 1][0];\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n第一题就解决了，但是这样处理 base case 很麻烦，而且注意一下状态转移方程，新状态只和相邻的一个状态有关，其实不用整个 dp 数组，只需要一个变量储存相邻的那个状态就足够了，这样可以把空间复杂度降到 O(1):\n\n// k == 1\nint maxProfit_k_1(int[] prices) {\n    int n = prices.length;\n    // base case: dp[-1][0] = 0, dp[-1][1] = -infinity\n    int dp_i_0 = 0, dp_i_1 = Integer.MIN_VALUE;\n    for (int i = 0; i < n; i++) {\n        // dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])\n        dp_i_0 = Math.max(dp_i_0, dp_i_1 + prices[i]);\n        // dp[i][1] = max(dp[i-1][1], -prices[i])\n        dp_i_1 = Math.max(dp_i_1, -prices[i]);\n    }\n    return dp_i_0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n两种方式都是一样的，不过这种编程方法简洁很多。但是如果没有前面状态转移方程的引导，是肯定看不懂的。后续的题目，我主要写这种空间复杂度 O(1) 的解法。\n\n第二题，k = +infinity\n\n如果 k 为正无穷，那么就可以认为 k 和 k - 1 是一样的。可以这样改写框架：\n\ndp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])\ndp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])\n            = max(dp[i-1][k][1], dp[i-1][k][0] - prices[i])\n\n我们发现数组中的 k 已经不会改变了，也就是说不需要记录 k 这个状态了：\ndp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])\ndp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i])\n\n\n1\n2\n3\n4\n5\n6\n7\n直接翻译成代码：\n\nint maxProfit_k_inf(int[] prices) {\n    int n = prices.length;\n    int dp_i_0 = 0, dp_i_1 = Integer.MIN_VALUE;\n    for (int i = 0; i < n; i++) {\n        int temp = dp_i_0;\n        dp_i_0 = Math.max(dp_i_0, dp_i_1 + prices[i]);\n        dp_i_1 = Math.max(dp_i_1, temp - prices[i]);\n    }\n    return dp_i_0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n第三题，k = +infinity with cooldown\n\n每次 sell 之后要等一天才能继续交易。只要把这个特点融入上一题的状态转移方程即可：\n\ndp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])\ndp[i][1] = max(dp[i-1][1], dp[i-2][0] - prices[i])\n解释：第 i 天选择 buy 的时候，要从 i-2 的状态转移，而不是 i-1 。\n\n\n1\n2\n3\n翻译成代码：\n\nint maxProfit_with_cool(int[] prices) {\n    int n = prices.length;\n    int dp_i_0 = 0, dp_i_1 = Integer.MIN_VALUE;\n    int dp_pre_0 = 0; // 代表 dp[i-2][0]\n    for (int i = 0; i < n; i++) {\n        int temp = dp_i_0;\n        dp_i_0 = Math.max(dp_i_0, dp_i_1 + prices[i]);\n        dp_i_1 = Math.max(dp_i_1, dp_pre_0 - prices[i]);\n        dp_pre_0 = temp;\n    }\n    return dp_i_0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n第四题，k = +infinity with fee\n\n每次交易要支付手续费，只要把手续费从利润中减去即可。改写方程：\n\ndp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])\ndp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i] - fee)\n解释：相当于买入股票的价格升高了。\n在第一个式子里减也是一样的，相当于卖出股票的价格减小了。\n\n\n1\n2\n3\n4\n直接翻译成代码：\n\nint maxProfit_with_fee(int[] prices, int fee) {\n    int n = prices.length;\n    int dp_i_0 = 0, dp_i_1 = Integer.MIN_VALUE;\n    for (int i = 0; i < n; i++) {\n        int temp = dp_i_0;\n        dp_i_0 = Math.max(dp_i_0, dp_i_1 + prices[i]);\n        dp_i_1 = Math.max(dp_i_1, temp - prices[i] - fee);\n    }\n    return dp_i_0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n第五题，k = 2\n\nk = 2 和前面题目的情况稍微不同，因为上面的情况都和 k 的关系不太大。要么 k 是正无穷，状态转移和 k 没关系了；要么 k = 1，跟 k = 0 这个 base case 挨得近，最后也没有存在感。\n\n这道题 k = 2 和后面要讲的 k 是任意正整数的情况中，对 k 的处理就凸显出来了。我们直接写代码，边写边分析原因。\n\n原始的动态转移方程，没有可化简的地方\ndp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])\ndp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])\n\n\n1\n2\n3\n按照之前的代码，我们可能想当然这样写代码（错误的）：\n\nint k = 2;\nint[][][] dp = new int[n][k + 1][2];\nfor (int i = 0; i < n; i++)\n    if (i - 1 == -1) { /* 处理一下 base case*/ }\n    dp[i][k][0] = Math.max(dp[i-1][k][0], dp[i-1][k][1] + prices[i]);\n    dp[i][k][1] = Math.max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i]);\n}\nreturn dp[n - 1][k][0];\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n为什么错误？我这不是照着状态转移方程写的吗？\n\n还记得前面总结的「穷举框架」吗？就是说我们必须穷举所有状态。其实我们之前的解法，都在穷举所有状态，只是之前的题目中 k 都被化简掉了。这道题由于没有消掉 k 的影响，所以必须要对 k 进行穷举：\n\nint max_k = 2;\nint[][][] dp = new int[n][max_k + 1][2];\nfor (int i = 0; i < n; i++) {\n    for (int k = max_k; k >= 1; k--) {\n        if (i - 1 == -1) { \n            /* 处理 base case */\n            dp[i][k][0] = 0;\n            dp[i][k][1] = -prices[i];\n            continue;\n        }\n        dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i]);\n        dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i]);\n    }\n}\n// 穷举了 n × max_k × 2 个状态，正确。\nreturn dp[n - 1][max_k][0];\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n如果你不理解，可以返回第一点「穷举框架」重新阅读体会一下。\n\n这里 k 取值范围比较小，所以可以不用 for 循环，直接把 k = 1 和 2 的情况手动列举出来也可以：\n\ndp[i][2][0] = max(dp[i-1][2][0], dp[i-1][2][1] + prices[i])\ndp[i][2][1] = max(dp[i-1][2][1], dp[i-1][1][0] - prices[i])\ndp[i][1][0] = max(dp[i-1][1][0], dp[i-1][1][1] + prices[i])\ndp[i][1][1] = max(dp[i-1][1][1], -prices[i])\n\nint maxProfit_k_2(int[] prices) {\n    int dp_i10 = 0, dp_i11 = Integer.MIN_VALUE;\n    int dp_i20 = 0, dp_i21 = Integer.MIN_VALUE;\n    for (int price : prices) {\n        dp_i20 = Math.max(dp_i20, dp_i21 + price);\n        dp_i21 = Math.max(dp_i21, dp_i10 - price);\n        dp_i10 = Math.max(dp_i10, dp_i11 + price);\n        dp_i11 = Math.max(dp_i11, -price);\n    }\n    return dp_i20;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n有状态转移方程和含义明确的变量名指导，相信你很容易看懂。其实我们可以故弄玄虚，把上述四个变量换成 a, b, c, d。这样当别人看到你的代码时就会一头雾水，大惊失色，不得不对你肃然起敬。\n\n第六题，k = any integer\n\n有了上一题 k = 2 的铺垫，这题应该和上一题的第一个解法没啥区别。但是出现了一个超内存的错误，原来是传入的 k 值会非常大，dp 数组太大了。现在想想，交易次数 k 最多有多大呢？\n\n一次交易由买入和卖出构成，至少需要两天。所以说有效的限制 k 应该不超过 n/2，如果超过，就没有约束作用了，相当于 k = +infinity。这种情况是之前解决过的。\n\n直接把之前的代码重用：\n\nint maxProfit_k_any(int max_k, int[] prices) {\n    int n = prices.length;\n    if (max_k > n / 2) \n        return maxProfit_k_inf(prices);\n\n    int[][][] dp = new int[n][max_k + 1][2];\n    for (int i = 0; i < n; i++) \n        for (int k = max_k; k >= 1; k--) {\n            if (i - 1 == -1) { /* 处理 base case */ }\n            dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i]);\n            dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i]);     \n        }\n    return dp[n - 1][max_k][0];\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n至此，6 道题目通过一个状态转移方程全部解决。\n\n# 四、最后总结\n本文给大家讲了如何通过状态转移的方法解决复杂的问题，用一个状态转移方程秒杀了 6 道股票买卖问题，现在想想，其实也不算难对吧？这已经属于动态规划问题中较困难的了。\n\n关键就在于列举出所有可能的「状态」，然后想想怎么穷举更新这些「状态」。一般用一个多维 dp 数组储存这些状态，从 base case 开始向后推进，推进到最后的状态，就是我们想要的答案。想想这个过程，你是不是有点理解「动态规划」这个名词的意义了呢？\n\n具体到股票买卖问题，我们发现了三个状态，使用了一个三维数组，无非还是穷举 + 更新，不过我们可以说的高大上一点，这叫「三维 DP」，怕不怕？这个大实话一说，立刻显得你高人一等，名利双收有没有。\n\n所以，大家不要被各种高大上的名词吓到，再多的困难问题，奇技淫巧，也不过是基本套路的不断升级组合产生的。只要把住算法的底层原理，即可举一反三，逐个击破。\n\n买卖股票的最佳时机 [https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/solution/]\n\n买卖股票的最佳时机 II [https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/]\n\n买卖股票的最佳时机 III [https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/]\n\n买卖股票的最佳时机 IV [https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/]\n\n最佳买卖股票时机含冷冻期 [https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/]\n\n买卖股票的最佳时机含手续费 [https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/]\n\n如果本文对你有帮助，欢迎关注我的公众号 labuladong，致力于把算法问题讲清楚～ 后台回复关键词【资料】可获得我精选的经典技术书籍～\n\n{:width=400} {:align=center}\n\n最后，点击我的头像可以查看更多详细题解，希望读者多多点赞，让我感受到你的认可～\n\n推荐阅读：\n\n动态规划设计方法：归纳思想 [https://leetcode-cn.com/problems/longest-increasing-subsequence/solution/dong-tai-gui-hua-she-ji-fang-fa-zhi-pai-you-xi-jia]\n\n滑动窗口算法解决一类子串问题 [https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/solution/hua-dong-chuang-kou-tong-yong-si-xiang-jie-jue-zi-/]\n\n腾讯面试题详解：编辑距离 [https://leetcode-cn.com/problems/edit-distance/solution/bian-ji-ju-chi-mian-shi-ti-xiang-jie-by-labuladong/]\n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-09-18 22:46:51Accepted [https://leetcode-cn.com//submissions/detail/7281193/]22 ms5.06%N/Ajava2018-09-18 22:45:29Accepted [https://leetcode-cn.com//submissions/detail/7281136/]56 ms5.06%N/Ajava# 统计信息\n通过次数提交次数AC比率124292451650.7%# 相似题目\n题目难度买卖股票的最佳时机 [https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/]简单买卖股票的最佳时机 II [https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/]简单",contentLowercase:"# 中文题目\n给定一个整数数组，其中第i个元素代表了第i天的股票价格 。​\n\n设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:\n\n * 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。\n * 卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。\n\n示例:\n\n输入: [1,2,3,0,2]\n输出: 3 \n解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]\n\n# 通过代码\nclass solution {\n    public int maxprofit(int[] prices) {\n         if (prices==null || prices.length==0){\n                return 0;\n            }\n            int s0=0;\n            int s1=-prices[0];\n            int s2=integer.min_value;\n            for (int i = 1; i < prices.length; i++) {\n                int pre0=s0;\n                int pre1=s1;\n                int pre2=s2;\n                s0=math.max(pre0,pre2);\n                s1=math.max(pre0-prices[i],pre1);\n                s2=pre1+prices[i];\n            }\n            return math.max(s0,s2);\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\nclass solution {\n    public int maxprofit(int[] prices) {\n         if (prices==null || prices.length==0){\n                return 0;\n            }\n            int s0=0;\n            int s1=-prices[0];\n            int s2=integer.min_value;\n            for (int i = 1; i < prices.length; i++) {\n                int pre0=s0;\n                int pre1=s1;\n                int pre2=s2;\n                s0=math.max(pre0,pre2);\n                s1=math.max(pre0-prices[i],pre1);\n                s2=pre1+prices[i];\n            }\n            return math.max(s0,s2);\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n# 高赞题解\n很多读者抱怨股票系列问题奇技淫巧太多，如果面试真的遇到这类问题，基本不会想到那些巧妙的办法，怎么办？所以本文拒绝奇技淫巧，而是稳扎稳打，只用一种通用方法解决所用问题，以不变应万变。\n\n这篇文章用状态机的技巧来解决，可以全部提交通过。不要觉得这个名词高大上，文学词汇而已，实际上就是 dp table，看一眼就明白了。\n\n先随便抽出一道题，看看别人的解法：\n\nint maxprofit(vector<int>& prices) {\n    if(prices.empty()) return 0;\n    int s1=-prices[0],s2=int_min,s3=int_min,s4=int_min;\n        \n    for(int i=1;i<prices.size();++i) {            \n        s1 = max(s1, -prices[i]);\n        s2 = max(s2, s1+prices[i]);\n        s3 = max(s3, s2-prices[i]);\n        s4 = max(s4, s3+prices[i]);\n    }\n    return max(0,s4);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n能看懂吧？会做了吗？不可能的，你看不懂，这才正常。就算你勉强看懂了，下一个问题你还是做不出来。为什么别人能写出这么诡异却又高效的解法呢？因为这类问题是有框架的，但是人家不会告诉你的，因为一旦告诉你，你五分钟就学会了，该算法题就不再神秘，变得不堪一击了。\n\n本文就来告诉你这个框架，然后带着你一道一道秒杀。\n\n这 6 道股票买卖问题是有共性的，我们通过对第四题（限制最大交易次数为 k）的分析一道一道解决。因为第四题是一个最泛化的形式，其他的问题都是这个形式的简化。\n\n第一题是只进行一次交易，相当于 k = 1；第二题是不限交易次数，相当于 k = +infinity（正无穷）；第三题是只进行 2 次交易，相当于 k = 2；剩下两道也是不限次数，但是加了交易「冷冻期」和「手续费」的额外条件，其实就是第二题的变种，都很容易处理。\n\n# 一、穷举框架\n首先，还是一样的思路：如何穷举？这里的穷举思路和上篇文章递归的思想不太一样。\n\n递归其实是符合我们思考的逻辑的，一步步推进，遇到无法解决的就丢给递归，一不小心就做出来了，可读性还很好。缺点就是一旦出错，你也不容易找到错误出现的原因。比如上篇文章的递归解法，肯定还有计算冗余，但确实不容易找到。\n\n而这里，我们不用递归思想进行穷举，而是利用「状态」进行穷举。我们具体到每一天，看看总共有几种可能的「状态」，再找出每个「状态」对应的「选择」。我们要穷举所有「状态」，穷举的目的是根据对应的「选择」更新状态。听起来抽象，你只要记住「状态」和「选择」两个词就行，下面实操一下就很容易明白了。\n\nfor 状态1 in 状态1的所有取值：\n    for 状态2 in 状态2的所有取值：\n        for ...\n            dp[状态1][状态2][...] = 择优(选择1，选择2...)\n\n\n1\n2\n3\n4\n比如说这个问题，每天都有三种「选择」：买入、卖出、无操作，我们用 buy, sell, rest 表示这三种选择。但问题是，并不是每天都可以任意选择这三种选择的，因为 sell 必须在 buy 之后，buy 必须在 sell 之后。那么 rest 操作还应该分两种状态，一种是 buy 之后的 rest（持有了股票），一种是 sell 之后的 rest（没有持有股票）。而且别忘了，我们还有交易次数 k 的限制，就是说你 buy 还只能在 k > 0 的前提下操作。\n\n很复杂对吧，不要怕，我们现在的目的只是穷举，你有再多的状态，老夫要做的就是一把梭全部列举出来。这个问题的「状态」有三个，第一个是天数，第二个是允许交易的最大次数，第三个是当前的持有状态（即之前说的 rest 的状态，我们不妨用 1 表示持有，0 表示没有持有）。然后我们用一个三维数组就可以装下这几种状态的全部组合：\n\ndp[i][k][0 or 1]\n0 <= i <= n-1, 1 <= k <= k\nn 为天数，大 k 为最多交易数\n此问题共 n × k × 2 种状态，全部穷举就能搞定。\n\nfor 0 <= i < n:\n    for 1 <= k <= k:\n        for s in {0, 1}:\n            dp[i][k][s] = max(buy, sell, rest)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n而且我们可以用自然语言描述出每一个状态的含义，比如说 dp[3][2][1] 的含义就是：今天是第三天，我现在手上持有着股票，至今最多进行 2 次交易。再比如 dp[2][3][0] 的含义：今天是第二天，我现在手上没有持有股票，至今最多进行 3 次交易。很容易理解，对吧？\n\n我们想求的最终答案是 dp[n - 1][k][0]，即最后一天，最多允许 k 次交易，最多获得多少利润。读者可能问为什么不是 dp[n - 1][k][1]？因为 [1] 代表手上还持有股票，[0] 表示手上的股票已经卖出去了，很显然后者得到的利润一定大于前者。\n\n记住如何解释「状态」，一旦你觉得哪里不好理解，把它翻译成自然语言就容易理解了。\n\n# 二、状态转移框架\n现在，我们完成了「状态」的穷举，我们开始思考每种「状态」有哪些「选择」，应该如何更新「状态」。只看「持有状态」，可以画个状态转移图。\n\n{:width=350} {:align=center}\n\n通过这个图可以很清楚地看到，每种状态（0 和 1）是如何转移而来的。根据这个图，我们来写一下状态转移方程：\n\ndp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])\n              max(   选择 rest  ,           选择 sell      )\n\n解释：今天我没有持有股票，有两种可能：\n要么是我昨天就没有持有，然后今天选择 rest，所以我今天还是没有持有；\n要么是我昨天持有股票，但是今天我 sell 了，所以我今天没有持有股票了。\n\ndp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])\n              max(   选择 rest  ,           选择 buy         )\n\n解释：今天我持有着股票，有两种可能：\n要么我昨天就持有着股票，然后今天选择 rest，所以我今天还持有着股票；\n要么我昨天本没有持有，但今天我选择 buy，所以今天我就持有股票了。\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n这个解释应该很清楚了，如果 buy，就要从利润中减去 prices[i]，如果 sell，就要给利润增加 prices[i]。今天的最大利润就是这两种可能选择中较大的那个。而且注意 k 的限制，我们在选择 buy 的时候，把 k 减小了 1，很好理解吧，当然你也可以在 sell 的时候减 1，一样的。\n\n现在，我们已经完成了动态规划中最困难的一步：状态转移方程。如果之前的内容你都可以理解，那么你已经可以秒杀所有问题了，只要套这个框架就行了。不过还差最后一点点，就是定义 base case，即最简单的情况。\n\ndp[-1][k][0] = 0\n解释：因为 i 是从 0 开始的，所以 i = -1 意味着还没有开始，这时候的利润当然是 0 。\ndp[-1][k][1] = -infinity\n解释：还没开始的时候，是不可能持有股票的，用负无穷表示这种不可能。\ndp[i][0][0] = 0\n解释：因为 k 是从 1 开始的，所以 k = 0 意味着根本不允许交易，这时候利润当然是 0 。\ndp[i][0][1] = -infinity\n解释：不允许交易的情况下，是不可能持有股票的，用负无穷表示这种不可能。\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n把上面的状态转移方程总结一下：\n\nbase case：\ndp[-1][k][0] = dp[i][0][0] = 0\ndp[-1][k][1] = dp[i][0][1] = -infinity\n\n状态转移方程：\ndp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])\ndp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])\n\n\n1\n2\n3\n4\n5\n6\n7\n读者可能会问，这个数组索引是 -1 怎么编程表示出来呢，负无穷怎么表示呢？这都是细节问题，有很多方法实现。现在完整的框架已经完成，下面开始具体化。\n\n# 三、秒杀题目\n第一题，k = 1\n\n直接套状态转移方程，根据 base case，可以做一些化简：\n\ndp[i][1][0] = max(dp[i-1][1][0], dp[i-1][1][1] + prices[i])\ndp[i][1][1] = max(dp[i-1][1][1], dp[i-1][0][0] - prices[i]) \n            = max(dp[i-1][1][1], -prices[i])\n解释：k = 0 的 base case，所以 dp[i-1][0][0] = 0。\n\n现在发现 k 都是 1，不会改变，即 k 对状态转移已经没有影响了。\n可以进行进一步化简去掉所有 k：\ndp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])\ndp[i][1] = max(dp[i-1][1], -prices[i])\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n直接写出代码：\n\nint n = prices.length;\nint[][] dp = new int[n][2];\nfor (int i = 0; i < n; i++) {\n    dp[i][0] = math.max(dp[i-1][0], dp[i-1][1] + prices[i]);\n    dp[i][1] = math.max(dp[i-1][1], -prices[i]);\n}\nreturn dp[n - 1][0];\n\n\n1\n2\n3\n4\n5\n6\n7\n显然 i = 0 时 dp[i-1] 是不合法的。这是因为我们没有对 i 的 base case 进行处理。可以这样处理：\n\nfor (int i = 0; i < n; i++) {\n    if (i - 1 == -1) {\n        dp[i][0] = 0;\n        // 解释：\n        //   dp[i][0] \n        // = max(dp[-1][0], dp[-1][1] + prices[i])\n        // = max(0, -infinity + prices[i]) = 0\n        dp[i][1] = -prices[i];\n        //解释：\n        //   dp[i][1] \n        // = max(dp[-1][1], dp[-1][0] - prices[i])\n        // = max(-infinity, 0 - prices[i]) \n        // = -prices[i]\n        continue;\n    }\n    dp[i][0] = math.max(dp[i-1][0], dp[i-1][1] + prices[i]);\n    dp[i][1] = math.max(dp[i-1][1], -prices[i]);\n}\nreturn dp[n - 1][0];\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n第一题就解决了，但是这样处理 base case 很麻烦，而且注意一下状态转移方程，新状态只和相邻的一个状态有关，其实不用整个 dp 数组，只需要一个变量储存相邻的那个状态就足够了，这样可以把空间复杂度降到 o(1):\n\n// k == 1\nint maxprofit_k_1(int[] prices) {\n    int n = prices.length;\n    // base case: dp[-1][0] = 0, dp[-1][1] = -infinity\n    int dp_i_0 = 0, dp_i_1 = integer.min_value;\n    for (int i = 0; i < n; i++) {\n        // dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])\n        dp_i_0 = math.max(dp_i_0, dp_i_1 + prices[i]);\n        // dp[i][1] = max(dp[i-1][1], -prices[i])\n        dp_i_1 = math.max(dp_i_1, -prices[i]);\n    }\n    return dp_i_0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n两种方式都是一样的，不过这种编程方法简洁很多。但是如果没有前面状态转移方程的引导，是肯定看不懂的。后续的题目，我主要写这种空间复杂度 o(1) 的解法。\n\n第二题，k = +infinity\n\n如果 k 为正无穷，那么就可以认为 k 和 k - 1 是一样的。可以这样改写框架：\n\ndp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])\ndp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])\n            = max(dp[i-1][k][1], dp[i-1][k][0] - prices[i])\n\n我们发现数组中的 k 已经不会改变了，也就是说不需要记录 k 这个状态了：\ndp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])\ndp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i])\n\n\n1\n2\n3\n4\n5\n6\n7\n直接翻译成代码：\n\nint maxprofit_k_inf(int[] prices) {\n    int n = prices.length;\n    int dp_i_0 = 0, dp_i_1 = integer.min_value;\n    for (int i = 0; i < n; i++) {\n        int temp = dp_i_0;\n        dp_i_0 = math.max(dp_i_0, dp_i_1 + prices[i]);\n        dp_i_1 = math.max(dp_i_1, temp - prices[i]);\n    }\n    return dp_i_0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n第三题，k = +infinity with cooldown\n\n每次 sell 之后要等一天才能继续交易。只要把这个特点融入上一题的状态转移方程即可：\n\ndp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])\ndp[i][1] = max(dp[i-1][1], dp[i-2][0] - prices[i])\n解释：第 i 天选择 buy 的时候，要从 i-2 的状态转移，而不是 i-1 。\n\n\n1\n2\n3\n翻译成代码：\n\nint maxprofit_with_cool(int[] prices) {\n    int n = prices.length;\n    int dp_i_0 = 0, dp_i_1 = integer.min_value;\n    int dp_pre_0 = 0; // 代表 dp[i-2][0]\n    for (int i = 0; i < n; i++) {\n        int temp = dp_i_0;\n        dp_i_0 = math.max(dp_i_0, dp_i_1 + prices[i]);\n        dp_i_1 = math.max(dp_i_1, dp_pre_0 - prices[i]);\n        dp_pre_0 = temp;\n    }\n    return dp_i_0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n第四题，k = +infinity with fee\n\n每次交易要支付手续费，只要把手续费从利润中减去即可。改写方程：\n\ndp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])\ndp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i] - fee)\n解释：相当于买入股票的价格升高了。\n在第一个式子里减也是一样的，相当于卖出股票的价格减小了。\n\n\n1\n2\n3\n4\n直接翻译成代码：\n\nint maxprofit_with_fee(int[] prices, int fee) {\n    int n = prices.length;\n    int dp_i_0 = 0, dp_i_1 = integer.min_value;\n    for (int i = 0; i < n; i++) {\n        int temp = dp_i_0;\n        dp_i_0 = math.max(dp_i_0, dp_i_1 + prices[i]);\n        dp_i_1 = math.max(dp_i_1, temp - prices[i] - fee);\n    }\n    return dp_i_0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n第五题，k = 2\n\nk = 2 和前面题目的情况稍微不同，因为上面的情况都和 k 的关系不太大。要么 k 是正无穷，状态转移和 k 没关系了；要么 k = 1，跟 k = 0 这个 base case 挨得近，最后也没有存在感。\n\n这道题 k = 2 和后面要讲的 k 是任意正整数的情况中，对 k 的处理就凸显出来了。我们直接写代码，边写边分析原因。\n\n原始的动态转移方程，没有可化简的地方\ndp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])\ndp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])\n\n\n1\n2\n3\n按照之前的代码，我们可能想当然这样写代码（错误的）：\n\nint k = 2;\nint[][][] dp = new int[n][k + 1][2];\nfor (int i = 0; i < n; i++)\n    if (i - 1 == -1) { /* 处理一下 base case*/ }\n    dp[i][k][0] = math.max(dp[i-1][k][0], dp[i-1][k][1] + prices[i]);\n    dp[i][k][1] = math.max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i]);\n}\nreturn dp[n - 1][k][0];\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n为什么错误？我这不是照着状态转移方程写的吗？\n\n还记得前面总结的「穷举框架」吗？就是说我们必须穷举所有状态。其实我们之前的解法，都在穷举所有状态，只是之前的题目中 k 都被化简掉了。这道题由于没有消掉 k 的影响，所以必须要对 k 进行穷举：\n\nint max_k = 2;\nint[][][] dp = new int[n][max_k + 1][2];\nfor (int i = 0; i < n; i++) {\n    for (int k = max_k; k >= 1; k--) {\n        if (i - 1 == -1) { \n            /* 处理 base case */\n            dp[i][k][0] = 0;\n            dp[i][k][1] = -prices[i];\n            continue;\n        }\n        dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i]);\n        dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i]);\n    }\n}\n// 穷举了 n × max_k × 2 个状态，正确。\nreturn dp[n - 1][max_k][0];\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n如果你不理解，可以返回第一点「穷举框架」重新阅读体会一下。\n\n这里 k 取值范围比较小，所以可以不用 for 循环，直接把 k = 1 和 2 的情况手动列举出来也可以：\n\ndp[i][2][0] = max(dp[i-1][2][0], dp[i-1][2][1] + prices[i])\ndp[i][2][1] = max(dp[i-1][2][1], dp[i-1][1][0] - prices[i])\ndp[i][1][0] = max(dp[i-1][1][0], dp[i-1][1][1] + prices[i])\ndp[i][1][1] = max(dp[i-1][1][1], -prices[i])\n\nint maxprofit_k_2(int[] prices) {\n    int dp_i10 = 0, dp_i11 = integer.min_value;\n    int dp_i20 = 0, dp_i21 = integer.min_value;\n    for (int price : prices) {\n        dp_i20 = math.max(dp_i20, dp_i21 + price);\n        dp_i21 = math.max(dp_i21, dp_i10 - price);\n        dp_i10 = math.max(dp_i10, dp_i11 + price);\n        dp_i11 = math.max(dp_i11, -price);\n    }\n    return dp_i20;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n有状态转移方程和含义明确的变量名指导，相信你很容易看懂。其实我们可以故弄玄虚，把上述四个变量换成 a, b, c, d。这样当别人看到你的代码时就会一头雾水，大惊失色，不得不对你肃然起敬。\n\n第六题，k = any integer\n\n有了上一题 k = 2 的铺垫，这题应该和上一题的第一个解法没啥区别。但是出现了一个超内存的错误，原来是传入的 k 值会非常大，dp 数组太大了。现在想想，交易次数 k 最多有多大呢？\n\n一次交易由买入和卖出构成，至少需要两天。所以说有效的限制 k 应该不超过 n/2，如果超过，就没有约束作用了，相当于 k = +infinity。这种情况是之前解决过的。\n\n直接把之前的代码重用：\n\nint maxprofit_k_any(int max_k, int[] prices) {\n    int n = prices.length;\n    if (max_k > n / 2) \n        return maxprofit_k_inf(prices);\n\n    int[][][] dp = new int[n][max_k + 1][2];\n    for (int i = 0; i < n; i++) \n        for (int k = max_k; k >= 1; k--) {\n            if (i - 1 == -1) { /* 处理 base case */ }\n            dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i]);\n            dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i]);     \n        }\n    return dp[n - 1][max_k][0];\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n至此，6 道题目通过一个状态转移方程全部解决。\n\n# 四、最后总结\n本文给大家讲了如何通过状态转移的方法解决复杂的问题，用一个状态转移方程秒杀了 6 道股票买卖问题，现在想想，其实也不算难对吧？这已经属于动态规划问题中较困难的了。\n\n关键就在于列举出所有可能的「状态」，然后想想怎么穷举更新这些「状态」。一般用一个多维 dp 数组储存这些状态，从 base case 开始向后推进，推进到最后的状态，就是我们想要的答案。想想这个过程，你是不是有点理解「动态规划」这个名词的意义了呢？\n\n具体到股票买卖问题，我们发现了三个状态，使用了一个三维数组，无非还是穷举 + 更新，不过我们可以说的高大上一点，这叫「三维 dp」，怕不怕？这个大实话一说，立刻显得你高人一等，名利双收有没有。\n\n所以，大家不要被各种高大上的名词吓到，再多的困难问题，奇技淫巧，也不过是基本套路的不断升级组合产生的。只要把住算法的底层原理，即可举一反三，逐个击破。\n\n买卖股票的最佳时机 [https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/solution/]\n\n买卖股票的最佳时机 ii [https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/]\n\n买卖股票的最佳时机 iii [https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/]\n\n买卖股票的最佳时机 iv [https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/]\n\n最佳买卖股票时机含冷冻期 [https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/]\n\n买卖股票的最佳时机含手续费 [https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/]\n\n如果本文对你有帮助，欢迎关注我的公众号 labuladong，致力于把算法问题讲清楚～ 后台回复关键词【资料】可获得我精选的经典技术书籍～\n\n{:width=400} {:align=center}\n\n最后，点击我的头像可以查看更多详细题解，希望读者多多点赞，让我感受到你的认可～\n\n推荐阅读：\n\n动态规划设计方法：归纳思想 [https://leetcode-cn.com/problems/longest-increasing-subsequence/solution/dong-tai-gui-hua-she-ji-fang-fa-zhi-pai-you-xi-jia]\n\n滑动窗口算法解决一类子串问题 [https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/solution/hua-dong-chuang-kou-tong-yong-si-xiang-jie-jue-zi-/]\n\n腾讯面试题详解：编辑距离 [https://leetcode-cn.com/problems/edit-distance/solution/bian-ji-ju-chi-mian-shi-ti-xiang-jie-by-labuladong/]\n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-09-18 22:46:51accepted [https://leetcode-cn.com//submissions/detail/7281193/]22 ms5.06%n/ajava2018-09-18 22:45:29accepted [https://leetcode-cn.com//submissions/detail/7281136/]56 ms5.06%n/ajava# 统计信息\n通过次数提交次数ac比率124292451650.7%# 相似题目\n题目难度买卖股票的最佳时机 [https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/]简单买卖股票的最佳时机 ii [https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/]简单"},{title:"337-打家劫舍 III(House Robber III)",frontmatter:{title:"337-打家劫舍 III(House Robber III)",date:"2018-09-15T00:00:00.000Z",categories:["中等"],tags:["树<Tree>","深度优先搜索<Depth-first Search>"]},regularPath:"/views/%E4%B8%AD%E7%AD%89/0337-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D%20III.html",relativePath:"views/中等/0337-打家劫舍 III.md",key:"v-0d191fb0",path:"/views/%E4%B8%AD%E7%AD%89/0337-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D%20III.html",headers:[{level:2,title:"中文题目",slug:"中文题目",charIndex:2},{level:2,title:"通过代码",slug:"通过代码",charIndex:434},{level:2,title:"高赞题解",slug:"高赞题解",charIndex:2859},{level:3,title:"说明",slug:"说明",charIndex:2866},{level:3,title:"解法1-暴力递归-最优子结构",slug:"解法1-暴力递归-最优子结构",charIndex:3021},{level:3,title:"解法2-记忆化-解决重复子问题",slug:"解法2-记忆化-解决重复子问题",charIndex:4006},{level:3,title:"解法3-终极解法",slug:"解法3-终极解法",charIndex:5188},{level:3,title:"后记",slug:"后记",charIndex:6334},{level:2,title:"提交历史",slug:"提交历史",charIndex:6373},{level:2,title:"统计信息",slug:"统计信息",charIndex:6602},{level:2,title:"相似题目",slug:"相似题目",charIndex:6636}],lastUpdated:"4/11/2021, 1:15:21 PM",headersStr:"中文题目 通过代码 高赞题解 说明 解法1-暴力递归-最优子结构 解法2-记忆化-解决重复子问题 解法3-终极解法 后记 提交历史 统计信息 相似题目",content:"# 中文题目\n在上次打劫完一条街道之后和一圈房屋后，小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为“根”。 除了“根”之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。\n\n计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。\n\n示例 1:\n\n输入: [3,2,3,null,3,null,1]\n\n     3\n    / \\\n   2   3\n    \\   \\ \n     3   1\n\n输出: 7 \n解释: 小偷一晚能够盗取的最高金额 = 3 + 3 + 1 = 7.\n\n示例 2:\n\n输入: [3,4,5,1,3,null,1]\n\n     3\n    / \\\n   4   5\n  / \\   \\ \n 1   3   1\n\n输出: 9\n解释: 小偷一晚能够盗取的最高金额 = 4 + 5 = 9.\n\n\n# 通过代码\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    // 直接递归方式\n//     public int rob(TreeNode root) {\n//         if (root==null){\n//                 return 0;\n//             }\n//             int val=0;\n            \n//             if (root.left!=null){\n//                 val+=rob(root.left.left)+rob(root.left.right);\n//             }\n            \n//             if (root.right!=null){\n//                 val+=rob(root.right.left)+rob(root.right.right);\n//             }\n            \n//             return Math.max(val+root.val,rob(root.left)+rob(root.right));\n//     }\n    \n    \n    \n    //        记忆化搜索方式\n        public int rob(TreeNode root){\n            return robSub(root,new HashMap<TreeNode,Integer>());\n        }\n\n        private int robSub(TreeNode root, HashMap<TreeNode, Integer> map) {\n            if (root==null){\n                return 0;\n            }\n            if (map.containsKey(root)){\n                return map.get(root);\n            }\n            int val=0;\n            if (root.left!=null){\n                val+=robSub(root.left.left,map)+robSub(root.left.right,map);\n            }\n            if (root.right!=null){\n                val+=robSub(root.right.left,map)+robSub(root.right.right,map);\n            }\n            val=Math.max(val+root.val,robSub(root.left,map)+robSub(root.right,map));\n            map.put(root,val);\n            return val;\n        }\n \n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public int rob(TreeNode root) {\n        if (root==null){\n                return 0;\n            }\n            int val=0;\n            \n            if (root.left!=null){\n                val+=rob(root.left.left)+rob(root.left.right);\n            }\n            \n            if (root.right!=null){\n                val+=rob(root.right.left)+rob(root.right.right);\n            }\n            \n            return Math.max(val+root.val,rob(root.left)+rob(root.right));\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n# 高赞题解\n# 说明\n本题目本身就是动态规划的树形版本，通过此题解，可以了解一下树形问题在动态规划问题解法 我们通过3个方法不断递进解决问题\n\n * 解法1通过递归实现，虽然解决了问题，但是复杂度太高\n * 解法2通过解决方法1中的重复子问题，实现了性能的百倍提升\n * 解法3 直接省去了重复子问题，性能又提升了一步\n\n# 解法1-暴力递归-最优子结构\n在解法1和解法2中 我们使用爷爷-两个孩子-4个孙子来说明问题 首先来定义这个问题的状态 爷爷节点获取到最大的偷取的钱数呢\n\n 1. 首先要明确相邻的节点不能偷，也就是爷爷选择偷，儿子就不能偷了，但是孙子可以偷\n 2. 二叉树只有左右两个孩子，一个爷爷最多2个儿子,4个孙子\n\n根据以上条件，我们可以得出单个节点的钱该怎么算 ** 4个孙子偷的钱 + 爷爷的钱 VS 两个儿子偷的钱 哪个组合钱多，就当做当前节点能偷的最大钱数。这就是动态规划里面的最优子结构**\n\n由于是二叉树，这里可以选择计算所有子节点\n\n4个孙子投的钱加上爷爷的钱如下int method1 = root.val + rob(root.left.left) + rob(root.left.right) + rob(root.right.left) + rob(root.right.right)两个儿子偷的钱如下int method2 = rob(root.left) + rob(root.right);挑选一个钱数多的方案则int result = Math.max(method1, method2);将上述方案写成代码如下\n\npublic int rob(TreeNode root) {\n    if (root == null) return 0;\n\n    int money = root.val;\n    if (root.left != null) {\n        money += (rob(root.left.left) + rob(root.left.right));\n    }\n\n    if (root.right != null) {\n        money += (rob(root.right.left) + rob(root.right.right));\n    }\n\n    return Math.max(money, rob(root.left) + rob(root.right));\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n信心满满的提交，一次通过，然而 执行用时:837 ms,在所有 java 提交中击败了24.49%的用户 这个结果太没面子了，下个解法进行优化\n\n# 解法2-记忆化-解决重复子问题\n针对解法一种速度太慢的问题，经过分析其实现，我们发现爷爷在计算自己能偷多少钱的时候，同时计算了4个孙子能偷多少钱，也计算了2个儿子能偷多少钱。这样在儿子当爷爷时，就会产生重复计算一遍孙子节点。\n\n于是乎我们发现了一个动态规划的关键优化点重复子问题我们这一步针对重复子问题进行优化，我们在做斐波那契数列时，使用的优化方案是记忆化,但是之前的问题都是使用数组解决的，把每次计算的结果都存起来，下次如果再来计算，就从缓存中取，不再计算了，这样就保证每个数字只计算一次。 由于二叉树不适合拿数组当缓存，我们这次使用哈希表来存储结果，TreeNode当做key，能偷的钱当做value\n\n解法1加上记忆化优化后代码如下\n\npublic int rob(TreeNode root) {\n    HashMap<TreeNode, Integer> memo = new HashMap<>();\n    return robInternal(root, memo);\n}\n\npublic int robInternal(TreeNode root, HashMap<TreeNode, Integer> memo) {\n    if (root == null) return 0;\n    if (memo.containsKey(root)) return memo.get(root);\n    int money = root.val;\n\n    if (root.left != null) {\n        money += (robInternal(root.left.left, memo) + robInternal(root.left.right, memo));\n    }\n    if (root.right != null) {\n        money += (robInternal(root.right.left, memo) + robInternal(root.right.right, memo));\n    }\n    int result = Math.max(money, robInternal(root.left, memo) + robInternal(root.right, memo));\n    memo.put(root, result);\n    return result;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n提交代码，执行用时 :4 ms, 在所有 java 提交中击败了54.92%的用户,速度提高了200倍。太开心了。别着急，还有一个终极方案呢，连记忆化消耗的时间都省了，能省则省么。\n\n# 解法3-终极解法\n上面两种解法用到了孙子节点，计算爷爷节点能偷的钱还要同时去计算孙子节点投的钱，虽然有了记忆化，但是还是有性能损耗。\n\n我们换一种办法来定义此问题 每个节点可选择偷或者不偷两种状态，根据题目意思，相连节点不能一起偷\n\n * 当前节点选择偷时，那么两个孩子节点就不能选择偷了\n * 当前节点选择不偷时，两个孩子节点只需要拿最多的钱出来就行(两个孩子节点偷不偷没关系)\n\n我们使用一个大小为2的数组来表示 int[] res = new int[2] 0代表不偷，1代表偷任何一个节点能偷到的最大钱的状态可以定义为\n\n 1. 当前节点选择不偷: 当前节点能偷到的最大钱数 = 左孩子能偷到的钱 + 右孩子能偷到的钱\n 2. 当前节点选择偷: 当前节点能偷到的最大钱数 = 左孩子选择自己不偷时能得到的钱 + 右孩子选择不偷时能得到的钱 + 当前节点的钱数\n\n表示为公式如下\n\nroot[0] = Math.max(rob(root.left)[0], rob(root.left)[1]) + Math.max(rob(root.right)[0], rob(root.right)[1])\nroot[1] = rob(root.left)[0] + rob(root.right)[0] + root.val;\n\n\n1\n2\n将公式做个变换就是代码啦\n\npublic int rob(TreeNode root) {\n    int[] result = robInternal(root);\n    return Math.max(result[0], result[1]);\n}\n\npublic int[] robInternal(TreeNode root) {\n    if (root == null) return new int[2];\n    int[] result = new int[2];\n\n    int[] left = robInternal(root.left);\n    int[] right = robInternal(root.right);\n\n    result[0] = Math.max(left[0], left[1]) + Math.max(right[0], right[1]);\n    result[1] = left[0] + right[0] + root.val;\n\n    return result;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n再提交一次 :执行用时1 ms, 在所有 java 提交中击败了99.87%的用户，这样的结果，我觉得可以了。\n\n# 后记\n当个现代化的小偷不容易啊，还得学习动态规划。 如有错误，欢迎指出\n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-09-15 19:43:20Accepted [https://leetcode-cn.com//submissions/detail/7140976/]12 ms39.45%N/Ajava2018-09-15 19:37:25Accepted [https://leetcode-cn.com//submissions/detail/7140797/]984 ms5.04%N/Ajava# 统计信息\n通过次数提交次数AC比率128192324155.2%# 相似题目\n题目难度打家劫舍 [https://leetcode-cn.com/problems/house-robber/]简单打家劫舍 II [https://leetcode-cn.com/problems/house-robber-ii/]中等",contentLowercase:"# 中文题目\n在上次打劫完一条街道之后和一圈房屋后，小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为“根”。 除了“根”之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。\n\n计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。\n\n示例 1:\n\n输入: [3,2,3,null,3,null,1]\n\n     3\n    / \\\n   2   3\n    \\   \\ \n     3   1\n\n输出: 7 \n解释: 小偷一晚能够盗取的最高金额 = 3 + 3 + 1 = 7.\n\n示例 2:\n\n输入: [3,4,5,1,3,null,1]\n\n     3\n    / \\\n   4   5\n  / \\   \\ \n 1   3   1\n\n输出: 9\n解释: 小偷一晚能够盗取的最高金额 = 4 + 5 = 9.\n\n\n# 通过代码\n/**\n * definition for a binary tree node.\n * public class treenode {\n *     int val;\n *     treenode left;\n *     treenode right;\n *     treenode(int x) { val = x; }\n * }\n */\nclass solution {\n    // 直接递归方式\n//     public int rob(treenode root) {\n//         if (root==null){\n//                 return 0;\n//             }\n//             int val=0;\n            \n//             if (root.left!=null){\n//                 val+=rob(root.left.left)+rob(root.left.right);\n//             }\n            \n//             if (root.right!=null){\n//                 val+=rob(root.right.left)+rob(root.right.right);\n//             }\n            \n//             return math.max(val+root.val,rob(root.left)+rob(root.right));\n//     }\n    \n    \n    \n    //        记忆化搜索方式\n        public int rob(treenode root){\n            return robsub(root,new hashmap<treenode,integer>());\n        }\n\n        private int robsub(treenode root, hashmap<treenode, integer> map) {\n            if (root==null){\n                return 0;\n            }\n            if (map.containskey(root)){\n                return map.get(root);\n            }\n            int val=0;\n            if (root.left!=null){\n                val+=robsub(root.left.left,map)+robsub(root.left.right,map);\n            }\n            if (root.right!=null){\n                val+=robsub(root.right.left,map)+robsub(root.right.right,map);\n            }\n            val=math.max(val+root.val,robsub(root.left,map)+robsub(root.right,map));\n            map.put(root,val);\n            return val;\n        }\n \n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n/**\n * definition for a binary tree node.\n * public class treenode {\n *     int val;\n *     treenode left;\n *     treenode right;\n *     treenode(int x) { val = x; }\n * }\n */\nclass solution {\n    public int rob(treenode root) {\n        if (root==null){\n                return 0;\n            }\n            int val=0;\n            \n            if (root.left!=null){\n                val+=rob(root.left.left)+rob(root.left.right);\n            }\n            \n            if (root.right!=null){\n                val+=rob(root.right.left)+rob(root.right.right);\n            }\n            \n            return math.max(val+root.val,rob(root.left)+rob(root.right));\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n# 高赞题解\n# 说明\n本题目本身就是动态规划的树形版本，通过此题解，可以了解一下树形问题在动态规划问题解法 我们通过3个方法不断递进解决问题\n\n * 解法1通过递归实现，虽然解决了问题，但是复杂度太高\n * 解法2通过解决方法1中的重复子问题，实现了性能的百倍提升\n * 解法3 直接省去了重复子问题，性能又提升了一步\n\n# 解法1-暴力递归-最优子结构\n在解法1和解法2中 我们使用爷爷-两个孩子-4个孙子来说明问题 首先来定义这个问题的状态 爷爷节点获取到最大的偷取的钱数呢\n\n 1. 首先要明确相邻的节点不能偷，也就是爷爷选择偷，儿子就不能偷了，但是孙子可以偷\n 2. 二叉树只有左右两个孩子，一个爷爷最多2个儿子,4个孙子\n\n根据以上条件，我们可以得出单个节点的钱该怎么算 ** 4个孙子偷的钱 + 爷爷的钱 vs 两个儿子偷的钱 哪个组合钱多，就当做当前节点能偷的最大钱数。这就是动态规划里面的最优子结构**\n\n由于是二叉树，这里可以选择计算所有子节点\n\n4个孙子投的钱加上爷爷的钱如下int method1 = root.val + rob(root.left.left) + rob(root.left.right) + rob(root.right.left) + rob(root.right.right)两个儿子偷的钱如下int method2 = rob(root.left) + rob(root.right);挑选一个钱数多的方案则int result = math.max(method1, method2);将上述方案写成代码如下\n\npublic int rob(treenode root) {\n    if (root == null) return 0;\n\n    int money = root.val;\n    if (root.left != null) {\n        money += (rob(root.left.left) + rob(root.left.right));\n    }\n\n    if (root.right != null) {\n        money += (rob(root.right.left) + rob(root.right.right));\n    }\n\n    return math.max(money, rob(root.left) + rob(root.right));\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n信心满满的提交，一次通过，然而 执行用时:837 ms,在所有 java 提交中击败了24.49%的用户 这个结果太没面子了，下个解法进行优化\n\n# 解法2-记忆化-解决重复子问题\n针对解法一种速度太慢的问题，经过分析其实现，我们发现爷爷在计算自己能偷多少钱的时候，同时计算了4个孙子能偷多少钱，也计算了2个儿子能偷多少钱。这样在儿子当爷爷时，就会产生重复计算一遍孙子节点。\n\n于是乎我们发现了一个动态规划的关键优化点重复子问题我们这一步针对重复子问题进行优化，我们在做斐波那契数列时，使用的优化方案是记忆化,但是之前的问题都是使用数组解决的，把每次计算的结果都存起来，下次如果再来计算，就从缓存中取，不再计算了，这样就保证每个数字只计算一次。 由于二叉树不适合拿数组当缓存，我们这次使用哈希表来存储结果，treenode当做key，能偷的钱当做value\n\n解法1加上记忆化优化后代码如下\n\npublic int rob(treenode root) {\n    hashmap<treenode, integer> memo = new hashmap<>();\n    return robinternal(root, memo);\n}\n\npublic int robinternal(treenode root, hashmap<treenode, integer> memo) {\n    if (root == null) return 0;\n    if (memo.containskey(root)) return memo.get(root);\n    int money = root.val;\n\n    if (root.left != null) {\n        money += (robinternal(root.left.left, memo) + robinternal(root.left.right, memo));\n    }\n    if (root.right != null) {\n        money += (robinternal(root.right.left, memo) + robinternal(root.right.right, memo));\n    }\n    int result = math.max(money, robinternal(root.left, memo) + robinternal(root.right, memo));\n    memo.put(root, result);\n    return result;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n提交代码，执行用时 :4 ms, 在所有 java 提交中击败了54.92%的用户,速度提高了200倍。太开心了。别着急，还有一个终极方案呢，连记忆化消耗的时间都省了，能省则省么。\n\n# 解法3-终极解法\n上面两种解法用到了孙子节点，计算爷爷节点能偷的钱还要同时去计算孙子节点投的钱，虽然有了记忆化，但是还是有性能损耗。\n\n我们换一种办法来定义此问题 每个节点可选择偷或者不偷两种状态，根据题目意思，相连节点不能一起偷\n\n * 当前节点选择偷时，那么两个孩子节点就不能选择偷了\n * 当前节点选择不偷时，两个孩子节点只需要拿最多的钱出来就行(两个孩子节点偷不偷没关系)\n\n我们使用一个大小为2的数组来表示 int[] res = new int[2] 0代表不偷，1代表偷任何一个节点能偷到的最大钱的状态可以定义为\n\n 1. 当前节点选择不偷: 当前节点能偷到的最大钱数 = 左孩子能偷到的钱 + 右孩子能偷到的钱\n 2. 当前节点选择偷: 当前节点能偷到的最大钱数 = 左孩子选择自己不偷时能得到的钱 + 右孩子选择不偷时能得到的钱 + 当前节点的钱数\n\n表示为公式如下\n\nroot[0] = math.max(rob(root.left)[0], rob(root.left)[1]) + math.max(rob(root.right)[0], rob(root.right)[1])\nroot[1] = rob(root.left)[0] + rob(root.right)[0] + root.val;\n\n\n1\n2\n将公式做个变换就是代码啦\n\npublic int rob(treenode root) {\n    int[] result = robinternal(root);\n    return math.max(result[0], result[1]);\n}\n\npublic int[] robinternal(treenode root) {\n    if (root == null) return new int[2];\n    int[] result = new int[2];\n\n    int[] left = robinternal(root.left);\n    int[] right = robinternal(root.right);\n\n    result[0] = math.max(left[0], left[1]) + math.max(right[0], right[1]);\n    result[1] = left[0] + right[0] + root.val;\n\n    return result;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n再提交一次 :执行用时1 ms, 在所有 java 提交中击败了99.87%的用户，这样的结果，我觉得可以了。\n\n# 后记\n当个现代化的小偷不容易啊，还得学习动态规划。 如有错误，欢迎指出\n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-09-15 19:43:20accepted [https://leetcode-cn.com//submissions/detail/7140976/]12 ms39.45%n/ajava2018-09-15 19:37:25accepted [https://leetcode-cn.com//submissions/detail/7140797/]984 ms5.04%n/ajava# 统计信息\n通过次数提交次数ac比率128192324155.2%# 相似题目\n题目难度打家劫舍 [https://leetcode-cn.com/problems/house-robber/]简单打家劫舍 ii [https://leetcode-cn.com/problems/house-robber-ii/]中等"},{title:"343-整数拆分(Integer Break)",frontmatter:{title:"343-整数拆分(Integer Break)",date:"2018-07-24T00:00:00.000Z",categories:["中等"],tags:["数学<Math>","动态规划<Dynamic Programming>"]},regularPath:"/views/%E4%B8%AD%E7%AD%89/0343-%E6%95%B4%E6%95%B0%E6%8B%86%E5%88%86.html",relativePath:"views/中等/0343-整数拆分.md",key:"v-4772a9c6",path:"/views/%E4%B8%AD%E7%AD%89/0343-%E6%95%B4%E6%95%B0%E6%8B%86%E5%88%86.html",headers:[{level:2,title:"中文题目",slug:"中文题目",charIndex:2},{level:2,title:"通过代码",slug:"通过代码",charIndex:192},{level:2,title:"高赞题解",slug:"高赞题解",charIndex:1960},{level:2,title:"提交历史",slug:"提交历史",charIndex:4476},{level:2,title:"统计信息",slug:"统计信息",charIndex:4802}],lastUpdated:"4/11/2021, 1:15:21 PM",headersStr:"中文题目 通过代码 高赞题解 提交历史 统计信息",content:"# 中文题目\n给定一个正整数n，将其拆分为至少两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。\n\n示例 1:\n\n输入: 2\n输出: 1\n解释: 2 = 1 + 1, 1 × 1 = 1。\n\n示例 2:\n\n输入: 10\n输出: 36\n解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36。\n\n说明: 你可以假设n不小于 2 且不大于 58。\n\n# 通过代码\nclass Solution {\n    // 自顶向下，记忆化搜索\n//     private int[] memo;\n//         public  int integerBreak(int n) {\n//             memo=new int[n+1];\n//             Arrays.fill(memo,-1);\n//             return breakInteger(n);\n//         }\n\n//        private  int breakInteger(int n) {\n//             if (n==1){\n//                 return 1;\n//             }\n//             if (memo[n]!=-1){\n//                 return memo[n];\n//             }\n//             int res=-1;\n//            for (int i = 1; i <= n-1; i++) {\n//               res=Math.max(res,Math.max(i*(n-i),i*breakInteger(n-i)));\n//            }\n//            memo[n]=res;\n//            return res;\n//        }\n     public  int integerBreak(int n) {\n           int[] memo=new int[n+1];\n           Arrays.fill(memo,-1);\n           memo[1]=1;\n           for (int i = 1; i <=n ; i++) {\n               for (int j = 1; j <i ; j++) {\n                   memo[i]=Math.max(memo[i],Math.max(j*(i-j),j*memo[i-j]));\n               }\n           }\n           return memo[n];\n       }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\nclass Solution {\n    private int[] memo;\n        public  int integerBreak(int n) {\n            memo=new int[n+1];\n            Arrays.fill(memo,-1);\n            return breakInteger(n);\n        }\n\n       private  int breakInteger(int n) {\n            if (n==1){\n                return 1;\n            }\n            if (memo[n]!=-1){\n                return memo[n];\n            }\n            int res=-1;\n           for (int i = 1; i <= n-1; i++) {\n              res=Math.max(res,Math.max(i*(n-i),i*breakInteger(n-i)));\n           }\n           memo[n]=res;\n           return res;\n       }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n# 高赞题解\n# 解题思路：\n * 首先，任何一个数字 nnn，都可以被分为有限个小数字之和 n=n1+n2+...+nMn = n_1 + n_2 + ... + n_Mn=n1​+n2​+...+nM​。\n   \n    * 根据常理： 一般这 MMM 个数字的乘积要大于原数字 nnn。\n   \n   \n * 其次，所有数字nnn 都可以通过对一个因子 xxx 求整数部分 aaa（a = n // x） 和余数部分 bbb （b = n % x）；\n   \n    * 即得出数字 nnn 由 aaa 个 xxx 和 111 个 bbb 相加而成。\n   \n   \n * 问题转化： 是否有优先级最高的因子 xxx 存在？若有，我们就可以把问题转化为求 xa∗bx^a * bxa∗b 这个表达式的最大值。\n   \n    * 例如：2=1+12 = 1 + 12=1+1，1∗1<21 * 1 < 21∗1<2，因此 222 比 1+11+11+1 更优；\n      \n      \n    * 例如：3=1+23 = 1 + 23=1+2，1∗2<31 * 2 < 31∗2<3，因此 333 比 111 和 222 更优；\n      \n      \n    * 例如：4=2+24 = 2 + 24=2+2，2∗2=42 * 2 = 42∗2=4，因此可以认为 444 与 222 等价，因此见到 444 就拆分；\n      \n      \n    * 例如：5=2+35 = 2 + 35=2+3；因为每个 555 都可以拆分为 2+32+32+3，而 2∗3=6>52 * 3 = 6 > 52∗3=6>5，因此见到 555 就拆分。\n      \n      \n    * 例如：6=3+3=2+2+26 = 3 + 3 = 2 + 2 + 26=3+3=2+2+2；因为 3∗3>2∗2∗2>63 * 3 > 2 * 2 * 2 > 63∗3>2∗2∗2>6。因此见到 666 就拆分，并且 333 是比 222 更优的因子。\n      \n      \n    * 易推出： 大数字都可以被拆分为多个小因子，以获取更大的乘积，只有 222 和 333 不需要拆分。\n      \n      n拆分乘积21+11不拆分，2 比 1+1 更优31+22不拆分，3 比 1+2 更优42+24拆分，2 与 4 等价52+36拆分63+39拆分，3+3 比 2+2+2 更优72+2+312拆分，但不能拆成 1+3+3\n   \n   \n * 观察以上枚举，我们可以列出以下贪心法则：\n   \n    * 第一优先级： 333；把数字 nnn 拆成尽可能多的 333 之和； * 特殊情况： 拆完后，如果余数是 111；则应把最后的 3+13 + 13+1 替换为 2+22 + 22+2，因为后者乘积更大；\n      \n      \n    * 第二优先级： 222；留下的余数如果是 222，则保留，不再拆为 1+11+11+1。\n   \n   \n * 算法流程：\n   \n    1. 当 n<=3n <= 3n<=3 时，按照贪心规则应直接保留原数字，但由于题目要求必须拆分，因此必须拆出一个 111，即直接返回 n−1n - 1n−1；\n    2. 求 nnn 除以 333 的整数部分 aaa 和余数部分 bbb；\n    3. 当 b==0b == 0b==0 时，直接返回 3a3^a3a；\n    4. 当 b==1b == 1b==1 时，要将一个 1+31 + 31+3 转换为 2+22+22+2，此时返回 3a−1∗23^{a-1} * 23a−1∗2；\n    5. 当 b==2b == 2b==2 时，返回 3a∗b3^a * b3a∗b。\n   \n   \n\n# 复杂度分析：\n * 时间复杂度 O(1)O(1)O(1) ： 仅有求整、求余、次方运算。 * 求整和求余运算 [https://stackoverflow.com/questions/35189851/time-complexity-of-modulo-operator-in-python]：查阅资料，提到不超过机器数的整数可以看作是 O(1)O(1)O(1) ；\n    * 次方运算 [https://stackoverflow.com/questions/32418731/java-math-powa-b-time-complexity]：查阅资料，提到不超过机器数的整数可以看作是 O(1)O(1)O(1) 。\n   \n   \n * 空间复杂度 O(1)O(1)O(1) ： a 和 b 使用常数大小额外空间。\n\n# 代码：\nclass Solution:\n    def integerBreak(self, n: int) -> int:\n        if n <= 3: return n - 1\n        a, b = n // 3, n % 3\n        if b == 0: return pow(3, a)\n        if b == 1: return pow(3, a - 1) * 4\n        return pow(3, a) * 2\n\n\n1\n2\n3\n4\n5\n6\n7\nclass Solution {\n    public int integerBreak(int n) {\n        if(n <= 3) return n - 1;\n        int a = n / 3, b = n % 3;\n        if(b == 0) return (int)Math.pow(3, a);\n        if(b == 1) return (int)Math.pow(3, a - 1) * 4;\n        return (int)Math.pow(3, a) * 2;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-07-24 08:20:20Accepted [https://leetcode-cn.com//submissions/detail/4566118/]4 ms32.99%N/Ajava2018-07-24 08:12:10Accepted [https://leetcode-cn.com//submissions/detail/4566060/]1 ms63.66%N/Ajava2018-07-24 08:10:27Wrong Answer [https://leetcode-cn.com//submissions/detail/4566051/]N/AN/AN/Ajava# 统计信息\n通过次数提交次数AC比率148222757953.7%",contentLowercase:"# 中文题目\n给定一个正整数n，将其拆分为至少两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。\n\n示例 1:\n\n输入: 2\n输出: 1\n解释: 2 = 1 + 1, 1 × 1 = 1。\n\n示例 2:\n\n输入: 10\n输出: 36\n解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36。\n\n说明: 你可以假设n不小于 2 且不大于 58。\n\n# 通过代码\nclass solution {\n    // 自顶向下，记忆化搜索\n//     private int[] memo;\n//         public  int integerbreak(int n) {\n//             memo=new int[n+1];\n//             arrays.fill(memo,-1);\n//             return breakinteger(n);\n//         }\n\n//        private  int breakinteger(int n) {\n//             if (n==1){\n//                 return 1;\n//             }\n//             if (memo[n]!=-1){\n//                 return memo[n];\n//             }\n//             int res=-1;\n//            for (int i = 1; i <= n-1; i++) {\n//               res=math.max(res,math.max(i*(n-i),i*breakinteger(n-i)));\n//            }\n//            memo[n]=res;\n//            return res;\n//        }\n     public  int integerbreak(int n) {\n           int[] memo=new int[n+1];\n           arrays.fill(memo,-1);\n           memo[1]=1;\n           for (int i = 1; i <=n ; i++) {\n               for (int j = 1; j <i ; j++) {\n                   memo[i]=math.max(memo[i],math.max(j*(i-j),j*memo[i-j]));\n               }\n           }\n           return memo[n];\n       }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\nclass solution {\n    private int[] memo;\n        public  int integerbreak(int n) {\n            memo=new int[n+1];\n            arrays.fill(memo,-1);\n            return breakinteger(n);\n        }\n\n       private  int breakinteger(int n) {\n            if (n==1){\n                return 1;\n            }\n            if (memo[n]!=-1){\n                return memo[n];\n            }\n            int res=-1;\n           for (int i = 1; i <= n-1; i++) {\n              res=math.max(res,math.max(i*(n-i),i*breakinteger(n-i)));\n           }\n           memo[n]=res;\n           return res;\n       }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n# 高赞题解\n# 解题思路：\n * 首先，任何一个数字 nnn，都可以被分为有限个小数字之和 n=n1+n2+...+nmn = n_1 + n_2 + ... + n_mn=n1​+n2​+...+nm​。\n   \n    * 根据常理： 一般这 mmm 个数字的乘积要大于原数字 nnn。\n   \n   \n * 其次，所有数字nnn 都可以通过对一个因子 xxx 求整数部分 aaa（a = n // x） 和余数部分 bbb （b = n % x）；\n   \n    * 即得出数字 nnn 由 aaa 个 xxx 和 111 个 bbb 相加而成。\n   \n   \n * 问题转化： 是否有优先级最高的因子 xxx 存在？若有，我们就可以把问题转化为求 xa∗bx^a * bxa∗b 这个表达式的最大值。\n   \n    * 例如：2=1+12 = 1 + 12=1+1，1∗1<21 * 1 < 21∗1<2，因此 222 比 1+11+11+1 更优；\n      \n      \n    * 例如：3=1+23 = 1 + 23=1+2，1∗2<31 * 2 < 31∗2<3，因此 333 比 111 和 222 更优；\n      \n      \n    * 例如：4=2+24 = 2 + 24=2+2，2∗2=42 * 2 = 42∗2=4，因此可以认为 444 与 222 等价，因此见到 444 就拆分；\n      \n      \n    * 例如：5=2+35 = 2 + 35=2+3；因为每个 555 都可以拆分为 2+32+32+3，而 2∗3=6>52 * 3 = 6 > 52∗3=6>5，因此见到 555 就拆分。\n      \n      \n    * 例如：6=3+3=2+2+26 = 3 + 3 = 2 + 2 + 26=3+3=2+2+2；因为 3∗3>2∗2∗2>63 * 3 > 2 * 2 * 2 > 63∗3>2∗2∗2>6。因此见到 666 就拆分，并且 333 是比 222 更优的因子。\n      \n      \n    * 易推出： 大数字都可以被拆分为多个小因子，以获取更大的乘积，只有 222 和 333 不需要拆分。\n      \n      n拆分乘积21+11不拆分，2 比 1+1 更优31+22不拆分，3 比 1+2 更优42+24拆分，2 与 4 等价52+36拆分63+39拆分，3+3 比 2+2+2 更优72+2+312拆分，但不能拆成 1+3+3\n   \n   \n * 观察以上枚举，我们可以列出以下贪心法则：\n   \n    * 第一优先级： 333；把数字 nnn 拆成尽可能多的 333 之和； * 特殊情况： 拆完后，如果余数是 111；则应把最后的 3+13 + 13+1 替换为 2+22 + 22+2，因为后者乘积更大；\n      \n      \n    * 第二优先级： 222；留下的余数如果是 222，则保留，不再拆为 1+11+11+1。\n   \n   \n * 算法流程：\n   \n    1. 当 n<=3n <= 3n<=3 时，按照贪心规则应直接保留原数字，但由于题目要求必须拆分，因此必须拆出一个 111，即直接返回 n−1n - 1n−1；\n    2. 求 nnn 除以 333 的整数部分 aaa 和余数部分 bbb；\n    3. 当 b==0b == 0b==0 时，直接返回 3a3^a3a；\n    4. 当 b==1b == 1b==1 时，要将一个 1+31 + 31+3 转换为 2+22+22+2，此时返回 3a−1∗23^{a-1} * 23a−1∗2；\n    5. 当 b==2b == 2b==2 时，返回 3a∗b3^a * b3a∗b。\n   \n   \n\n# 复杂度分析：\n * 时间复杂度 o(1)o(1)o(1) ： 仅有求整、求余、次方运算。 * 求整和求余运算 [https://stackoverflow.com/questions/35189851/time-complexity-of-modulo-operator-in-python]：查阅资料，提到不超过机器数的整数可以看作是 o(1)o(1)o(1) ；\n    * 次方运算 [https://stackoverflow.com/questions/32418731/java-math-powa-b-time-complexity]：查阅资料，提到不超过机器数的整数可以看作是 o(1)o(1)o(1) 。\n   \n   \n * 空间复杂度 o(1)o(1)o(1) ： a 和 b 使用常数大小额外空间。\n\n# 代码：\nclass solution:\n    def integerbreak(self, n: int) -> int:\n        if n <= 3: return n - 1\n        a, b = n // 3, n % 3\n        if b == 0: return pow(3, a)\n        if b == 1: return pow(3, a - 1) * 4\n        return pow(3, a) * 2\n\n\n1\n2\n3\n4\n5\n6\n7\nclass solution {\n    public int integerbreak(int n) {\n        if(n <= 3) return n - 1;\n        int a = n / 3, b = n % 3;\n        if(b == 0) return (int)math.pow(3, a);\n        if(b == 1) return (int)math.pow(3, a - 1) * 4;\n        return (int)math.pow(3, a) * 2;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-07-24 08:20:20accepted [https://leetcode-cn.com//submissions/detail/4566118/]4 ms32.99%n/ajava2018-07-24 08:12:10accepted [https://leetcode-cn.com//submissions/detail/4566060/]1 ms63.66%n/ajava2018-07-24 08:10:27wrong answer [https://leetcode-cn.com//submissions/detail/4566051/]n/an/an/ajava# 统计信息\n通过次数提交次数ac比率148222757953.7%"},{title:"347-前 K 个高频元素(Top K Frequent Elements)",frontmatter:{title:"347-前 K 个高频元素(Top K Frequent Elements)",date:"2018-07-17T00:00:00.000Z",categories:["中等"],tags:["堆<Heap>","哈希表<Hash Table>"]},regularPath:"/views/%E4%B8%AD%E7%AD%89/0347-%E5%89%8D%20K%20%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0.html",relativePath:"views/中等/0347-前 K 个高频元素.md",key:"v-a45ead70",path:"/views/%E4%B8%AD%E7%AD%89/0347-%E5%89%8D%20K%20%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0.html",headers:[{level:2,title:"中文题目",slug:"中文题目",charIndex:2},{level:2,title:"通过代码",slug:"通过代码",charIndex:214},{level:2,title:"官方题解",slug:"官方题解",charIndex:1251},{level:2,title:"提交历史",slug:"提交历史",charIndex:3229},{level:2,title:"统计信息",slug:"统计信息",charIndex:3358},{level:2,title:"相似题目",slug:"相似题目",charIndex:3392}],lastUpdated:"4/11/2021, 1:15:21 PM",headersStr:"中文题目 通过代码 官方题解 提交历史 统计信息 相似题目",content:'# 中文题目\n给定一个非空的整数数组，返回其中出现频率前k高的元素。\n\n示例 1:\n\n输入: nums = [1,1,1,2,2,3], k = 2\n输出: [1,2]\n\n\n示例 2:\n\n输入: nums = [1], k = 1\n输出: [1]\n\n说明：\n\n * 你可以假设给定的k总是合理的，且 1 ≤ k ≤ 数组中不相同的元素的个数。\n * 你的算法的时间复杂度必须优于 O(n log n) ,n是数组的大小。\n\n# 通过代码\nimport java.util.*;\nclass Solution {\n    public List<Integer> topKFrequent(int[] nums, int k) {\n         Map<Integer,Integer> map=new HashMap<>();\n            for (int i = 0; i < nums.length; i++) {\n                if (map.containsKey(nums[i])){\n                    map.put(nums[i],map.get(nums[i])+1);\n                }else {\n                    map.put(nums[i],1);\n                }\n            }\n            PriorityQueue<Map.Entry<Integer,Integer>> pq=new PriorityQueue<>(new Comparator<Map.Entry<Integer, Integer>>() {\n                @Override\n                public int compare(Map.Entry<Integer, Integer> o1, Map.Entry<Integer, Integer> o2) {\n                    return o2.getValue()-o1.getValue();\n                }\n            });\n            pq.addAll(map.entrySet());\n            List<Integer> list=new LinkedList<>();\n            for (int i = 0; i < k; i++) {\n                list.add(pq.poll().getKey());\n            }\n            return list;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n# 官方题解\n# 方法 1：堆\n想法\n\nk = 1 时问题很简单，线性时间内就可以解决。只需要用哈希表维护元素出现频率，每一步更新最高频元素即可。\n\n当 k > 1 就需要一个能够根据出现频率快速获取元素的数据结构，这就是优先队列。\n\n首先建立一个元素值对应出现频率的哈希表。在 Java 中使用 HashMap，但需要手工填值。在 Python 中提供一个字典结构用作哈希表和在 collections 库中的 Counter 方法去构建我们需要的哈希表。\n\n这个步骤需要 O(N)O(N)O(N) 时间其中 NNN 是列表中元素个数。\n\n第二步建立堆，堆中添加一个元素的复杂度是 O(log⁡(k))O(\\log(k))O(log(k))，要进行 NNN 次复杂度是 O(N)O(N)O(N)。\n\n最后一步是输出结果，复杂度为 O(klog⁡(k))O(k\\log(k))O(klog(k))。\n\n在 Python 中可以使用 heapq 库中的 nlargest 方法 [https://hg.python.org/cpython/file/2.7/Lib/heapq.py#l203]，可以在相同时间内完成，但只需要一行代码解决。\n\n<,,,,,,,,,,,,,>\n\nclass Solution {\n  public List<Integer> topKFrequent(int[] nums, int k) {\n    // build hash map : character and how often it appears\n    HashMap<Integer, Integer> count = new HashMap();\n    for (int n: nums) {\n      count.put(n, count.getOrDefault(n, 0) + 1);\n    }\n\n    // init heap \'the less frequent element first\'\n    PriorityQueue<Integer> heap =\n            new PriorityQueue<Integer>((n1, n2) -> count.get(n1) - count.get(n2));\n\n    // keep k top frequent elements in the heap\n    for (int n: count.keySet()) {\n      heap.add(n);\n      if (heap.size() > k)\n        heap.poll();\n    }\n\n    // build output list\n    List<Integer> top_k = new LinkedList();\n    while (!heap.isEmpty())\n      top_k.add(heap.poll());\n    Collections.reverse(top_k);\n    return top_k;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\nclass Solution:\n    def topKFrequent(self, nums, k):\n        """\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        """ \n        count = collections.Counter(nums)   \n        return heapq.nlargest(k, count.keys(), key=count.get) \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n复杂度分析\n\n * 时间复杂度：O(Nlog⁡(k))O(N\\log(k))O(Nlog(k))。Counter 方法的复杂度是 O(N)O(N)O(N)，建堆和输出的复杂度是 O(Nlog⁡(k))O(N \\log(k))O(Nlog(k))。因此总复杂度为 O(N+Nlog⁡(k))=O(Nlog⁡(k))O(N + N \\log(k)) = O(N \\log(k))O(N+Nlog(k))=O(Nlog(k))。\n * 空间复杂度：O(N)O(N)O(N)，存储哈希表的开销。\n\n注释\n\n根据复杂度分析，方法对于小 k 的情况是很优的。但是如果 k 值很大，我们可以将算法改成删除频率最低的若干个元素。\n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-07-17 20:28:56Accepted [https://leetcode-cn.com//submissions/detail/4295411/]38 ms18.57%N/Ajava# 统计信息\n通过次数提交次数AC比率325055446559.7%# 相似题目\n题目难度统计词频 [https://leetcode-cn.com/problems/word-frequency/]中等数组中的第K个最大元素 [https://leetcode-cn.com/problems/kth-largest-element-in-an-array/]中等根据字符出现频率排序 [https://leetcode-cn.com/problems/sort-characters-by-frequency/]中等分割数组为连续子序列 [https://leetcode-cn.com/problems/split-array-into-consecutive-subsequences/]中等前K个高频单词 [https://leetcode-cn.com/problems/top-k-frequent-words/]中等最接近原点的 K 个点 [https://leetcode-cn.com/problems/k-closest-points-to-origin/]中等',contentLowercase:'# 中文题目\n给定一个非空的整数数组，返回其中出现频率前k高的元素。\n\n示例 1:\n\n输入: nums = [1,1,1,2,2,3], k = 2\n输出: [1,2]\n\n\n示例 2:\n\n输入: nums = [1], k = 1\n输出: [1]\n\n说明：\n\n * 你可以假设给定的k总是合理的，且 1 ≤ k ≤ 数组中不相同的元素的个数。\n * 你的算法的时间复杂度必须优于 o(n log n) ,n是数组的大小。\n\n# 通过代码\nimport java.util.*;\nclass solution {\n    public list<integer> topkfrequent(int[] nums, int k) {\n         map<integer,integer> map=new hashmap<>();\n            for (int i = 0; i < nums.length; i++) {\n                if (map.containskey(nums[i])){\n                    map.put(nums[i],map.get(nums[i])+1);\n                }else {\n                    map.put(nums[i],1);\n                }\n            }\n            priorityqueue<map.entry<integer,integer>> pq=new priorityqueue<>(new comparator<map.entry<integer, integer>>() {\n                @override\n                public int compare(map.entry<integer, integer> o1, map.entry<integer, integer> o2) {\n                    return o2.getvalue()-o1.getvalue();\n                }\n            });\n            pq.addall(map.entryset());\n            list<integer> list=new linkedlist<>();\n            for (int i = 0; i < k; i++) {\n                list.add(pq.poll().getkey());\n            }\n            return list;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n# 官方题解\n# 方法 1：堆\n想法\n\nk = 1 时问题很简单，线性时间内就可以解决。只需要用哈希表维护元素出现频率，每一步更新最高频元素即可。\n\n当 k > 1 就需要一个能够根据出现频率快速获取元素的数据结构，这就是优先队列。\n\n首先建立一个元素值对应出现频率的哈希表。在 java 中使用 hashmap，但需要手工填值。在 python 中提供一个字典结构用作哈希表和在 collections 库中的 counter 方法去构建我们需要的哈希表。\n\n这个步骤需要 o(n)o(n)o(n) 时间其中 nnn 是列表中元素个数。\n\n第二步建立堆，堆中添加一个元素的复杂度是 o(log⁡(k))o(\\log(k))o(log(k))，要进行 nnn 次复杂度是 o(n)o(n)o(n)。\n\n最后一步是输出结果，复杂度为 o(klog⁡(k))o(k\\log(k))o(klog(k))。\n\n在 python 中可以使用 heapq 库中的 nlargest 方法 [https://hg.python.org/cpython/file/2.7/lib/heapq.py#l203]，可以在相同时间内完成，但只需要一行代码解决。\n\n<,,,,,,,,,,,,,>\n\nclass solution {\n  public list<integer> topkfrequent(int[] nums, int k) {\n    // build hash map : character and how often it appears\n    hashmap<integer, integer> count = new hashmap();\n    for (int n: nums) {\n      count.put(n, count.getordefault(n, 0) + 1);\n    }\n\n    // init heap \'the less frequent element first\'\n    priorityqueue<integer> heap =\n            new priorityqueue<integer>((n1, n2) -> count.get(n1) - count.get(n2));\n\n    // keep k top frequent elements in the heap\n    for (int n: count.keyset()) {\n      heap.add(n);\n      if (heap.size() > k)\n        heap.poll();\n    }\n\n    // build output list\n    list<integer> top_k = new linkedlist();\n    while (!heap.isempty())\n      top_k.add(heap.poll());\n    collections.reverse(top_k);\n    return top_k;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\nclass solution:\n    def topkfrequent(self, nums, k):\n        """\n        :type nums: list[int]\n        :type k: int\n        :rtype: list[int]\n        """ \n        count = collections.counter(nums)   \n        return heapq.nlargest(k, count.keys(), key=count.get) \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n复杂度分析\n\n * 时间复杂度：o(nlog⁡(k))o(n\\log(k))o(nlog(k))。counter 方法的复杂度是 o(n)o(n)o(n)，建堆和输出的复杂度是 o(nlog⁡(k))o(n \\log(k))o(nlog(k))。因此总复杂度为 o(n+nlog⁡(k))=o(nlog⁡(k))o(n + n \\log(k)) = o(n \\log(k))o(n+nlog(k))=o(nlog(k))。\n * 空间复杂度：o(n)o(n)o(n)，存储哈希表的开销。\n\n注释\n\n根据复杂度分析，方法对于小 k 的情况是很优的。但是如果 k 值很大，我们可以将算法改成删除频率最低的若干个元素。\n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-07-17 20:28:56accepted [https://leetcode-cn.com//submissions/detail/4295411/]38 ms18.57%n/ajava# 统计信息\n通过次数提交次数ac比率325055446559.7%# 相似题目\n题目难度统计词频 [https://leetcode-cn.com/problems/word-frequency/]中等数组中的第k个最大元素 [https://leetcode-cn.com/problems/kth-largest-element-in-an-array/]中等根据字符出现频率排序 [https://leetcode-cn.com/problems/sort-characters-by-frequency/]中等分割数组为连续子序列 [https://leetcode-cn.com/problems/split-array-into-consecutive-subsequences/]中等前k个高频单词 [https://leetcode-cn.com/problems/top-k-frequent-words/]中等最接近原点的 k 个点 [https://leetcode-cn.com/problems/k-closest-points-to-origin/]中等'},{title:"377-组合总和 Ⅳ(Combination Sum IV)",frontmatter:{title:"377-组合总和 Ⅳ(Combination Sum IV)",date:"2018-09-30T00:00:00.000Z",categories:["中等"],tags:["动态规划<Dynamic Programming>"]},regularPath:"/views/%E4%B8%AD%E7%AD%89/0377-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C%20%E2%85%A3.html",relativePath:"views/中等/0377-组合总和 Ⅳ.md",key:"v-fedf490e",path:"/views/%E4%B8%AD%E7%AD%89/0377-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C%20%E2%85%A3.html",headers:[{level:2,title:"中文题目",slug:"中文题目",charIndex:2},{level:2,title:"通过代码",slug:"通过代码",charIndex:319},{level:2,title:"高赞题解",slug:"高赞题解",charIndex:902},{level:3,title:"方法：动态规划",slug:"方法：动态规划",charIndex:1239},{level:3,title:"对于进阶问题的思考",slug:"对于进阶问题的思考",charIndex:3166},{level:2,title:"提交历史",slug:"提交历史",charIndex:3526},{level:2,title:"统计信息",slug:"统计信息",charIndex:3760},{level:2,title:"相似题目",slug:"相似题目",charIndex:3793}],lastUpdated:"4/11/2021, 1:15:21 PM",headersStr:"中文题目 通过代码 高赞题解 方法：动态规划 对于进阶问题的思考 提交历史 统计信息 相似题目",content:'# 中文题目\n给定一个由正整数组成且不存在重复数字的数组，找出和为给定目标正整数的组合的个数。\n\n示例:\n\n\nnums = [1, 2, 3]\ntarget = 4\n\n所有可能的组合为：\n(1, 1, 1, 1)\n(1, 1, 2)\n(1, 2, 1)\n(1, 3)\n(2, 1, 1)\n(2, 2)\n(3, 1)\n\n请注意，顺序不同的序列被视作不同的组合。\n\n因此输出为 7。\n\n\n进阶：\n如果给定的数组中含有负数会怎么样？\n问题会产生什么变化？\n我们需要在题目中添加什么限制来允许负数的出现？\n\n致谢：\n特别感谢@pbrother [https://leetcode.com/pbrother/]添加此问题并创建所有测试用例。\n\n# 通过代码\nclass Solution {\n       private int[] dp;\n\npublic int combinationSum4(int[] nums, int target) {\n    dp = new int[target + 1];\n    Arrays.fill(dp, -1);\n    dp[0] = 1;\n    return helper(nums, target);\n}\n\nprivate int helper(int[] nums, int target) {\n    if (dp[target] != -1) {\n        return dp[target];\n    }\n    int res = 0;\n    for (int i = 0; i < nums.length; i++) {\n        if (target >= nums[i]) {\n            res += helper(nums, target - nums[i]);\n        }\n    }\n    dp[target] = res;\n    return res;\n}\n    }\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n# 高赞题解\n思路分析：\n\n遇到这一类问题，脑子里能想到的常规思路大概有“搜索”、“动态规划”，因为不用得到具体的组合表示，因此“动态规划”应该、差不多就是求解这道问题的方法。\n\n“动态规划”在本质上其实还是“搜索”，并且是“记忆化搜索”。\n\n * “记忆化搜索”求解问题的方式是“从上至下”的，遇到重复的问题，查“缓存”。\n * “动态规划”求解问题的方式是“从下至上”的，正是因为“从下至上”，所以遇到“规模更大”的问题的之后，它之前的那些“规模更小”的问题都已经解决过了。因此，不需要“缓存”机制。\n\n所以，我们还是画树形图分析。\n\n\n\n很容易发现“重叠子问题”，因此，我们可以使用“动态规划”来做，如果题目问具体的解，那么用“回溯搜索”做。\n\n对上图的解释：\n\n\n\n# 方法：动态规划\n“动态规划”的两个步骤是思考“状态”以及“状态转移方程”。\n\n1、状态\n\n对于“状态”，我们首先思考能不能就用问题当中问的方式定义状态，上面递归树都画出来了。当然就用问题问的方式。\n\ndp[i] ：对于给定的由正整数组成且不存在重复数字的数组，和为 i 的组合的个数。\n\n思考输出什么？因为状态就是问题当中问的方式而定义的，因此输出就是最后一个状态 dp[n]。\n\n2、状态转移方程\n\n由上面的树形图，可以很容易地写出状态转移方程：\n\ndp[i] = sum{dp[i - num] for num in nums and if i >= num}\n\n\n1\n注意：在 000 这一点，我们定义 dp[0] = 1的，它表示如果 nums 里有一个数恰好等于 target，它单独成为 111 种可能。\n\n参考代码：\n\npublic class Solution {\n\n    /**\n     * 这里状态定义就是题目要求的，并不难，状态转移方程要动点脑子，也不难：\n     * 状态转移方程：dp[i]= dp[i - nums[0]] + dp[i - nums[1]] + dp[i - nums[2]] + ... （当 [] 里面的数 >= 0）\n     * 特别注意：dp[0] = 1，表示，如果那个硬币的面值刚刚好等于需要凑出的价值，这个就成为 1 种组合方案\n     * 再举一个具体的例子：nums=[1, 3, 4], target=7;\n     * dp[7] = dp[6] + dp[4] + dp[3]\n     * 即：7 的组合数可以由三部分组成，1 和 dp[6]，3 和 dp[4], 4 和dp[3];\n     *\n     * @param nums\n     * @param target\n     * @return\n     */\n    public int combinationSum4(int[] nums, int target) {\n        int len = nums.length;\n        if (len == 0) {\n            return 0;\n        }\n        int[] dp = new int[target + 1];\n\n        // 注意：理解这一句代码的含义\n        dp[0] = 1;\n        for (int i = 1; i <= target; i++) {\n            for (int j = 0; j < len; j++) {\n                if (i - nums[j] >= 0) {\n                    dp[i] += dp[i - nums[j]];\n                }\n            }\n        }\n        return dp[target];\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\nclass Solution:\n    def combinationSum4(self, nums, target):\n        size = len(nums)\n        if size == 0 or target <= 0:\n            return 0\n\n        dp = [0 for _ in range(target + 1)]\n        \n        # 这一步很关键，想想为什么 dp[0] 是 1\n        # 因为 0 表示空集，空集和它"前面"的元素凑成一种解法，所以是 1\n        # 这一步要加深体会\n        \n        dp[0] = 1\n\n        for i in range(1, target + 1):\n            for j in range(size):\n                if i >= nums[j]:\n                    dp[i] += dp[i - nums[j]]\n\n        return dp[-1]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n# 对于进阶问题的思考\n1、如果给定的数组中含有负数会怎么样？问题会产生什么变化？\n\n如果有负数，相当于给定数组中的元素有了更多的组合，特别是出现了一对相反数的时候，例如题目中的示例 [-4, 1, 2, 3, 4]，target = 4 的时候，-4 和 4 可以无限次地、成对添加到题目中的示例中，成为新的组合，那么这道问题就没有什么意义了。\n\n仔细思考，负数我只要不选它就行了。但由于这道问题的问法是“组合”，因此我们要保证有负数参与进来，不能够与已有的正数的组合之和为 0 即可。\n\n2、我们需要在题目中添加什么限制来允许负数的出现？\n\n * 如果有负数参与进来，不能够与已有的正数的组合之和为 0 ；\n * 或者限制负数的使用次数，设计成类似 0-1 背包问题的样子。\n\n可能有考虑不完全的地方，欢迎讨论。\n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-09-30 22:27:57Accepted [https://leetcode-cn.com//submissions/detail/7772655/]1 ms99.73%N/Ajava2018-09-30 22:27:11Time Limit Exceeded [https://leetcode-cn.com//submissions/detail/7772636/]N/AN/AN/Ajava# 统计信息\n通过次数提交次数AC比率63781560040.9%# 相似题目\n题目难度组合总和 [https://leetcode-cn.com/problems/combination-sum/]中等',contentLowercase:'# 中文题目\n给定一个由正整数组成且不存在重复数字的数组，找出和为给定目标正整数的组合的个数。\n\n示例:\n\n\nnums = [1, 2, 3]\ntarget = 4\n\n所有可能的组合为：\n(1, 1, 1, 1)\n(1, 1, 2)\n(1, 2, 1)\n(1, 3)\n(2, 1, 1)\n(2, 2)\n(3, 1)\n\n请注意，顺序不同的序列被视作不同的组合。\n\n因此输出为 7。\n\n\n进阶：\n如果给定的数组中含有负数会怎么样？\n问题会产生什么变化？\n我们需要在题目中添加什么限制来允许负数的出现？\n\n致谢：\n特别感谢@pbrother [https://leetcode.com/pbrother/]添加此问题并创建所有测试用例。\n\n# 通过代码\nclass solution {\n       private int[] dp;\n\npublic int combinationsum4(int[] nums, int target) {\n    dp = new int[target + 1];\n    arrays.fill(dp, -1);\n    dp[0] = 1;\n    return helper(nums, target);\n}\n\nprivate int helper(int[] nums, int target) {\n    if (dp[target] != -1) {\n        return dp[target];\n    }\n    int res = 0;\n    for (int i = 0; i < nums.length; i++) {\n        if (target >= nums[i]) {\n            res += helper(nums, target - nums[i]);\n        }\n    }\n    dp[target] = res;\n    return res;\n}\n    }\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n# 高赞题解\n思路分析：\n\n遇到这一类问题，脑子里能想到的常规思路大概有“搜索”、“动态规划”，因为不用得到具体的组合表示，因此“动态规划”应该、差不多就是求解这道问题的方法。\n\n“动态规划”在本质上其实还是“搜索”，并且是“记忆化搜索”。\n\n * “记忆化搜索”求解问题的方式是“从上至下”的，遇到重复的问题，查“缓存”。\n * “动态规划”求解问题的方式是“从下至上”的，正是因为“从下至上”，所以遇到“规模更大”的问题的之后，它之前的那些“规模更小”的问题都已经解决过了。因此，不需要“缓存”机制。\n\n所以，我们还是画树形图分析。\n\n\n\n很容易发现“重叠子问题”，因此，我们可以使用“动态规划”来做，如果题目问具体的解，那么用“回溯搜索”做。\n\n对上图的解释：\n\n\n\n# 方法：动态规划\n“动态规划”的两个步骤是思考“状态”以及“状态转移方程”。\n\n1、状态\n\n对于“状态”，我们首先思考能不能就用问题当中问的方式定义状态，上面递归树都画出来了。当然就用问题问的方式。\n\ndp[i] ：对于给定的由正整数组成且不存在重复数字的数组，和为 i 的组合的个数。\n\n思考输出什么？因为状态就是问题当中问的方式而定义的，因此输出就是最后一个状态 dp[n]。\n\n2、状态转移方程\n\n由上面的树形图，可以很容易地写出状态转移方程：\n\ndp[i] = sum{dp[i - num] for num in nums and if i >= num}\n\n\n1\n注意：在 000 这一点，我们定义 dp[0] = 1的，它表示如果 nums 里有一个数恰好等于 target，它单独成为 111 种可能。\n\n参考代码：\n\npublic class solution {\n\n    /**\n     * 这里状态定义就是题目要求的，并不难，状态转移方程要动点脑子，也不难：\n     * 状态转移方程：dp[i]= dp[i - nums[0]] + dp[i - nums[1]] + dp[i - nums[2]] + ... （当 [] 里面的数 >= 0）\n     * 特别注意：dp[0] = 1，表示，如果那个硬币的面值刚刚好等于需要凑出的价值，这个就成为 1 种组合方案\n     * 再举一个具体的例子：nums=[1, 3, 4], target=7;\n     * dp[7] = dp[6] + dp[4] + dp[3]\n     * 即：7 的组合数可以由三部分组成，1 和 dp[6]，3 和 dp[4], 4 和dp[3];\n     *\n     * @param nums\n     * @param target\n     * @return\n     */\n    public int combinationsum4(int[] nums, int target) {\n        int len = nums.length;\n        if (len == 0) {\n            return 0;\n        }\n        int[] dp = new int[target + 1];\n\n        // 注意：理解这一句代码的含义\n        dp[0] = 1;\n        for (int i = 1; i <= target; i++) {\n            for (int j = 0; j < len; j++) {\n                if (i - nums[j] >= 0) {\n                    dp[i] += dp[i - nums[j]];\n                }\n            }\n        }\n        return dp[target];\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\nclass solution:\n    def combinationsum4(self, nums, target):\n        size = len(nums)\n        if size == 0 or target <= 0:\n            return 0\n\n        dp = [0 for _ in range(target + 1)]\n        \n        # 这一步很关键，想想为什么 dp[0] 是 1\n        # 因为 0 表示空集，空集和它"前面"的元素凑成一种解法，所以是 1\n        # 这一步要加深体会\n        \n        dp[0] = 1\n\n        for i in range(1, target + 1):\n            for j in range(size):\n                if i >= nums[j]:\n                    dp[i] += dp[i - nums[j]]\n\n        return dp[-1]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n# 对于进阶问题的思考\n1、如果给定的数组中含有负数会怎么样？问题会产生什么变化？\n\n如果有负数，相当于给定数组中的元素有了更多的组合，特别是出现了一对相反数的时候，例如题目中的示例 [-4, 1, 2, 3, 4]，target = 4 的时候，-4 和 4 可以无限次地、成对添加到题目中的示例中，成为新的组合，那么这道问题就没有什么意义了。\n\n仔细思考，负数我只要不选它就行了。但由于这道问题的问法是“组合”，因此我们要保证有负数参与进来，不能够与已有的正数的组合之和为 0 即可。\n\n2、我们需要在题目中添加什么限制来允许负数的出现？\n\n * 如果有负数参与进来，不能够与已有的正数的组合之和为 0 ；\n * 或者限制负数的使用次数，设计成类似 0-1 背包问题的样子。\n\n可能有考虑不完全的地方，欢迎讨论。\n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-09-30 22:27:57accepted [https://leetcode-cn.com//submissions/detail/7772655/]1 ms99.73%n/ajava2018-09-30 22:27:11time limit exceeded [https://leetcode-cn.com//submissions/detail/7772636/]n/an/an/ajava# 统计信息\n通过次数提交次数ac比率63781560040.9%# 相似题目\n题目难度组合总和 [https://leetcode-cn.com/problems/combination-sum/]中等'},{title:"416-分割等和子集(Partition Equal Subset Sum)",frontmatter:{title:"416-分割等和子集(Partition Equal Subset Sum)",date:"2018-07-25T00:00:00.000Z",categories:["中等"],tags:["动态规划<Dynamic Programming>"]},regularPath:"/views/%E4%B8%AD%E7%AD%89/0416-%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86.html",relativePath:"views/中等/0416-分割等和子集.md",key:"v-b2977cb0",path:"/views/%E4%B8%AD%E7%AD%89/0416-%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86.html",headers:[{level:2,title:"中文题目",slug:"中文题目",charIndex:2},{level:2,title:"通过代码",slug:"通过代码",charIndex:235},{level:2,title:"高赞题解",slug:"高赞题解",charIndex:4824},{level:2,title:"提交历史",slug:"提交历史",charIndex:11420},{level:2,title:"统计信息",slug:"统计信息",charIndex:11746},{level:2,title:"相似题目",slug:"相似题目",charIndex:11780}],lastUpdated:"4/11/2021, 1:15:21 PM",headersStr:"中文题目 通过代码 高赞题解 提交历史 统计信息 相似题目",content:"# 中文题目\n给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。\n\n注意:\n\n 1. 每个数组中的元素不会超过 100\n 2. 数组的大小不会超过 200\n\n示例 1:\n\n输入: [1, 5, 11, 5]\n\n输出: true\n\n解释: 数组可以分割成 [1, 5, 5] 和 [11].\n\n\n\n\n示例 2:\n\n输入: [1, 2, 3, 5]\n\n输出: false\n\n解释: 数组不能分割成两个元素和相等的子集.\n\n\n\n\n# 通过代码\nclass Solution {\n//    //        memo[i][c] 表示使用索引为[0...i]的这些元素，是否可以完全填充一个容量为c的背包\n// //        -1：表示未计算，0表示不可以填充，1表示可以填充\n//         int[][] memo;\n//         public boolean canPartition(int[] nums) {\n//             int sum=0;\n//             for (int i = 0; i < nums.length; i++) {\n//                 sum+=nums[i];\n//             }\n//             if (sum%2!=0){\n//                 return false;\n//             }\n//             memo=new int[nums.length][sum/2+1];\n//             for (int i = 0; i < memo.length; i++) {\n//                 Arrays.fill(memo[i],-1);\n//             }\n// //            最多只能分割nums.length-1个，è¦åæä¸¤个æ°ç»\n//             return tryPartition(nums,nums.length-1,sum/2);\n//         }\n\n//         private boolean tryPartition(int[] nums, int index, int sum) {\n//             if (sum==0){\n//                 return true;\n//             }\n//             if (sum < 0 || index <0){\n//                 return false;\n//             }\n//             if (memo[index][sum] != -1){\n//                 return memo[index][sum]==1;\n//             }\n//             memo[index][sum]=(tryPartition(nums,index-1,sum)||tryPartition(nums,index-1,sum-nums[index]))?1:0;\n//             return memo[index][sum]==1;\n//         }\n        public boolean canPartition(int[] nums) {\n            int sum = 0;\n            for (int i = 0; i < nums.length; i++) {\n                sum += nums[i];\n            }\n            if (sum % 2 != 0) {\n                return false;\n            }\n            int n = nums.length;\n            int C = sum / 2;\n            boolean[] memo = new boolean[C+1];\n            for (int i = 0; i <= C; i++) {\n                memo[i] = (nums[0] == i); //如果nums[0] 为i的话，直接将nums[0]放进去填满背包\n            }\n            for (int i = 1; i < n; i++) {\n                for (int j = C; j >= nums[i]; j--) {\n                    memo[j] = memo[j] || memo[j - nums[i]];\n                }\n            }\n            return memo[C];\n\n        }\n\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\nclass Solution {\n   //        memo[i][c] 表示使用索引为[0...i]的这些元素，是否可以完全填充一个容量为c的背包\n//        -1：表示未计算，0表示不可以填充，1表示可以填充\n        int[][] memo;\n        public boolean canPartition(int[] nums) {\n            int sum=0;\n            for (int i = 0; i < nums.length; i++) {\n                sum+=nums[i];\n            }\n            if (sum%2!=0){\n                return false;\n            }\n            memo=new int[nums.length][sum/2+1];\n            for (int i = 0; i < memo.length; i++) {\n                Arrays.fill(memo[i],-1);\n            }\n//            最多只能分割nums.length-1个，è¦åæä¸¤个æ°ç»\n            return tryPartition(nums,nums.length-1,sum/2);\n        }\n\n        private boolean tryPartition(int[] nums, int index, int sum) {\n            if (sum==0){\n                return true;\n            }\n            if (sum < 0 || index <0){\n                return false;\n            }\n            if (memo[index][sum] != -1){\n                return memo[index][sum]==1;\n            }\n            memo[index][sum]=(tryPartition(nums,index-1,sum)||tryPartition(nums,index-1,sum-nums[index]))?1:0;\n            return memo[index][sum]==1;\n        }\n\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\nclass Solution {\n   //        memo[i][c] 表示使用索引为[0...i]的这些元素，是否可以完全填充一个容量为c的背包\n//        -1：表示未计算，0表示不可以填充，1表示可以填充\n        int[][] memo;\n        public boolean canPartition(int[] nums) {\n            int sum=0;\n            for (int i = 0; i < nums.length; i++) {\n                sum+=nums[i];\n            }\n            if (sum%2!=0){\n                return false;\n            }\n            memo=new int[nums.length][sum/2+1];\n            for (int i = 0; i < memo.length; i++) {\n                Arrays.fill(memo[i],-1);\n            }\n//            最多只能分割nums.length-1个，è¦åæä¸¤个æ°ç»\n            return tryPartition(nums,nums.length-1,sum/2);\n        }\n\n        private boolean tryPartition(int[] nums, int index, int sum) {\n            if (sum==0){\n                return true;\n            }\n            if (sum < 0 || index <0){\n                return false;\n            }\n            if (memo[index][sum] != -1){\n                return memo[index][sum]==1;\n            }\n            memo[index][sum]=(tryPartition(nums,index-1,sum)||tryPartition(nums,index-1,sum-nums[index]))?1:0;\n            return memo[index][sum]==1;\n        }\n\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n# 高赞题解\n关于 0-1 背包问题的介绍，大家可以在互联网上搜索《背包九讲》进行相关知识的学习。本题解有些地方使用了 0-1 背包问题的描述，因此会不加解释的使用“背包”、“容量”这样的名词。\n\n本题解按照动态规划的一般思考路径进行讲解，它们是：\n\n1、状态定义；\n\n2、状态转移方程；\n\n3、初始化；\n\n4、输出；\n\n5、思考状态压缩。\n\n这 5 个部分是本题解的结构。其它动态规划问题也可以按照这样的路径去思考、解释和理解。\n\n\n\n\n事实上，这是一个典型的“动态规划”问题，并且它的“原形”是“0-1 背包问题”。使用“动态规划”解决问题的思路是“以空间换时间”，“规划”这个词在英文中就是“填表格”的意思，代码执行的过程，也可以称之为“填表格”。\n\n做这道题需要做这样一个等价转换：是否可以从这个数组中挑选出一些正整数，使得这些数的和等于整个数组元素的和的一半。前提条件是：数组的和一定得是偶数，即数组的和一定得被 222 整除，这一点是特判。\n\n本题与 0-1 背包问题有一个很大的不同，即：\n\n * 0-1 背包问题选取的物品的容积总量不能超过规定的总量；\n * 本题选取的数字之和需要恰恰好等于规定的和的一半。\n\n这一点区别，决定了在初始化的时候，所有的值应该初始化为 false。 （《背包九讲》的作者在介绍 0-1 背包问题的时候，有强调过这点区别，我在这里也只是再重复一下。）\n\n作为“0-1 背包问题”，它的特点是：“每个数只能用一次”。思路是：物品一个一个选，容量也逐个放大考虑。我们实际生活中也是这样做的，尝试一个一个把候选物品放入“背包”。\n\n具体做法是：画一个 len 行，target + 1 列的表格。这里 len 是物品的个数，target 是背包的容量。len 行表示一个一个物品考虑，target + 1多出来的那 1 列，表示背包容量从 0 开始，很多时候，我们需要考虑这个容量为 0 的数值。\n\n * 状态定义：dp[i][j]表示从数组的 [0, i] 这个子区间内挑选一些正整数，每个数只能用一次，使得这些数的和恰好等于 j。\n * 状态转移方程：很多时候，状态转移方程思考的角度是“分类讨论”，对于“0-1 背包问题”而言就是“当前考虑到的数字选与不选”。\n\n1、不选择 nums[i]，如果在 [0, i - 1] 这个子区间内已经有一部分元素，使得它们的和为 j ，那么 dp[i][j] = true；\n\n2、选择 nums[i]，如果在 [0, i - 1] 这个子区间内就得找到一部分元素，使得它们的和为 j - nums[i]。\n\n状态转移方程是：\n\ndp[i][j] = dp[i - 1][j] or dp[i - 1][j - nums[i]]\n\n\n1\n一般写出状态转移方程以后，就需要考虑边界条件（一般而言也是初始化条件）。\n\n1、j - nums[i] 作为数组的下标，一定得保证大于等于 0 ，因此 nums[i] <= j； 2、注意到一种非常特殊的情况：j 恰好等于 nums[i]，即单独 nums[j] 这个数恰好等于此时“背包的容积” j，这也是符合题意的。\n\n因此完整的状态转移方程是：\n\ndp[i][j]={dp[i−1][j],至少是这个答案，如果dp[i−1][j]为真，直接计算下一个状态true,nums[i] = jdp[i−1][j−nums[i]].nums[i] < j\\text{dp}[i][j]= \\begin{cases} \\text{dp}[i - 1][j], & 至少是这个答案，如果 \\ \\text{dp}[i - 1][j] \\ 为真，直接计算下一个状态 \\\\ \\text{true}, & \\text{nums[i] = j} \\\\ \\text{dp}[i - 1][j - nums[i]]. & \\text{nums[i] < j} \\end{cases}dp[i][j]=⎩⎪⎨⎪⎧​dp[i−1][j],true,dp[i−1][j−nums[i]].​至少是这个答案，如果dp[i−1][j]为真，直接计算下一个状态nums[i] = jnums[i] < j​\n\n说明：虽然写成花括号，但是它们的关系是或者。\n\n * 初始化：dp[0][0] = false，因为是正整数，当然凑不出和为 0。\n * 输出：dp[len - 1][target]，这里 len 表示数组的长度，target 是数组的元素之和（必须是偶数）的一半。\n\n参考代码 1：\n\npublic class Solution {\n\n    public boolean canPartition(int[] nums) {\n        int len = nums.length;\n        if (len == 0) {\n            return false;\n        }\n\n        int sum = 0;\n        for (int num : nums) {\n            sum += num;\n        }\n\n        // 特判：如果是奇数，就不符合要求\n        if ((sum & 1) == 1) {\n            return false;\n        }\n\n        int target = sum / 2;\n\n        // 创建二维状态数组，行：物品索引，列：容量（包括 0）\n        boolean[][] dp = new boolean[len][target + 1];\n\n        // 先填表格第 0 行，第 1 个数只能让容积为它自己的背包恰好装满\n        if (nums[0] <= target) {\n            dp[0][nums[0]] = true;\n        }\n\n        // 再填表格后面几行\n        for (int i = 1; i < len; i++) {\n            for (int j = 0; j <= target; j++) {\n                // 直接从上一行先把结果抄下来，然后再修正\n                dp[i][j] = dp[i - 1][j];\n\n                if (nums[i] == j) {\n                    dp[i][j] = true;\n                    continue;\n                }\n                if (nums[i] < j) {\n                    dp[i][j] = dp[i - 1][j] || dp[i - 1][j - nums[i]];\n                }\n            }\n        }\n        return dp[len - 1][target];\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n复杂度分析：\n\n * 时间复杂度：O(NC)O(NC)O(NC)：这里 NNN 是数组元素的个数，CCC 是数组元素的和的一半。\n * 空间复杂度：O(NC)O(NC)O(NC)。\n\n下面是几点说明：\n\n1、修改状态数组初始化的定义：dp[0][0] = true。\n\n注意到：容量为 0 的时候，即 dp[i][0] 按照本意来说，应该设置为 false ，但是注意到状态转移方程（代码中）：\n\ndp[i][j] = dp[i - 1][j] || dp[i - 1][j - nums[i]];\n\n\n1\nj - nums[i] == 0 成立的时候，根据上面分析，就说明单独的 nums[i] 这个数就恰好能够在被分割为单独的一组，其余的数分割成为另外一组，因此，我们把初始化的 dp[i][0] 设置成为 true 在代码运行层面是完全没有问题的。\n\n2、观察状态转移方程的特点，or 的结果只要为真，表格下面所有的值都为真，因此在填表的时候，只要表格的最后一列是 true，代码就可以结束，直接返回 true 即可。\n\n参考代码 2：\n\npublic class Solution {\n\n    public boolean canPartition(int[] nums) {\n        int len = nums.length;\n        if (len == 0) {\n            return false;\n        }\n\n        int sum = 0;\n        for (int num : nums) {\n            sum += num;\n        }\n\n        if ((sum & 1) == 1) {\n            return false;\n        }\n\n        int target = sum / 2;\n\n        boolean[][] dp = new boolean[len][target + 1];\n        // 初始化成为 true 虽然不符合状态定义，但是从状态转移来说是完全可以的\n        dp[0][0] = true;\n\n        if (nums[0] <= target) {\n            dp[0][nums[0]] = true;\n        }\n\n        for (int i = 1; i < len; i++) {\n            for (int j = 0; j <= target; j++) {\n\n                dp[i][j] = dp[i - 1][j];\n\n                if (nums[i] <= j) {\n                    dp[i][j] = dp[i - 1][j] || dp[i - 1][j - nums[i]];\n                }\n            }\n\n            // 由于状态转移方程的特殊性，提前结束，可以认为是剪枝操作\n            if (dp[i][target]) {\n                return true;\n            }\n        }\n        return dp[len - 1][target];\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n复杂度分析：(同上)\n\n3、“0-1 背包问题”常规优化：“装填数组”从二维降到一维，减少空间复杂度。\n\n * 在“填表格”的时候，当前行只参考了上一行的值，因此状态数组可以只设置 222 行，使用“滚动数组”的技巧“填表格”即可；\n   \n   \n * 实际上连“滚动数组”都不必，在“填表格”的时候，当前行总是参考了它上面一行 “头顶上” 那个位置和“左上角”某个位置的值。因此，我们可以只开一个一维数组，从后向前依次填表即可。\n   \n   \n\n> 这一点第 1 次接触的时候，可能会觉得很奇怪，理解的办法是，就拿题目中的示例，画一个表格，自己模拟一遍程序是如何“填表”的行为，就很清楚为什么状态数组压缩到 1 行的时候，需要“从后前向”填表。\n\n\n * “从后向前” 写的过程中，一旦 nums[i] <= j 不满足，可以马上退出当前循环，因为后面的 j 的值肯定越来越小，没有必要继续做判断，直接进入外层循环的下一层。相当于也是一个剪枝，这一点是“从前向后”填表所不具备的。\n\n参考代码 3：只展示了状态数组压缩到一维，并且“从后向前”填表格的代码。\n\npublic class Solution {\n\n    public boolean canPartition(int[] nums) {\n        int len = nums.length;\n        if (len == 0) {\n            return false;\n        }\n\n        int sum = 0;\n        for (int num : nums) {\n            sum += num;\n        }\n\n        if ((sum & 1) == 1) {\n            return false;\n        }\n\n        int target = sum / 2;\n\n        boolean[] dp = new boolean[target + 1];\n        dp[0] = true;\n\n        if (nums[0] <= target) {\n            dp[nums[0]] = true;\n        }\n\n        for (int i = 1; i < len; i++) {\n            for (int j = target; nums[i] <= j; j--) {\n                if (dp[target]) {\n                    return true;\n                }\n\n                dp[j] = dp[j] || dp[j - nums[i]];\n            }\n        }\n        return dp[target];\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n复杂度分析：\n\n * 时间复杂度：O(NC)O(NC)O(NC)：这里 NNN 是数组元素的个数，CCC 是数组元素的和的一半。\n * 空间复杂度：O(C)O(C)O(C)：减少了物品那个维度，无论来多少个数，用一行表示状态就够了。\n\n补充说明：“0-1 背包”问题是一类非常重要的动态规划问题，一开始学习的时候，可能会觉得比较陌生，这个时候，建议要自己手动计算一下，画一个表格，模拟一遍代码的执行流程。\n\n\n\n在编写代码完成以后，把数组 dp 打印出来，看看是不是与自己手算的一样。以加深体会动态规划的设计思想：“从一个最小规模的问题开始，新问的最优解均是由比它规模还小的子问题的最优解转换得到，在求解的过程中记录每一步的结果”。\n\n\n\n\n最后思考为什么题目说是正整数，有 000 是否可以，有实数可以吗，有负数可以吗？\n\n * 000 的存在意义不大，放在哪个子集都是可以的；\n * 实数有可能是无理数，也可能是无限不循环小数，在计算整个数组元素的和的一半，要除法，然后在比较两个子集元素的和是否相等的时候，就会遇到精度的问题；\n * 再说负数，负数其实也是可以存在的，但要用到“回溯搜索”解决。\n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-07-25 08:56:20Accepted [https://leetcode-cn.com//submissions/detail/4613710/]34 ms8.77%N/Ajava2018-07-25 08:54:33Accepted [https://leetcode-cn.com//submissions/detail/4613679/]44 ms5.17%N/Ajava2018-07-24 21:25:38Accepted [https://leetcode-cn.com//submissions/detail/4602658/]47 ms5.17%N/Ajava# 统计信息\n通过次数提交次数AC比率155023495044.4%# 相似题目\n题目难度划分为k个相等的子集 [https://leetcode-cn.com/problems/partition-to-k-equal-sum-subsets/]中等",contentLowercase:"# 中文题目\n给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。\n\n注意:\n\n 1. 每个数组中的元素不会超过 100\n 2. 数组的大小不会超过 200\n\n示例 1:\n\n输入: [1, 5, 11, 5]\n\n输出: true\n\n解释: 数组可以分割成 [1, 5, 5] 和 [11].\n\n\n\n\n示例 2:\n\n输入: [1, 2, 3, 5]\n\n输出: false\n\n解释: 数组不能分割成两个元素和相等的子集.\n\n\n\n\n# 通过代码\nclass solution {\n//    //        memo[i][c] 表示使用索引为[0...i]的这些元素，是否可以完全填充一个容量为c的背包\n// //        -1：表示未计算，0表示不可以填充，1表示可以填充\n//         int[][] memo;\n//         public boolean canpartition(int[] nums) {\n//             int sum=0;\n//             for (int i = 0; i < nums.length; i++) {\n//                 sum+=nums[i];\n//             }\n//             if (sum%2!=0){\n//                 return false;\n//             }\n//             memo=new int[nums.length][sum/2+1];\n//             for (int i = 0; i < memo.length; i++) {\n//                 arrays.fill(memo[i],-1);\n//             }\n// //            最多只能分割nums.length-1个，è¦åæä¸¤个æ°ç»\n//             return trypartition(nums,nums.length-1,sum/2);\n//         }\n\n//         private boolean trypartition(int[] nums, int index, int sum) {\n//             if (sum==0){\n//                 return true;\n//             }\n//             if (sum < 0 || index <0){\n//                 return false;\n//             }\n//             if (memo[index][sum] != -1){\n//                 return memo[index][sum]==1;\n//             }\n//             memo[index][sum]=(trypartition(nums,index-1,sum)||trypartition(nums,index-1,sum-nums[index]))?1:0;\n//             return memo[index][sum]==1;\n//         }\n        public boolean canpartition(int[] nums) {\n            int sum = 0;\n            for (int i = 0; i < nums.length; i++) {\n                sum += nums[i];\n            }\n            if (sum % 2 != 0) {\n                return false;\n            }\n            int n = nums.length;\n            int c = sum / 2;\n            boolean[] memo = new boolean[c+1];\n            for (int i = 0; i <= c; i++) {\n                memo[i] = (nums[0] == i); //如果nums[0] 为i的话，直接将nums[0]放进去填满背包\n            }\n            for (int i = 1; i < n; i++) {\n                for (int j = c; j >= nums[i]; j--) {\n                    memo[j] = memo[j] || memo[j - nums[i]];\n                }\n            }\n            return memo[c];\n\n        }\n\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\nclass solution {\n   //        memo[i][c] 表示使用索引为[0...i]的这些元素，是否可以完全填充一个容量为c的背包\n//        -1：表示未计算，0表示不可以填充，1表示可以填充\n        int[][] memo;\n        public boolean canpartition(int[] nums) {\n            int sum=0;\n            for (int i = 0; i < nums.length; i++) {\n                sum+=nums[i];\n            }\n            if (sum%2!=0){\n                return false;\n            }\n            memo=new int[nums.length][sum/2+1];\n            for (int i = 0; i < memo.length; i++) {\n                arrays.fill(memo[i],-1);\n            }\n//            最多只能分割nums.length-1个，è¦åæä¸¤个æ°ç»\n            return trypartition(nums,nums.length-1,sum/2);\n        }\n\n        private boolean trypartition(int[] nums, int index, int sum) {\n            if (sum==0){\n                return true;\n            }\n            if (sum < 0 || index <0){\n                return false;\n            }\n            if (memo[index][sum] != -1){\n                return memo[index][sum]==1;\n            }\n            memo[index][sum]=(trypartition(nums,index-1,sum)||trypartition(nums,index-1,sum-nums[index]))?1:0;\n            return memo[index][sum]==1;\n        }\n\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\nclass solution {\n   //        memo[i][c] 表示使用索引为[0...i]的这些元素，是否可以完全填充一个容量为c的背包\n//        -1：表示未计算，0表示不可以填充，1表示可以填充\n        int[][] memo;\n        public boolean canpartition(int[] nums) {\n            int sum=0;\n            for (int i = 0; i < nums.length; i++) {\n                sum+=nums[i];\n            }\n            if (sum%2!=0){\n                return false;\n            }\n            memo=new int[nums.length][sum/2+1];\n            for (int i = 0; i < memo.length; i++) {\n                arrays.fill(memo[i],-1);\n            }\n//            最多只能分割nums.length-1个，è¦åæä¸¤个æ°ç»\n            return trypartition(nums,nums.length-1,sum/2);\n        }\n\n        private boolean trypartition(int[] nums, int index, int sum) {\n            if (sum==0){\n                return true;\n            }\n            if (sum < 0 || index <0){\n                return false;\n            }\n            if (memo[index][sum] != -1){\n                return memo[index][sum]==1;\n            }\n            memo[index][sum]=(trypartition(nums,index-1,sum)||trypartition(nums,index-1,sum-nums[index]))?1:0;\n            return memo[index][sum]==1;\n        }\n\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n# 高赞题解\n关于 0-1 背包问题的介绍，大家可以在互联网上搜索《背包九讲》进行相关知识的学习。本题解有些地方使用了 0-1 背包问题的描述，因此会不加解释的使用“背包”、“容量”这样的名词。\n\n本题解按照动态规划的一般思考路径进行讲解，它们是：\n\n1、状态定义；\n\n2、状态转移方程；\n\n3、初始化；\n\n4、输出；\n\n5、思考状态压缩。\n\n这 5 个部分是本题解的结构。其它动态规划问题也可以按照这样的路径去思考、解释和理解。\n\n\n\n\n事实上，这是一个典型的“动态规划”问题，并且它的“原形”是“0-1 背包问题”。使用“动态规划”解决问题的思路是“以空间换时间”，“规划”这个词在英文中就是“填表格”的意思，代码执行的过程，也可以称之为“填表格”。\n\n做这道题需要做这样一个等价转换：是否可以从这个数组中挑选出一些正整数，使得这些数的和等于整个数组元素的和的一半。前提条件是：数组的和一定得是偶数，即数组的和一定得被 222 整除，这一点是特判。\n\n本题与 0-1 背包问题有一个很大的不同，即：\n\n * 0-1 背包问题选取的物品的容积总量不能超过规定的总量；\n * 本题选取的数字之和需要恰恰好等于规定的和的一半。\n\n这一点区别，决定了在初始化的时候，所有的值应该初始化为 false。 （《背包九讲》的作者在介绍 0-1 背包问题的时候，有强调过这点区别，我在这里也只是再重复一下。）\n\n作为“0-1 背包问题”，它的特点是：“每个数只能用一次”。思路是：物品一个一个选，容量也逐个放大考虑。我们实际生活中也是这样做的，尝试一个一个把候选物品放入“背包”。\n\n具体做法是：画一个 len 行，target + 1 列的表格。这里 len 是物品的个数，target 是背包的容量。len 行表示一个一个物品考虑，target + 1多出来的那 1 列，表示背包容量从 0 开始，很多时候，我们需要考虑这个容量为 0 的数值。\n\n * 状态定义：dp[i][j]表示从数组的 [0, i] 这个子区间内挑选一些正整数，每个数只能用一次，使得这些数的和恰好等于 j。\n * 状态转移方程：很多时候，状态转移方程思考的角度是“分类讨论”，对于“0-1 背包问题”而言就是“当前考虑到的数字选与不选”。\n\n1、不选择 nums[i]，如果在 [0, i - 1] 这个子区间内已经有一部分元素，使得它们的和为 j ，那么 dp[i][j] = true；\n\n2、选择 nums[i]，如果在 [0, i - 1] 这个子区间内就得找到一部分元素，使得它们的和为 j - nums[i]。\n\n状态转移方程是：\n\ndp[i][j] = dp[i - 1][j] or dp[i - 1][j - nums[i]]\n\n\n1\n一般写出状态转移方程以后，就需要考虑边界条件（一般而言也是初始化条件）。\n\n1、j - nums[i] 作为数组的下标，一定得保证大于等于 0 ，因此 nums[i] <= j； 2、注意到一种非常特殊的情况：j 恰好等于 nums[i]，即单独 nums[j] 这个数恰好等于此时“背包的容积” j，这也是符合题意的。\n\n因此完整的状态转移方程是：\n\ndp[i][j]={dp[i−1][j],至少是这个答案，如果dp[i−1][j]为真，直接计算下一个状态true,nums[i] = jdp[i−1][j−nums[i]].nums[i] < j\\text{dp}[i][j]= \\begin{cases} \\text{dp}[i - 1][j], & 至少是这个答案，如果 \\ \\text{dp}[i - 1][j] \\ 为真，直接计算下一个状态 \\\\ \\text{true}, & \\text{nums[i] = j} \\\\ \\text{dp}[i - 1][j - nums[i]]. & \\text{nums[i] < j} \\end{cases}dp[i][j]=⎩⎪⎨⎪⎧​dp[i−1][j],true,dp[i−1][j−nums[i]].​至少是这个答案，如果dp[i−1][j]为真，直接计算下一个状态nums[i] = jnums[i] < j​\n\n说明：虽然写成花括号，但是它们的关系是或者。\n\n * 初始化：dp[0][0] = false，因为是正整数，当然凑不出和为 0。\n * 输出：dp[len - 1][target]，这里 len 表示数组的长度，target 是数组的元素之和（必须是偶数）的一半。\n\n参考代码 1：\n\npublic class solution {\n\n    public boolean canpartition(int[] nums) {\n        int len = nums.length;\n        if (len == 0) {\n            return false;\n        }\n\n        int sum = 0;\n        for (int num : nums) {\n            sum += num;\n        }\n\n        // 特判：如果是奇数，就不符合要求\n        if ((sum & 1) == 1) {\n            return false;\n        }\n\n        int target = sum / 2;\n\n        // 创建二维状态数组，行：物品索引，列：容量（包括 0）\n        boolean[][] dp = new boolean[len][target + 1];\n\n        // 先填表格第 0 行，第 1 个数只能让容积为它自己的背包恰好装满\n        if (nums[0] <= target) {\n            dp[0][nums[0]] = true;\n        }\n\n        // 再填表格后面几行\n        for (int i = 1; i < len; i++) {\n            for (int j = 0; j <= target; j++) {\n                // 直接从上一行先把结果抄下来，然后再修正\n                dp[i][j] = dp[i - 1][j];\n\n                if (nums[i] == j) {\n                    dp[i][j] = true;\n                    continue;\n                }\n                if (nums[i] < j) {\n                    dp[i][j] = dp[i - 1][j] || dp[i - 1][j - nums[i]];\n                }\n            }\n        }\n        return dp[len - 1][target];\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n复杂度分析：\n\n * 时间复杂度：o(nc)o(nc)o(nc)：这里 nnn 是数组元素的个数，ccc 是数组元素的和的一半。\n * 空间复杂度：o(nc)o(nc)o(nc)。\n\n下面是几点说明：\n\n1、修改状态数组初始化的定义：dp[0][0] = true。\n\n注意到：容量为 0 的时候，即 dp[i][0] 按照本意来说，应该设置为 false ，但是注意到状态转移方程（代码中）：\n\ndp[i][j] = dp[i - 1][j] || dp[i - 1][j - nums[i]];\n\n\n1\nj - nums[i] == 0 成立的时候，根据上面分析，就说明单独的 nums[i] 这个数就恰好能够在被分割为单独的一组，其余的数分割成为另外一组，因此，我们把初始化的 dp[i][0] 设置成为 true 在代码运行层面是完全没有问题的。\n\n2、观察状态转移方程的特点，or 的结果只要为真，表格下面所有的值都为真，因此在填表的时候，只要表格的最后一列是 true，代码就可以结束，直接返回 true 即可。\n\n参考代码 2：\n\npublic class solution {\n\n    public boolean canpartition(int[] nums) {\n        int len = nums.length;\n        if (len == 0) {\n            return false;\n        }\n\n        int sum = 0;\n        for (int num : nums) {\n            sum += num;\n        }\n\n        if ((sum & 1) == 1) {\n            return false;\n        }\n\n        int target = sum / 2;\n\n        boolean[][] dp = new boolean[len][target + 1];\n        // 初始化成为 true 虽然不符合状态定义，但是从状态转移来说是完全可以的\n        dp[0][0] = true;\n\n        if (nums[0] <= target) {\n            dp[0][nums[0]] = true;\n        }\n\n        for (int i = 1; i < len; i++) {\n            for (int j = 0; j <= target; j++) {\n\n                dp[i][j] = dp[i - 1][j];\n\n                if (nums[i] <= j) {\n                    dp[i][j] = dp[i - 1][j] || dp[i - 1][j - nums[i]];\n                }\n            }\n\n            // 由于状态转移方程的特殊性，提前结束，可以认为是剪枝操作\n            if (dp[i][target]) {\n                return true;\n            }\n        }\n        return dp[len - 1][target];\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n复杂度分析：(同上)\n\n3、“0-1 背包问题”常规优化：“装填数组”从二维降到一维，减少空间复杂度。\n\n * 在“填表格”的时候，当前行只参考了上一行的值，因此状态数组可以只设置 222 行，使用“滚动数组”的技巧“填表格”即可；\n   \n   \n * 实际上连“滚动数组”都不必，在“填表格”的时候，当前行总是参考了它上面一行 “头顶上” 那个位置和“左上角”某个位置的值。因此，我们可以只开一个一维数组，从后向前依次填表即可。\n   \n   \n\n> 这一点第 1 次接触的时候，可能会觉得很奇怪，理解的办法是，就拿题目中的示例，画一个表格，自己模拟一遍程序是如何“填表”的行为，就很清楚为什么状态数组压缩到 1 行的时候，需要“从后前向”填表。\n\n\n * “从后向前” 写的过程中，一旦 nums[i] <= j 不满足，可以马上退出当前循环，因为后面的 j 的值肯定越来越小，没有必要继续做判断，直接进入外层循环的下一层。相当于也是一个剪枝，这一点是“从前向后”填表所不具备的。\n\n参考代码 3：只展示了状态数组压缩到一维，并且“从后向前”填表格的代码。\n\npublic class solution {\n\n    public boolean canpartition(int[] nums) {\n        int len = nums.length;\n        if (len == 0) {\n            return false;\n        }\n\n        int sum = 0;\n        for (int num : nums) {\n            sum += num;\n        }\n\n        if ((sum & 1) == 1) {\n            return false;\n        }\n\n        int target = sum / 2;\n\n        boolean[] dp = new boolean[target + 1];\n        dp[0] = true;\n\n        if (nums[0] <= target) {\n            dp[nums[0]] = true;\n        }\n\n        for (int i = 1; i < len; i++) {\n            for (int j = target; nums[i] <= j; j--) {\n                if (dp[target]) {\n                    return true;\n                }\n\n                dp[j] = dp[j] || dp[j - nums[i]];\n            }\n        }\n        return dp[target];\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n复杂度分析：\n\n * 时间复杂度：o(nc)o(nc)o(nc)：这里 nnn 是数组元素的个数，ccc 是数组元素的和的一半。\n * 空间复杂度：o(c)o(c)o(c)：减少了物品那个维度，无论来多少个数，用一行表示状态就够了。\n\n补充说明：“0-1 背包”问题是一类非常重要的动态规划问题，一开始学习的时候，可能会觉得比较陌生，这个时候，建议要自己手动计算一下，画一个表格，模拟一遍代码的执行流程。\n\n\n\n在编写代码完成以后，把数组 dp 打印出来，看看是不是与自己手算的一样。以加深体会动态规划的设计思想：“从一个最小规模的问题开始，新问的最优解均是由比它规模还小的子问题的最优解转换得到，在求解的过程中记录每一步的结果”。\n\n\n\n\n最后思考为什么题目说是正整数，有 000 是否可以，有实数可以吗，有负数可以吗？\n\n * 000 的存在意义不大，放在哪个子集都是可以的；\n * 实数有可能是无理数，也可能是无限不循环小数，在计算整个数组元素的和的一半，要除法，然后在比较两个子集元素的和是否相等的时候，就会遇到精度的问题；\n * 再说负数，负数其实也是可以存在的，但要用到“回溯搜索”解决。\n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-07-25 08:56:20accepted [https://leetcode-cn.com//submissions/detail/4613710/]34 ms8.77%n/ajava2018-07-25 08:54:33accepted [https://leetcode-cn.com//submissions/detail/4613679/]44 ms5.17%n/ajava2018-07-24 21:25:38accepted [https://leetcode-cn.com//submissions/detail/4602658/]47 ms5.17%n/ajava# 统计信息\n通过次数提交次数ac比率155023495044.4%# 相似题目\n题目难度划分为k个相等的子集 [https://leetcode-cn.com/problems/partition-to-k-equal-sum-subsets/]中等"},{title:"435-无重叠区间(Non-overlapping Intervals)",frontmatter:{title:"435-无重叠区间(Non-overlapping Intervals)",date:"2018-07-25T00:00:00.000Z",categories:["中等"],tags:["贪心算法<Greedy>"]},regularPath:"/views/%E4%B8%AD%E7%AD%89/0435-%E6%97%A0%E9%87%8D%E5%8F%A0%E5%8C%BA%E9%97%B4.html",relativePath:"views/中等/0435-无重叠区间.md",key:"v-4b6669ef",path:"/views/%E4%B8%AD%E7%AD%89/0435-%E6%97%A0%E9%87%8D%E5%8F%A0%E5%8C%BA%E9%97%B4.html",headers:[{level:2,title:"中文题目",slug:"中文题目",charIndex:2},{level:2,title:"通过代码",slug:"通过代码",charIndex:338},{level:2,title:"官方题解",slug:"官方题解",charIndex:4366},{level:2,title:"提交历史",slug:"提交历史",charIndex:12664},{level:2,title:"统计信息",slug:"统计信息",charIndex:13090},{level:2,title:"相似题目",slug:"相似题目",charIndex:13123}],lastUpdated:"4/11/2021, 1:15:21 PM",headersStr:"中文题目 通过代码 官方题解 提交历史 统计信息 相似题目",content:"# 中文题目\n给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。\n\n注意:\n\n 1. 可以认为区间的终点总是大于它的起点。\n 2. 区间 [1,2] 和 [2,3] 的边界相互“接触”，但没有相互重叠。\n\n示例 1:\n\n\n输入: [ [1,2], [2,3], [3,4], [1,3] ]\n\n输出: 1\n\n解释: 移除 [1,3] 后，剩下的区间没有重叠。\n\n\n示例 2:\n\n\n输入: [ [1,2], [1,2], [1,2] ]\n\n输出: 2\n\n解释: 你需要移除两个 [1,2] 来使剩下的区间没有重叠。\n\n\n示例 3:\n\n\n输入: [ [1,2], [2,3] ]\n\n输出: 0\n\n解释: 你不需要移除任何区间，因为它们已经是无重叠的了。\n\n\n# 通过代码\n/**\n * Definition for an interval.\n * public class Interval {\n *     int start;\n *     int end;\n *     Interval() { start = 0; end = 0; }\n *     Interval(int s, int e) { start = s; end = e; }\n * }\n */\nimport java.util.Arrays;\nimport java.util.Comparator;\nclass Solution {\n//      public int eraseOverlapIntervals(Interval[] intervals) {\n//            if (intervals.length==0 || intervals.length==1){\n//                 return 0;\n//             }\n//             Arrays.sort(intervals,new Cmp());\n//             int[] meno= new int[intervals.length + 1];\n//                      Arrays.fill(meno,1);\n\n//             for (int i = 1; i < intervals.length; i++) {\n//                 for (int j = 0; j < i; j++) {\n//                     if (intervals[i].start>=intervals[j].end){\n//                         meno[i]=Math.max(meno[i],1+meno[j]);\n//                     }\n//                 }\n//             }\n//             int res=0;\n//             for (int i = 0; i < meno.length; i++) {\n//                 res=Math.max(res,meno[i]);\n//             }\n//             return intervals.length-res;\n//         }\n\n//         class Cmp implements Comparator<Interval>{\n\n//            @Override\n//             public int compare(Interval o1, Interval o2) {\n//                 if (o1.start != o2.start){\n//                     return o1.start - o2.start;\n//                 }else {\n//                     return o1.end - o2.end;\n//                 }\n//             }\n//         }\n    public int eraseOverlapIntervals(Interval[] intervals) {\n            if (intervals.length==0 || intervals.length==1){\n                return 0;\n            }\n            Arrays.sort(intervals,new Cmp());\n            int res=1;\n            int pre=0;\n            for (int i = 1; i < intervals.length; i++) {\n                if (intervals[i].start>=intervals[pre].end){\n                    pre=i;\n                    res++;\n                }\n            }\n            return intervals.length-res;\n        }\n\n        class Cmp implements Comparator<Interval>{\n\n            @Override\n            public int compare(Interval o1, Interval o2) {\n                if (o1.end != o2.end){\n                    return o1.end - o2.end;\n                }else {\n                    return o1.start - o2.start;\n                }\n            }\n        }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n/**\n * Definition for an interval.\n * public class Interval {\n *     int start;\n *     int end;\n *     Interval() { start = 0; end = 0; }\n *     Interval(int s, int e) { start = s; end = e; }\n * }\n */\nimport java.util.Arrays;\nimport java.util.Comparator;\nclass Solution {\n     public int eraseOverlapIntervals(Interval[] intervals) {\n           if (intervals.length==0 || intervals.length==1){\n                return 0;\n            }\n            Arrays.sort(intervals,new Cmp());\n            int[] meno= new int[intervals.length + 1];\n                     Arrays.fill(meno,1);\n\n            for (int i = 1; i < intervals.length; i++) {\n                for (int j = 0; j < i; j++) {\n                    if (intervals[i].start>=intervals[j].end){\n                        meno[i]=Math.max(meno[i],1+meno[j]);\n                    }\n                }\n            }\n            int res=0;\n            for (int i = 0; i < meno.length; i++) {\n                res=Math.max(res,meno[i]);\n            }\n            return intervals.length-res;\n        }\n\n        class Cmp implements Comparator<Interval>{\n\n           @Override\n            public int compare(Interval o1, Interval o2) {\n                if (o1.start != o2.start){\n                    return o1.start - o2.start;\n                }else {\n                    return o1.end - o2.end;\n                }\n            }\n        }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n# 官方题解\n# 方法一：暴力法 【超时】\n在暴力法中，我们尝试删除不同组合中的重叠间隔，然后检查哪个组合需要最少的删除次数。为此，我们首先根据起始点对区间进行排序。接着，我们使用递归函数 eraseOverlapIntervals，它使用上一个区间 prevprevprev 的下标和当前区间 currcurrcurr （我们试图不移除）的下标作为参数，返回从当前下标开始需要移除的区间个数。\n\n我们从 prev=−1prev=-1prev=−1 和 curr=0curr=0curr=0 开始。在每次递归调用中，检测当前的区间是否与上一个区间重叠。若不重叠，则不将当前区间从最终列表中移除，以 prev=currprev=currprev=curr 和 curr=curr+1curr=curr + 1curr=curr+1 调用函数 eraseOverlapIntervals。函数调用的结果存储在 takentakentaken 变量中。\n\n另一方面，我们也将当前区间移除调用递归，因为本区间可能和后面的区间重叠，因此移除本区间可能会导致更少的区间移除。于是，参数为 prev=prevprev=prevprev=prev 和 curr=curr+1curr=curr + 1curr=curr+1。由于我们移除了一个区间，最后的结果应该是函数的返回值再加上 1，存储在 notTakennotTakennotTaken 变量中。当返回某个特定下标对应的移除数时，返回 takentakentaken 和 notTakennotTakennotTaken 中的较小值。\n\npublic class Solution {\n    class myComparator implements Comparator<Interval> {\n        public int compare(Interval a, Interval b) {\n            return a.start - b.start;\n        }\n    }\n    public int eraseOverlapIntervals(Interval[] intervals) {\n        Arrays.sort(intervals, new myComparator());\n        return erase_Overlap_Intervals(-1, 0, intervals);\n    }\n    public int erase_Overlap_Intervals(int prev, int curr, Interval[] intervals) {\n        if (curr == intervals.length) {\n            return 0;\n        }\n        int taken = Integer.MAX_VALUE, nottaken;\n        if (prev == -1 || intervals[prev].end <= intervals[curr].start) {\n            taken = erase_Overlap_Intervals(curr, curr + 1, intervals);\n        }\n        nottaken = erase_Overlap_Intervals(prev, curr + 1, intervals) + 1;\n        return Math.min(taken, nottaken);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n复杂度分析\n\n * 时间复杂度：O(2n)O(2^n)O(2n)。总共可能的组合数为 2n2^n2n。\n * 空间复杂度：O(n)O(n)O(n)。 递归的深度为 nnn。\n\n\n\n\n# 方法二：从起始点的动态规划 【通过】\n算法\n\n如果我们按照起始点对区间进行排序，可以很大程度上简化问题。一旦完成之后，我们就可以使用一个 dpdpdp 数组，其中 dp[i]dp[i]dp[i] 存储着只考虑到 第i个第i个第i个 区间范围内（包括其本身），最大可能的区间数。现在，当计算 dp[i+1]dp[i+1]dp[i+1] 时，我们不能只考虑 dp[i]dp[i]dp[i] 的值，因为前面的 iii 个区间都可能与 第 i+1i+1i+1 个区间发生重叠。因此，我们需要考虑能够使得 j≤ij \\leq ij≤i 且与第 i+1i+1i+1 个区间不发生重叠的所有 dp[j]dp[j]dp[j] 中的最大值。状态转移方程如下：\n\ndp[i+1]=max⁡(dp[j])+1,dp[i+1]= \\max(dp[j]) + 1,dp[i+1]=max(dp[j])+1,\n\n其中对于所有 j≤ij \\leq ij≤i ，第 i 个和第 j 个区间不发生重叠。\n\n最后，为了计算最终列表中区间的最大区间数量，我们需要找到 dpdpdp 数组中的最大值。最终的结果为区间的总数减去刚刚的结果 (intervals.length−ansintervals.length-ansintervals.length−ans)。\n\n下面的动画展示了算法的流程：\n\n<,,,,,,,,,,,,,,,,,,,,,,,,,,>\n\npublic class Solution {\n    class myComparator implements Comparator<Interval> {\n        public int compare(Interval a, Interval b) {\n            return a.start - b.start;\n        }\n    }\n    public boolean isOverlapping(Interval i, Interval j) {\n        return i.end > j.start;\n    }\n    public int eraseOverlapIntervals(Interval[] intervals) {\n        if (intervals.length == 0) {\n            return 0;\n        }\n        Arrays.sort(intervals, new myComparator());\n        int dp[] = new int[intervals.length];\n        dp[0] = 1;\n        int ans = 1;\n        for (int i = 1; i < dp.length; i++) {\n            int max = 0;\n            for (int j = i - 1; j >= 0; j--) {\n                if (!isOverlapping(intervals[j], intervals[i])) {\n                    max = Math.max(dp[j], max);\n                }\n            }\n            dp[i] = max + 1;\n            ans = Math.max(ans, dp[i]);\n\n        }\n        return intervals.length - ans;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n复杂度分析\n\n * 时间复杂度 : O(n2)O(n^2)O(n2)。需要两重循环。\n   \n   \n * 空间复杂度 : O(n)O(n)O(n)。 dpdpdp 数组占用的空间。\n   \n   \n\n\n\n\n# 方法三：从终点的动态规划 【通过】\n算法\n\n在上面讨论过的 DP 算法中，为了计算每个 dp[i]dp[i]dp[i] 的值，我们需要遍历 dpdpdp 数组，直到起始索引。如果我们使用根据终点排序的列表，则可以去除这一开销。我们依然使用 dpdpdp 数组，其中 dp[i]dp[i]dp[i] 用于存储存储着只考虑到 第i个第i个第i个 区间范围内（包括其本身），最大可能的区间数。为了计算 dp[i+1]dp[i+1]dp[i+1] ，考虑两种情况:\n\n情况一\n\n> 第 i+1i+1i+1 个区间对应的区间需要被包括在最终列表中以达到删除区间最少:\n\n\n在这种情况下，我们需要从第 i+1i + 1i+1 到开头遍历区间数组，寻找第一个不重叠的区间。这是由于，如果我们要包含当前区间，我们就需要移除所有和当前区间重叠的区间。但我们不需要每次都回到开头，相反，我们可以在找到第一个不重叠的区间后停止遍历，并用 dp[j]+1dp[j] + 1dp[j]+1 填入 dp[i+1]dp[i+1]dp[i+1] ，因为 dp[j]dp[j]dp[j] 是存储 直到第 jjj 个区间范围内最大区间数的元素。\n\n情况二\n\n> 第 i+1i+1i+1 个区间对应的区间需要被移除以达到删除区间最少：\n\n\n在这种情况下，当前元素不会被包括在最终列表中。因此，考虑到第 i+1i+1i+1 个区间的最大数量和 只考虑到 iii 个的相同。因此，我们用 dp[i]dp[i]dp[i] 的值填充 dp[i+1]dp[i+1]dp[i+1]。\n\n最终 dp[i+1]dp[i+1]dp[i+1] 的值为上述两值中较大的。\n\n最终的结果为区间的总数减去 dpdpdp 数组的最大值。下面的动画展示了算法过程：\n\n<,,,,,,,,,,,,,,,,,,,,,,>\n\npublic class Solution {\n    class myComparator implements Comparator<Interval> {\n        public int compare(Interval a, Interval b) {\n            return a.end - b.end;\n        }\n    }\n    public boolean isOverlapping(Interval i, Interval j) {\n        return i.end > j.start;\n    }\n    public int eraseOverlapIntervals(Interval[] intervals) {\n        if (intervals.length == 0) {\n            return 0;\n        }\n        Arrays.sort(intervals, new myComparator());\n        int dp[] = new int[intervals.length];\n        dp[0] = 1;\n        int ans = 1;\n        for (int i = 1; i < dp.length; i++) {\n            int max = 0;\n            for (int j = i - 1; j >= 0; j--) {\n                if (!isOverlapping(intervals[j], intervals[i])) {\n                    max = Math.max(dp[j], max);\n                    break;\n                }\n            }\n            dp[i] = Math.max(max + 1, dp[i - 1]);\n            ans = Math.max(ans, dp[i]);\n        }\n        return intervals.length - ans;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n复杂度分析\n\n * 时间复杂度 : O(n2)O(n^2)O(n2)。需要两重循环。\n   \n   \n * 空间复杂度 : O(n)O(n)O(n)。 dpdpdp 数组占用的空间。\n   \n   \n\n\n\n\n####方法四：从起点的贪心算法 【通过】\n\n算法\n\n如果我们按照起点对区间进行排序，贪心算法就可以起到很好的效果。当按照起点先后顺序考虑区间的时候。我们利用一个 prevprevprev 指针追踪刚刚添加到最终列表中的区间。遍历的时候，可能遇到图中的三种情况：\n\n\n\n情况一\n\n> 当前考虑的两个区间不重叠：\n\n\n在这种情况下，不移除任何区间，将 prevprevprev 赋值为后面的区间，移除区间数量不变。\n\n情况二\n\n> 两个区间重叠，后一个区间的终点在前一个区间的终点之前。\n\n\n这种情况下，我们可以简单地只用后一个区间。这是显然的，因为后一个区间的长度更小，可以留下更多的空间（AAA 和 BBB），容纳更多的区间。因此， prevprevprev 更新为当前区间，移除区间的数量 + 1。\n\n情况三\n\n> 两个区间重叠，后一个区间的终点在前一个区间的终点之后。\n\n\n这种情况下，我们用贪心策略处理问题，直接移除后一个区间。为了理解这种做法的正确性，请看下图，该图包含了所有可能的情况。从图可以清楚地看出，选择前移区间总会得到更好的结果。因此，prevprevprev 不变，移除区间的数量 + 1。\n\n\n\npublic class Solution {\n    class myComparator implements Comparator<Interval> {\n        public int compare(Interval a, Interval b) {\n            return a.start - b.start;\n        }\n    }\n    public int eraseOverlapIntervals(Interval[] intervals) {\n        if (intervals.length == 0) {\n            return 0;\n        }\n        Arrays.sort(intervals, new myComparator());\n        int end = intervals[0].end, prev = 0, count = 0;\n        for (int i = 1; i < intervals.length; i++) {\n            if (intervals[prev].end > intervals[i].start) {\n                if (intervals[prev].end > intervals[i].end) {\n                    prev = i;\n                }\n                count++;\n            } else {\n                prev = i;\n            }\n        }\n        return count;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n复杂度分析\n\n * 时间复杂度：O(nlog⁡(n))O\\big(n \\log(n)\\big)O(nlog(n))。排序需要O(nlog⁡(n))O\\big(n \\log(n)\\big)O(nlog(n)) 的时间。\n   \n   \n * 空间复杂度：O(1)O(1)O(1)。不需要额外空间。\n   \n   \n\n\n\n\n# 方法五：从终点的贪心算法 【通过】\n算法\n\n上面讨论的贪心算法是根据起点进行贪心选择。而在本方法中，我们根据终点进行贪心选择。为此，我首先根据终点对区间进行排序。接着，对排好序的区间进行遍历。在遍历的过程中，若没有区间重叠，就不移除任何区间。如果存在重叠，就直接删除掉当前区间。\n\n为了解释这种做法，我们继续对每种可能情况进行讨论。\n\n\n\n情况一\n\n> 当前考虑的两个区间不重叠：\n\n\n在这种情况下，不移除任何区间，将 prevprevprev 赋值为后面的区间。\n\nCase 2:\n\n> 两个区间重叠，当前区间的终点在前一个区间的终点之后。\n\n\n在这种情况下，如图所示，前一个区间是当前区间的真子集。因此，移除当前区间可以给别的区间更多的容纳空间。因此，保留前一个区间不变，更新当前区间。Case 3:\n\n> 两个区间重叠，当前区间的终点在前一个区间的终点之前。\n\n\n在这种情况下，出现了唯一有可能移除前一个区间的机会，因为移除前一个区间可以带来 AAA 的额外空间。然而，类似于上图的 3a 和 3b，此时也不应该移除前一个区间。然而，移除当前区间却可以带来 BBB 的额外空间。因此，保留前一个区间不变，更新当前区间。\n\npublic class Solution {\n    class myComparator implements Comparator<Interval> {\n        public int compare(Interval a, Interval b) {\n            return a.end - b.end;\n        }\n    }\n    public int eraseOverlapIntervals(Interval[] intervals) {\n        if (intervals.length == 0) {\n            return 0;\n        }\n        Arrays.sort(intervals, new myComparator());\n        int end = intervals[0].end;\n        int count = 1;\n        for (int i = 1; i < intervals.length; i++) {\n            if (intervals[i].start >= end) {\n                end = intervals[i].end;\n                count++;\n            }\n        }\n        return intervals.length - count;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n复杂度分析\n\n * 时间复杂度：O(nlog⁡(n))O\\big(n \\log(n)\\big)O(nlog(n))。排序需要O(nlog⁡(n))O\\big(n \\log(n)\\big)O(nlog(n)) 的时间。\n   \n   \n * 空间复杂度：O(1)O(1)O(1)。不需要额外空间。\n   \n   \n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-07-25 21:15:29Accepted [https://leetcode-cn.com//submissions/detail/4649730/]13 ms16.65%N/Ajava2018-07-25 21:09:46Accepted [https://leetcode-cn.com//submissions/detail/4649460/]167 ms5.1%N/Ajava2018-07-25 21:04:57Wrong Answer [https://leetcode-cn.com//submissions/detail/4649241/]N/AN/AN/Ajava2018-07-25 21:00:57Wrong Answer [https://leetcode-cn.com//submissions/detail/4649036/]N/AN/AN/Ajava# 统计信息\n通过次数提交次数AC比率70791610843.9%# 相似题目\n题目难度用最少数量的箭引爆气球 [https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons/]中等",contentLowercase:"# 中文题目\n给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。\n\n注意:\n\n 1. 可以认为区间的终点总是大于它的起点。\n 2. 区间 [1,2] 和 [2,3] 的边界相互“接触”，但没有相互重叠。\n\n示例 1:\n\n\n输入: [ [1,2], [2,3], [3,4], [1,3] ]\n\n输出: 1\n\n解释: 移除 [1,3] 后，剩下的区间没有重叠。\n\n\n示例 2:\n\n\n输入: [ [1,2], [1,2], [1,2] ]\n\n输出: 2\n\n解释: 你需要移除两个 [1,2] 来使剩下的区间没有重叠。\n\n\n示例 3:\n\n\n输入: [ [1,2], [2,3] ]\n\n输出: 0\n\n解释: 你不需要移除任何区间，因为它们已经是无重叠的了。\n\n\n# 通过代码\n/**\n * definition for an interval.\n * public class interval {\n *     int start;\n *     int end;\n *     interval() { start = 0; end = 0; }\n *     interval(int s, int e) { start = s; end = e; }\n * }\n */\nimport java.util.arrays;\nimport java.util.comparator;\nclass solution {\n//      public int eraseoverlapintervals(interval[] intervals) {\n//            if (intervals.length==0 || intervals.length==1){\n//                 return 0;\n//             }\n//             arrays.sort(intervals,new cmp());\n//             int[] meno= new int[intervals.length + 1];\n//                      arrays.fill(meno,1);\n\n//             for (int i = 1; i < intervals.length; i++) {\n//                 for (int j = 0; j < i; j++) {\n//                     if (intervals[i].start>=intervals[j].end){\n//                         meno[i]=math.max(meno[i],1+meno[j]);\n//                     }\n//                 }\n//             }\n//             int res=0;\n//             for (int i = 0; i < meno.length; i++) {\n//                 res=math.max(res,meno[i]);\n//             }\n//             return intervals.length-res;\n//         }\n\n//         class cmp implements comparator<interval>{\n\n//            @override\n//             public int compare(interval o1, interval o2) {\n//                 if (o1.start != o2.start){\n//                     return o1.start - o2.start;\n//                 }else {\n//                     return o1.end - o2.end;\n//                 }\n//             }\n//         }\n    public int eraseoverlapintervals(interval[] intervals) {\n            if (intervals.length==0 || intervals.length==1){\n                return 0;\n            }\n            arrays.sort(intervals,new cmp());\n            int res=1;\n            int pre=0;\n            for (int i = 1; i < intervals.length; i++) {\n                if (intervals[i].start>=intervals[pre].end){\n                    pre=i;\n                    res++;\n                }\n            }\n            return intervals.length-res;\n        }\n\n        class cmp implements comparator<interval>{\n\n            @override\n            public int compare(interval o1, interval o2) {\n                if (o1.end != o2.end){\n                    return o1.end - o2.end;\n                }else {\n                    return o1.start - o2.start;\n                }\n            }\n        }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n/**\n * definition for an interval.\n * public class interval {\n *     int start;\n *     int end;\n *     interval() { start = 0; end = 0; }\n *     interval(int s, int e) { start = s; end = e; }\n * }\n */\nimport java.util.arrays;\nimport java.util.comparator;\nclass solution {\n     public int eraseoverlapintervals(interval[] intervals) {\n           if (intervals.length==0 || intervals.length==1){\n                return 0;\n            }\n            arrays.sort(intervals,new cmp());\n            int[] meno= new int[intervals.length + 1];\n                     arrays.fill(meno,1);\n\n            for (int i = 1; i < intervals.length; i++) {\n                for (int j = 0; j < i; j++) {\n                    if (intervals[i].start>=intervals[j].end){\n                        meno[i]=math.max(meno[i],1+meno[j]);\n                    }\n                }\n            }\n            int res=0;\n            for (int i = 0; i < meno.length; i++) {\n                res=math.max(res,meno[i]);\n            }\n            return intervals.length-res;\n        }\n\n        class cmp implements comparator<interval>{\n\n           @override\n            public int compare(interval o1, interval o2) {\n                if (o1.start != o2.start){\n                    return o1.start - o2.start;\n                }else {\n                    return o1.end - o2.end;\n                }\n            }\n        }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n# 官方题解\n# 方法一：暴力法 【超时】\n在暴力法中，我们尝试删除不同组合中的重叠间隔，然后检查哪个组合需要最少的删除次数。为此，我们首先根据起始点对区间进行排序。接着，我们使用递归函数 eraseoverlapintervals，它使用上一个区间 prevprevprev 的下标和当前区间 currcurrcurr （我们试图不移除）的下标作为参数，返回从当前下标开始需要移除的区间个数。\n\n我们从 prev=−1prev=-1prev=−1 和 curr=0curr=0curr=0 开始。在每次递归调用中，检测当前的区间是否与上一个区间重叠。若不重叠，则不将当前区间从最终列表中移除，以 prev=currprev=currprev=curr 和 curr=curr+1curr=curr + 1curr=curr+1 调用函数 eraseoverlapintervals。函数调用的结果存储在 takentakentaken 变量中。\n\n另一方面，我们也将当前区间移除调用递归，因为本区间可能和后面的区间重叠，因此移除本区间可能会导致更少的区间移除。于是，参数为 prev=prevprev=prevprev=prev 和 curr=curr+1curr=curr + 1curr=curr+1。由于我们移除了一个区间，最后的结果应该是函数的返回值再加上 1，存储在 nottakennottakennottaken 变量中。当返回某个特定下标对应的移除数时，返回 takentakentaken 和 nottakennottakennottaken 中的较小值。\n\npublic class solution {\n    class mycomparator implements comparator<interval> {\n        public int compare(interval a, interval b) {\n            return a.start - b.start;\n        }\n    }\n    public int eraseoverlapintervals(interval[] intervals) {\n        arrays.sort(intervals, new mycomparator());\n        return erase_overlap_intervals(-1, 0, intervals);\n    }\n    public int erase_overlap_intervals(int prev, int curr, interval[] intervals) {\n        if (curr == intervals.length) {\n            return 0;\n        }\n        int taken = integer.max_value, nottaken;\n        if (prev == -1 || intervals[prev].end <= intervals[curr].start) {\n            taken = erase_overlap_intervals(curr, curr + 1, intervals);\n        }\n        nottaken = erase_overlap_intervals(prev, curr + 1, intervals) + 1;\n        return math.min(taken, nottaken);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n复杂度分析\n\n * 时间复杂度：o(2n)o(2^n)o(2n)。总共可能的组合数为 2n2^n2n。\n * 空间复杂度：o(n)o(n)o(n)。 递归的深度为 nnn。\n\n\n\n\n# 方法二：从起始点的动态规划 【通过】\n算法\n\n如果我们按照起始点对区间进行排序，可以很大程度上简化问题。一旦完成之后，我们就可以使用一个 dpdpdp 数组，其中 dp[i]dp[i]dp[i] 存储着只考虑到 第i个第i个第i个 区间范围内（包括其本身），最大可能的区间数。现在，当计算 dp[i+1]dp[i+1]dp[i+1] 时，我们不能只考虑 dp[i]dp[i]dp[i] 的值，因为前面的 iii 个区间都可能与 第 i+1i+1i+1 个区间发生重叠。因此，我们需要考虑能够使得 j≤ij \\leq ij≤i 且与第 i+1i+1i+1 个区间不发生重叠的所有 dp[j]dp[j]dp[j] 中的最大值。状态转移方程如下：\n\ndp[i+1]=max⁡(dp[j])+1,dp[i+1]= \\max(dp[j]) + 1,dp[i+1]=max(dp[j])+1,\n\n其中对于所有 j≤ij \\leq ij≤i ，第 i 个和第 j 个区间不发生重叠。\n\n最后，为了计算最终列表中区间的最大区间数量，我们需要找到 dpdpdp 数组中的最大值。最终的结果为区间的总数减去刚刚的结果 (intervals.length−ansintervals.length-ansintervals.length−ans)。\n\n下面的动画展示了算法的流程：\n\n<,,,,,,,,,,,,,,,,,,,,,,,,,,>\n\npublic class solution {\n    class mycomparator implements comparator<interval> {\n        public int compare(interval a, interval b) {\n            return a.start - b.start;\n        }\n    }\n    public boolean isoverlapping(interval i, interval j) {\n        return i.end > j.start;\n    }\n    public int eraseoverlapintervals(interval[] intervals) {\n        if (intervals.length == 0) {\n            return 0;\n        }\n        arrays.sort(intervals, new mycomparator());\n        int dp[] = new int[intervals.length];\n        dp[0] = 1;\n        int ans = 1;\n        for (int i = 1; i < dp.length; i++) {\n            int max = 0;\n            for (int j = i - 1; j >= 0; j--) {\n                if (!isoverlapping(intervals[j], intervals[i])) {\n                    max = math.max(dp[j], max);\n                }\n            }\n            dp[i] = max + 1;\n            ans = math.max(ans, dp[i]);\n\n        }\n        return intervals.length - ans;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n复杂度分析\n\n * 时间复杂度 : o(n2)o(n^2)o(n2)。需要两重循环。\n   \n   \n * 空间复杂度 : o(n)o(n)o(n)。 dpdpdp 数组占用的空间。\n   \n   \n\n\n\n\n# 方法三：从终点的动态规划 【通过】\n算法\n\n在上面讨论过的 dp 算法中，为了计算每个 dp[i]dp[i]dp[i] 的值，我们需要遍历 dpdpdp 数组，直到起始索引。如果我们使用根据终点排序的列表，则可以去除这一开销。我们依然使用 dpdpdp 数组，其中 dp[i]dp[i]dp[i] 用于存储存储着只考虑到 第i个第i个第i个 区间范围内（包括其本身），最大可能的区间数。为了计算 dp[i+1]dp[i+1]dp[i+1] ，考虑两种情况:\n\n情况一\n\n> 第 i+1i+1i+1 个区间对应的区间需要被包括在最终列表中以达到删除区间最少:\n\n\n在这种情况下，我们需要从第 i+1i + 1i+1 到开头遍历区间数组，寻找第一个不重叠的区间。这是由于，如果我们要包含当前区间，我们就需要移除所有和当前区间重叠的区间。但我们不需要每次都回到开头，相反，我们可以在找到第一个不重叠的区间后停止遍历，并用 dp[j]+1dp[j] + 1dp[j]+1 填入 dp[i+1]dp[i+1]dp[i+1] ，因为 dp[j]dp[j]dp[j] 是存储 直到第 jjj 个区间范围内最大区间数的元素。\n\n情况二\n\n> 第 i+1i+1i+1 个区间对应的区间需要被移除以达到删除区间最少：\n\n\n在这种情况下，当前元素不会被包括在最终列表中。因此，考虑到第 i+1i+1i+1 个区间的最大数量和 只考虑到 iii 个的相同。因此，我们用 dp[i]dp[i]dp[i] 的值填充 dp[i+1]dp[i+1]dp[i+1]。\n\n最终 dp[i+1]dp[i+1]dp[i+1] 的值为上述两值中较大的。\n\n最终的结果为区间的总数减去 dpdpdp 数组的最大值。下面的动画展示了算法过程：\n\n<,,,,,,,,,,,,,,,,,,,,,,>\n\npublic class solution {\n    class mycomparator implements comparator<interval> {\n        public int compare(interval a, interval b) {\n            return a.end - b.end;\n        }\n    }\n    public boolean isoverlapping(interval i, interval j) {\n        return i.end > j.start;\n    }\n    public int eraseoverlapintervals(interval[] intervals) {\n        if (intervals.length == 0) {\n            return 0;\n        }\n        arrays.sort(intervals, new mycomparator());\n        int dp[] = new int[intervals.length];\n        dp[0] = 1;\n        int ans = 1;\n        for (int i = 1; i < dp.length; i++) {\n            int max = 0;\n            for (int j = i - 1; j >= 0; j--) {\n                if (!isoverlapping(intervals[j], intervals[i])) {\n                    max = math.max(dp[j], max);\n                    break;\n                }\n            }\n            dp[i] = math.max(max + 1, dp[i - 1]);\n            ans = math.max(ans, dp[i]);\n        }\n        return intervals.length - ans;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n复杂度分析\n\n * 时间复杂度 : o(n2)o(n^2)o(n2)。需要两重循环。\n   \n   \n * 空间复杂度 : o(n)o(n)o(n)。 dpdpdp 数组占用的空间。\n   \n   \n\n\n\n\n####方法四：从起点的贪心算法 【通过】\n\n算法\n\n如果我们按照起点对区间进行排序，贪心算法就可以起到很好的效果。当按照起点先后顺序考虑区间的时候。我们利用一个 prevprevprev 指针追踪刚刚添加到最终列表中的区间。遍历的时候，可能遇到图中的三种情况：\n\n\n\n情况一\n\n> 当前考虑的两个区间不重叠：\n\n\n在这种情况下，不移除任何区间，将 prevprevprev 赋值为后面的区间，移除区间数量不变。\n\n情况二\n\n> 两个区间重叠，后一个区间的终点在前一个区间的终点之前。\n\n\n这种情况下，我们可以简单地只用后一个区间。这是显然的，因为后一个区间的长度更小，可以留下更多的空间（aaa 和 bbb），容纳更多的区间。因此， prevprevprev 更新为当前区间，移除区间的数量 + 1。\n\n情况三\n\n> 两个区间重叠，后一个区间的终点在前一个区间的终点之后。\n\n\n这种情况下，我们用贪心策略处理问题，直接移除后一个区间。为了理解这种做法的正确性，请看下图，该图包含了所有可能的情况。从图可以清楚地看出，选择前移区间总会得到更好的结果。因此，prevprevprev 不变，移除区间的数量 + 1。\n\n\n\npublic class solution {\n    class mycomparator implements comparator<interval> {\n        public int compare(interval a, interval b) {\n            return a.start - b.start;\n        }\n    }\n    public int eraseoverlapintervals(interval[] intervals) {\n        if (intervals.length == 0) {\n            return 0;\n        }\n        arrays.sort(intervals, new mycomparator());\n        int end = intervals[0].end, prev = 0, count = 0;\n        for (int i = 1; i < intervals.length; i++) {\n            if (intervals[prev].end > intervals[i].start) {\n                if (intervals[prev].end > intervals[i].end) {\n                    prev = i;\n                }\n                count++;\n            } else {\n                prev = i;\n            }\n        }\n        return count;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n复杂度分析\n\n * 时间复杂度：o(nlog⁡(n))o\\big(n \\log(n)\\big)o(nlog(n))。排序需要o(nlog⁡(n))o\\big(n \\log(n)\\big)o(nlog(n)) 的时间。\n   \n   \n * 空间复杂度：o(1)o(1)o(1)。不需要额外空间。\n   \n   \n\n\n\n\n# 方法五：从终点的贪心算法 【通过】\n算法\n\n上面讨论的贪心算法是根据起点进行贪心选择。而在本方法中，我们根据终点进行贪心选择。为此，我首先根据终点对区间进行排序。接着，对排好序的区间进行遍历。在遍历的过程中，若没有区间重叠，就不移除任何区间。如果存在重叠，就直接删除掉当前区间。\n\n为了解释这种做法，我们继续对每种可能情况进行讨论。\n\n\n\n情况一\n\n> 当前考虑的两个区间不重叠：\n\n\n在这种情况下，不移除任何区间，将 prevprevprev 赋值为后面的区间。\n\ncase 2:\n\n> 两个区间重叠，当前区间的终点在前一个区间的终点之后。\n\n\n在这种情况下，如图所示，前一个区间是当前区间的真子集。因此，移除当前区间可以给别的区间更多的容纳空间。因此，保留前一个区间不变，更新当前区间。case 3:\n\n> 两个区间重叠，当前区间的终点在前一个区间的终点之前。\n\n\n在这种情况下，出现了唯一有可能移除前一个区间的机会，因为移除前一个区间可以带来 aaa 的额外空间。然而，类似于上图的 3a 和 3b，此时也不应该移除前一个区间。然而，移除当前区间却可以带来 bbb 的额外空间。因此，保留前一个区间不变，更新当前区间。\n\npublic class solution {\n    class mycomparator implements comparator<interval> {\n        public int compare(interval a, interval b) {\n            return a.end - b.end;\n        }\n    }\n    public int eraseoverlapintervals(interval[] intervals) {\n        if (intervals.length == 0) {\n            return 0;\n        }\n        arrays.sort(intervals, new mycomparator());\n        int end = intervals[0].end;\n        int count = 1;\n        for (int i = 1; i < intervals.length; i++) {\n            if (intervals[i].start >= end) {\n                end = intervals[i].end;\n                count++;\n            }\n        }\n        return intervals.length - count;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n复杂度分析\n\n * 时间复杂度：o(nlog⁡(n))o\\big(n \\log(n)\\big)o(nlog(n))。排序需要o(nlog⁡(n))o\\big(n \\log(n)\\big)o(nlog(n)) 的时间。\n   \n   \n * 空间复杂度：o(1)o(1)o(1)。不需要额外空间。\n   \n   \n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-07-25 21:15:29accepted [https://leetcode-cn.com//submissions/detail/4649730/]13 ms16.65%n/ajava2018-07-25 21:09:46accepted [https://leetcode-cn.com//submissions/detail/4649460/]167 ms5.1%n/ajava2018-07-25 21:04:57wrong answer [https://leetcode-cn.com//submissions/detail/4649241/]n/an/an/ajava2018-07-25 21:00:57wrong answer [https://leetcode-cn.com//submissions/detail/4649036/]n/an/an/ajava# 统计信息\n通过次数提交次数ac比率70791610843.9%# 相似题目\n题目难度用最少数量的箭引爆气球 [https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons/]中等"},{title:"450-删除二叉搜索树中的节点(Delete Node in a BST)",frontmatter:{title:"450-删除二叉搜索树中的节点(Delete Node in a BST)",date:"2018-09-08T00:00:00.000Z",categories:["中等"],tags:["树<Tree>"]},regularPath:"/views/%E4%B8%AD%E7%AD%89/0450-%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9.html",relativePath:"views/中等/0450-删除二叉搜索树中的节点.md",key:"v-64e21c1e",path:"/views/%E4%B8%AD%E7%AD%89/0450-%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9.html",headers:[{level:2,title:"中文题目",slug:"中文题目",charIndex:2},{level:2,title:"通过代码",slug:"通过代码",charIndex:452},{level:2,title:"官方题解",slug:"官方题解",charIndex:1619},{level:2,title:"提交历史",slug:"提交历史",charIndex:6744},{level:2,title:"统计信息",slug:"统计信息",charIndex:6971},{level:2,title:"相似题目",slug:"相似题目",charIndex:7004}],lastUpdated:"4/11/2021, 1:15:21 PM",headersStr:"中文题目 通过代码 官方题解 提交历史 统计信息 相似题目",content:'# 中文题目\n给定一个二叉搜索树的根节点 root 和一个值 key，删除二叉搜索树中的key对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。\n\n一般来说，删除节点可分为两个步骤：\n\n 1. 首先找到需要删除的节点；\n 2. 如果找到了，删除它。\n\n说明： 要求算法时间复杂度为 O(h)，h 为树的高度。\n\n示例:\n\n\nroot = [5,3,6,2,4,null,7]\nkey = 3\n\n    5\n   / \\\n  3   6\n / \\   \\\n2   4   7\n\n给定需要删除的节点值是 3，所以我们首先找到 3 这个节点，然后删除它。\n\n一个正确的答案是 [5,4,6,2,null,null,7], 如下图所示。\n\n    5\n   / \\\n  4   6\n /     \\\n2       7\n\n另一个正确答案是 [5,2,6,null,4,null,7]。\n\n    5\n   / \\\n  2   6\n   \\   \\\n    4   7\n\n\n# 通过代码\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n public TreeNode deleteNode(TreeNode root, int key) {\n        if (root==null){\n            return null;\n        }\n        if (key<root.val){\n            root.left=deleteNode(root.left,key);\n        }else if (key >root.val){\n            root.right=deleteNode(root.right,key);\n        }else {\n            if (root.left==null){\n                return root.right;\n            }else if (root.right==null){\n                return root.left;\n            }\n//            去找右孩子中的最小的一个元素\n            TreeNode minNode=findMin(root.right);\n//            改变当前root的值\n            root.val=minNode.val;\n//            删除右孩子中最小的元素\n            root.right=deleteNode(root.right,minNode.val);\n        }\n        return root;\n    }\n\n    private TreeNode findMin(TreeNode node) {\n        while (node.left!=null){\n            node=node.left;\n        }\n        return node;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n# 官方题解\n# 二叉搜索树的三个特性：\n这些性质最好在面试之前了解清楚：\n\n * 二叉搜索树的中序遍历的序列是递增排序的序列。中序遍历的遍历次序：Left -> Node -> Right。\n\npublic LinkedList<Integer> inorder(TreeNode root, LinkedList<Integer> arr) {\n  if (root == null) return arr;\n  inorder(root.left, arr);\n  arr.add(root.val);\n  inorder(root.right, arr);\n  return arr;\n} \n\n\n1\n2\n3\n4\n5\n6\n7\ndef inorder(root):\n    return inorder(root.left) + [root.val] + inorder(root.right) if root else []\n\n\n1\n2\n{:width=500}\n\n * Successor 代表的是中序遍历序列的下一个节点。即比当前节点大的最小节点，简称后继节点。 先取当前节点的右节点，然后一直取该节点的左节点，直到左节点为空，则最后指向的节点为后继节点。\n\npublic int successor(TreeNode root) {\n  root = root.right;\n  while (root.left != null) root = root.left;\n  return root;\n} \n\n\n1\n2\n3\n4\n5\ndef successor(root):\n    root = root.right\n    while root.left:\n        root = root.left\n    return root\n\n\n1\n2\n3\n4\n5\n * Predecessor 代表的是中序遍历序列的前一个节点。即比当前节点小的最大节点，简称前驱节点。先取当前节点的左节点，然后取该节点的右节点，直到右节点为空，则最后指向的节点为前驱节点。\n\npublic int predecessor(TreeNode root) {\n  root = root.left;\n  while (root.right != null) root = root.right;\n  return root;\n} \n\n\n1\n2\n3\n4\n5\ndef predecessor(root):\n    root = root.left\n    while root.right:\n        root = root.right\n    return root\n\n\n1\n2\n3\n4\n5\n{:width=500}\n\n# 方法：递归\n这里有三种可能的情况：\n\n * 要删除的节点为叶子节点，可以直接删除。\n\n{:width=500}\n\n * 要删除的几点不是叶子节点且拥有右节点，则该节点可以由该节点的后继节点进行替代，该后继节点位于右子树中较低的位置。然后可以从后继节点的位置递归向下操作以删除后继节点。\n\n{:width=500}\n\n * 要删除的节点不是叶子节点，且没有右节点但是有左节点。这意味着它的后继节点在它的上面，但是我们并不想返回。我们可以使用它的前驱节点进行替代，然后再递归的向下删除前驱节点。\n\n{:width=500}\n\n算法：\n\n * 如果 key > root.val，说明要删除的节点在右子树，root.right = deleteNode(root.right, key)。\n * 如果 key < root.val，说明要删除的节点在左子树，root.left = deleteNode(root.left, key)。\n * 如果 key == root.val，则该节点就是我们要删除的节点，则： * 如果该节点是叶子节点，则直接删除它：root = null。\n    * 如果该节点不是叶子节点且有右节点，则用它的后继节点的值替代 root.val = successor.val，然后删除后继节点。\n    * 如果该节点不是叶子节点且只有左节点，则用它的前驱节点的值替代 root.val = predecessor.val，然后删除前驱节点。\n   \n   \n * 返回 root。\n\n{:width=500}\n\nclass Solution {\n  /*\n  One step right and then always left\n  */\n  public int successor(TreeNode root) {\n    root = root.right;\n    while (root.left != null) root = root.left;\n    return root.val;\n  }\n\n  /*\n  One step left and then always right\n  */\n  public int predecessor(TreeNode root) {\n    root = root.left;\n    while (root.right != null) root = root.right;\n    return root.val;\n  }\n\n  public TreeNode deleteNode(TreeNode root, int key) {\n    if (root == null) return null;\n\n    // delete from the right subtree\n    if (key > root.val) root.right = deleteNode(root.right, key);\n    // delete from the left subtree\n    else if (key < root.val) root.left = deleteNode(root.left, key);\n    // delete the current node\n    else {\n      // the node is a leaf\n      if (root.left == null && root.right == null) root = null;\n      // the node is not a leaf and has a right child\n      else if (root.right != null) {\n        root.val = successor(root);\n        root.right = deleteNode(root.right, root.val);\n      }\n      // the node is not a leaf, has no right child, and has a left child    \n      else {\n        root.val = predecessor(root);\n        root.left = deleteNode(root.left, root.val);\n      }\n    }\n    return root;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\nclass Solution:\n    def successor(self, root):\n        """\n        One step right and then always left\n        """\n        root = root.right\n        while root.left:\n            root = root.left\n        return root.val\n    \n    def predecessor(self, root):\n        """\n        One step left and then always right\n        """\n        root = root.left\n        while root.right:\n            root = root.right\n        return root.val\n        \n    def deleteNode(self, root: TreeNode, key: int) -> TreeNode:\n        if not root:\n            return None\n        \n        # delete from the right subtree\n        if key > root.val:\n            root.right = self.deleteNode(root.right, key)\n        # delete from the left subtree\n        elif key < root.val:\n            root.left = self.deleteNode(root.left, key)\n        # delete the current node\n        else:\n            # the node is a leaf\n            if not (root.left or root.right):\n                root = None\n            # the node is not a leaf and has a right child\n            elif root.right:\n                root.val = self.successor(root)\n                root.right = self.deleteNode(root.right, root.val)\n            # the node is not a leaf, has no right child, and has a left child    \n            else:\n                root.val = self.predecessor(root)\n                root.left = self.deleteNode(root.left, root.val)\n                        \n        return root\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n复杂度分析\n\n * 时间复杂度：O(log⁡N)\\mathcal{O}(\\log N)O(logN)。在算法的执行过程中，我们一直在树上向左或向右移动。首先先用 O(H1)\\mathcal{O}(H_1)O(H1​) 的时间找到要删除的节点，H1H_1H1​ 值得是从根节点到要删除节点的高度。然后删除节点需要 O(H2)\\mathcal{O}(H_2)O(H2​) 的时间，H2H_2H2​ 指的是从要删除节点到替换节点的高度。由于 O(H1+H2)=O(H)\\mathcal{O}(H_1 + H_2) = \\mathcal{O}(H)O(H1​+H2​)=O(H)，HHH 值得是树的高度，若树是一个平衡树则 HHH = log⁡N\\log NlogN。\n * 空间复杂度：O(H)\\mathcal{O}(H)O(H)，递归时堆栈使用的空间，HHH 是树的高度。\n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-09-08 17:14:04Accepted [https://leetcode-cn.com//submissions/detail/6750389/]6 ms14.6%N/Ajava2018-09-08 17:13:26Runtime Error [https://leetcode-cn.com//submissions/detail/6750346/]N/AN/AN/Ajava# 统计信息\n通过次数提交次数AC比率74101983837.4%# 相似题目\n题目难度拆分二叉搜索树 [https://leetcode-cn.com/problems/split-bst/]中等',contentLowercase:'# 中文题目\n给定一个二叉搜索树的根节点 root 和一个值 key，删除二叉搜索树中的key对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。\n\n一般来说，删除节点可分为两个步骤：\n\n 1. 首先找到需要删除的节点；\n 2. 如果找到了，删除它。\n\n说明： 要求算法时间复杂度为 o(h)，h 为树的高度。\n\n示例:\n\n\nroot = [5,3,6,2,4,null,7]\nkey = 3\n\n    5\n   / \\\n  3   6\n / \\   \\\n2   4   7\n\n给定需要删除的节点值是 3，所以我们首先找到 3 这个节点，然后删除它。\n\n一个正确的答案是 [5,4,6,2,null,null,7], 如下图所示。\n\n    5\n   / \\\n  4   6\n /     \\\n2       7\n\n另一个正确答案是 [5,2,6,null,4,null,7]。\n\n    5\n   / \\\n  2   6\n   \\   \\\n    4   7\n\n\n# 通过代码\n/**\n * definition for a binary tree node.\n * public class treenode {\n *     int val;\n *     treenode left;\n *     treenode right;\n *     treenode(int x) { val = x; }\n * }\n */\nclass solution {\n public treenode deletenode(treenode root, int key) {\n        if (root==null){\n            return null;\n        }\n        if (key<root.val){\n            root.left=deletenode(root.left,key);\n        }else if (key >root.val){\n            root.right=deletenode(root.right,key);\n        }else {\n            if (root.left==null){\n                return root.right;\n            }else if (root.right==null){\n                return root.left;\n            }\n//            去找右孩子中的最小的一个元素\n            treenode minnode=findmin(root.right);\n//            改变当前root的值\n            root.val=minnode.val;\n//            删除右孩子中最小的元素\n            root.right=deletenode(root.right,minnode.val);\n        }\n        return root;\n    }\n\n    private treenode findmin(treenode node) {\n        while (node.left!=null){\n            node=node.left;\n        }\n        return node;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n# 官方题解\n# 二叉搜索树的三个特性：\n这些性质最好在面试之前了解清楚：\n\n * 二叉搜索树的中序遍历的序列是递增排序的序列。中序遍历的遍历次序：left -> node -> right。\n\npublic linkedlist<integer> inorder(treenode root, linkedlist<integer> arr) {\n  if (root == null) return arr;\n  inorder(root.left, arr);\n  arr.add(root.val);\n  inorder(root.right, arr);\n  return arr;\n} \n\n\n1\n2\n3\n4\n5\n6\n7\ndef inorder(root):\n    return inorder(root.left) + [root.val] + inorder(root.right) if root else []\n\n\n1\n2\n{:width=500}\n\n * successor 代表的是中序遍历序列的下一个节点。即比当前节点大的最小节点，简称后继节点。 先取当前节点的右节点，然后一直取该节点的左节点，直到左节点为空，则最后指向的节点为后继节点。\n\npublic int successor(treenode root) {\n  root = root.right;\n  while (root.left != null) root = root.left;\n  return root;\n} \n\n\n1\n2\n3\n4\n5\ndef successor(root):\n    root = root.right\n    while root.left:\n        root = root.left\n    return root\n\n\n1\n2\n3\n4\n5\n * predecessor 代表的是中序遍历序列的前一个节点。即比当前节点小的最大节点，简称前驱节点。先取当前节点的左节点，然后取该节点的右节点，直到右节点为空，则最后指向的节点为前驱节点。\n\npublic int predecessor(treenode root) {\n  root = root.left;\n  while (root.right != null) root = root.right;\n  return root;\n} \n\n\n1\n2\n3\n4\n5\ndef predecessor(root):\n    root = root.left\n    while root.right:\n        root = root.right\n    return root\n\n\n1\n2\n3\n4\n5\n{:width=500}\n\n# 方法：递归\n这里有三种可能的情况：\n\n * 要删除的节点为叶子节点，可以直接删除。\n\n{:width=500}\n\n * 要删除的几点不是叶子节点且拥有右节点，则该节点可以由该节点的后继节点进行替代，该后继节点位于右子树中较低的位置。然后可以从后继节点的位置递归向下操作以删除后继节点。\n\n{:width=500}\n\n * 要删除的节点不是叶子节点，且没有右节点但是有左节点。这意味着它的后继节点在它的上面，但是我们并不想返回。我们可以使用它的前驱节点进行替代，然后再递归的向下删除前驱节点。\n\n{:width=500}\n\n算法：\n\n * 如果 key > root.val，说明要删除的节点在右子树，root.right = deletenode(root.right, key)。\n * 如果 key < root.val，说明要删除的节点在左子树，root.left = deletenode(root.left, key)。\n * 如果 key == root.val，则该节点就是我们要删除的节点，则： * 如果该节点是叶子节点，则直接删除它：root = null。\n    * 如果该节点不是叶子节点且有右节点，则用它的后继节点的值替代 root.val = successor.val，然后删除后继节点。\n    * 如果该节点不是叶子节点且只有左节点，则用它的前驱节点的值替代 root.val = predecessor.val，然后删除前驱节点。\n   \n   \n * 返回 root。\n\n{:width=500}\n\nclass solution {\n  /*\n  one step right and then always left\n  */\n  public int successor(treenode root) {\n    root = root.right;\n    while (root.left != null) root = root.left;\n    return root.val;\n  }\n\n  /*\n  one step left and then always right\n  */\n  public int predecessor(treenode root) {\n    root = root.left;\n    while (root.right != null) root = root.right;\n    return root.val;\n  }\n\n  public treenode deletenode(treenode root, int key) {\n    if (root == null) return null;\n\n    // delete from the right subtree\n    if (key > root.val) root.right = deletenode(root.right, key);\n    // delete from the left subtree\n    else if (key < root.val) root.left = deletenode(root.left, key);\n    // delete the current node\n    else {\n      // the node is a leaf\n      if (root.left == null && root.right == null) root = null;\n      // the node is not a leaf and has a right child\n      else if (root.right != null) {\n        root.val = successor(root);\n        root.right = deletenode(root.right, root.val);\n      }\n      // the node is not a leaf, has no right child, and has a left child    \n      else {\n        root.val = predecessor(root);\n        root.left = deletenode(root.left, root.val);\n      }\n    }\n    return root;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\nclass solution:\n    def successor(self, root):\n        """\n        one step right and then always left\n        """\n        root = root.right\n        while root.left:\n            root = root.left\n        return root.val\n    \n    def predecessor(self, root):\n        """\n        one step left and then always right\n        """\n        root = root.left\n        while root.right:\n            root = root.right\n        return root.val\n        \n    def deletenode(self, root: treenode, key: int) -> treenode:\n        if not root:\n            return none\n        \n        # delete from the right subtree\n        if key > root.val:\n            root.right = self.deletenode(root.right, key)\n        # delete from the left subtree\n        elif key < root.val:\n            root.left = self.deletenode(root.left, key)\n        # delete the current node\n        else:\n            # the node is a leaf\n            if not (root.left or root.right):\n                root = none\n            # the node is not a leaf and has a right child\n            elif root.right:\n                root.val = self.successor(root)\n                root.right = self.deletenode(root.right, root.val)\n            # the node is not a leaf, has no right child, and has a left child    \n            else:\n                root.val = self.predecessor(root)\n                root.left = self.deletenode(root.left, root.val)\n                        \n        return root\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n复杂度分析\n\n * 时间复杂度：o(log⁡n)\\mathcal{o}(\\log n)o(logn)。在算法的执行过程中，我们一直在树上向左或向右移动。首先先用 o(h1)\\mathcal{o}(h_1)o(h1​) 的时间找到要删除的节点，h1h_1h1​ 值得是从根节点到要删除节点的高度。然后删除节点需要 o(h2)\\mathcal{o}(h_2)o(h2​) 的时间，h2h_2h2​ 指的是从要删除节点到替换节点的高度。由于 o(h1+h2)=o(h)\\mathcal{o}(h_1 + h_2) = \\mathcal{o}(h)o(h1​+h2​)=o(h)，hhh 值得是树的高度，若树是一个平衡树则 hhh = log⁡n\\log nlogn。\n * 空间复杂度：o(h)\\mathcal{o}(h)o(h)，递归时堆栈使用的空间，hhh 是树的高度。\n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-09-08 17:14:04accepted [https://leetcode-cn.com//submissions/detail/6750389/]6 ms14.6%n/ajava2018-09-08 17:13:26runtime error [https://leetcode-cn.com//submissions/detail/6750346/]n/an/an/ajava# 统计信息\n通过次数提交次数ac比率74101983837.4%# 相似题目\n题目难度拆分二叉搜索树 [https://leetcode-cn.com/problems/split-bst/]中等'},{title:"438-找到字符串中所有字母异位词(Find All Anagrams in a String)",frontmatter:{title:"438-找到字符串中所有字母异位词(Find All Anagrams in a String)",date:"2018-05-21T00:00:00.000Z",categories:["中等"],tags:["哈希表<Hash Table>"]},regularPath:"/views/%E4%B8%AD%E7%AD%89/0438-%E6%89%BE%E5%88%B0%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E6%89%80%E6%9C%89%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D.html",relativePath:"views/中等/0438-找到字符串中所有字母异位词.md",key:"v-2f5ba20c",path:"/views/%E4%B8%AD%E7%AD%89/0438-%E6%89%BE%E5%88%B0%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E6%89%80%E6%9C%89%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D.html",headers:[{level:2,title:"中文题目",slug:"中文题目",charIndex:2},{level:2,title:"通过代码",slug:"通过代码",charIndex:435},{level:2,title:"高赞题解",slug:"高赞题解",charIndex:1515},{level:3,title:"一、最小覆盖子串",slug:"一、最小覆盖子串",charIndex:2324},{level:3,title:"二、找到字符串中所有字母异位词",slug:"二、找到字符串中所有字母异位词",charIndex:6492},{level:3,title:"三、无重复字符的最长子串",slug:"三、无重复字符的最长子串",charIndex:7787},{level:3,title:"最后总结",slug:"最后总结",charIndex:8607},{level:2,title:"提交历史",slug:"提交历史",charIndex:9509},{level:2,title:"统计信息",slug:"统计信息",charIndex:9638},{level:2,title:"相似题目",slug:"相似题目",charIndex:9672}],lastUpdated:"4/11/2021, 1:15:21 PM",headersStr:"中文题目 通过代码 高赞题解 一、最小覆盖子串 二、找到字符串中所有字母异位词 三、无重复字符的最长子串 最后总结 提交历史 统计信息 相似题目",content:'# 中文题目\n给定一个字符串s和一个非空字符串p，找到s中所有是p的字母异位词的子串，返回这些子串的起始索引。\n\n字符串只包含小写英文字母，并且字符串s和 p的长度都不超过 20100。\n\n说明：\n\n * 字母异位词指字母相同，但排列不同的字符串。\n * 不考虑答案输出的顺序。\n\n示例 1:\n\n\n输入:\ns: "cbaebabacd" p: "abc"\n\n输出:\n[0, 6]\n\n解释:\n起始索引等于 0 的子串是 "cba", 它是 "abc" 的字母异位词。\n起始索引等于 6 的子串是 "bac", 它是 "abc" 的字母异位词。\n\n\n示例 2:\n\n\n输入:\ns: "abab" p: "ab"\n\n输出:\n[0, 1, 2]\n\n解释:\n起始索引等于 0 的子串是 "ab", 它是 "ab" 的字母异位词。\n起始索引等于 1 的子串是 "ba", 它是 "ab" 的字母异位词。\n起始索引等于 2 的子串是 "ab", 它是 "ab" 的字母异位词。\n\n\n# 通过代码\nclass Solution {\n    public List<Integer> findAnagrams(String s, String p) {\n         List<Integer> list=new ArrayList<>();\n            if (null == s || s.length()==0 || null == p || p.length()==0){\n                return list;\n            }\n            int hash[]=new int[256];\n            for (char c : p.toCharArray()) {\n                hash[c]++;\n            }\n\n            int left=0;\n            int right=0;\n            int count =p.length();\n            while (right <s.length()){\n//                判断此时新加入的右边的字母在hash表中是否还存在\n                if (hash[s.charAt(right++)]--\x3e=1){\n                    count--;\n                }\n//                所有字符都在，添加到list中\n                if (count==0){\n                    list.add(left);\n                }\n//                判断当前的子串的长度是否跟p的长度相同，以及hashè¡¨中left的字母的加一，并将count也加一\n                if (right-left==p.length() && hash[s.charAt(left++)]++ >=0){\n                    count++;\n                }\n            }\n            return list;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n# 高赞题解\n本文详解「滑动窗口」这种高级双指针技巧的算法框架，带你秒杀几道难度较大的子字符串匹配问题：\n\n76. 最小覆盖子串 [https://leetcode-cn.com/problems/minimum-window-substring/]\n\n438. 找到字符串中所有字母异位词 [https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/]\n\n3. 无重复字符的最长子串 [https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/]\n\n最后抽象出一个简单的滑动窗口算法框架。\n\n力扣上至少有 9 道题目可以用此方法高效解决。但是有几道是 VIP 题目，有几道题目虽不难但太复杂，所以本文只选择点赞最高，较为经典的，最能够讲明白的三道题来讲解。第一题为了让读者掌握算法模板，篇幅相对长，后两题就基本秒杀了。\n\n本文代码为 C++ 实现，不会用到什么编程方面的奇技淫巧，但是还是简单介绍一下一些用到的数据结构，以免有的读者因为语言的细节问题阻碍对算法思想的理解：\n\nunordered_map 就是哈希表（字典），它的一个方法 count(key) 相当于 containsKey(key) 可以判断键 key 是否存在。\n\n可以使用方括号访问键对应的值 map[key]。需要注意的是，如果该 key 不存在，C++ 会自动创建这个 key，并把 map[key] 赋值为 0。\n\n所以代码中多次出现的 map[key]++ 相当于 Java 的 map.put(key, map.getOrDefault(key, 0) + 1)。\n\n本文大部分代码都是图片形式，可以点开放大，更重要的是可以左右滑动方便对比代码。下面进入正题。\n\n# 一、最小覆盖子串\n题目链接 [https://leetcode-cn.com/problems/minimum-window-substring/]\n\n题目不难理解，就是说要在 S(source) 中找到包含 T(target) 中全部字母的一个子串，顺序无所谓，但这个子串一定是所有可能子串中最短的。\n\n如果我们使用暴力解法，代码大概是这样的：\n\nfor (int i = 0; i < s.size(); i++)\n    for (int j = i + 1; j < s.size(); j++)\n        if s[i:j] 包含 t 的所有字母:\n            更新答案\n\n\n1\n2\n3\n4\n思路很直接吧，但是显然，这个算法的复杂度肯定大于 O(N^2) 了，不好。\n\n滑动窗口算法的思路是这样：\n\n1、我们在字符串 S 中使用双指针中的左右指针技巧，初始化 left = right = 0，把索引闭区间 [left, right] 称为一个「窗口」。\n\n2、我们先不断地增加 right 指针扩大窗口 [left, right]，直到窗口中的字符串符合要求（包含了 T 中的所有字符）。\n\n3、此时，我们停止增加 right，转而不断增加 left 指针缩小窗口 [left, right]，直到窗口中的字符串不再符合要求（不包含 T 中的所有字符了）。同时，每次增加 left，我们都要更新一轮结果。\n\n4、重复第 2 和第 3 步，直到 right 到达字符串 S 的尽头。\n\n这个思路其实也不难，第 2 步相当于在寻找一个「可行解」，然后第 3 步在优化这个「可行解」，最终找到最优解。左右指针轮流前进，窗口大小增增减减，窗口不断向右滑动。\n\n下面画图理解一下，needs 和 window 相当于计数器，分别记录 T 中字符出现次数和窗口中的相应字符的出现次数。\n\n初始状态：\n\n{:width="500"}\n\n增加 right，直到窗口 [left, right] 包含了 T 中所有字符：\n\n{:width="500"}\n\n现在开始增加 left，缩小窗口 [left, right]。\n\n{:width="500"}\n\n直到窗口中的字符串不再符合要求，left 不再继续移动。\n\n{:width="500"}\n\n之后重复上述过程，先移动 right，再移动 left…… 直到 right 指针到达字符串 S 的末端，算法结束。\n\n如果你能够理解上述过程，恭喜，你已经完全掌握了滑动窗口算法思想。至于如何具体到问题，如何得出此题的答案，都是编程问题，等会提供一套模板，理解一下就会了。\n\n上述过程可以简单地写出如下伪码框架：\n\nstring s, t;\n// 在 s 中寻找 t 的「最小覆盖子串」\nint left = 0, right = 0;\nstring res = s;\n\nwhile(right < s.size()) {\n    window.add(s[right]);\n    right++;\n    // 如果符合要求，移动 left 缩小窗口\n    while (window 符合要求) {\n        // 如果这个窗口的子串更短，则更新 res\n        res = minLen(res, window);\n        window.remove(s[left]);\n        left++;\n    }\n}\nreturn res;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n如果上述代码你也能够理解，那么你离解题更近了一步。关注我的众公号 labuladong 看更多精彩算法文章。现在就剩下一个比较棘手的问题：如何判断 window 即子串 s[left...right] 是否符合要求，是否包含 t 的所有字符呢？\n\n可以用两个哈希表当作计数器解决。用一个哈希表 needs 记录字符串 t 中包含的字符及出现次数，用另一个哈希表 window 记录当前「窗口」中包含的字符及出现的次数，如果 window 包含所有 needs 中的键，且这些键对应的值都大于等于 needs 中的值，那么就可以知道当前「窗口」符合要求了，可以开始移动 left 指针了。\n\n现在将上面的框架继续细化：\n\nstring s, t;\n// 在 s 中寻找 t 的「最小覆盖子串」\nint left = 0, right = 0;\nstring res = s;\n\n// 相当于两个计数器\nunordered_map<char, int> window;\nunordered_map<char, int> needs;\nfor (char c : t) needs[c]++;\n\n// 记录 window 中已经有多少字符符合要求了\nint match = 0; \n\nwhile (right < s.size()) {\n    char c1 = s[right];\n    if (needs.count(c1)) {\n        window[c1]++; // 加入 window\n        if (window[c1] == needs[c1])\n            // 字符 c1 的出现次数符合要求了\n            match++;\n    }\n    right++;\n\n    // window 中的字符串已符合 needs 的要求了\n    while (match == needs.size()) {\n        // 更新结果 res\n        res = minLen(res, window);\n        char c2 = s[left];\n        if (needs.count(c2)) {\n            window[c2]--; // 移出 window\n            if (window[c2] < needs[c2])\n                // 字符 c2 出现次数不再符合要求\n                match--;\n        }\n        left++;\n    }\n}\nreturn res;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n上述代码已经具备完整的逻辑了，只有一处伪码，即更新 res 的地方，不过这个问题太好解决了，直接看解法吧！\n\nstring minWindow(string s, string t) {\n    // 记录最短子串的开始位置和长度\n    int start = 0, minLen = INT_MAX;\n    int left = 0, right = 0;\n    \n    unordered_map<char, int> window;\n    unordered_map<char, int> needs;\n    for (char c : t) needs[c]++;\n    \n    int match = 0;\n    \n    while (right < s.size()) {\n        char c1 = s[right];\n        if (needs.count(c1)) {\n            window[c1]++;\n            if (window[c1] == needs[c1]) \n                match++;\n        }\n        right++;\n        \n        while (match == needs.size()) {\n            if (right - left < minLen) {\n                // 更新最小子串的位置和长度\n                start = left;\n                minLen = right - left;\n            }\n            char c2 = s[left];\n            if (needs.count(c2)) {\n                window[c2]--;\n                if (window[c2] < needs[c2])\n                    match--;\n            }\n            left++;\n        }\n    }\n    return minLen == INT_MAX ?\n                "" : s.substr(start, minLen);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n如果直接甩给你这么一大段代码，我想你的心态是爆炸的，但是通过之前的步步跟进，你是否能够理解这个算法的内在逻辑呢？你是否能清晰看出该算法的结构呢？\n\n这个算法的时间复杂度是 O(M + N)，M 和 N 分别是字符串 S 和 T 的长度。因为我们先用 for 循环遍历了字符串 T 来初始化 needs，时间 O(N)，之后的两个 while 循环最多执行 2M 次，时间 O(M)。\n\n读者也许认为嵌套的 while 循环复杂度应该是平方级，但是你这样想，while 执行的次数就是双指针 left 和 right 走的总路程，最多是 2M 嘛。\n\n# 二、找到字符串中所有字母异位词\n题目链接 [https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/]\n\n这道题的难度是 Easy，但是评论区点赞最多的一条是这样：\n\nHow can this problem be marked as easy???\n\n实际上，这个 Easy 是属于了解双指针技巧的人的，只要把上一道题的代码改中更新 res 部分的代码稍加修改就成了这道题的解：\n\nvector<int> findAnagrams(string s, string t) {\n    // 用数组记录答案\n    vector<int> res;\n    int left = 0, right = 0;\n    unordered_map<char, int> needs;\n    unordered_map<char, int> window;\n    for (char c : t) needs[c]++;\n    int match = 0;\n    \n    while (right < s.size()) {\n        char c1 = s[right];\n        if (needs.count(c1)) {\n            window[c1]++;\n            if (window[c1] == needs[c1])\n                match++;\n        }\n        right++;\n\n        while (match == needs.size()) {\n            // 如果 window 的大小合适\n            // 就把起始索引 left 加入结果\n            if (right - left == t.size()) {\n                res.push_back(left);\n            }\n            char c2 = s[left];\n            if (needs.count(c2)) {\n                window[c2]--;\n                if (window[c2] < needs[c2])\n                    match--;\n            }\n            left++;\n        }\n    }\n    return res;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n因为这道题和上一道的场景类似，也需要 window 中包含串 t 的所有字符，但上一道题要找长度最短的子串，这道题要找长度相同的子串，也就是「字母异位词」嘛。\n\n# 三、无重复字符的最长子串\n题目链接 [https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/]\n\n遇到子串问题，首先想到的就是滑动窗口技巧。\n\n类似之前的思路，使用 window 作为计数器记录窗口中的字符出现次数，然后先向右移动 right，当 window 中出现重复字符时，开始移动 left 缩小窗口，如此往复：\n\nint lengthOfLongestSubstring(string s) {\n    int left = 0, right = 0;\n    unordered_map<char, int> window;\n    int res = 0; // 记录最长长度\n\n    while (right < s.size()) {\n        char c1 = s[right];\n        window[c1]++;\n        right++;\n        // 如果 window 中出现重复字符\n        // 开始移动 left 缩小窗口\n        while (window[c1] > 1) {\n            char c2 = s[left];\n            window[c2]--;\n            left++;\n        }\n        res = max(res, right - left);\n    }\n    return res;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n需要注意的是，因为我们要求的是最长子串，所以需要在每次移动 right 增大窗口时更新 res，而不是像之前的题目在移动 left 缩小窗口时更新 res。\n\n# 最后总结\n通过上面三道题，我们可以总结出滑动窗口算法的抽象思想：\n\nint left = 0, right = 0;\n\nwhile (right < s.size()) {\n    window.add(s[right]);\n    right++;\n    \n    while (valid) {\n        window.remove(s[left]);\n        left++;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n其中 window 的数据类型可以视具体情况而定，比如上述题目都使用哈希表充当计数器，当然你也可以用一个数组实现同样效果，因为我们只处理英文字母。\n\n稍微麻烦的地方就是这个 valid 条件，为了实现这个条件的实时更新，我们可能会写很多代码。比如前两道题，看起来解法篇幅那么长，实际上思想还是很简单，只是大多数代码都在处理这个问题而已。\n\n如果本文对你有帮助，欢迎关注我的公众号 labuladong，致力于把算法问题讲清楚～ 后台回复关键词【资料】可获得我精选的经典技术书籍～\n\n{:width=400} {:align=center}\n\n最后，点击我的头像可以查看更多详细题解，希望读者多多点赞，让我感受到你的认可～\n\n推荐阅读：\n\nKMP 算法详解 [https://leetcode-cn.com/problems/implement-strstr/solution/kmp-suan-fa-xiang-jie-by-labuladong/]\n\nLRU 缓存淘汰算法详解 [https://leetcode-cn.com/problems/lru-cache/solution/lru-ce-lue-xiang-jie-he-shi-xian-by-labuladong/]\n\n腾讯面试题详解：编辑距离 [https://leetcode-cn.com/problems/edit-distance/solution/bian-ji-ju-chi-mian-shi-ti-xiang-jie-by-labuladong/]\n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-05-21 18:36:21Accepted [https://leetcode-cn.com//submissions/detail/2473360/]18 ms55.85%N/Ajava# 统计信息\n通过次数提交次数AC比率152043783240.2%# 相似题目\n题目难度有效的字母异位词 [https://leetcode-cn.com/problems/valid-anagram/]简单字符串的排列 [https://leetcode-cn.com/problems/permutation-in-string/]中等',contentLowercase:'# 中文题目\n给定一个字符串s和一个非空字符串p，找到s中所有是p的字母异位词的子串，返回这些子串的起始索引。\n\n字符串只包含小写英文字母，并且字符串s和 p的长度都不超过 20100。\n\n说明：\n\n * 字母异位词指字母相同，但排列不同的字符串。\n * 不考虑答案输出的顺序。\n\n示例 1:\n\n\n输入:\ns: "cbaebabacd" p: "abc"\n\n输出:\n[0, 6]\n\n解释:\n起始索引等于 0 的子串是 "cba", 它是 "abc" 的字母异位词。\n起始索引等于 6 的子串是 "bac", 它是 "abc" 的字母异位词。\n\n\n示例 2:\n\n\n输入:\ns: "abab" p: "ab"\n\n输出:\n[0, 1, 2]\n\n解释:\n起始索引等于 0 的子串是 "ab", 它是 "ab" 的字母异位词。\n起始索引等于 1 的子串是 "ba", 它是 "ab" 的字母异位词。\n起始索引等于 2 的子串是 "ab", 它是 "ab" 的字母异位词。\n\n\n# 通过代码\nclass solution {\n    public list<integer> findanagrams(string s, string p) {\n         list<integer> list=new arraylist<>();\n            if (null == s || s.length()==0 || null == p || p.length()==0){\n                return list;\n            }\n            int hash[]=new int[256];\n            for (char c : p.tochararray()) {\n                hash[c]++;\n            }\n\n            int left=0;\n            int right=0;\n            int count =p.length();\n            while (right <s.length()){\n//                判断此时新加入的右边的字母在hash表中是否还存在\n                if (hash[s.charat(right++)]--\x3e=1){\n                    count--;\n                }\n//                所有字符都在，添加到list中\n                if (count==0){\n                    list.add(left);\n                }\n//                判断当前的子串的长度是否跟p的长度相同，以及hashè¡¨中left的字母的加一，并将count也加一\n                if (right-left==p.length() && hash[s.charat(left++)]++ >=0){\n                    count++;\n                }\n            }\n            return list;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n# 高赞题解\n本文详解「滑动窗口」这种高级双指针技巧的算法框架，带你秒杀几道难度较大的子字符串匹配问题：\n\n76. 最小覆盖子串 [https://leetcode-cn.com/problems/minimum-window-substring/]\n\n438. 找到字符串中所有字母异位词 [https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/]\n\n3. 无重复字符的最长子串 [https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/]\n\n最后抽象出一个简单的滑动窗口算法框架。\n\n力扣上至少有 9 道题目可以用此方法高效解决。但是有几道是 vip 题目，有几道题目虽不难但太复杂，所以本文只选择点赞最高，较为经典的，最能够讲明白的三道题来讲解。第一题为了让读者掌握算法模板，篇幅相对长，后两题就基本秒杀了。\n\n本文代码为 c++ 实现，不会用到什么编程方面的奇技淫巧，但是还是简单介绍一下一些用到的数据结构，以免有的读者因为语言的细节问题阻碍对算法思想的理解：\n\nunordered_map 就是哈希表（字典），它的一个方法 count(key) 相当于 containskey(key) 可以判断键 key 是否存在。\n\n可以使用方括号访问键对应的值 map[key]。需要注意的是，如果该 key 不存在，c++ 会自动创建这个 key，并把 map[key] 赋值为 0。\n\n所以代码中多次出现的 map[key]++ 相当于 java 的 map.put(key, map.getordefault(key, 0) + 1)。\n\n本文大部分代码都是图片形式，可以点开放大，更重要的是可以左右滑动方便对比代码。下面进入正题。\n\n# 一、最小覆盖子串\n题目链接 [https://leetcode-cn.com/problems/minimum-window-substring/]\n\n题目不难理解，就是说要在 s(source) 中找到包含 t(target) 中全部字母的一个子串，顺序无所谓，但这个子串一定是所有可能子串中最短的。\n\n如果我们使用暴力解法，代码大概是这样的：\n\nfor (int i = 0; i < s.size(); i++)\n    for (int j = i + 1; j < s.size(); j++)\n        if s[i:j] 包含 t 的所有字母:\n            更新答案\n\n\n1\n2\n3\n4\n思路很直接吧，但是显然，这个算法的复杂度肯定大于 o(n^2) 了，不好。\n\n滑动窗口算法的思路是这样：\n\n1、我们在字符串 s 中使用双指针中的左右指针技巧，初始化 left = right = 0，把索引闭区间 [left, right] 称为一个「窗口」。\n\n2、我们先不断地增加 right 指针扩大窗口 [left, right]，直到窗口中的字符串符合要求（包含了 t 中的所有字符）。\n\n3、此时，我们停止增加 right，转而不断增加 left 指针缩小窗口 [left, right]，直到窗口中的字符串不再符合要求（不包含 t 中的所有字符了）。同时，每次增加 left，我们都要更新一轮结果。\n\n4、重复第 2 和第 3 步，直到 right 到达字符串 s 的尽头。\n\n这个思路其实也不难，第 2 步相当于在寻找一个「可行解」，然后第 3 步在优化这个「可行解」，最终找到最优解。左右指针轮流前进，窗口大小增增减减，窗口不断向右滑动。\n\n下面画图理解一下，needs 和 window 相当于计数器，分别记录 t 中字符出现次数和窗口中的相应字符的出现次数。\n\n初始状态：\n\n{:width="500"}\n\n增加 right，直到窗口 [left, right] 包含了 t 中所有字符：\n\n{:width="500"}\n\n现在开始增加 left，缩小窗口 [left, right]。\n\n{:width="500"}\n\n直到窗口中的字符串不再符合要求，left 不再继续移动。\n\n{:width="500"}\n\n之后重复上述过程，先移动 right，再移动 left…… 直到 right 指针到达字符串 s 的末端，算法结束。\n\n如果你能够理解上述过程，恭喜，你已经完全掌握了滑动窗口算法思想。至于如何具体到问题，如何得出此题的答案，都是编程问题，等会提供一套模板，理解一下就会了。\n\n上述过程可以简单地写出如下伪码框架：\n\nstring s, t;\n// 在 s 中寻找 t 的「最小覆盖子串」\nint left = 0, right = 0;\nstring res = s;\n\nwhile(right < s.size()) {\n    window.add(s[right]);\n    right++;\n    // 如果符合要求，移动 left 缩小窗口\n    while (window 符合要求) {\n        // 如果这个窗口的子串更短，则更新 res\n        res = minlen(res, window);\n        window.remove(s[left]);\n        left++;\n    }\n}\nreturn res;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n如果上述代码你也能够理解，那么你离解题更近了一步。关注我的众公号 labuladong 看更多精彩算法文章。现在就剩下一个比较棘手的问题：如何判断 window 即子串 s[left...right] 是否符合要求，是否包含 t 的所有字符呢？\n\n可以用两个哈希表当作计数器解决。用一个哈希表 needs 记录字符串 t 中包含的字符及出现次数，用另一个哈希表 window 记录当前「窗口」中包含的字符及出现的次数，如果 window 包含所有 needs 中的键，且这些键对应的值都大于等于 needs 中的值，那么就可以知道当前「窗口」符合要求了，可以开始移动 left 指针了。\n\n现在将上面的框架继续细化：\n\nstring s, t;\n// 在 s 中寻找 t 的「最小覆盖子串」\nint left = 0, right = 0;\nstring res = s;\n\n// 相当于两个计数器\nunordered_map<char, int> window;\nunordered_map<char, int> needs;\nfor (char c : t) needs[c]++;\n\n// 记录 window 中已经有多少字符符合要求了\nint match = 0; \n\nwhile (right < s.size()) {\n    char c1 = s[right];\n    if (needs.count(c1)) {\n        window[c1]++; // 加入 window\n        if (window[c1] == needs[c1])\n            // 字符 c1 的出现次数符合要求了\n            match++;\n    }\n    right++;\n\n    // window 中的字符串已符合 needs 的要求了\n    while (match == needs.size()) {\n        // 更新结果 res\n        res = minlen(res, window);\n        char c2 = s[left];\n        if (needs.count(c2)) {\n            window[c2]--; // 移出 window\n            if (window[c2] < needs[c2])\n                // 字符 c2 出现次数不再符合要求\n                match--;\n        }\n        left++;\n    }\n}\nreturn res;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n上述代码已经具备完整的逻辑了，只有一处伪码，即更新 res 的地方，不过这个问题太好解决了，直接看解法吧！\n\nstring minwindow(string s, string t) {\n    // 记录最短子串的开始位置和长度\n    int start = 0, minlen = int_max;\n    int left = 0, right = 0;\n    \n    unordered_map<char, int> window;\n    unordered_map<char, int> needs;\n    for (char c : t) needs[c]++;\n    \n    int match = 0;\n    \n    while (right < s.size()) {\n        char c1 = s[right];\n        if (needs.count(c1)) {\n            window[c1]++;\n            if (window[c1] == needs[c1]) \n                match++;\n        }\n        right++;\n        \n        while (match == needs.size()) {\n            if (right - left < minlen) {\n                // 更新最小子串的位置和长度\n                start = left;\n                minlen = right - left;\n            }\n            char c2 = s[left];\n            if (needs.count(c2)) {\n                window[c2]--;\n                if (window[c2] < needs[c2])\n                    match--;\n            }\n            left++;\n        }\n    }\n    return minlen == int_max ?\n                "" : s.substr(start, minlen);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n如果直接甩给你这么一大段代码，我想你的心态是爆炸的，但是通过之前的步步跟进，你是否能够理解这个算法的内在逻辑呢？你是否能清晰看出该算法的结构呢？\n\n这个算法的时间复杂度是 o(m + n)，m 和 n 分别是字符串 s 和 t 的长度。因为我们先用 for 循环遍历了字符串 t 来初始化 needs，时间 o(n)，之后的两个 while 循环最多执行 2m 次，时间 o(m)。\n\n读者也许认为嵌套的 while 循环复杂度应该是平方级，但是你这样想，while 执行的次数就是双指针 left 和 right 走的总路程，最多是 2m 嘛。\n\n# 二、找到字符串中所有字母异位词\n题目链接 [https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/]\n\n这道题的难度是 easy，但是评论区点赞最多的一条是这样：\n\nhow can this problem be marked as easy???\n\n实际上，这个 easy 是属于了解双指针技巧的人的，只要把上一道题的代码改中更新 res 部分的代码稍加修改就成了这道题的解：\n\nvector<int> findanagrams(string s, string t) {\n    // 用数组记录答案\n    vector<int> res;\n    int left = 0, right = 0;\n    unordered_map<char, int> needs;\n    unordered_map<char, int> window;\n    for (char c : t) needs[c]++;\n    int match = 0;\n    \n    while (right < s.size()) {\n        char c1 = s[right];\n        if (needs.count(c1)) {\n            window[c1]++;\n            if (window[c1] == needs[c1])\n                match++;\n        }\n        right++;\n\n        while (match == needs.size()) {\n            // 如果 window 的大小合适\n            // 就把起始索引 left 加入结果\n            if (right - left == t.size()) {\n                res.push_back(left);\n            }\n            char c2 = s[left];\n            if (needs.count(c2)) {\n                window[c2]--;\n                if (window[c2] < needs[c2])\n                    match--;\n            }\n            left++;\n        }\n    }\n    return res;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n因为这道题和上一道的场景类似，也需要 window 中包含串 t 的所有字符，但上一道题要找长度最短的子串，这道题要找长度相同的子串，也就是「字母异位词」嘛。\n\n# 三、无重复字符的最长子串\n题目链接 [https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/]\n\n遇到子串问题，首先想到的就是滑动窗口技巧。\n\n类似之前的思路，使用 window 作为计数器记录窗口中的字符出现次数，然后先向右移动 right，当 window 中出现重复字符时，开始移动 left 缩小窗口，如此往复：\n\nint lengthoflongestsubstring(string s) {\n    int left = 0, right = 0;\n    unordered_map<char, int> window;\n    int res = 0; // 记录最长长度\n\n    while (right < s.size()) {\n        char c1 = s[right];\n        window[c1]++;\n        right++;\n        // 如果 window 中出现重复字符\n        // 开始移动 left 缩小窗口\n        while (window[c1] > 1) {\n            char c2 = s[left];\n            window[c2]--;\n            left++;\n        }\n        res = max(res, right - left);\n    }\n    return res;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n需要注意的是，因为我们要求的是最长子串，所以需要在每次移动 right 增大窗口时更新 res，而不是像之前的题目在移动 left 缩小窗口时更新 res。\n\n# 最后总结\n通过上面三道题，我们可以总结出滑动窗口算法的抽象思想：\n\nint left = 0, right = 0;\n\nwhile (right < s.size()) {\n    window.add(s[right]);\n    right++;\n    \n    while (valid) {\n        window.remove(s[left]);\n        left++;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n其中 window 的数据类型可以视具体情况而定，比如上述题目都使用哈希表充当计数器，当然你也可以用一个数组实现同样效果，因为我们只处理英文字母。\n\n稍微麻烦的地方就是这个 valid 条件，为了实现这个条件的实时更新，我们可能会写很多代码。比如前两道题，看起来解法篇幅那么长，实际上思想还是很简单，只是大多数代码都在处理这个问题而已。\n\n如果本文对你有帮助，欢迎关注我的公众号 labuladong，致力于把算法问题讲清楚～ 后台回复关键词【资料】可获得我精选的经典技术书籍～\n\n{:width=400} {:align=center}\n\n最后，点击我的头像可以查看更多详细题解，希望读者多多点赞，让我感受到你的认可～\n\n推荐阅读：\n\nkmp 算法详解 [https://leetcode-cn.com/problems/implement-strstr/solution/kmp-suan-fa-xiang-jie-by-labuladong/]\n\nlru 缓存淘汰算法详解 [https://leetcode-cn.com/problems/lru-cache/solution/lru-ce-lue-xiang-jie-he-shi-xian-by-labuladong/]\n\n腾讯面试题详解：编辑距离 [https://leetcode-cn.com/problems/edit-distance/solution/bian-ji-ju-chi-mian-shi-ti-xiang-jie-by-labuladong/]\n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-05-21 18:36:21accepted [https://leetcode-cn.com//submissions/detail/2473360/]18 ms55.85%n/ajava# 统计信息\n通过次数提交次数ac比率152043783240.2%# 相似题目\n题目难度有效的字母异位词 [https://leetcode-cn.com/problems/valid-anagram/]简单字符串的排列 [https://leetcode-cn.com/problems/permutation-in-string/]中等'},{title:"451-根据字符出现频率排序(Sort Characters By Frequency)",frontmatter:{title:"451-根据字符出现频率排序(Sort Characters By Frequency)",date:"2018-06-04T00:00:00.000Z",categories:["中等"],tags:["堆<Heap>","哈希表<Hash Table>"]},regularPath:"/views/%E4%B8%AD%E7%AD%89/0451-%E6%A0%B9%E6%8D%AE%E5%AD%97%E7%AC%A6%E5%87%BA%E7%8E%B0%E9%A2%91%E7%8E%87%E6%8E%92%E5%BA%8F.html",relativePath:"views/中等/0451-根据字符出现频率排序.md",key:"v-4f4e8ede",path:"/views/%E4%B8%AD%E7%AD%89/0451-%E6%A0%B9%E6%8D%AE%E5%AD%97%E7%AC%A6%E5%87%BA%E7%8E%B0%E9%A2%91%E7%8E%87%E6%8E%92%E5%BA%8F.html",headers:[{level:2,title:"中文题目",slug:"中文题目",charIndex:2},{level:2,title:"通过代码",slug:"通过代码",charIndex:340},{level:2,title:"高赞题解",slug:"高赞题解",charIndex:1625},{level:2,title:"提交历史",slug:"提交历史",charIndex:2228},{level:2,title:"统计信息",slug:"统计信息",charIndex:2357},{level:2,title:"相似题目",slug:"相似题目",charIndex:2391}],lastUpdated:"4/11/2021, 1:15:21 PM",headersStr:"中文题目 通过代码 高赞题解 提交历史 统计信息 相似题目",content:'# 中文题目\n给定一个字符串，请将字符串里的字符按照出现的频率降序排列。\n\n示例 1:\n\n\n输入:\n"tree"\n\n输出:\n"eert"\n\n解释:\n\'e\'出现两次，\'r\'和\'t\'都只出现一次。\n因此\'e\'必须出现在\'r\'和\'t\'之前。此外，"eetr"也是一个有效的答案。\n\n\n示例 2:\n\n\n输入:\n"cccaaa"\n\n输出:\n"cccaaa"\n\n解释:\n\'c\'和\'a\'都出现三次。此外，"aaaccc"也是有效的答案。\n注意"cacaca"是不正确的，因为相同的字母必须放在一起。\n\n\n示例 3:\n\n\n输入:\n"Aabb"\n\n输出:\n"bbAa"\n\n解释:\n此外，"bbaA"也是一个有效的答案，但"Aabb"是不正确的。\n注意\'A\'和\'a\'被认为是两种不同的字符。\n\n\n# 通过代码\nimport java.util.*;\nclass Solution {\n    public String frequencySort(String s) {\n        Map<Character,Integer> map=new HashMap<>();\n            for (int i = 0; i < s.length(); i++) {\n                if (map.containsKey(s.charAt(i))){\n                    map.put(s.charAt(i),map.get(s.charAt(i))+1);\n                }else {\n                    map.put(s.charAt(i),1);\n                }\n            }\n            PriorityQueue<Map.Entry<Character,Integer>> priorityQueue=new PriorityQueue<>(\n                    new Comparator<Map.Entry<Character, Integer>>() {\n                @Override\n                public int compare(Map.Entry<Character, Integer> o1, Map.Entry<Character, Integer> o2) {\n                    return o2.getValue()-o1.getValue();\n                }\n            });\n            priorityQueue.addAll(map.entrySet());\n            StringBuffer stringBuffer=new StringBuffer();\n            while (!priorityQueue.isEmpty()){\n                Map.Entry entry=priorityQueue.poll();\n                for (int i = 0; i < (Integer) entry.getValue(); i++) {\n                    stringBuffer.append(entry.getKey());\n                }\n            }\n            return stringBuffer.toString();\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n# 高赞题解\n因为最多只有0-127的ascii码，直接O（n）排序算法。秒杀100%\n\nchar * frequencySort(char * s){\n    int check[128] = {0};\n    int len = strlen(s);\n    int i;\n    char* ret = (char*)malloc(len+1);\n    memset(ret,0,len+1);\n    for(i = 0; i < len;i++) check[s[i]]++;\n    int max = -1;\n    int pos = -1;\n    int now = 0;\n    while(max != 0){\n        max = -1;\n        pos = -1;\n        for(i = 0; i < 128;i++) if(check[i] > max) max = check[i],pos = i;\n        for(i = 0; i < max;i++) ret[now++] = pos;\n        check[pos] = 0;\n    }\n    ret[now] = 0;\n    return ret;\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-06-04 23:26:26Accepted [https://leetcode-cn.com//submissions/detail/2907115/]53 ms16.52%N/Ajava# 统计信息\n通过次数提交次数AC比率117301920361.1%# 相似题目\n题目难度前 K 个高频元素 [https://leetcode-cn.com/problems/top-k-frequent-elements/]中等字符串中的第一个唯一字符 [https://leetcode-cn.com/problems/first-unique-character-in-a-string/]简单',contentLowercase:'# 中文题目\n给定一个字符串，请将字符串里的字符按照出现的频率降序排列。\n\n示例 1:\n\n\n输入:\n"tree"\n\n输出:\n"eert"\n\n解释:\n\'e\'出现两次，\'r\'和\'t\'都只出现一次。\n因此\'e\'必须出现在\'r\'和\'t\'之前。此外，"eetr"也是一个有效的答案。\n\n\n示例 2:\n\n\n输入:\n"cccaaa"\n\n输出:\n"cccaaa"\n\n解释:\n\'c\'和\'a\'都出现三次。此外，"aaaccc"也是有效的答案。\n注意"cacaca"是不正确的，因为相同的字母必须放在一起。\n\n\n示例 3:\n\n\n输入:\n"aabb"\n\n输出:\n"bbaa"\n\n解释:\n此外，"bbaa"也是一个有效的答案，但"aabb"是不正确的。\n注意\'a\'和\'a\'被认为是两种不同的字符。\n\n\n# 通过代码\nimport java.util.*;\nclass solution {\n    public string frequencysort(string s) {\n        map<character,integer> map=new hashmap<>();\n            for (int i = 0; i < s.length(); i++) {\n                if (map.containskey(s.charat(i))){\n                    map.put(s.charat(i),map.get(s.charat(i))+1);\n                }else {\n                    map.put(s.charat(i),1);\n                }\n            }\n            priorityqueue<map.entry<character,integer>> priorityqueue=new priorityqueue<>(\n                    new comparator<map.entry<character, integer>>() {\n                @override\n                public int compare(map.entry<character, integer> o1, map.entry<character, integer> o2) {\n                    return o2.getvalue()-o1.getvalue();\n                }\n            });\n            priorityqueue.addall(map.entryset());\n            stringbuffer stringbuffer=new stringbuffer();\n            while (!priorityqueue.isempty()){\n                map.entry entry=priorityqueue.poll();\n                for (int i = 0; i < (integer) entry.getvalue(); i++) {\n                    stringbuffer.append(entry.getkey());\n                }\n            }\n            return stringbuffer.tostring();\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n# 高赞题解\n因为最多只有0-127的ascii码，直接o（n）排序算法。秒杀100%\n\nchar * frequencysort(char * s){\n    int check[128] = {0};\n    int len = strlen(s);\n    int i;\n    char* ret = (char*)malloc(len+1);\n    memset(ret,0,len+1);\n    for(i = 0; i < len;i++) check[s[i]]++;\n    int max = -1;\n    int pos = -1;\n    int now = 0;\n    while(max != 0){\n        max = -1;\n        pos = -1;\n        for(i = 0; i < 128;i++) if(check[i] > max) max = check[i],pos = i;\n        for(i = 0; i < max;i++) ret[now++] = pos;\n        check[pos] = 0;\n    }\n    ret[now] = 0;\n    return ret;\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-06-04 23:26:26accepted [https://leetcode-cn.com//submissions/detail/2907115/]53 ms16.52%n/ajava# 统计信息\n通过次数提交次数ac比率117301920361.1%# 相似题目\n题目难度前 k 个高频元素 [https://leetcode-cn.com/problems/top-k-frequent-elements/]中等字符串中的第一个唯一字符 [https://leetcode-cn.com/problems/first-unique-character-in-a-string/]简单'},{title:"454-四数相加 II(4Sum II)",frontmatter:{title:"454-四数相加 II(4Sum II)",date:"2018-06-11T00:00:00.000Z",categories:["中等"],tags:["哈希表<Hash Table>","二分查找<Binary Search>"]},regularPath:"/views/%E4%B8%AD%E7%AD%89/0454-%E5%9B%9B%E6%95%B0%E7%9B%B8%E5%8A%A0%20II.html",relativePath:"views/中等/0454-四数相加 II.md",key:"v-9b996c72",path:"/views/%E4%B8%AD%E7%AD%89/0454-%E5%9B%9B%E6%95%B0%E7%9B%B8%E5%8A%A0%20II.html",headers:[{level:2,title:"中文题目",slug:"中文题目",charIndex:2},{level:2,title:"通过代码",slug:"通过代码",charIndex:412},{level:2,title:"高赞题解",slug:"高赞题解",charIndex:1375},{level:2,title:"提交历史",slug:"提交历史",charIndex:1662},{level:2,title:"统计信息",slug:"统计信息",charIndex:1791},{level:2,title:"相似题目",slug:"相似题目",charIndex:1825}],lastUpdated:"4/11/2021, 1:15:21 PM",headersStr:"中文题目 通过代码 高赞题解 提交历史 统计信息 相似题目",content:"# 中文题目\n给定四个包含整数的数组列表 A , B , C , D ,计算有多少个元组 (i, j, k, l)，使得A[i] + B[j] + C[k] + D[l] = 0。\n\n为了使问题简单化，所有的 A, B, C, D 具有相同的长度 N，且 0 ≤ N ≤ 500 。所有整数的范围在 -228 到 228 - 1 之间，最终结果不会超过 231 - 1 。\n\n例如:\n\n\n输入:\nA = [ 1, 2]\nB = [-2,-1]\nC = [-1, 2]\nD = [ 0, 2]\n\n输出:\n2\n\n解释:\n两个元组如下:\n1. (0, 0, 0, 1) -> A[0] + B[0] + C[0] + D[1] = 1 + (-2) + (-1) + 2 = 0\n2. (1, 1, 0, 0) -> A[1] + B[1] + C[0] + D[0] = 2 + (-1) + (-1) + 0 = 0\n\n\n# 通过代码\nimport java.util.HashMap;\nimport java.util.Map;\nclass Solution {\n    public int fourSumCount(int[] A, int[] B, int[] C, int[] D) {\n        Map<Integer,Integer> map=new HashMap<>();\n            for (int i = 0; i < C.length; i++) {\n                for (int j = 0; j < D.length; j++) {\n                    if (map.containsKey(C[i]+D[j])){\n                        int tmp=map.get(C[i]+D[j]);\n                        map.put(C[i]+D[j],++tmp);\n                    }else {\n                        map.put(C[i]+D[j],1);\n                    }\n                }\n            }\n            int count=0;\n            for (int i = 0; i < A.length; i++) {\n                for (int j = 0; j < B.length; j++) {\n                    if (map.containsKey(0-A[i]-B[j])){\n                        count+=map.get(0-A[i]-B[j]);\n                    }\n                }\n            }\n            return count;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n# 高赞题解\nclass Solution:\n    def fourSumCount(self, A: List[int], B: List[int], C: List[int], D: List[int]) -> int:\n        dic = collections.Counter(a + b for a in A for b in B)\n        return sum(dic.get(- c - d, 0) for c in C for d in D)\n\n\n1\n2\n3\n4\n * 思路同第一题 TWO SUM 的 O(N) 字典解法，记录需要的值\n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-06-11 23:04:47Accepted [https://leetcode-cn.com//submissions/detail/3108735/]232 ms5.16%N/Ajava# 统计信息\n通过次数提交次数AC比率137552545954.0%# 相似题目\n题目难度四数之和 [https://leetcode-cn.com/problems/4sum/]中等",contentLowercase:"# 中文题目\n给定四个包含整数的数组列表 a , b , c , d ,计算有多少个元组 (i, j, k, l)，使得a[i] + b[j] + c[k] + d[l] = 0。\n\n为了使问题简单化，所有的 a, b, c, d 具有相同的长度 n，且 0 ≤ n ≤ 500 。所有整数的范围在 -228 到 228 - 1 之间，最终结果不会超过 231 - 1 。\n\n例如:\n\n\n输入:\na = [ 1, 2]\nb = [-2,-1]\nc = [-1, 2]\nd = [ 0, 2]\n\n输出:\n2\n\n解释:\n两个元组如下:\n1. (0, 0, 0, 1) -> a[0] + b[0] + c[0] + d[1] = 1 + (-2) + (-1) + 2 = 0\n2. (1, 1, 0, 0) -> a[1] + b[1] + c[0] + d[0] = 2 + (-1) + (-1) + 0 = 0\n\n\n# 通过代码\nimport java.util.hashmap;\nimport java.util.map;\nclass solution {\n    public int foursumcount(int[] a, int[] b, int[] c, int[] d) {\n        map<integer,integer> map=new hashmap<>();\n            for (int i = 0; i < c.length; i++) {\n                for (int j = 0; j < d.length; j++) {\n                    if (map.containskey(c[i]+d[j])){\n                        int tmp=map.get(c[i]+d[j]);\n                        map.put(c[i]+d[j],++tmp);\n                    }else {\n                        map.put(c[i]+d[j],1);\n                    }\n                }\n            }\n            int count=0;\n            for (int i = 0; i < a.length; i++) {\n                for (int j = 0; j < b.length; j++) {\n                    if (map.containskey(0-a[i]-b[j])){\n                        count+=map.get(0-a[i]-b[j]);\n                    }\n                }\n            }\n            return count;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n# 高赞题解\nclass solution:\n    def foursumcount(self, a: list[int], b: list[int], c: list[int], d: list[int]) -> int:\n        dic = collections.counter(a + b for a in a for b in b)\n        return sum(dic.get(- c - d, 0) for c in c for d in d)\n\n\n1\n2\n3\n4\n * 思路同第一题 two sum 的 o(n) 字典解法，记录需要的值\n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-06-11 23:04:47accepted [https://leetcode-cn.com//submissions/detail/3108735/]232 ms5.16%n/ajava# 统计信息\n通过次数提交次数ac比率137552545954.0%# 相似题目\n题目难度四数之和 [https://leetcode-cn.com/problems/4sum/]中等"},{title:"剑指 Offer 04-二维数组中的查找(二维数组中的查找 LCOF)",frontmatter:{title:"剑指 Offer 04-二维数组中的查找(二维数组中的查找 LCOF)",date:"2021-04-08T00:00:00.000Z",categories:["中等"],tags:["数组<Array>","双指针<Two Pointers>"]},regularPath:"/views/%E4%B8%AD%E7%AD%89/%E5%89%91%E6%8C%87%20Offer%2004-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE.html",relativePath:"views/中等/剑指 Offer 04-二维数组中的查找.md",key:"v-237c778e",path:"/views/%E4%B8%AD%E7%AD%89/%E5%89%91%E6%8C%87%20Offer%2004-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE.html",headers:[{level:2,title:"中文题目",slug:"中文题目",charIndex:2},{level:2,title:"通过代码",slug:"通过代码",charIndex:392},{level:2,title:"高赞题解",slug:"高赞题解",charIndex:966},{level:2,title:"提交历史",slug:"提交历史",charIndex:3016},{level:2,title:"统计信息",slug:"统计信息",charIndex:3252}],lastUpdated:"4/11/2021, 1:15:21 PM",headersStr:"中文题目 通过代码 高赞题解 提交历史 统计信息",content:"# 中文题目\n在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。\n\n\n\n示例:\n\n现有矩阵 matrix 如下：\n\n\n[\n  [1,   4,  7, 11, 15],\n  [2,   5,  8, 12, 19],\n  [3,   6,  9, 16, 22],\n  [10, 13, 14, 17, 24],\n  [18, 21, 23, 26, 30]\n]\n\n\n给定 target =5，返回true。\n\n给定 target =20，返回false。\n\n\n\n限制：\n\n0 \n\n0 \n\n\n\n注意：本题与主站 240 题相同：https://leetcode-cn.com/problems/search-a-2d-matrix-ii/\n\n# 通过代码\nclass Solution {\n        public boolean findNumberIn2DArray(int[][] matrix, int target) {\n            // 行数\n            int row = matrix.length;\n            if (row==0){\n                return false;\n            }\n            // 列数\n            int col = matrix[0].length;\n            for (int i = row - 1, j = 0; i >= 0 && j < col; ) {\n                if (matrix[i][j] > target) i--;\n                else if (matrix[i][j] < target) j++;\n                else return true;\n            }\n            return false;\n        }\n    }\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n# 高赞题解\n# 解题思路：\n> 若使用暴力法遍历矩阵 matrix ，则时间复杂度为 O(NM)O(NM)O(NM) 。暴力法未利用矩阵 “从上到下递增、从左到右递增” 的特点，显然不是最优解法。\n\n\n如下图所示，我们将矩阵逆时针旋转 45° ，并将其转化为图形式，发现其类似于 二叉搜索树 ，即对于每个元素，其左分支元素更小、右分支元素更大。因此，通过从 “根节点” 开始搜索，遇到比 target 大的元素就向左，反之向右，即可找到目标值 target 。\n\n{:width=450}\n\n“根节点” 对应的是矩阵的 “左下角” 和 “右上角” 元素，本文称之为 标志数 ，以 matrix 中的 左下角元素 为标志数 flag ，则有:\n\n 1. 若 flag > target ，则 target 一定在 flag 所在 行的上方 ，即 flag 所在行可被消去。\n 2. 若 flag < target ，则 target 一定在 flag 所在 列的右方 ，即 flag 所在列可被消去。\n\n# 算法流程：\n 1. 从矩阵 matrix 左下角元素（索引设为 (i, j) ）开始遍历，并与目标值对比： * 当 matrix[i][j] > target 时，执行 i-- ，即消去第 i 行元素；\n     * 当 matrix[i][j] < target 时，执行 j++ ，即消去第 j 列元素；\n     * 当 matrix[i][j] = target 时，返回 truetruetrue ，代表找到目标值。\n    \n    \n 2. 若行索引或列索引越界，则代表矩阵中无目标值，返回 falsefalsefalse 。\n\n> 每轮 i 或 j 移动后，相当于生成了“消去一行（列）的新矩阵”， 索引(i,j) 指向新矩阵的左下角元素（标志数），因此可重复使用以上性质消去行（列）。\n\n\n# 复杂度分析：\n * 时间复杂度 O(M+N)O(M+N)O(M+N) ：其中，NNN 和 MMM 分别为矩阵行数和列数，此算法最多循环 M+NM+NM+N 次。\n * 空间复杂度 O(1)O(1)O(1) : i, j 指针使用常数大小额外空间。\n\n<,,,,,>\n\n# 代码：\nclass Solution:\n    def findNumberIn2DArray(self, matrix: List[List[int]], target: int) -> bool:\n        i, j = len(matrix) - 1, 0\n        while i >= 0 and j < len(matrix[0]):\n            if matrix[i][j] > target: i -= 1\n            elif matrix[i][j] < target: j += 1\n            else: return True\n        return False\n\n\n1\n2\n3\n4\n5\n6\n7\n8\nclass Solution {\n    public boolean findNumberIn2DArray(int[][] matrix, int target) {\n        int i = matrix.length - 1, j = 0;\n        while(i >= 0 && j < matrix[0].length)\n        {\n            if(matrix[i][j] > target) i--;\n            else if(matrix[i][j] < target) j++;\n            else return true;\n        }\n        return false;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\nclass Solution {\npublic:\n    bool findNumberIn2DArray(vector<vector<int>>& matrix, int target) {\n        int i = matrix.size() - 1, j = 0;\n        while(i >= 0 && j < matrix[0].size())\n        {\n            if(matrix[i][j] > target) i--;\n            else if(matrix[i][j] < target) j++;\n            else return true;\n        }\n        return false;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2021-04-08 17:34:21Accepted [https://leetcode-cn.com//submissions/detail/165344161/]0 ms100.0%44.3 MBjava2021-04-08 17:32:26Runtime Error [https://leetcode-cn.com//submissions/detail/165343346/]N/AN/AN/Ajava# 统计信息\n通过次数提交次数AC比率17061342168440.5%",contentLowercase:"# 中文题目\n在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。\n\n\n\n示例:\n\n现有矩阵 matrix 如下：\n\n\n[\n  [1,   4,  7, 11, 15],\n  [2,   5,  8, 12, 19],\n  [3,   6,  9, 16, 22],\n  [10, 13, 14, 17, 24],\n  [18, 21, 23, 26, 30]\n]\n\n\n给定 target =5，返回true。\n\n给定 target =20，返回false。\n\n\n\n限制：\n\n0 \n\n0 \n\n\n\n注意：本题与主站 240 题相同：https://leetcode-cn.com/problems/search-a-2d-matrix-ii/\n\n# 通过代码\nclass solution {\n        public boolean findnumberin2darray(int[][] matrix, int target) {\n            // 行数\n            int row = matrix.length;\n            if (row==0){\n                return false;\n            }\n            // 列数\n            int col = matrix[0].length;\n            for (int i = row - 1, j = 0; i >= 0 && j < col; ) {\n                if (matrix[i][j] > target) i--;\n                else if (matrix[i][j] < target) j++;\n                else return true;\n            }\n            return false;\n        }\n    }\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n# 高赞题解\n# 解题思路：\n> 若使用暴力法遍历矩阵 matrix ，则时间复杂度为 o(nm)o(nm)o(nm) 。暴力法未利用矩阵 “从上到下递增、从左到右递增” 的特点，显然不是最优解法。\n\n\n如下图所示，我们将矩阵逆时针旋转 45° ，并将其转化为图形式，发现其类似于 二叉搜索树 ，即对于每个元素，其左分支元素更小、右分支元素更大。因此，通过从 “根节点” 开始搜索，遇到比 target 大的元素就向左，反之向右，即可找到目标值 target 。\n\n{:width=450}\n\n“根节点” 对应的是矩阵的 “左下角” 和 “右上角” 元素，本文称之为 标志数 ，以 matrix 中的 左下角元素 为标志数 flag ，则有:\n\n 1. 若 flag > target ，则 target 一定在 flag 所在 行的上方 ，即 flag 所在行可被消去。\n 2. 若 flag < target ，则 target 一定在 flag 所在 列的右方 ，即 flag 所在列可被消去。\n\n# 算法流程：\n 1. 从矩阵 matrix 左下角元素（索引设为 (i, j) ）开始遍历，并与目标值对比： * 当 matrix[i][j] > target 时，执行 i-- ，即消去第 i 行元素；\n     * 当 matrix[i][j] < target 时，执行 j++ ，即消去第 j 列元素；\n     * 当 matrix[i][j] = target 时，返回 truetruetrue ，代表找到目标值。\n    \n    \n 2. 若行索引或列索引越界，则代表矩阵中无目标值，返回 falsefalsefalse 。\n\n> 每轮 i 或 j 移动后，相当于生成了“消去一行（列）的新矩阵”， 索引(i,j) 指向新矩阵的左下角元素（标志数），因此可重复使用以上性质消去行（列）。\n\n\n# 复杂度分析：\n * 时间复杂度 o(m+n)o(m+n)o(m+n) ：其中，nnn 和 mmm 分别为矩阵行数和列数，此算法最多循环 m+nm+nm+n 次。\n * 空间复杂度 o(1)o(1)o(1) : i, j 指针使用常数大小额外空间。\n\n<,,,,,>\n\n# 代码：\nclass solution:\n    def findnumberin2darray(self, matrix: list[list[int]], target: int) -> bool:\n        i, j = len(matrix) - 1, 0\n        while i >= 0 and j < len(matrix[0]):\n            if matrix[i][j] > target: i -= 1\n            elif matrix[i][j] < target: j += 1\n            else: return true\n        return false\n\n\n1\n2\n3\n4\n5\n6\n7\n8\nclass solution {\n    public boolean findnumberin2darray(int[][] matrix, int target) {\n        int i = matrix.length - 1, j = 0;\n        while(i >= 0 && j < matrix[0].length)\n        {\n            if(matrix[i][j] > target) i--;\n            else if(matrix[i][j] < target) j++;\n            else return true;\n        }\n        return false;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\nclass solution {\npublic:\n    bool findnumberin2darray(vector<vector<int>>& matrix, int target) {\n        int i = matrix.size() - 1, j = 0;\n        while(i >= 0 && j < matrix[0].size())\n        {\n            if(matrix[i][j] > target) i--;\n            else if(matrix[i][j] < target) j++;\n            else return true;\n        }\n        return false;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2021-04-08 17:34:21accepted [https://leetcode-cn.com//submissions/detail/165344161/]0 ms100.0%44.3 mbjava2021-04-08 17:32:26runtime error [https://leetcode-cn.com//submissions/detail/165343346/]n/an/an/ajava# 统计信息\n通过次数提交次数ac比率17061342168440.5%"},{title:"23-合并K个排序链表(Merge k Sorted Lists)",frontmatter:{title:"23-合并K个排序链表(Merge k Sorted Lists)",date:"2018-09-05T00:00:00.000Z",categories:["困难"],tags:["堆<Heap>","链表<Linked List>","分治算法<Divide and Conquer>"]},regularPath:"/views/%E5%9B%B0%E9%9A%BE/0023-%E5%90%88%E5%B9%B6K%E4%B8%AA%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8.html",relativePath:"views/困难/0023-合并K个排序链表.md",key:"v-25ece19a",path:"/views/%E5%9B%B0%E9%9A%BE/0023-%E5%90%88%E5%B9%B6K%E4%B8%AA%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8.html",headers:[{level:2,title:"中文题目",slug:"中文题目",charIndex:2},{level:2,title:"通过代码",slug:"通过代码",charIndex:114},{level:2,title:"官方题解",slug:"官方题解",charIndex:1385},{level:2,title:"提交历史",slug:"提交历史",charIndex:6072},{level:2,title:"统计信息",slug:"统计信息",charIndex:6401},{level:2,title:"相似题目",slug:"相似题目",charIndex:6436}],lastUpdated:"4/11/2021, 1:15:21 PM",headersStr:"中文题目 通过代码 官方题解 提交历史 统计信息 相似题目",content:'# 中文题目\n合并k个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。\n\n示例:\n\n输入:\n[\n  1->4->5,\n  1->3->4,\n  2->6\n]\n输出: 1->1->2->3->4->4->5->6\n\n# 通过代码\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        if (lists.length==0 || lists==null){\n                return null;\n            }\n        PriorityQueue<ListNode> priorityQueue=new PriorityQueue<ListNode>(new Comparator<ListNode>() {\n                @Override\n                public int compare(ListNode o1, ListNode o2) {\n                    return o1.val-o2.val;\n                }\n            });\n            for (int i = 0; i < lists.length; i++) {\n                while (lists[i]!=null){\n                    priorityQueue.add(lists[i]);\n                    lists[i]=lists[i].next;\n                }\n            }\n            if (priorityQueue.isEmpty()){\n                return null;\n            }\n            ListNode root=priorityQueue.poll();\n            ListNode head=root;\n            while (!priorityQueue.isEmpty()){\n                root.next=priorityQueue.poll();\n                root=root.next;\n            }\n            root.next=null;\n            return head;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n# 官方题解\n# 方法 1：暴力\n想法 & 算法\n\n * 遍历所有链表，将所有节点的值放到一个数组中。\n * 将这个数组排序，然后遍历所有元素得到正确顺序的值。\n * 用遍历得到的值，创建一个新的有序链表。\n\n关于排序，你可以参考 这里 [https://www.cs.cmu.edu/~adamchik/15-121/lectures/Sorting%20Algorithms/sorting.html] 获得更多关于排序算法的内容。\n\nclass Solution(object):\n    def mergeKLists(self, lists):\n        """\n        :type lists: List[ListNode]\n        :rtype: ListNode\n        """\n        self.nodes = []\n        head = point = ListNode(0)\n        for l in lists:\n            while l:\n                self.nodes.append(l.val)\n                l = l.next\n        for x in sorted(self.nodes):\n            point.next = ListNode(x)\n            point = point.next\n        return head.next\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n复杂度分析\n\n * 时间复杂度：O(Nlog⁡N)O(N\\log N)O(NlogN) ，其中 NNN 是节点的总数目。\n   \n    * 遍历所有的值需花费 O(N)O(N)O(N) 的时间。\n    * 一个稳定的排序算法花费 O(Nlog⁡N)O(N\\log N)O(NlogN) 的时间。\n    * 遍历同时创建新的有序链表花费 O(N)O(N)O(N) 的时间。\n   \n   \n * 空间复杂度：O(N)O(N)O(N) 。\n   \n    * 排序花费 O(N)O(N)O(N) 空间（这取决于你选择的算法）。\n    * 创建一个新的链表花费 O(N)O(N)O(N) 的空间。\n   \n   \n\n# 方法 2：逐一比较\n算法\n\n * 比较 k\\text{k}k 个节点（每个链表的首节点），获得最小值的节点。\n * 将选中的节点接在最终有序链表的后面。\n\n复杂度分析\n\n * 时间复杂度： O(kN)O(kN)O(kN) ，其中 k\\text{k}k 是链表的数目。\n   \n    * 几乎最终有序链表中每个节点的时间开销都为 O(k)O(k)O(k) （k-1\\text{k-1}k-1 次比较）。\n    * 总共有 NNN 个节点在最后的链表中。\n   \n   \n * 空间复杂度：\n   \n    * O(n)O(n)O(n) 。创建一个新的链表空间开销为 O(n)O(n)O(n) 。\n    * O(1)O(1)O(1) 。重复利用原来的链表节点，每次选择节点时将它直接接在最后返回的链表后面，而不是创建一个新的节点。\n   \n   \n\n# 方法 3：用优先队列优化方法 2\n算法\n\n几乎与上述方法一样，除了将 比较环节 用 优先队列 进行了优化。你可以参考 这里 [https://baike.baidu.com/item/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/9354754?fr=aladdin] 获取更多信息。\n\nfrom Queue import PriorityQueue\n\nclass Solution(object):\n    def mergeKLists(self, lists):\n        """\n        :type lists: List[ListNode]\n        :rtype: ListNode\n        """\n        head = point = ListNode(0)\n        q = PriorityQueue()\n        for l in lists:\n            if l:\n                q.put((l.val, l))\n        while not q.empty():\n            val, node = q.get()\n            point.next = ListNode(val)\n            point = point.next\n            node = node.next\n            if node:\n                q.put((node.val, node))\n        return head.next\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n复杂度分析\n\n * 时间复杂度： O(Nlog⁡k)O(N\\log k)O(Nlogk) ，其中 k\\text{k}k 是链表的数目。\n   \n    * 弹出操作时，比较操作的代价会被优化到 O(log⁡k)O(\\log k)O(logk) 。同时，找到最小值节点的时间开销仅仅为 O(1)O(1)O(1)。\n    * 最后的链表中总共有 NNN 个节点。\n   \n   \n * 空间复杂度：\n   \n    * O(n)O(n)O(n) 。创造一个新的链表需要 O(n)O(n)O(n) 的开销。\n    * O(k)O(k)O(k) 。以上代码采用了重复利用原有节点，所以只要 O(1)O(1)O(1) 的空间。同时优先队列（通常用堆实现）需要 O(k)O(k)O(k) 的空间（远比大多数情况的 NNN要小）。\n   \n   \n\n# 方法 4：逐一两两合并链表\n算法\n\n将合并 k\\text{k}k 个链表的问题转化成合并 2 个链表 k-1\\text{k-1}k-1 次。这里是 合并两个有序链表 [https://leetcode-cn.com/problems/merge-two-sorted-lists/] 的题目。\n\n复杂度分析\n\n * 时间复杂度： O(kN)O(kN)O(kN) ，其中 k\\text{k}k 是链表的数目。\n   \n    * 我们可以在 O(n)O(n)O(n) 的时间内合并两个有序链表，其中 nnn 是两个链表的总长度。\n    * 把所有合并过程所需的时间加起来，我们可以得到： O(∑i=1k−1(i∗(Nk)+Nk))=O(kN)O(\\sum_{i=1}^{k-1} (i*(\\frac{N}{k}) + \\frac{N}{k})) = O(kN)O(∑i=1k−1​(i∗(kN​)+kN​))=O(kN) 。\n   \n   \n * 空间复杂度：O(1)O(1)O(1)\n   \n    * 我们可以在 O(1)O(1)O(1) 空间内合并两个有序链表。\n   \n   \n\n# 方法 5：分治\n想法 & 算法\n\n这个方法沿用了上面的解法，但是进行了较大的优化。我们不需要对大部分节点重复遍历多次。\n\n * 将 k\\text{k}k 个链表配对并将同一对中的链表合并。\n * 第一轮合并以后， k\\text{k}k 个链表被合并成了 k2\\frac{k}{2}2k​ 个链表，平均长度为 2Nk\\frac{2N}{k}k2N​ ，然后是 k4\\frac{k}{4}4k​ 个链表， k8\\frac{k}{8}8k​ 个链表等等。\n * 重复这一过程，直到我们得到了最终的有序链表。\n\n因此，我们在每一次配对合并的过程中都会遍历几乎全部 NNN 个节点，并重复这一过程 log⁡2K\\log_2Klog2​K 次。\n\n{:width="400"} {:align="center"}\n\nclass Solution(object):\n    def mergeKLists(self, lists):\n        """\n        :type lists: List[ListNode]\n        :rtype: ListNode\n        """\n        amount = len(lists)\n        interval = 1\n        while interval < amount:\n            for i in range(0, amount - interval, interval * 2):\n                lists[i] = self.merge2Lists(lists[i], lists[i + interval])\n            interval *= 2\n        return lists[0] if amount > 0 else lists\n\n    def merge2Lists(self, l1, l2):\n        head = point = ListNode(0)\n        while l1 and l2:\n            if l1.val <= l2.val:\n                point.next = l1\n                l1 = l1.next\n            else:\n                point.next = l2\n                l2 = l1\n                l1 = point.next.next\n            point = point.next\n        if not l1:\n            point.next=l2\n        else:\n            point.next=l1\n        return head.next\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n复杂度分析\n\n * 时间复杂度： O(Nlog⁡k)O(N\\log k)O(Nlogk) ，其中 k\\text{k}k 是链表的数目。\n   \n    * 我们可以在 O(n)O(n)O(n) 的时间内合并两个有序链表，其中 nnn 是两个链表中的总节点数。\n    * 将所有的合并进程加起来，我们可以得到：O(∑i=1log2kN)=O(Nlog⁡k)O\\big(\\sum_{i=1}^{log_2k}N \\big)= O(N\\log k)O(∑i=1log2​k​N)=O(Nlogk) 。\n   \n   \n * 空间复杂度：O(1)O(1)O(1)\n   \n    * 我们可以用 O(1)O(1)O(1) 的空间实现两个有序链表的合并。\n   \n   \n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-09-05 20:49:51Accepted [https://leetcode-cn.com//submissions/detail/6603590/]25 ms35.07%N/Ajava2018-09-05 20:47:39Runtime Error [https://leetcode-cn.com//submissions/detail/6603442/]N/AN/AN/Ajava2018-09-05 20:47:05Runtime Error [https://leetcode-cn.com//submissions/detail/6603395/]N/AN/AN/Ajava# 统计信息\n通过次数提交次数AC比率6759913940648.5%# 相似题目\n题目难度合并两个有序链表 [https://leetcode-cn.com/problems/merge-two-sorted-lists/]简单丑数 II [https://leetcode-cn.com/problems/ugly-number-ii/]中等',contentLowercase:'# 中文题目\n合并k个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。\n\n示例:\n\n输入:\n[\n  1->4->5,\n  1->3->4,\n  2->6\n]\n输出: 1->1->2->3->4->4->5->6\n\n# 通过代码\n/**\n * definition for singly-linked list.\n * public class listnode {\n *     int val;\n *     listnode next;\n *     listnode(int x) { val = x; }\n * }\n */\nclass solution {\n    public listnode mergeklists(listnode[] lists) {\n        if (lists.length==0 || lists==null){\n                return null;\n            }\n        priorityqueue<listnode> priorityqueue=new priorityqueue<listnode>(new comparator<listnode>() {\n                @override\n                public int compare(listnode o1, listnode o2) {\n                    return o1.val-o2.val;\n                }\n            });\n            for (int i = 0; i < lists.length; i++) {\n                while (lists[i]!=null){\n                    priorityqueue.add(lists[i]);\n                    lists[i]=lists[i].next;\n                }\n            }\n            if (priorityqueue.isempty()){\n                return null;\n            }\n            listnode root=priorityqueue.poll();\n            listnode head=root;\n            while (!priorityqueue.isempty()){\n                root.next=priorityqueue.poll();\n                root=root.next;\n            }\n            root.next=null;\n            return head;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n# 官方题解\n# 方法 1：暴力\n想法 & 算法\n\n * 遍历所有链表，将所有节点的值放到一个数组中。\n * 将这个数组排序，然后遍历所有元素得到正确顺序的值。\n * 用遍历得到的值，创建一个新的有序链表。\n\n关于排序，你可以参考 这里 [https://www.cs.cmu.edu/~adamchik/15-121/lectures/sorting%20algorithms/sorting.html] 获得更多关于排序算法的内容。\n\nclass solution(object):\n    def mergeklists(self, lists):\n        """\n        :type lists: list[listnode]\n        :rtype: listnode\n        """\n        self.nodes = []\n        head = point = listnode(0)\n        for l in lists:\n            while l:\n                self.nodes.append(l.val)\n                l = l.next\n        for x in sorted(self.nodes):\n            point.next = listnode(x)\n            point = point.next\n        return head.next\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n复杂度分析\n\n * 时间复杂度：o(nlog⁡n)o(n\\log n)o(nlogn) ，其中 nnn 是节点的总数目。\n   \n    * 遍历所有的值需花费 o(n)o(n)o(n) 的时间。\n    * 一个稳定的排序算法花费 o(nlog⁡n)o(n\\log n)o(nlogn) 的时间。\n    * 遍历同时创建新的有序链表花费 o(n)o(n)o(n) 的时间。\n   \n   \n * 空间复杂度：o(n)o(n)o(n) 。\n   \n    * 排序花费 o(n)o(n)o(n) 空间（这取决于你选择的算法）。\n    * 创建一个新的链表花费 o(n)o(n)o(n) 的空间。\n   \n   \n\n# 方法 2：逐一比较\n算法\n\n * 比较 k\\text{k}k 个节点（每个链表的首节点），获得最小值的节点。\n * 将选中的节点接在最终有序链表的后面。\n\n复杂度分析\n\n * 时间复杂度： o(kn)o(kn)o(kn) ，其中 k\\text{k}k 是链表的数目。\n   \n    * 几乎最终有序链表中每个节点的时间开销都为 o(k)o(k)o(k) （k-1\\text{k-1}k-1 次比较）。\n    * 总共有 nnn 个节点在最后的链表中。\n   \n   \n * 空间复杂度：\n   \n    * o(n)o(n)o(n) 。创建一个新的链表空间开销为 o(n)o(n)o(n) 。\n    * o(1)o(1)o(1) 。重复利用原来的链表节点，每次选择节点时将它直接接在最后返回的链表后面，而不是创建一个新的节点。\n   \n   \n\n# 方法 3：用优先队列优化方法 2\n算法\n\n几乎与上述方法一样，除了将 比较环节 用 优先队列 进行了优化。你可以参考 这里 [https://baike.baidu.com/item/%e4%bc%98%e5%85%88%e9%98%9f%e5%88%97/9354754?fr=aladdin] 获取更多信息。\n\nfrom queue import priorityqueue\n\nclass solution(object):\n    def mergeklists(self, lists):\n        """\n        :type lists: list[listnode]\n        :rtype: listnode\n        """\n        head = point = listnode(0)\n        q = priorityqueue()\n        for l in lists:\n            if l:\n                q.put((l.val, l))\n        while not q.empty():\n            val, node = q.get()\n            point.next = listnode(val)\n            point = point.next\n            node = node.next\n            if node:\n                q.put((node.val, node))\n        return head.next\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n复杂度分析\n\n * 时间复杂度： o(nlog⁡k)o(n\\log k)o(nlogk) ，其中 k\\text{k}k 是链表的数目。\n   \n    * 弹出操作时，比较操作的代价会被优化到 o(log⁡k)o(\\log k)o(logk) 。同时，找到最小值节点的时间开销仅仅为 o(1)o(1)o(1)。\n    * 最后的链表中总共有 nnn 个节点。\n   \n   \n * 空间复杂度：\n   \n    * o(n)o(n)o(n) 。创造一个新的链表需要 o(n)o(n)o(n) 的开销。\n    * o(k)o(k)o(k) 。以上代码采用了重复利用原有节点，所以只要 o(1)o(1)o(1) 的空间。同时优先队列（通常用堆实现）需要 o(k)o(k)o(k) 的空间（远比大多数情况的 nnn要小）。\n   \n   \n\n# 方法 4：逐一两两合并链表\n算法\n\n将合并 k\\text{k}k 个链表的问题转化成合并 2 个链表 k-1\\text{k-1}k-1 次。这里是 合并两个有序链表 [https://leetcode-cn.com/problems/merge-two-sorted-lists/] 的题目。\n\n复杂度分析\n\n * 时间复杂度： o(kn)o(kn)o(kn) ，其中 k\\text{k}k 是链表的数目。\n   \n    * 我们可以在 o(n)o(n)o(n) 的时间内合并两个有序链表，其中 nnn 是两个链表的总长度。\n    * 把所有合并过程所需的时间加起来，我们可以得到： o(∑i=1k−1(i∗(nk)+nk))=o(kn)o(\\sum_{i=1}^{k-1} (i*(\\frac{n}{k}) + \\frac{n}{k})) = o(kn)o(∑i=1k−1​(i∗(kn​)+kn​))=o(kn) 。\n   \n   \n * 空间复杂度：o(1)o(1)o(1)\n   \n    * 我们可以在 o(1)o(1)o(1) 空间内合并两个有序链表。\n   \n   \n\n# 方法 5：分治\n想法 & 算法\n\n这个方法沿用了上面的解法，但是进行了较大的优化。我们不需要对大部分节点重复遍历多次。\n\n * 将 k\\text{k}k 个链表配对并将同一对中的链表合并。\n * 第一轮合并以后， k\\text{k}k 个链表被合并成了 k2\\frac{k}{2}2k​ 个链表，平均长度为 2nk\\frac{2n}{k}k2n​ ，然后是 k4\\frac{k}{4}4k​ 个链表， k8\\frac{k}{8}8k​ 个链表等等。\n * 重复这一过程，直到我们得到了最终的有序链表。\n\n因此，我们在每一次配对合并的过程中都会遍历几乎全部 nnn 个节点，并重复这一过程 log⁡2k\\log_2klog2​k 次。\n\n{:width="400"} {:align="center"}\n\nclass solution(object):\n    def mergeklists(self, lists):\n        """\n        :type lists: list[listnode]\n        :rtype: listnode\n        """\n        amount = len(lists)\n        interval = 1\n        while interval < amount:\n            for i in range(0, amount - interval, interval * 2):\n                lists[i] = self.merge2lists(lists[i], lists[i + interval])\n            interval *= 2\n        return lists[0] if amount > 0 else lists\n\n    def merge2lists(self, l1, l2):\n        head = point = listnode(0)\n        while l1 and l2:\n            if l1.val <= l2.val:\n                point.next = l1\n                l1 = l1.next\n            else:\n                point.next = l2\n                l2 = l1\n                l1 = point.next.next\n            point = point.next\n        if not l1:\n            point.next=l2\n        else:\n            point.next=l1\n        return head.next\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n复杂度分析\n\n * 时间复杂度： o(nlog⁡k)o(n\\log k)o(nlogk) ，其中 k\\text{k}k 是链表的数目。\n   \n    * 我们可以在 o(n)o(n)o(n) 的时间内合并两个有序链表，其中 nnn 是两个链表中的总节点数。\n    * 将所有的合并进程加起来，我们可以得到：o(∑i=1log2kn)=o(nlog⁡k)o\\big(\\sum_{i=1}^{log_2k}n \\big)= o(n\\log k)o(∑i=1log2​k​n)=o(nlogk) 。\n   \n   \n * 空间复杂度：o(1)o(1)o(1)\n   \n    * 我们可以用 o(1)o(1)o(1) 的空间实现两个有序链表的合并。\n   \n   \n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-09-05 20:49:51accepted [https://leetcode-cn.com//submissions/detail/6603590/]25 ms35.07%n/ajava2018-09-05 20:47:39runtime error [https://leetcode-cn.com//submissions/detail/6603442/]n/an/an/ajava2018-09-05 20:47:05runtime error [https://leetcode-cn.com//submissions/detail/6603395/]n/an/an/ajava# 统计信息\n通过次数提交次数ac比率6759913940648.5%# 相似题目\n题目难度合并两个有序链表 [https://leetcode-cn.com/problems/merge-two-sorted-lists/]简单丑数 ii [https://leetcode-cn.com/problems/ugly-number-ii/]中等'},{title:"51-N皇后(N-Queens)",frontmatter:{title:"51-N皇后(N-Queens)",date:"2018-07-22T00:00:00.000Z",categories:["困难"],tags:["回溯算法<Backtracking>"]},regularPath:"/views/%E5%9B%B0%E9%9A%BE/0051-N%E7%9A%87%E5%90%8E.html",relativePath:"views/困难/0051-N皇后.md",key:"v-0677f7bb",path:"/views/%E5%9B%B0%E9%9A%BE/0051-N%E7%9A%87%E5%90%8E.html",headers:[{level:2,title:"中文题目",slug:"中文题目",charIndex:2},{level:2,title:"通过代码",slug:"通过代码",charIndex:302},{level:2,title:"官方题解",slug:"官方题解",charIndex:3709},{level:2,title:"提交历史",slug:"提交历史",charIndex:8341},{level:2,title:"统计信息",slug:"统计信息",charIndex:8766},{level:2,title:"相似题目",slug:"相似题目",charIndex:8800}],lastUpdated:"4/11/2021, 1:15:21 PM",headersStr:"中文题目 通过代码 官方题解 提交历史 统计信息 相似题目",content:'# 中文题目\nn皇后问题研究的是如何将 n个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。\n\n\n\n上图为 8 皇后问题的一种解法。\n\n给定一个整数 n，返回所有不同的n皇后问题的解决方案。\n\n每一种解法包含一个明确的n 皇后问题的棋子放置方案，该方案中 \'Q\' 和 \'.\' 分别代表了皇后和空位。\n\n示例:\n\n输入: 4\n输出: [\n [".Q..",  // 解法 1\n  "...Q",\n  "Q...",\n  "..Q."],\n\n ["..Q.",  // 解法 2\n  "Q...",\n  "...Q",\n  ".Q.."]\n]\n解释: 4 皇后问题存在两个不同的解法。\n\n\n# 通过代码\nclass Solution {\n   List<List<String>> res=new LinkedList<>();\n    boolean[] col,dia1,dia2;\n    public List<List<String>> solveNQueens(int n) {\n        col=new boolean[n]; //同一列不能有两个\n        dia1=new boolean[2*n-1]; //两条对角线\n        dia2=new boolean[2*n-1];\n        LinkedList<Integer> row=new LinkedList<>();\n        putQueen(n,0,row);\n        return res;\n    }\n\n    private void putQueen(int n, int index, LinkedList<Integer> row) {\n        if (index==n){\n            List<String> list=generate(row);\n            res.add(list);\n            return;\n        }\n        for (int i = 0; i < n; i++) {\n//            å¤æ­åä¸åå两条对角线，两条对角线ä¸æ»¡è¶³ index+i相等和index-i+n-1相等\n            if (!col[i] && !dia1[index+i] && !dia2[index-i+n-1]){\n                row.addLast(i);\n                col[i]=true;\n                dia1[index+i]=true;\n                dia2[index-i+n-1]=true;\n                putQueen(n,index+1,row);\n                col[i]=false;\n                dia1[index+i]=false;\n                dia2[index-i+n-1]=false;\n                row.removeLast();\n            }\n        }\n        return;\n    }\n    //根据记录得到的点的列位置还原出图\n    private List<String> generate(LinkedList<Integer> row) {\n        LinkedList<String> linkedList=new LinkedList<>();\n        for (int i = 0; i < row.size(); i++) {\n            StringBuilder stringBuilder=new StringBuilder();\n            for (int j = 0; j < row.size(); j++) {\n                stringBuilder.append(\'.\');\n            }\n            stringBuilder.replace(row.get(i),row.get(i)+1,"Q");\n            linkedList.add(stringBuilder.toString());\n        }\n        return linkedList;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\nclass Solution {\n    List<List<String>> res=new LinkedList<>();\n    boolean[] col,dia1,dia2;\n    public List<List<String>> solveNQueens(int n) {\n        col=new boolean[n];\n        dia1=new boolean[2*n-1];\n        dia2=new boolean[2*n-1];\n        LinkedList<Integer> row=new LinkedList<>();\n        putQueen(n,0,row);\n        return res;\n    }\n\n    private void putQueen(int n, int index, LinkedList<Integer> row) {\n        if (index==n){\n            List<String> list=generate(row);\n            res.add(list);\n            return;\n        }\n        for (int i = 0; i < n; i++) {\n            if (!col[i] && !dia1[index+i] && !dia2[index-i+n-1]){\n                row.addLast(i);\n                col[i]=true;\n                dia1[index+i]=true;\n                dia2[index-i+n-1]=true;\n                putQueen(n,index+1,row);\n                col[i]=false;\n                dia1[index+i]=false;\n                dia2[index-i+n-1]=false;\n                row.removeLast();\n            }\n        }\n        return;\n    }\n\n    private List<String> generate(LinkedList<Integer> row) {\n        LinkedList<String> linkedList=new LinkedList<>();\n        for (int i = 0; i < row.size(); i++) {\n            StringBuilder stringBuilder=new StringBuilder();\n            for (int j = 0; j < row.size(); j++) {\n                stringBuilder.append(\'.\');\n            }\n            stringBuilder.replace(row.get(i),row.get(i)+1,"Q");\n            linkedList.add(stringBuilder.toString());\n        }\n        return linkedList;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n# 官方题解\n# 直观想法\n第一个想法是使用蛮力法，意味着生成在棋盘上放置 N 个皇后的所有可能的情况，并且检查是否保证没有皇后可以互相攻击。这意味着 O(NN)\\mathcal{O}(N^N)O(NN) 的时间复杂度，因此我们必须考虑优化。\n\n下面是两个有用的编程概念。\n\n> 第一个叫做 约束编程.\n\n\n它的基本含义是在放置每个皇后以后增加限制。当在棋盘上放置了一个皇后后，立即排除当前行，列和对应的两个对角线。该过程传递了 约束 从而有助于减少需要考虑情况数。\n\n{:width=500px}\n\n> 第二个叫做 回溯法.\n\n\n我们来想象一下，当在棋盘上放置了几个皇后且不会相互攻击。但是选择的方案不是最优的，因为无法放置下一个皇后。此时我们该怎么做？回溯。意思是回退一步，来改变最后放置皇后的位置并且接着往下放置。如果还是不行，再 回溯。\n\n{:width=500px}\n\n\n\n\n\n\n# 方法1：回溯\n在建立算法之前，我们来考虑两个有用的细节。\n\n> 一行只可能有一个皇后且一列也只可能有一个皇后。\n\n\n这意味着没有必要再棋盘上考虑所有的方格。只需要按列循环即可。\n\n> 对于所有的主对角线有 行号 + 列号 = 常数，对于所有的次对角线有 行号 - 列号 = 常数.\n\n\n这可以让我们标记已经在攻击范围下的对角线并且检查一个方格 (行号, 列号) 是否处在攻击位置。\n\n{:width=500px}\n\n现在已经可以写回溯函数 backtrack(row = 0).\n\n * 从第一个 row = 0 开始.\n   \n   \n * 循环列并且试图在每个 column 中放置皇后.\n   \n    * 如果方格 (row, column) 不在攻击范围内\n      \n       * 在 (row, column) 方格上放置皇后。\n       * 排除对应行，列和两个对角线的位置。\n       * If 所有的行被考虑过，row == N * 意味着我们找到了一个解\n         \n         \n       * Else * 继续考虑接下来的皇后放置 backtrack(row + 1).\n         \n         \n       * 回溯：将在 (row, column) 方格的皇后移除.\n      \n      \n   \n   \n\n下面是上述算法的一个直接的实现。\n\n<,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,>\n\nclass Solution {\n  int rows[];\n  // "hill" diagonals\n  int hills[];\n  // "dale" diagonals\n  int dales[];\n  int n;\n  // output\n  List<List<String>> output = new ArrayList();\n  // queens positions\n  int queens[];\n\n  public boolean isNotUnderAttack(int row, int col) {\n    int res = rows[col] + hills[row - col + 2 * n] + dales[row + col];\n    return (res == 0) ? true : false;\n  }\n\n  public void placeQueen(int row, int col) {\n    queens[row] = col;\n    rows[col] = 1;\n    hills[row - col + 2 * n] = 1;  // "hill" diagonals\n    dales[row + col] = 1;   //"dale" diagonals\n  }\n\n  public void removeQueen(int row, int col) {\n    queens[row] = 0;\n    rows[col] = 0;\n    hills[row - col + 2 * n] = 0;\n    dales[row + col] = 0;\n  }\n\n  public void addSolution() {\n    List<String> solution = new ArrayList<String>();\n    for (int i = 0; i < n; ++i) {\n      int col = queens[i];\n      StringBuilder sb = new StringBuilder();\n      for(int j = 0; j < col; ++j) sb.append(".");\n      sb.append("Q");\n      for(int j = 0; j < n - col - 1; ++j) sb.append(".");\n      solution.add(sb.toString());\n    }\n    output.add(solution);\n  }\n\n  public void backtrack(int row) {\n    for (int col = 0; col < n; col++) {\n      if (isNotUnderAttack(row, col)) {\n        placeQueen(row, col);\n        // if n queens are already placed\n        if (row + 1 == n) addSolution();\n          // if not proceed to place the rest\n        else backtrack(row + 1);\n        // backtrack\n        removeQueen(row, col);\n      }\n    }\n  }\n\n  public List<List<String>> solveNQueens(int n) {\n    this.n = n;\n    rows = new int[n];\n    hills = new int[4 * n - 1];\n    dales = new int[2 * n - 1];\n    queens = new int[n];\n\n    backtrack(0);\n    return output;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\nclass Solution:\n    def solveNQueens(self, n: int) -> List[List[str]]:\n        def could_place(row, col):\n            return not (cols[col] + hill_diagonals[row - col] + dale_diagonals[row + col])\n        \n        def place_queen(row, col):\n            queens.add((row, col))\n            cols[col] = 1\n            hill_diagonals[row - col] = 1\n            dale_diagonals[row + col] = 1\n        \n        def remove_queen(row, col):\n            queens.remove((row, col))\n            cols[col] = 0\n            hill_diagonals[row - col] = 0\n            dale_diagonals[row + col] = 0\n        \n        def add_solution():\n            solution = []\n            for _, col in sorted(queens):\n                solution.append(\'.\' * col + \'Q\' + \'.\' * (n - col - 1))\n            output.append(solution)\n        \n        def backtrack(row = 0):\n            for col in range(n):\n                if could_place(row, col):\n                    place_queen(row, col)\n                    if row + 1 == n:\n                        add_solution()\n                    else:\n                        backtrack(row + 1)\n                    remove_queen(row, col)\n        \n        cols = [0] * n\n        hill_diagonals = [0] * (2 * n - 1)\n        dale_diagonals = [0] * (2 * n - 1)\n        queens = set()\n        output = []\n        backtrack()\n        return output\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n复杂度分析\n\n * 时间复杂度：O(N!)\\mathcal{O}(N!)O(N!). 放置第 1 个皇后有 N 种可能的方法，放置两个皇后的方法不超过 N (N - 2) ，放置 3 个皇后的方法不超过 N(N - 2)(N - 4) ，以此类推。总体上，时间复杂度为 O(N!)\\mathcal{O}(N!)O(N!) .\n * 空间复杂度：O(N)\\mathcal{O}(N)O(N) . 需要保存对角线和行的信息。\n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-07-22 23:13:30Accepted [https://leetcode-cn.com//submissions/detail/4515428/]7 ms35.31%N/Ajava2018-07-22 23:10:16Accepted [https://leetcode-cn.com//submissions/detail/4515339/]7 ms35.31%N/Ajava2018-07-22 23:08:12Wrong Answer [https://leetcode-cn.com//submissions/detail/4515278/]N/AN/AN/Ajava2018-07-22 23:06:12Wrong Answer [https://leetcode-cn.com//submissions/detail/4515216/]N/AN/AN/Ajava# 统计信息\n通过次数提交次数AC比率230543418367.4%# 相似题目\n题目难度N皇后 II [https://leetcode-cn.com/problems/n-queens-ii/]困难网格照明 [https://leetcode-cn.com/problems/grid-illumination/]困难',contentLowercase:'# 中文题目\nn皇后问题研究的是如何将 n个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。\n\n\n\n上图为 8 皇后问题的一种解法。\n\n给定一个整数 n，返回所有不同的n皇后问题的解决方案。\n\n每一种解法包含一个明确的n 皇后问题的棋子放置方案，该方案中 \'q\' 和 \'.\' 分别代表了皇后和空位。\n\n示例:\n\n输入: 4\n输出: [\n [".q..",  // 解法 1\n  "...q",\n  "q...",\n  "..q."],\n\n ["..q.",  // 解法 2\n  "q...",\n  "...q",\n  ".q.."]\n]\n解释: 4 皇后问题存在两个不同的解法。\n\n\n# 通过代码\nclass solution {\n   list<list<string>> res=new linkedlist<>();\n    boolean[] col,dia1,dia2;\n    public list<list<string>> solvenqueens(int n) {\n        col=new boolean[n]; //同一列不能有两个\n        dia1=new boolean[2*n-1]; //两条对角线\n        dia2=new boolean[2*n-1];\n        linkedlist<integer> row=new linkedlist<>();\n        putqueen(n,0,row);\n        return res;\n    }\n\n    private void putqueen(int n, int index, linkedlist<integer> row) {\n        if (index==n){\n            list<string> list=generate(row);\n            res.add(list);\n            return;\n        }\n        for (int i = 0; i < n; i++) {\n//            å¤æ­åä¸åå两条对角线，两条对角线ä¸æ»¡è¶³ index+i相等和index-i+n-1相等\n            if (!col[i] && !dia1[index+i] && !dia2[index-i+n-1]){\n                row.addlast(i);\n                col[i]=true;\n                dia1[index+i]=true;\n                dia2[index-i+n-1]=true;\n                putqueen(n,index+1,row);\n                col[i]=false;\n                dia1[index+i]=false;\n                dia2[index-i+n-1]=false;\n                row.removelast();\n            }\n        }\n        return;\n    }\n    //根据记录得到的点的列位置还原出图\n    private list<string> generate(linkedlist<integer> row) {\n        linkedlist<string> linkedlist=new linkedlist<>();\n        for (int i = 0; i < row.size(); i++) {\n            stringbuilder stringbuilder=new stringbuilder();\n            for (int j = 0; j < row.size(); j++) {\n                stringbuilder.append(\'.\');\n            }\n            stringbuilder.replace(row.get(i),row.get(i)+1,"q");\n            linkedlist.add(stringbuilder.tostring());\n        }\n        return linkedlist;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\nclass solution {\n    list<list<string>> res=new linkedlist<>();\n    boolean[] col,dia1,dia2;\n    public list<list<string>> solvenqueens(int n) {\n        col=new boolean[n];\n        dia1=new boolean[2*n-1];\n        dia2=new boolean[2*n-1];\n        linkedlist<integer> row=new linkedlist<>();\n        putqueen(n,0,row);\n        return res;\n    }\n\n    private void putqueen(int n, int index, linkedlist<integer> row) {\n        if (index==n){\n            list<string> list=generate(row);\n            res.add(list);\n            return;\n        }\n        for (int i = 0; i < n; i++) {\n            if (!col[i] && !dia1[index+i] && !dia2[index-i+n-1]){\n                row.addlast(i);\n                col[i]=true;\n                dia1[index+i]=true;\n                dia2[index-i+n-1]=true;\n                putqueen(n,index+1,row);\n                col[i]=false;\n                dia1[index+i]=false;\n                dia2[index-i+n-1]=false;\n                row.removelast();\n            }\n        }\n        return;\n    }\n\n    private list<string> generate(linkedlist<integer> row) {\n        linkedlist<string> linkedlist=new linkedlist<>();\n        for (int i = 0; i < row.size(); i++) {\n            stringbuilder stringbuilder=new stringbuilder();\n            for (int j = 0; j < row.size(); j++) {\n                stringbuilder.append(\'.\');\n            }\n            stringbuilder.replace(row.get(i),row.get(i)+1,"q");\n            linkedlist.add(stringbuilder.tostring());\n        }\n        return linkedlist;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n# 官方题解\n# 直观想法\n第一个想法是使用蛮力法，意味着生成在棋盘上放置 n 个皇后的所有可能的情况，并且检查是否保证没有皇后可以互相攻击。这意味着 o(nn)\\mathcal{o}(n^n)o(nn) 的时间复杂度，因此我们必须考虑优化。\n\n下面是两个有用的编程概念。\n\n> 第一个叫做 约束编程.\n\n\n它的基本含义是在放置每个皇后以后增加限制。当在棋盘上放置了一个皇后后，立即排除当前行，列和对应的两个对角线。该过程传递了 约束 从而有助于减少需要考虑情况数。\n\n{:width=500px}\n\n> 第二个叫做 回溯法.\n\n\n我们来想象一下，当在棋盘上放置了几个皇后且不会相互攻击。但是选择的方案不是最优的，因为无法放置下一个皇后。此时我们该怎么做？回溯。意思是回退一步，来改变最后放置皇后的位置并且接着往下放置。如果还是不行，再 回溯。\n\n{:width=500px}\n\n\n\n\n\n\n# 方法1：回溯\n在建立算法之前，我们来考虑两个有用的细节。\n\n> 一行只可能有一个皇后且一列也只可能有一个皇后。\n\n\n这意味着没有必要再棋盘上考虑所有的方格。只需要按列循环即可。\n\n> 对于所有的主对角线有 行号 + 列号 = 常数，对于所有的次对角线有 行号 - 列号 = 常数.\n\n\n这可以让我们标记已经在攻击范围下的对角线并且检查一个方格 (行号, 列号) 是否处在攻击位置。\n\n{:width=500px}\n\n现在已经可以写回溯函数 backtrack(row = 0).\n\n * 从第一个 row = 0 开始.\n   \n   \n * 循环列并且试图在每个 column 中放置皇后.\n   \n    * 如果方格 (row, column) 不在攻击范围内\n      \n       * 在 (row, column) 方格上放置皇后。\n       * 排除对应行，列和两个对角线的位置。\n       * if 所有的行被考虑过，row == n * 意味着我们找到了一个解\n         \n         \n       * else * 继续考虑接下来的皇后放置 backtrack(row + 1).\n         \n         \n       * 回溯：将在 (row, column) 方格的皇后移除.\n      \n      \n   \n   \n\n下面是上述算法的一个直接的实现。\n\n<,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,>\n\nclass solution {\n  int rows[];\n  // "hill" diagonals\n  int hills[];\n  // "dale" diagonals\n  int dales[];\n  int n;\n  // output\n  list<list<string>> output = new arraylist();\n  // queens positions\n  int queens[];\n\n  public boolean isnotunderattack(int row, int col) {\n    int res = rows[col] + hills[row - col + 2 * n] + dales[row + col];\n    return (res == 0) ? true : false;\n  }\n\n  public void placequeen(int row, int col) {\n    queens[row] = col;\n    rows[col] = 1;\n    hills[row - col + 2 * n] = 1;  // "hill" diagonals\n    dales[row + col] = 1;   //"dale" diagonals\n  }\n\n  public void removequeen(int row, int col) {\n    queens[row] = 0;\n    rows[col] = 0;\n    hills[row - col + 2 * n] = 0;\n    dales[row + col] = 0;\n  }\n\n  public void addsolution() {\n    list<string> solution = new arraylist<string>();\n    for (int i = 0; i < n; ++i) {\n      int col = queens[i];\n      stringbuilder sb = new stringbuilder();\n      for(int j = 0; j < col; ++j) sb.append(".");\n      sb.append("q");\n      for(int j = 0; j < n - col - 1; ++j) sb.append(".");\n      solution.add(sb.tostring());\n    }\n    output.add(solution);\n  }\n\n  public void backtrack(int row) {\n    for (int col = 0; col < n; col++) {\n      if (isnotunderattack(row, col)) {\n        placequeen(row, col);\n        // if n queens are already placed\n        if (row + 1 == n) addsolution();\n          // if not proceed to place the rest\n        else backtrack(row + 1);\n        // backtrack\n        removequeen(row, col);\n      }\n    }\n  }\n\n  public list<list<string>> solvenqueens(int n) {\n    this.n = n;\n    rows = new int[n];\n    hills = new int[4 * n - 1];\n    dales = new int[2 * n - 1];\n    queens = new int[n];\n\n    backtrack(0);\n    return output;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\nclass solution:\n    def solvenqueens(self, n: int) -> list[list[str]]:\n        def could_place(row, col):\n            return not (cols[col] + hill_diagonals[row - col] + dale_diagonals[row + col])\n        \n        def place_queen(row, col):\n            queens.add((row, col))\n            cols[col] = 1\n            hill_diagonals[row - col] = 1\n            dale_diagonals[row + col] = 1\n        \n        def remove_queen(row, col):\n            queens.remove((row, col))\n            cols[col] = 0\n            hill_diagonals[row - col] = 0\n            dale_diagonals[row + col] = 0\n        \n        def add_solution():\n            solution = []\n            for _, col in sorted(queens):\n                solution.append(\'.\' * col + \'q\' + \'.\' * (n - col - 1))\n            output.append(solution)\n        \n        def backtrack(row = 0):\n            for col in range(n):\n                if could_place(row, col):\n                    place_queen(row, col)\n                    if row + 1 == n:\n                        add_solution()\n                    else:\n                        backtrack(row + 1)\n                    remove_queen(row, col)\n        \n        cols = [0] * n\n        hill_diagonals = [0] * (2 * n - 1)\n        dale_diagonals = [0] * (2 * n - 1)\n        queens = set()\n        output = []\n        backtrack()\n        return output\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n复杂度分析\n\n * 时间复杂度：o(n!)\\mathcal{o}(n!)o(n!). 放置第 1 个皇后有 n 种可能的方法，放置两个皇后的方法不超过 n (n - 2) ，放置 3 个皇后的方法不超过 n(n - 2)(n - 4) ，以此类推。总体上，时间复杂度为 o(n!)\\mathcal{o}(n!)o(n!) .\n * 空间复杂度：o(n)\\mathcal{o}(n)o(n) . 需要保存对角线和行的信息。\n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-07-22 23:13:30accepted [https://leetcode-cn.com//submissions/detail/4515428/]7 ms35.31%n/ajava2018-07-22 23:10:16accepted [https://leetcode-cn.com//submissions/detail/4515339/]7 ms35.31%n/ajava2018-07-22 23:08:12wrong answer [https://leetcode-cn.com//submissions/detail/4515278/]n/an/an/ajava2018-07-22 23:06:12wrong answer [https://leetcode-cn.com//submissions/detail/4515216/]n/an/an/ajava# 统计信息\n通过次数提交次数ac比率230543418367.4%# 相似题目\n题目难度n皇后 ii [https://leetcode-cn.com/problems/n-queens-ii/]困难网格照明 [https://leetcode-cn.com/problems/grid-illumination/]困难'},{title:"145-二叉树的后序遍历(Binary Tree Postorder Traversal)",frontmatter:{title:"145-二叉树的后序遍历(Binary Tree Postorder Traversal)",date:"2018-09-05T00:00:00.000Z",categories:["困难"],tags:["栈<Stack>","树<Tree>"]},regularPath:"/views/%E5%9B%B0%E9%9A%BE/0145-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86.html",relativePath:"views/困难/0145-二叉树的后序遍历.md",key:"v-b27509c4",path:"/views/%E5%9B%B0%E9%9A%BE/0145-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86.html",headers:[{level:2,title:"中文题目",slug:"中文题目",charIndex:2},{level:2,title:"通过代码",slug:"通过代码",charIndex:123},{level:2,title:"官方题解",slug:"官方题解",charIndex:4323},{level:2,title:"提交历史",slug:"提交历史",charIndex:6451},{level:2,title:"统计信息",slug:"统计信息",charIndex:6771},{level:2,title:"相似题目",slug:"相似题目",charIndex:6805}],lastUpdated:"4/11/2021, 1:15:21 PM",headersStr:"中文题目 通过代码 官方题解 提交历史 统计信息 相似题目",content:'# 中文题目\n给定一个二叉树，返回它的 后序遍历。\n\n示例:\n\n输入: [1,null,2,3]  \n   1\n    \\\n     2\n    /\n   3 \n\n输出: [3,2,1]\n\n进阶:递归算法很简单，你可以通过迭代算法完成吗？\n\n# 通过代码\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public List<Integer> postorderTraversal(TreeNode root) {\n        List<Integer> list=new LinkedList<>();\n            Stack<TreeNode> stack=new Stack<>();\n            TreeNode pre = null;\n            while(!stack.isEmpty() || root != null) {\n\n                while(root != null) {\n                    stack.push(root);\n                    root = root.left;\n                }\n\n                root = stack.peek();\n                if(root.right != null && root.right != pre) {\n                    root = root.right;\n                }else {\n                    root = stack.pop();\n                    list.add(root.val);\n                    pre = root;\n                    root = null;\n                }\n            }\n            return list;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nimport java.util.Stack;\nclass Solution{\n     class Command{\n            String s;\n            TreeNode node;\n\n            public Command(String s, TreeNode node) {\n                this.s = s;\n                this.node = node;\n            }\n        }\n        public  List<Integer> postorderTraversal(TreeNode root) {\n            LinkedList<Integer> linkedList=new LinkedList<>();\n            if (root==null){\n                return linkedList;\n            }\n//            模拟系统栈调用\n            Stack<Command> stack=new Stack<>();\n            stack.push(new Command("go",root));\n            while (!stack.isEmpty()){\n                Command command=stack.pop();\n                if (command.s.equals("print")){\n                    linkedList.add(command.node.val);\n                }else {\n//                    与递归的相反\n                    stack.push(new Command("print",command.node));\n                    if (command.node.right!=null){\n                        stack.push(new Command("go",command.node.right));\n                    }\n                    if (command.node.left!=null){\n                        stack.push(new Command("go",command.node.left));\n                    }\n                   \n                }\n            }\n            return linkedList;\n        }\n    \n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nimport java.util.Stack;\nclass Solution{\n     class Command{\n            String s;\n            TreeNode node;\n\n            public Command(String s, TreeNode node) {\n                this.s = s;\n                this.node = node;\n            }\n        }\n        public  List<Integer> postorderTraversal(TreeNode root) {\n            LinkedList<Integer> linkedList=new LinkedList<>();\n            if (root==null){\n                return linkedList;\n            }\n//            模拟系统栈调用\n            Stack<Command> stack=new Stack<>();\n            stack.push(new Command("go",root));\n            while (!stack.isEmpty()){\n                Command command=stack.pop();\n                if (command.s.equals("print")){\n                    linkedList.add(command.node.val);\n                }else {\n//                    与递归的相反\n                    stack.push(new Command("print",command.node));\n                    if (command.node.right!=null){\n                        stack.push(new Command("go",command.node.right));\n                    }\n                    if (command.node.left!=null){\n                        stack.push(new Command("go",command.node.left));\n                    }\n                   \n                }\n            }\n            return linkedList;\n        }\n    \n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n# 官方题解\n# 如何遍历一棵树\n有两种通用的遍历树的策略：\n\n * 深度优先搜索（DFS）\n   \n   在这个策略中，我们采用深度作为优先级，以便从跟开始一直到达某个确定的叶子，然后再返回根到达另一个分支。\n   \n   深度优先搜索策略又可以根据根节点、左孩子和右孩子的相对顺序被细分为先序遍历，中序遍历和后序遍历。\n   \n   \n * 宽度优先搜索（BFS）\n   \n   我们按照高度顺序一层一层的访问整棵树，高层次的节点将会比低层次的节点先被访问到。\n   \n   \n\n下图中的顶点按照访问的顺序编号，按照 1-2-3-4-5 的顺序来比较不同的策略。\n\n{:align=center}\n\n本问题就是用宽度优先搜索遍历来划分层次：[[1], [2, 3], [4, 5]]。\n\n# 方法 1：迭代\n算法\n\n首先，定义树的存储结构 TreeNode。\n\n/* Definition for a binary tree node. */\npublic class TreeNode {\n  int val;\n  TreeNode left;\n  TreeNode right;\n\n  TreeNode(int x) {\n    val = x;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\nclass TreeNode(object):\n    """ Definition of a binary tree node."""\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\n\n1\n2\n3\n4\n5\n6\n从根节点开始依次迭代，弹出栈顶元素输出到输出列表中，然后依次压入它的所有孩子节点，按照从上到下、从左至右的顺序依次压入栈中。\n\n因为深度优先搜索后序遍历的顺序是从下到上、从左至右，所以需要将输出列表逆序输出。\n\nclass Solution {\n  public List<Integer> postorderTraversal(TreeNode root) {\n    LinkedList<TreeNode> stack = new LinkedList<>();\n    LinkedList<Integer> output = new LinkedList<>();\n    if (root == null) {\n      return output;\n    }\n\n    stack.add(root);\n    while (!stack.isEmpty()) {\n      TreeNode node = stack.pollLast();\n      output.addFirst(node.val);\n      if (node.left != null) {\n        stack.add(node.left);\n      }\n      if (node.right != null) {\n        stack.add(node.right);\n      }\n    }\n    return output;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\nclass Solution(object):\n    def postorderTraversal(self, root):\n        """\n        :type root: TreeNode\n        :rtype: List[int]\n        """\n        if root is None:\n            return []\n\n        stack, output = [root, ], []\n        while stack:\n            root = stack.pop()\n            output.append(root.val)\n            if root.left is not None:\n                stack.append(root.left)\n            if root.right is not None:\n                stack.append(root.right)\n                \n        return output[::-1]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n复杂度分析\n\n * 时间复杂度：访问每个节点恰好一次，因此时间复杂度为 O(N)O(N)O(N)，其中 NNN 是节点的个数，也就是树的大小。\n * 空间复杂度：取决于树的结构，最坏情况需要保存整棵树，因此空间复杂度为 O(N)O(N)O(N)。\n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-09-05 16:29:55Accepted [https://leetcode-cn.com//submissions/detail/6588280/]2 ms5.9%N/Ajava2018-09-05 16:27:26Accepted [https://leetcode-cn.com//submissions/detail/6588069/]2 ms5.9%N/Ajava2018-07-16 20:58:54Accepted [https://leetcode-cn.com//submissions/detail/4253440/]2 ms5.9%N/Ajava# 统计信息\n通过次数提交次数AC比率459826606269.6%# 相似题目\n题目难度二叉树的中序遍历 [https://leetcode-cn.com/problems/binary-tree-inorder-traversal/]中等N叉树的后序遍历 [https://leetcode-cn.com/problems/n-ary-tree-postorder-traversal/]简单',contentLowercase:'# 中文题目\n给定一个二叉树，返回它的 后序遍历。\n\n示例:\n\n输入: [1,null,2,3]  \n   1\n    \\\n     2\n    /\n   3 \n\n输出: [3,2,1]\n\n进阶:递归算法很简单，你可以通过迭代算法完成吗？\n\n# 通过代码\n/**\n * definition for a binary tree node.\n * public class treenode {\n *     int val;\n *     treenode left;\n *     treenode right;\n *     treenode(int x) { val = x; }\n * }\n */\nclass solution {\n    public list<integer> postordertraversal(treenode root) {\n        list<integer> list=new linkedlist<>();\n            stack<treenode> stack=new stack<>();\n            treenode pre = null;\n            while(!stack.isempty() || root != null) {\n\n                while(root != null) {\n                    stack.push(root);\n                    root = root.left;\n                }\n\n                root = stack.peek();\n                if(root.right != null && root.right != pre) {\n                    root = root.right;\n                }else {\n                    root = stack.pop();\n                    list.add(root.val);\n                    pre = root;\n                    root = null;\n                }\n            }\n            return list;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n/**\n * definition for a binary tree node.\n * public class treenode {\n *     int val;\n *     treenode left;\n *     treenode right;\n *     treenode(int x) { val = x; }\n * }\n */\nimport java.util.stack;\nclass solution{\n     class command{\n            string s;\n            treenode node;\n\n            public command(string s, treenode node) {\n                this.s = s;\n                this.node = node;\n            }\n        }\n        public  list<integer> postordertraversal(treenode root) {\n            linkedlist<integer> linkedlist=new linkedlist<>();\n            if (root==null){\n                return linkedlist;\n            }\n//            模拟系统栈调用\n            stack<command> stack=new stack<>();\n            stack.push(new command("go",root));\n            while (!stack.isempty()){\n                command command=stack.pop();\n                if (command.s.equals("print")){\n                    linkedlist.add(command.node.val);\n                }else {\n//                    与递归的相反\n                    stack.push(new command("print",command.node));\n                    if (command.node.right!=null){\n                        stack.push(new command("go",command.node.right));\n                    }\n                    if (command.node.left!=null){\n                        stack.push(new command("go",command.node.left));\n                    }\n                   \n                }\n            }\n            return linkedlist;\n        }\n    \n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n/**\n * definition for a binary tree node.\n * public class treenode {\n *     int val;\n *     treenode left;\n *     treenode right;\n *     treenode(int x) { val = x; }\n * }\n */\nimport java.util.stack;\nclass solution{\n     class command{\n            string s;\n            treenode node;\n\n            public command(string s, treenode node) {\n                this.s = s;\n                this.node = node;\n            }\n        }\n        public  list<integer> postordertraversal(treenode root) {\n            linkedlist<integer> linkedlist=new linkedlist<>();\n            if (root==null){\n                return linkedlist;\n            }\n//            模拟系统栈调用\n            stack<command> stack=new stack<>();\n            stack.push(new command("go",root));\n            while (!stack.isempty()){\n                command command=stack.pop();\n                if (command.s.equals("print")){\n                    linkedlist.add(command.node.val);\n                }else {\n//                    与递归的相反\n                    stack.push(new command("print",command.node));\n                    if (command.node.right!=null){\n                        stack.push(new command("go",command.node.right));\n                    }\n                    if (command.node.left!=null){\n                        stack.push(new command("go",command.node.left));\n                    }\n                   \n                }\n            }\n            return linkedlist;\n        }\n    \n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n# 官方题解\n# 如何遍历一棵树\n有两种通用的遍历树的策略：\n\n * 深度优先搜索（dfs）\n   \n   在这个策略中，我们采用深度作为优先级，以便从跟开始一直到达某个确定的叶子，然后再返回根到达另一个分支。\n   \n   深度优先搜索策略又可以根据根节点、左孩子和右孩子的相对顺序被细分为先序遍历，中序遍历和后序遍历。\n   \n   \n * 宽度优先搜索（bfs）\n   \n   我们按照高度顺序一层一层的访问整棵树，高层次的节点将会比低层次的节点先被访问到。\n   \n   \n\n下图中的顶点按照访问的顺序编号，按照 1-2-3-4-5 的顺序来比较不同的策略。\n\n{:align=center}\n\n本问题就是用宽度优先搜索遍历来划分层次：[[1], [2, 3], [4, 5]]。\n\n# 方法 1：迭代\n算法\n\n首先，定义树的存储结构 treenode。\n\n/* definition for a binary tree node. */\npublic class treenode {\n  int val;\n  treenode left;\n  treenode right;\n\n  treenode(int x) {\n    val = x;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\nclass treenode(object):\n    """ definition of a binary tree node."""\n    def __init__(self, x):\n        self.val = x\n        self.left = none\n        self.right = none\n\n\n1\n2\n3\n4\n5\n6\n从根节点开始依次迭代，弹出栈顶元素输出到输出列表中，然后依次压入它的所有孩子节点，按照从上到下、从左至右的顺序依次压入栈中。\n\n因为深度优先搜索后序遍历的顺序是从下到上、从左至右，所以需要将输出列表逆序输出。\n\nclass solution {\n  public list<integer> postordertraversal(treenode root) {\n    linkedlist<treenode> stack = new linkedlist<>();\n    linkedlist<integer> output = new linkedlist<>();\n    if (root == null) {\n      return output;\n    }\n\n    stack.add(root);\n    while (!stack.isempty()) {\n      treenode node = stack.polllast();\n      output.addfirst(node.val);\n      if (node.left != null) {\n        stack.add(node.left);\n      }\n      if (node.right != null) {\n        stack.add(node.right);\n      }\n    }\n    return output;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\nclass solution(object):\n    def postordertraversal(self, root):\n        """\n        :type root: treenode\n        :rtype: list[int]\n        """\n        if root is none:\n            return []\n\n        stack, output = [root, ], []\n        while stack:\n            root = stack.pop()\n            output.append(root.val)\n            if root.left is not none:\n                stack.append(root.left)\n            if root.right is not none:\n                stack.append(root.right)\n                \n        return output[::-1]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n复杂度分析\n\n * 时间复杂度：访问每个节点恰好一次，因此时间复杂度为 o(n)o(n)o(n)，其中 nnn 是节点的个数，也就是树的大小。\n * 空间复杂度：取决于树的结构，最坏情况需要保存整棵树，因此空间复杂度为 o(n)o(n)o(n)。\n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-09-05 16:29:55accepted [https://leetcode-cn.com//submissions/detail/6588280/]2 ms5.9%n/ajava2018-09-05 16:27:26accepted [https://leetcode-cn.com//submissions/detail/6588069/]2 ms5.9%n/ajava2018-07-16 20:58:54accepted [https://leetcode-cn.com//submissions/detail/4253440/]2 ms5.9%n/ajava# 统计信息\n通过次数提交次数ac比率459826606269.6%# 相似题目\n题目难度二叉树的中序遍历 [https://leetcode-cn.com/problems/binary-tree-inorder-traversal/]中等n叉树的后序遍历 [https://leetcode-cn.com/problems/n-ary-tree-postorder-traversal/]简单'},{title:"282-给表达式添加运算符(Expression Add Operators)",frontmatter:{title:"282-给表达式添加运算符(Expression Add Operators)",date:"2018-09-27T00:00:00.000Z",categories:["困难"],tags:["分治算法<Divide and Conquer>"]},regularPath:"/views/%E5%9B%B0%E9%9A%BE/0282-%E7%BB%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B7%BB%E5%8A%A0%E8%BF%90%E7%AE%97%E7%AC%A6.html",relativePath:"views/困难/0282-给表达式添加运算符.md",key:"v-7016069a",path:"/views/%E5%9B%B0%E9%9A%BE/0282-%E7%BB%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B7%BB%E5%8A%A0%E8%BF%90%E7%AE%97%E7%AC%A6.html",headers:[{level:2,title:"中文题目",slug:"中文题目",charIndex:2},{level:2,title:"通过代码",slug:"通过代码",charIndex:367},{level:2,title:"官方题解",slug:"官方题解",charIndex:1605},{level:2,title:"提交历史",slug:"提交历史",charIndex:9762},{level:2,title:"统计信息",slug:"统计信息",charIndex:9892},{level:2,title:"相似题目",slug:"相似题目",charIndex:9924}],lastUpdated:"4/11/2021, 1:15:21 PM",headersStr:"中文题目 通过代码 官方题解 提交历史 统计信息 相似题目",content:'# 中文题目\n给定一个仅包含数字0-9的字符串和一个目标值，在数字之间添加二元运算符（不是一元）+、-或*，返回所有能够得到目标值的表达式。\n\n示例 1:\n\n输入: num = "123", target = 6\n输出: ["1+2+3", "1*2*3"] \n\n\n示例 2:\n\n输入: num = "232", target = 8\n输出: ["2*3+2", "2+3*2"]\n\n示例 3:\n\n输入: num = "105", target = 5\n输出: ["1*0+5","10-5"]\n\n示例 4:\n\n输入: num = "00", target = 0\n输出: ["0+0", "0-0", "0*0"]\n\n\n示例 5:\n\n输入: num = "3456237490", target = 9191\n输出: []\n\n\n# 通过代码\npublic class Solution {\n    public List<String> addOperators(String num, int target) {\n        List<String> rst = new ArrayList<String>();\n        if(num == null || num.length() == 0) return rst;\n        helper(rst, "", num, target, 0, 0, 0);\n        return rst;\n    }\n    public void helper(List<String> rst, String path, String num, int target, int pos, long eval, long multed){\n        if(pos == num.length()){\n            if(target == eval)\n                rst.add(path);\n            return;\n        }\n        for(int i = pos; i < num.length(); i++){\n            if(i != pos && num.charAt(pos) == \'0\') break;\n            long cur = Long.parseLong(num.substring(pos, i + 1));\n            if(pos == 0){\n                helper(rst, path + cur, num, target, i + 1, cur, cur);\n            }\n            else{\n                helper(rst, path + "+" + cur, num, target, i + 1, eval + cur , cur);\n                \n                helper(rst, path + "-" + cur, num, target, i + 1, eval -cur, -cur);\n                \n                helper(rst, path + "*" + cur, num, target, i + 1, eval - multed + multed * cur, multed * cur );\n            }\n        }\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n# 官方题解\n# 方法一：回溯\n让我们先看看这个问题要求我们做什么，然后才能找到解决它的方法。因此，我们得到一个数字串和 3 个不同的运算符：\n\n * + Addition\n\n * - Subtraction\n\n * * Multiplication\n\n我们必须找到数字之间所有可能的二元运算符组合，以便结果表达式的整体值等于给定的目标值。让我们来看看将运算符放在数字之间的确切含义的几个可能性，这样问题就更清楚了。\n\n假设我们有以下一组数字 “123456789”，给我们的目标值是 45。让我们看看通过将操作符放在不同的位置可以得到的一些可能的结果表达式。\n\n1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 = 45\n1 + 2 - 3 + 4 - 5 + 6 - 7 + 8 - 9 = -3\n1 + 2 * 3 - 4 + 5 + 6 - 7 * 8 - 9 = -51\n1 + 2 + 3 + 4 + 5 - 6 * 7 + 8 * 9 = 45\n\n\n1\n2\n3\n4\n这只是使用给定的数字串和三个运算符可能得到的许多表达式中的 4 个。\n\n通过查看上面的例子，我们无法真正找出结果表达式中的任何特定模式，这些模式告诉我们哪一个表达式将给出结果目标。\n\n由于这个问题明确地说明我们有二元运算符，这意味着每个运算符都需要两个操作数。 我们可以把每个数字都当作操作数。\n\n这意味着，在每对数字之间，我们可以使用三个运算符中的任何一个，即 +++、−-− 或×\\times×。\n\n如果你看过问题陈述和问题中给出的例子，你会发现有一个例子，数字是 “105”，目标值是 5。对于这个特殊的例子，有两个表达式给我们，它们是 1*0+5 和 10-5。\n\n第二个表达式是在解决这个问题之前需要注意的，因为这会使事情变得有点复杂。\n\n如果我们只需要考虑那些简单地用数字作为操作数的表达式，那么这个问题就更容易解决了。\n\n但是，在这个问题中，我们可以让各种数字组合在一起，形成一个更大的数字，成为表达式的一部分。让我们看看数字 “123456” 和目标 30 的一些示例表达式。\n\n1 * 23 - 4 + 5 + 6 = 30\n12 - 3 * 4 + 5 * 6 = 30\n1 - 23 - 4 + 56 = 30\n\n\n1\n2\n3\n这意味着，尽管我们定义了运算符的数量，即3个不同的二元运算符，但是操作数的数量并没有很好地为我们定义。\n\n这是我们在解决方案中需要解决的原始问题的很大一部分。\n\n因为我们被要求找出所有值等于给定目标的有效表达式，而且我们不知道两个操作数之间的特定运算符最终会给我们一个有效表达式，\n\n> 我们尝试所有的选择\n\n\n这意味着一旦我们定义了给定表达式的操作数，我们就可以在每个连续的操作数对之间选择三个可能的操作数。\n\n从实现的角度来看，操作数对于原始字符串意味着什么？\n\n> 操作数是由原始字符串的子字符串形成的整数\n\n\n让我们来看看字符串 “123456789” 的两种不同的数组分割方式：\n\n{:width="500"} {:align=center}\n\n由于我们需要返回所有有效表达式，这些表达式的计算结果为给定的目标值，因此我们必须尝试给定数组的所有可能分区，从而考虑所有可能的操作数，这些操作数可以由数字组成。\n\n有一种非常简单的方法可以将此合并到我们的算法中。现在，在算法的每一点上，我们都有三个不同的选择对应于三个不同的操作符。\n\n> 我们合并这些分区的方法是考虑第四个运算符，它只向前移动一步，将当前操作数扩展一位。实际上，在我们的实现中，从 12−−>12312 --\x3e 12312−−>123 开始是一个无操作操作数。(12∗10)+3(12*10)+3(12∗10)+3。\n\n\n现在，我们的算法中有4个不同的递归路径，我们必须尝试所有这些路径，看看哪一个会导致潜在的解决方案。\n\n算法：在查看伪代码之前，让我们先快速查看回溯算法中涉及的步骤。\n\n 1. 如上所述，我们有多种选择，可以选择使用什么运算符，可以选择哪些操作数，因此，我们必须考虑找到所有有效表达式的所有可能性。\n 2. 我们的递归调用 index ，它表示我们在原始 nums 字符串中看到的当前数字，以及到目前为止构建的表达式字符串。\n 3. 在每一步中，我们都有 4 个不同的递归调用。NO OP 调用只是将当前的操作数扩展到当前数字并向前移动。其余的递归调用对应于+、-、和 *。\n 4. 我们继续这样构建表达式，最终会处理整个 nums 字符串。那时，我们检查到现在为止构建的表达式是否是有效的表达式，如果是有效的表达式，我们会记录它。\n\n1. procedure recurse(digits, index, expression):\n2.     if we have reached the end of the string:\n3.         if the expression evaluates to the target:\n4.             Valid Expression found!\n5.     else:\n6.         try out operator \'NO OP\' and recurse\n7.         try out operator * and recurse\n8.         try out operator + and recurse\n9.         try out operator - and recurse\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n算法现在看起来非常简单。然而，实现需要更多的思考，在实际实现之前，我们需要解决一些问题。\n\n> 当我们用原始字符串中的所有数字构建表达式时，我们检查表达式是否是有效的表达式。我们如何实际检查该表达式是否有效？\n\n\n一种方法是编写一个自定义的 eval 函数，它接受一个字符串并返回表达式的值。如果这样做（python 用户可以使用内置函数 eval ），您将超过时间限制。\n\n我们不能实时跟踪表达式的值吗？\n\n是的。这就是我们要遵循的理念。除了跟踪表达式字符串是什么，我们还将跟踪它的值，以便当递归到达基本情况时，我们可以通过 O(1)O(1)O(1) 的时间复杂度来判断表达式是否等于目标值\n\n如果只是 + 和 - 运算符参与的话，实现会很简单。这是因为这两个操作符具有相同的优先级。这意味着我们可以继续动态地评估表达式，而不会出现任何问题。\n\n{:width="500"} {:align=center}\n\n若添加 * 操作符，看看如何快速构建表达式。\n\n{:width="500"} {:align=center}\n\n我们所说的动态构建表达式是指我们一直跟踪表达式的值，直到现在，我们只是将该值作为我们的运算符的两个操作数之一。正如我们从上面的两个例子中看到的，如果它只是 + 和 - 操作符，那么这就可以工作了。\n\n但是，这种方法肯定会失败，因为 * 运算符优先于 +和 -。* 运算符需要表达式中实际的前一个操作数，而不是表达式的当前值。也就是说，在上面的例子中，* 运算符需要 2 而不是 12 才能得到正确的值 18。\n\n如何处理？如何处理这个问题的想法来源于上面的讨论。我们只需要跟踪表达式中的最后一个操作数，以及它是如何整体修改表达式的值的，这样当我们考虑 * 运算符时，我们可以反转前一个操作数的效果，并考虑它的乘法。让我们来看一下以前打破的例子。\n\n{:width="500"} {:align=center}\n\n现在我们可以看看这个算法的实际实现。\n\nclass Solution {\n\n  public ArrayList<String> answer;\n  public String digits;\n  public long target;\n\n  public void recurse(\n      int index, long previousOperand, long currentOperand, long value, ArrayList<String> ops) {\n    String nums = this.digits;\n\n    // Done processing all the digits in num\n    if (index == nums.length()) {\n\n      // If the final value == target expected AND\n      // no operand is left unprocessed\n      if (value == this.target && currentOperand == 0) {\n        StringBuilder sb = new StringBuilder();\n        ops.subList(1, ops.size()).forEach(v -> sb.append(v));\n        this.answer.add(sb.toString());\n      }\n      return;\n    }\n\n    // Extending the current operand by one digit\n    currentOperand = currentOperand * 10 + Character.getNumericValue(nums.charAt(index));\n    String current_val_rep = Long.toString(currentOperand);\n    int length = nums.length();\n\n    // To avoid cases where we have 1 + 05 or 1 * 05 since 05 won\'t be a\n    // valid operand. Hence this check\n    if (currentOperand > 0) {\n\n      // NO OP recursion\n      recurse(index + 1, previousOperand, currentOperand, value, ops);\n    }\n\n    // ADDITION\n    ops.add("+");\n    ops.add(current_val_rep);\n    recurse(index + 1, currentOperand, 0, value + currentOperand, ops);\n    ops.remove(ops.size() - 1);\n    ops.remove(ops.size() - 1);\n\n    if (ops.size() > 0) {\n\n      // SUBTRACTION\n      ops.add("-");\n      ops.add(current_val_rep);\n      recurse(index + 1, -currentOperand, 0, value - currentOperand, ops);\n      ops.remove(ops.size() - 1);\n      ops.remove(ops.size() - 1);\n\n      // MULTIPLICATION\n      ops.add("*");\n      ops.add(current_val_rep);\n      recurse(\n          index + 1,\n          currentOperand * previousOperand,\n          0,\n          value - previousOperand + (currentOperand * previousOperand),\n          ops);\n      ops.remove(ops.size() - 1);\n      ops.remove(ops.size() - 1);\n    }\n  }\n\n  public List<String> addOperators(String num, int target) {\n\n    if (num.length() == 0) {\n      return new ArrayList<String>();\n    }\n\n    this.target = target;\n    this.digits = num;\n    this.answer = new ArrayList<String>();\n    this.recurse(0, 0, 0, 0, new ArrayList<String>());\n    return this.answer;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\nclass Solution:\n    def addOperators(self, num: \'str\', target: \'int\') -> \'List[str]\':\n\n        N = len(num)\n        answers = []\n        def recurse(index, prev_operand, current_operand, value, string):\n\n            # Done processing all the digits in num\n            if index == N:\n\n                # If the final value == target expected AND\n                # no operand is left unprocessed\n                if value == target and current_operand == 0:\n                    answers.append("".join(string[1:]))\n                return\n\n            # Extending the current operand by one digit\n            current_operand = current_operand*10 + int(num[index])\n            str_op = str(current_operand)\n\n            # To avoid cases where we have 1 + 05 or 1 * 05 since 05 won\'t be a\n            # valid operand. Hence this check\n            if current_operand > 0:\n\n                # NO OP recursion\n                recurse(index + 1, prev_operand, current_operand, value, string)\n\n            # ADDITION\n            string.append(\'+\'); string.append(str_op)\n            recurse(index + 1, current_operand, 0, value + current_operand, string)\n            string.pop();string.pop()\n\n            # Can subtract or multiply only if there are some previous operands\n            if string:\n\n                # SUBTRACTION\n                string.append(\'-\'); string.append(str_op)\n                recurse(index + 1, -current_operand, 0, value - current_operand, string)\n                string.pop();string.pop()\n\n                # MULTIPLICATION\n                string.append(\'*\'); string.append(str_op)\n                recurse(index + 1, current_operand * prev_operand, 0, value - prev_operand + (current_operand * prev_operand), string)\n                string.pop();string.pop()\n        recurse(0, 0, 0, 0, [])    \n        return answers\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n复杂度分析\n\n * 时间复杂度：\n\n 1. 在这一过程的每一步中，我们都会考虑 4 种不同的选择或 4 种不同的递归路径。基本情况是当索引值达到 NNN 时，即 nums 数组的长度。因此，我们的复杂性将是O(4n)O(4^n)O(4n)。\n 2. 对于基本情况，我们在 Java 中使用了 StringBuilder::toString 函数和在 Python 中使用了 .join() 函数花费了 O(N)O(N)O(N) 时间。这里 NNN 表示了表达式的长度。在最坏的情况下，每个数字都是一个操作数，我们有 NNN 个数字和 N−1N-1N−1 个运算符。所以 O(N)O(N)O(N)是对于一个表达式。在最坏的情况下，我们可以有 O(4n)O(4^n)O(4n) 有效表达式。\n\n * 空间复杂度：\n\n 1. 对于 Python 和 Java 实现，我们有一个列表数据结构，我们只在有效的表达式中更新，我们创建一个新的字符串并添加到我们的答案数组中。因此，中间列表所占的空间将是 O(n)O(n)O(n) ,因为在最坏的情况下，表达式将从所有数字中构建为操作数。\n 2. 由于递归堆栈的大小由索引的值决定，因此递归堆栈占用的空间也将为 O(n)O(n)O(n) 并且从 000 一直到 NNN 不等。\n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-09-27 15:32:23Accepted [https://leetcode-cn.com//submissions/detail/7629704/]377 ms10.64%N/Ajava# 统计信息\n通过次数提交次数AC比率1545493931.3%# 相似题目\n题目难度逆波兰表达式求值 [https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/]中等基本计算器 [https://leetcode-cn.com/problems/basic-calculator/]困难基本计算器 II [https://leetcode-cn.com/problems/basic-calculator-ii/]中等为运算表达式设计优先级 [https://leetcode-cn.com/problems/different-ways-to-add-parentheses/]中等目标和 [https://leetcode-cn.com/problems/target-sum/]中等',contentLowercase:'# 中文题目\n给定一个仅包含数字0-9的字符串和一个目标值，在数字之间添加二元运算符（不是一元）+、-或*，返回所有能够得到目标值的表达式。\n\n示例 1:\n\n输入: num = "123", target = 6\n输出: ["1+2+3", "1*2*3"] \n\n\n示例 2:\n\n输入: num = "232", target = 8\n输出: ["2*3+2", "2+3*2"]\n\n示例 3:\n\n输入: num = "105", target = 5\n输出: ["1*0+5","10-5"]\n\n示例 4:\n\n输入: num = "00", target = 0\n输出: ["0+0", "0-0", "0*0"]\n\n\n示例 5:\n\n输入: num = "3456237490", target = 9191\n输出: []\n\n\n# 通过代码\npublic class solution {\n    public list<string> addoperators(string num, int target) {\n        list<string> rst = new arraylist<string>();\n        if(num == null || num.length() == 0) return rst;\n        helper(rst, "", num, target, 0, 0, 0);\n        return rst;\n    }\n    public void helper(list<string> rst, string path, string num, int target, int pos, long eval, long multed){\n        if(pos == num.length()){\n            if(target == eval)\n                rst.add(path);\n            return;\n        }\n        for(int i = pos; i < num.length(); i++){\n            if(i != pos && num.charat(pos) == \'0\') break;\n            long cur = long.parselong(num.substring(pos, i + 1));\n            if(pos == 0){\n                helper(rst, path + cur, num, target, i + 1, cur, cur);\n            }\n            else{\n                helper(rst, path + "+" + cur, num, target, i + 1, eval + cur , cur);\n                \n                helper(rst, path + "-" + cur, num, target, i + 1, eval -cur, -cur);\n                \n                helper(rst, path + "*" + cur, num, target, i + 1, eval - multed + multed * cur, multed * cur );\n            }\n        }\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n# 官方题解\n# 方法一：回溯\n让我们先看看这个问题要求我们做什么，然后才能找到解决它的方法。因此，我们得到一个数字串和 3 个不同的运算符：\n\n * + addition\n\n * - subtraction\n\n * * multiplication\n\n我们必须找到数字之间所有可能的二元运算符组合，以便结果表达式的整体值等于给定的目标值。让我们来看看将运算符放在数字之间的确切含义的几个可能性，这样问题就更清楚了。\n\n假设我们有以下一组数字 “123456789”，给我们的目标值是 45。让我们看看通过将操作符放在不同的位置可以得到的一些可能的结果表达式。\n\n1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 = 45\n1 + 2 - 3 + 4 - 5 + 6 - 7 + 8 - 9 = -3\n1 + 2 * 3 - 4 + 5 + 6 - 7 * 8 - 9 = -51\n1 + 2 + 3 + 4 + 5 - 6 * 7 + 8 * 9 = 45\n\n\n1\n2\n3\n4\n这只是使用给定的数字串和三个运算符可能得到的许多表达式中的 4 个。\n\n通过查看上面的例子，我们无法真正找出结果表达式中的任何特定模式，这些模式告诉我们哪一个表达式将给出结果目标。\n\n由于这个问题明确地说明我们有二元运算符，这意味着每个运算符都需要两个操作数。 我们可以把每个数字都当作操作数。\n\n这意味着，在每对数字之间，我们可以使用三个运算符中的任何一个，即 +++、−-− 或×\\times×。\n\n如果你看过问题陈述和问题中给出的例子，你会发现有一个例子，数字是 “105”，目标值是 5。对于这个特殊的例子，有两个表达式给我们，它们是 1*0+5 和 10-5。\n\n第二个表达式是在解决这个问题之前需要注意的，因为这会使事情变得有点复杂。\n\n如果我们只需要考虑那些简单地用数字作为操作数的表达式，那么这个问题就更容易解决了。\n\n但是，在这个问题中，我们可以让各种数字组合在一起，形成一个更大的数字，成为表达式的一部分。让我们看看数字 “123456” 和目标 30 的一些示例表达式。\n\n1 * 23 - 4 + 5 + 6 = 30\n12 - 3 * 4 + 5 * 6 = 30\n1 - 23 - 4 + 56 = 30\n\n\n1\n2\n3\n这意味着，尽管我们定义了运算符的数量，即3个不同的二元运算符，但是操作数的数量并没有很好地为我们定义。\n\n这是我们在解决方案中需要解决的原始问题的很大一部分。\n\n因为我们被要求找出所有值等于给定目标的有效表达式，而且我们不知道两个操作数之间的特定运算符最终会给我们一个有效表达式，\n\n> 我们尝试所有的选择\n\n\n这意味着一旦我们定义了给定表达式的操作数，我们就可以在每个连续的操作数对之间选择三个可能的操作数。\n\n从实现的角度来看，操作数对于原始字符串意味着什么？\n\n> 操作数是由原始字符串的子字符串形成的整数\n\n\n让我们来看看字符串 “123456789” 的两种不同的数组分割方式：\n\n{:width="500"} {:align=center}\n\n由于我们需要返回所有有效表达式，这些表达式的计算结果为给定的目标值，因此我们必须尝试给定数组的所有可能分区，从而考虑所有可能的操作数，这些操作数可以由数字组成。\n\n有一种非常简单的方法可以将此合并到我们的算法中。现在，在算法的每一点上，我们都有三个不同的选择对应于三个不同的操作符。\n\n> 我们合并这些分区的方法是考虑第四个运算符，它只向前移动一步，将当前操作数扩展一位。实际上，在我们的实现中，从 12−−>12312 --\x3e 12312−−>123 开始是一个无操作操作数。(12∗10)+3(12*10)+3(12∗10)+3。\n\n\n现在，我们的算法中有4个不同的递归路径，我们必须尝试所有这些路径，看看哪一个会导致潜在的解决方案。\n\n算法：在查看伪代码之前，让我们先快速查看回溯算法中涉及的步骤。\n\n 1. 如上所述，我们有多种选择，可以选择使用什么运算符，可以选择哪些操作数，因此，我们必须考虑找到所有有效表达式的所有可能性。\n 2. 我们的递归调用 index ，它表示我们在原始 nums 字符串中看到的当前数字，以及到目前为止构建的表达式字符串。\n 3. 在每一步中，我们都有 4 个不同的递归调用。no op 调用只是将当前的操作数扩展到当前数字并向前移动。其余的递归调用对应于+、-、和 *。\n 4. 我们继续这样构建表达式，最终会处理整个 nums 字符串。那时，我们检查到现在为止构建的表达式是否是有效的表达式，如果是有效的表达式，我们会记录它。\n\n1. procedure recurse(digits, index, expression):\n2.     if we have reached the end of the string:\n3.         if the expression evaluates to the target:\n4.             valid expression found!\n5.     else:\n6.         try out operator \'no op\' and recurse\n7.         try out operator * and recurse\n8.         try out operator + and recurse\n9.         try out operator - and recurse\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n算法现在看起来非常简单。然而，实现需要更多的思考，在实际实现之前，我们需要解决一些问题。\n\n> 当我们用原始字符串中的所有数字构建表达式时，我们检查表达式是否是有效的表达式。我们如何实际检查该表达式是否有效？\n\n\n一种方法是编写一个自定义的 eval 函数，它接受一个字符串并返回表达式的值。如果这样做（python 用户可以使用内置函数 eval ），您将超过时间限制。\n\n我们不能实时跟踪表达式的值吗？\n\n是的。这就是我们要遵循的理念。除了跟踪表达式字符串是什么，我们还将跟踪它的值，以便当递归到达基本情况时，我们可以通过 o(1)o(1)o(1) 的时间复杂度来判断表达式是否等于目标值\n\n如果只是 + 和 - 运算符参与的话，实现会很简单。这是因为这两个操作符具有相同的优先级。这意味着我们可以继续动态地评估表达式，而不会出现任何问题。\n\n{:width="500"} {:align=center}\n\n若添加 * 操作符，看看如何快速构建表达式。\n\n{:width="500"} {:align=center}\n\n我们所说的动态构建表达式是指我们一直跟踪表达式的值，直到现在，我们只是将该值作为我们的运算符的两个操作数之一。正如我们从上面的两个例子中看到的，如果它只是 + 和 - 操作符，那么这就可以工作了。\n\n但是，这种方法肯定会失败，因为 * 运算符优先于 +和 -。* 运算符需要表达式中实际的前一个操作数，而不是表达式的当前值。也就是说，在上面的例子中，* 运算符需要 2 而不是 12 才能得到正确的值 18。\n\n如何处理？如何处理这个问题的想法来源于上面的讨论。我们只需要跟踪表达式中的最后一个操作数，以及它是如何整体修改表达式的值的，这样当我们考虑 * 运算符时，我们可以反转前一个操作数的效果，并考虑它的乘法。让我们来看一下以前打破的例子。\n\n{:width="500"} {:align=center}\n\n现在我们可以看看这个算法的实际实现。\n\nclass solution {\n\n  public arraylist<string> answer;\n  public string digits;\n  public long target;\n\n  public void recurse(\n      int index, long previousoperand, long currentoperand, long value, arraylist<string> ops) {\n    string nums = this.digits;\n\n    // done processing all the digits in num\n    if (index == nums.length()) {\n\n      // if the final value == target expected and\n      // no operand is left unprocessed\n      if (value == this.target && currentoperand == 0) {\n        stringbuilder sb = new stringbuilder();\n        ops.sublist(1, ops.size()).foreach(v -> sb.append(v));\n        this.answer.add(sb.tostring());\n      }\n      return;\n    }\n\n    // extending the current operand by one digit\n    currentoperand = currentoperand * 10 + character.getnumericvalue(nums.charat(index));\n    string current_val_rep = long.tostring(currentoperand);\n    int length = nums.length();\n\n    // to avoid cases where we have 1 + 05 or 1 * 05 since 05 won\'t be a\n    // valid operand. hence this check\n    if (currentoperand > 0) {\n\n      // no op recursion\n      recurse(index + 1, previousoperand, currentoperand, value, ops);\n    }\n\n    // addition\n    ops.add("+");\n    ops.add(current_val_rep);\n    recurse(index + 1, currentoperand, 0, value + currentoperand, ops);\n    ops.remove(ops.size() - 1);\n    ops.remove(ops.size() - 1);\n\n    if (ops.size() > 0) {\n\n      // subtraction\n      ops.add("-");\n      ops.add(current_val_rep);\n      recurse(index + 1, -currentoperand, 0, value - currentoperand, ops);\n      ops.remove(ops.size() - 1);\n      ops.remove(ops.size() - 1);\n\n      // multiplication\n      ops.add("*");\n      ops.add(current_val_rep);\n      recurse(\n          index + 1,\n          currentoperand * previousoperand,\n          0,\n          value - previousoperand + (currentoperand * previousoperand),\n          ops);\n      ops.remove(ops.size() - 1);\n      ops.remove(ops.size() - 1);\n    }\n  }\n\n  public list<string> addoperators(string num, int target) {\n\n    if (num.length() == 0) {\n      return new arraylist<string>();\n    }\n\n    this.target = target;\n    this.digits = num;\n    this.answer = new arraylist<string>();\n    this.recurse(0, 0, 0, 0, new arraylist<string>());\n    return this.answer;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\nclass solution:\n    def addoperators(self, num: \'str\', target: \'int\') -> \'list[str]\':\n\n        n = len(num)\n        answers = []\n        def recurse(index, prev_operand, current_operand, value, string):\n\n            # done processing all the digits in num\n            if index == n:\n\n                # if the final value == target expected and\n                # no operand is left unprocessed\n                if value == target and current_operand == 0:\n                    answers.append("".join(string[1:]))\n                return\n\n            # extending the current operand by one digit\n            current_operand = current_operand*10 + int(num[index])\n            str_op = str(current_operand)\n\n            # to avoid cases where we have 1 + 05 or 1 * 05 since 05 won\'t be a\n            # valid operand. hence this check\n            if current_operand > 0:\n\n                # no op recursion\n                recurse(index + 1, prev_operand, current_operand, value, string)\n\n            # addition\n            string.append(\'+\'); string.append(str_op)\n            recurse(index + 1, current_operand, 0, value + current_operand, string)\n            string.pop();string.pop()\n\n            # can subtract or multiply only if there are some previous operands\n            if string:\n\n                # subtraction\n                string.append(\'-\'); string.append(str_op)\n                recurse(index + 1, -current_operand, 0, value - current_operand, string)\n                string.pop();string.pop()\n\n                # multiplication\n                string.append(\'*\'); string.append(str_op)\n                recurse(index + 1, current_operand * prev_operand, 0, value - prev_operand + (current_operand * prev_operand), string)\n                string.pop();string.pop()\n        recurse(0, 0, 0, 0, [])    \n        return answers\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n复杂度分析\n\n * 时间复杂度：\n\n 1. 在这一过程的每一步中，我们都会考虑 4 种不同的选择或 4 种不同的递归路径。基本情况是当索引值达到 nnn 时，即 nums 数组的长度。因此，我们的复杂性将是o(4n)o(4^n)o(4n)。\n 2. 对于基本情况，我们在 java 中使用了 stringbuilder::tostring 函数和在 python 中使用了 .join() 函数花费了 o(n)o(n)o(n) 时间。这里 nnn 表示了表达式的长度。在最坏的情况下，每个数字都是一个操作数，我们有 nnn 个数字和 n−1n-1n−1 个运算符。所以 o(n)o(n)o(n)是对于一个表达式。在最坏的情况下，我们可以有 o(4n)o(4^n)o(4n) 有效表达式。\n\n * 空间复杂度：\n\n 1. 对于 python 和 java 实现，我们有一个列表数据结构，我们只在有效的表达式中更新，我们创建一个新的字符串并添加到我们的答案数组中。因此，中间列表所占的空间将是 o(n)o(n)o(n) ,因为在最坏的情况下，表达式将从所有数字中构建为操作数。\n 2. 由于递归堆栈的大小由索引的值决定，因此递归堆栈占用的空间也将为 o(n)o(n)o(n) 并且从 000 一直到 nnn 不等。\n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-09-27 15:32:23accepted [https://leetcode-cn.com//submissions/detail/7629704/]377 ms10.64%n/ajava# 统计信息\n通过次数提交次数ac比率1545493931.3%# 相似题目\n题目难度逆波兰表达式求值 [https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/]中等基本计算器 [https://leetcode-cn.com/problems/basic-calculator/]困难基本计算器 ii [https://leetcode-cn.com/problems/basic-calculator-ii/]中等为运算表达式设计优先级 [https://leetcode-cn.com/problems/different-ways-to-add-parentheses/]中等目标和 [https://leetcode-cn.com/problems/target-sum/]中等'},{title:"1-两数之和(Two Sum)",frontmatter:{title:"1-两数之和(Two Sum)",date:"2018-09-11T00:00:00.000Z",categories:["简单"],tags:["数组<Array>","哈希表<Hash Table>"]},regularPath:"/views/%E7%AE%80%E5%8D%95/0001-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C.html",relativePath:"views/简单/0001-两数之和.md",key:"v-0a7ef002",path:"/views/%E7%AE%80%E5%8D%95/0001-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C.html",headers:[{level:2,title:"中文题目",slug:"中文题目",charIndex:2},{level:2,title:"通过代码",slug:"通过代码",charIndex:201},{level:2,title:"官方题解",slug:"官方题解",charIndex:2090},{level:2,title:"提交历史",slug:"提交历史",charIndex:4724},{level:2,title:"统计信息",slug:"统计信息",charIndex:5847},{level:2,title:"相似题目",slug:"相似题目",charIndex:5884}],lastUpdated:"4/11/2021, 1:15:21 PM",headersStr:"中文题目 通过代码 官方题解 提交历史 统计信息 相似题目",content:'# 中文题目\n给定一个整数数组 nums和一个目标值 target，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。\n\n你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。\n\n示例:\n\n给定 nums = [2, 7, 11, 15], target = 9\n\n因为 nums[0] + nums[1] = 2 + 7 = 9\n所以返回 [0, 1]\n\n\n# 通过代码\nimport java.util.HashMap;\nimport java.util.Map;\nclass Solution {\n   public int[] twoSum(int[] numbers, int target) {\n        int[] result = new int[2];\n        Map<Integer, Integer> map = new HashMap<Integer, Integer>();\n        for (int i = 0; i < numbers.length; i++) {\n            if (map.containsKey(target - numbers[i])) {\n                result[1] = i ;\n                result[0] = map.get(target - numbers[i]);\n                return result;\n            }\n            map.put(numbers[i], i);\n        }\n        return result;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\nclass Solution {\n    public int[] twoSum(int[] nums, int target) {\n        int temp[]=Arrays.copyOf(nums,nums.length);\n        Arrays.sort(nums);\n        int i,j=0;\n        boolean flag=false;\n        for (i=0;i<nums.length;i++){\n            for (j=(nums.length-1);j>0;j--){\n//                System.out.println(i+" "+j);\n                if ((nums[i]+nums[j])==target){\n                    flag=true;\n                    break;\n                }\n            }\n            if (flag){\n                break;\n            }\n        }\n\n        int l=0,n=0;\n        int count=0;\n        for (int h=0;(h<temp.length)&&(count<2);h++){\n            if (nums[i]==temp[h] ){\n                l=h;\n                count++;\n                temp[h]=Integer.MAX_VALUE;\n                nums[i]=Integer.MAX_VALUE;\n                continue;\n            }\n            if (nums[j]==temp[h]){\n                n=h;\n                count++;\n                temp[h]=Integer.MAX_VALUE;\n                nums[j]=Integer.MAX_VALUE;\n                continue;\n            }\n        }\n        if (l>n){\n            int k=n;\n            n=l;\n            l=k;\n        }\n        return new int[]{l,n};\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n# 官方题解\n# 方法一：暴力法\n暴力法很简单，遍历每个元素 xxx，并查找是否存在一个值与 target−xtarget - xtarget−x 相等的目标元素。\n\nclass Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        throw new IllegalArgumentException("No two sum solution");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n复杂度分析：\n\n * 时间复杂度：O(n2)O(n^2)O(n2)对于每个元素，我们试图通过遍历数组的其余部分来寻找它所对应的目标元素，这将耗费 O(n)O(n)O(n) 的时间。因此时间复杂度为 O(n2)O(n^2)O(n2)。\n   \n   \n * 空间复杂度：O(1)O(1)O(1)。\n   \n   \n\n\n\n\n# 方法二：两遍哈希表\n为了对运行时间复杂度进行优化，我们需要一种更有效的方法来检查数组中是否存在目标元素。如果存在，我们需要找出它的索引。保持数组中的每个元素与其索引相互对应的最好方法是什么？哈希表。\n\n通过以空间换取速度的方式，我们可以将查找时间从 O(n)O(n)O(n) 降低到 O(1)O(1)O(1)。哈希表正是为此目的而构建的，它支持以 近似 恒定的时间进行快速查找。我用“近似”来描述，是因为一旦出现冲突，查找用时可能会退化到 O(n)O(n)O(n)。但只要你仔细地挑选哈希函数，在哈希表中进行查找的用时应当被摊销为 O(1)O(1)O(1)。\n\n一个简单的实现使用了两次迭代。在第一次迭代中，我们将每个元素的值和它的索引添加到表中。然后，在第二次迭代中，我们将检查每个元素所对应的目标元素（target−nums[i]target - nums[i]target−nums[i]）是否存在于表中。注意，该目标元素不能是 nums[i]nums[i]nums[i] 本身！\n\nclass Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            map.put(nums[i], i);\n        }\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement) && map.get(complement) != i) {\n                return new int[] { i, map.get(complement) };\n            }\n        }\n        throw new IllegalArgumentException("No two sum solution");\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n复杂度分析：\n\n * 时间复杂度：O(n)O(n)O(n)， 我们把包含有 nnn 个元素的列表遍历两次。由于哈希表将查找时间缩短到 O(1)O(1)O(1) ，所以时间复杂度为 O(n)O(n)O(n)。\n   \n   \n * 空间复杂度：O(n)O(n)O(n)， 所需的额外空间取决于哈希表中存储的元素数量，该表中存储了 nnn 个元素。\n   \n   \n\n\n\n\n# 方法三：一遍哈希表\n事实证明，我们可以一次完成。在进行迭代并将元素插入到表中的同时，我们还会回过头来检查表中是否已经存在当前元素所对应的目标元素。如果它存在，那我们已经找到了对应解，并立即将其返回。\n\nclass Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        throw new IllegalArgumentException("No two sum solution");\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n复杂度分析：\n\n * 时间复杂度：O(n)O(n)O(n)， 我们只遍历了包含有 nnn 个元素的列表一次。在表中进行的每次查找只花费 O(1)O(1)O(1) 的时间。\n   \n   \n * 空间复杂度：O(n)O(n)O(n)， 所需的额外空间取决于哈希表中存储的元素数量，该表最多需要存储 nnn 个元素。\n   \n   \n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-09-11 21:03:13Compile Error [https://leetcode-cn.com//submissions/detail/6930947/]N/AN/AN/Ajava2018-09-11 21:02:15Compile Error [https://leetcode-cn.com//submissions/detail/6930894/]N/AN/AN/Ajava2018-05-17 00:02:53Accepted [https://leetcode-cn.com//submissions/detail/2344230/]7 ms57.96%N/Ajava2018-05-17 00:00:54Wrong Answer [https://leetcode-cn.com//submissions/detail/2344194/]N/AN/AN/Ajava2018-05-16 23:58:38Compile Error [https://leetcode-cn.com//submissions/detail/2344157/]N/AN/AN/Ajava2018-05-16 23:58:18Compile Error [https://leetcode-cn.com//submissions/detail/2344154/]N/AN/AN/Ajava2017-11-13 21:42:18Accepted [https://leetcode-cn.com//submissions/detail/1149024/]11 ms56.99%N/Ajava2017-11-13 21:37:43Wrong Answer [https://leetcode-cn.com//submissions/detail/1149016/]N/AN/AN/Ajava2017-11-13 21:35:20Wrong Answer [https://leetcode-cn.com//submissions/detail/1149034/]N/AN/AN/Ajava2017-11-13 20:06:12Wrong Answer [https://leetcode-cn.com//submissions/detail/1149032/]N/AN/AN/Ajava2017-11-13 19:59:01Wrong Answer [https://leetcode-cn.com//submissions/detail/1149030/]N/AN/AN/Ajava# 统计信息\n通过次数提交次数AC比率790575166832847.4%# 相似题目\n题目难度三数之和 [https://leetcode-cn.com/problems/3sum/]中等四数之和 [https://leetcode-cn.com/problems/4sum/]中等两数之和 II - 输入有序数组 [https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/]简单两数之和 III - 数据结构设计 [https://leetcode-cn.com/problems/two-sum-iii-data-structure-design/]简单和为K的子数组 [https://leetcode-cn.com/problems/subarray-sum-equals-k/]中等两数之和 IV - 输入 BST [https://leetcode-cn.com/problems/two-sum-iv-input-is-a-bst/]简单小于 K 的两数之和 [https://leetcode-cn.com/problems/two-sum-less-than-k/]简单',contentLowercase:'# 中文题目\n给定一个整数数组 nums和一个目标值 target，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。\n\n你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。\n\n示例:\n\n给定 nums = [2, 7, 11, 15], target = 9\n\n因为 nums[0] + nums[1] = 2 + 7 = 9\n所以返回 [0, 1]\n\n\n# 通过代码\nimport java.util.hashmap;\nimport java.util.map;\nclass solution {\n   public int[] twosum(int[] numbers, int target) {\n        int[] result = new int[2];\n        map<integer, integer> map = new hashmap<integer, integer>();\n        for (int i = 0; i < numbers.length; i++) {\n            if (map.containskey(target - numbers[i])) {\n                result[1] = i ;\n                result[0] = map.get(target - numbers[i]);\n                return result;\n            }\n            map.put(numbers[i], i);\n        }\n        return result;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\nclass solution {\n    public int[] twosum(int[] nums, int target) {\n        int temp[]=arrays.copyof(nums,nums.length);\n        arrays.sort(nums);\n        int i,j=0;\n        boolean flag=false;\n        for (i=0;i<nums.length;i++){\n            for (j=(nums.length-1);j>0;j--){\n//                system.out.println(i+" "+j);\n                if ((nums[i]+nums[j])==target){\n                    flag=true;\n                    break;\n                }\n            }\n            if (flag){\n                break;\n            }\n        }\n\n        int l=0,n=0;\n        int count=0;\n        for (int h=0;(h<temp.length)&&(count<2);h++){\n            if (nums[i]==temp[h] ){\n                l=h;\n                count++;\n                temp[h]=integer.max_value;\n                nums[i]=integer.max_value;\n                continue;\n            }\n            if (nums[j]==temp[h]){\n                n=h;\n                count++;\n                temp[h]=integer.max_value;\n                nums[j]=integer.max_value;\n                continue;\n            }\n        }\n        if (l>n){\n            int k=n;\n            n=l;\n            l=k;\n        }\n        return new int[]{l,n};\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n# 官方题解\n# 方法一：暴力法\n暴力法很简单，遍历每个元素 xxx，并查找是否存在一个值与 target−xtarget - xtarget−x 相等的目标元素。\n\nclass solution {\n    public int[] twosum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        throw new illegalargumentexception("no two sum solution");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n复杂度分析：\n\n * 时间复杂度：o(n2)o(n^2)o(n2)对于每个元素，我们试图通过遍历数组的其余部分来寻找它所对应的目标元素，这将耗费 o(n)o(n)o(n) 的时间。因此时间复杂度为 o(n2)o(n^2)o(n2)。\n   \n   \n * 空间复杂度：o(1)o(1)o(1)。\n   \n   \n\n\n\n\n# 方法二：两遍哈希表\n为了对运行时间复杂度进行优化，我们需要一种更有效的方法来检查数组中是否存在目标元素。如果存在，我们需要找出它的索引。保持数组中的每个元素与其索引相互对应的最好方法是什么？哈希表。\n\n通过以空间换取速度的方式，我们可以将查找时间从 o(n)o(n)o(n) 降低到 o(1)o(1)o(1)。哈希表正是为此目的而构建的，它支持以 近似 恒定的时间进行快速查找。我用“近似”来描述，是因为一旦出现冲突，查找用时可能会退化到 o(n)o(n)o(n)。但只要你仔细地挑选哈希函数，在哈希表中进行查找的用时应当被摊销为 o(1)o(1)o(1)。\n\n一个简单的实现使用了两次迭代。在第一次迭代中，我们将每个元素的值和它的索引添加到表中。然后，在第二次迭代中，我们将检查每个元素所对应的目标元素（target−nums[i]target - nums[i]target−nums[i]）是否存在于表中。注意，该目标元素不能是 nums[i]nums[i]nums[i] 本身！\n\nclass solution {\n    public int[] twosum(int[] nums, int target) {\n        map<integer, integer> map = new hashmap<>();\n        for (int i = 0; i < nums.length; i++) {\n            map.put(nums[i], i);\n        }\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containskey(complement) && map.get(complement) != i) {\n                return new int[] { i, map.get(complement) };\n            }\n        }\n        throw new illegalargumentexception("no two sum solution");\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n复杂度分析：\n\n * 时间复杂度：o(n)o(n)o(n)， 我们把包含有 nnn 个元素的列表遍历两次。由于哈希表将查找时间缩短到 o(1)o(1)o(1) ，所以时间复杂度为 o(n)o(n)o(n)。\n   \n   \n * 空间复杂度：o(n)o(n)o(n)， 所需的额外空间取决于哈希表中存储的元素数量，该表中存储了 nnn 个元素。\n   \n   \n\n\n\n\n# 方法三：一遍哈希表\n事实证明，我们可以一次完成。在进行迭代并将元素插入到表中的同时，我们还会回过头来检查表中是否已经存在当前元素所对应的目标元素。如果它存在，那我们已经找到了对应解，并立即将其返回。\n\nclass solution {\n    public int[] twosum(int[] nums, int target) {\n        map<integer, integer> map = new hashmap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containskey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        throw new illegalargumentexception("no two sum solution");\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n复杂度分析：\n\n * 时间复杂度：o(n)o(n)o(n)， 我们只遍历了包含有 nnn 个元素的列表一次。在表中进行的每次查找只花费 o(1)o(1)o(1) 的时间。\n   \n   \n * 空间复杂度：o(n)o(n)o(n)， 所需的额外空间取决于哈希表中存储的元素数量，该表最多需要存储 nnn 个元素。\n   \n   \n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-09-11 21:03:13compile error [https://leetcode-cn.com//submissions/detail/6930947/]n/an/an/ajava2018-09-11 21:02:15compile error [https://leetcode-cn.com//submissions/detail/6930894/]n/an/an/ajava2018-05-17 00:02:53accepted [https://leetcode-cn.com//submissions/detail/2344230/]7 ms57.96%n/ajava2018-05-17 00:00:54wrong answer [https://leetcode-cn.com//submissions/detail/2344194/]n/an/an/ajava2018-05-16 23:58:38compile error [https://leetcode-cn.com//submissions/detail/2344157/]n/an/an/ajava2018-05-16 23:58:18compile error [https://leetcode-cn.com//submissions/detail/2344154/]n/an/an/ajava2017-11-13 21:42:18accepted [https://leetcode-cn.com//submissions/detail/1149024/]11 ms56.99%n/ajava2017-11-13 21:37:43wrong answer [https://leetcode-cn.com//submissions/detail/1149016/]n/an/an/ajava2017-11-13 21:35:20wrong answer [https://leetcode-cn.com//submissions/detail/1149034/]n/an/an/ajava2017-11-13 20:06:12wrong answer [https://leetcode-cn.com//submissions/detail/1149032/]n/an/an/ajava2017-11-13 19:59:01wrong answer [https://leetcode-cn.com//submissions/detail/1149030/]n/an/an/ajava# 统计信息\n通过次数提交次数ac比率790575166832847.4%# 相似题目\n题目难度三数之和 [https://leetcode-cn.com/problems/3sum/]中等四数之和 [https://leetcode-cn.com/problems/4sum/]中等两数之和 ii - 输入有序数组 [https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/]简单两数之和 iii - 数据结构设计 [https://leetcode-cn.com/problems/two-sum-iii-data-structure-design/]简单和为k的子数组 [https://leetcode-cn.com/problems/subarray-sum-equals-k/]中等两数之和 iv - 输入 bst [https://leetcode-cn.com/problems/two-sum-iv-input-is-a-bst/]简单小于 k 的两数之和 [https://leetcode-cn.com/problems/two-sum-less-than-k/]简单'},{title:"7-整数反转(Reverse Integer)",frontmatter:{title:"7-整数反转(Reverse Integer)",date:"2017-11-14T00:00:00.000Z",categories:["简单"],tags:["数学<Math>"]},regularPath:"/views/%E7%AE%80%E5%8D%95/0007-%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC.html",relativePath:"views/简单/0007-整数反转.md",key:"v-f20421d4",path:"/views/%E7%AE%80%E5%8D%95/0007-%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC.html",headers:[{level:2,title:"中文题目",slug:"中文题目",charIndex:2},{level:2,title:"通过代码",slug:"通过代码",charIndex:203},{level:2,title:"官方题解",slug:"官方题解",charIndex:723},{level:2,title:"提交历史",slug:"提交历史",charIndex:2720},{level:2,title:"统计信息",slug:"统计信息",charIndex:3046},{level:2,title:"相似题目",slug:"相似题目",charIndex:3082}],lastUpdated:"4/11/2021, 1:15:21 PM",headersStr:"中文题目 通过代码 官方题解 提交历史 统计信息 相似题目",content:"# 中文题目\n给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。\n\n示例 1:\n\n输入: 123\n输出: 321\n\n\n示例 2:\n\n输入: -123\n输出: -321\n\n\n示例 3:\n\n输入: 120\n输出: 21\n\n\n注意:\n\n假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−231, 231− 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。\n\n# 通过代码\nclass Solution{\n    public int reverse(int x){\n        long a=0;\n        boolean flag=false;\n        if (x<0){\n            x=Math.abs(x);\n            flag=true;\n        }\n        while ((x/10)>0||(x%10)>0){\n            int temp=x%10;\n            if ((Integer.MAX_VALUE-a*10)<temp){\n                return 0;\n            }\n            a=temp+a*10;\n            x/=10;\n        }\n        if (flag){\n            a*=(-1);\n        }\n        return (int) a;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n# 官方题解\n# 方法：弹出和推入数字 & 溢出前进行检查\n思路\n\n我们可以一次构建反转整数的一位数字。在这样做的时候，我们可以预先检查向原整数附加另一位数字是否会导致溢出。\n\n算法\n\n反转整数的方法可以与反转字符串进行类比。\n\n我们想重复“弹出” xxx 的最后一位数字，并将它“推入”到 rev\\text{rev}rev 的后面。最后，rev\\text{rev}rev 将与 xxx 相反。\n\n要在没有辅助堆栈 / 数组的帮助下 “弹出” 和 “推入” 数字，我们可以使用数学方法。\n\n//pop operation:\npop = x % 10;\nx /= 10;\n\n//push operation:\ntemp = rev * 10 + pop;\nrev = temp;\n\n\n1\n2\n3\n4\n5\n6\n7\n但是，这种方法很危险，因为当 temp=rev⋅10+pop\\text{temp} = \\text{rev} \\cdot 10 + \\text{pop}temp=rev⋅10+pop 时会导致溢出。\n\n幸运的是，事先检查这个语句是否会导致溢出很容易。\n\n为了便于解释，我们假设 rev\\text{rev}rev 是正数。\n\n 1. 如果 temp=rev⋅10+poptemp = \\text{rev} \\cdot 10 + \\text{pop}temp=rev⋅10+pop 导致溢出，那么一定有 rev≥INTMAX10\\text{rev} \\geq \\frac{INTMAX}{10}rev≥10INTMAX​。\n 2. 如果 rev>INTMAX10\\text{rev} > \\frac{INTMAX}{10}rev>10INTMAX​，那么 temp=rev⋅10+poptemp = \\text{rev} \\cdot 10 + \\text{pop}temp=rev⋅10+pop 一定会溢出。\n 3. 如果 rev==INTMAX10\\text{rev} == \\frac{INTMAX}{10}rev==10INTMAX​，那么只要 pop>7\\text{pop} > 7pop>7，temp=rev⋅10+poptemp = \\text{rev} \\cdot 10 + \\text{pop}temp=rev⋅10+pop 就会溢出。\n\n当 rev\\text{rev}rev 为负时可以应用类似的逻辑。\n\nclass Solution {\npublic:\n    int reverse(int x) {\n        int rev = 0;\n        while (x != 0) {\n            int pop = x % 10;\n            x /= 10;\n            if (rev > INT_MAX/10 || (rev == INT_MAX / 10 && pop > 7)) return 0;\n            if (rev < INT_MIN/10 || (rev == INT_MIN / 10 && pop < -8)) return 0;\n            rev = rev * 10 + pop;\n        }\n        return rev;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\nclass Solution {\n    public int reverse(int x) {\n        int rev = 0;\n        while (x != 0) {\n            int pop = x % 10;\n            x /= 10;\n            if (rev > Integer.MAX_VALUE/10 || (rev == Integer.MAX_VALUE / 10 && pop > 7)) return 0;\n            if (rev < Integer.MIN_VALUE/10 || (rev == Integer.MIN_VALUE / 10 && pop < -8)) return 0;\n            rev = rev * 10 + pop;\n        }\n        return rev;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n复杂度分析\n\n * 时间复杂度：O(log⁡(x))O(\\log(x))O(log(x))，xxx 中大约有 log⁡10(x)\\log_{10}(x)log10​(x) 位数字。\n * 空间复杂度：O(1)O(1)O(1)。\n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2017-11-14 23:53:17Accepted [https://leetcode-cn.com//submissions/detail/1149018/]36 ms5.17%N/Ajava2017-11-14 23:43:57Wrong Answer [https://leetcode-cn.com//submissions/detail/1149036/]N/AN/AN/Ajava2017-11-14 23:37:40Wrong Answer [https://leetcode-cn.com//submissions/detail/1149035/]N/AN/AN/Ajava# 统计信息\n通过次数提交次数AC比率25859777191233.5%# 相似题目\n题目难度字符串转换整数 (atoi) [https://leetcode-cn.com/problems/string-to-integer-atoi/]中等颠倒二进制位 [https://leetcode-cn.com/problems/reverse-bits/]简单",contentLowercase:"# 中文题目\n给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。\n\n示例 1:\n\n输入: 123\n输出: 321\n\n\n示例 2:\n\n输入: -123\n输出: -321\n\n\n示例 3:\n\n输入: 120\n输出: 21\n\n\n注意:\n\n假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−231, 231− 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。\n\n# 通过代码\nclass solution{\n    public int reverse(int x){\n        long a=0;\n        boolean flag=false;\n        if (x<0){\n            x=math.abs(x);\n            flag=true;\n        }\n        while ((x/10)>0||(x%10)>0){\n            int temp=x%10;\n            if ((integer.max_value-a*10)<temp){\n                return 0;\n            }\n            a=temp+a*10;\n            x/=10;\n        }\n        if (flag){\n            a*=(-1);\n        }\n        return (int) a;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n# 官方题解\n# 方法：弹出和推入数字 & 溢出前进行检查\n思路\n\n我们可以一次构建反转整数的一位数字。在这样做的时候，我们可以预先检查向原整数附加另一位数字是否会导致溢出。\n\n算法\n\n反转整数的方法可以与反转字符串进行类比。\n\n我们想重复“弹出” xxx 的最后一位数字，并将它“推入”到 rev\\text{rev}rev 的后面。最后，rev\\text{rev}rev 将与 xxx 相反。\n\n要在没有辅助堆栈 / 数组的帮助下 “弹出” 和 “推入” 数字，我们可以使用数学方法。\n\n//pop operation:\npop = x % 10;\nx /= 10;\n\n//push operation:\ntemp = rev * 10 + pop;\nrev = temp;\n\n\n1\n2\n3\n4\n5\n6\n7\n但是，这种方法很危险，因为当 temp=rev⋅10+pop\\text{temp} = \\text{rev} \\cdot 10 + \\text{pop}temp=rev⋅10+pop 时会导致溢出。\n\n幸运的是，事先检查这个语句是否会导致溢出很容易。\n\n为了便于解释，我们假设 rev\\text{rev}rev 是正数。\n\n 1. 如果 temp=rev⋅10+poptemp = \\text{rev} \\cdot 10 + \\text{pop}temp=rev⋅10+pop 导致溢出，那么一定有 rev≥intmax10\\text{rev} \\geq \\frac{intmax}{10}rev≥10intmax​。\n 2. 如果 rev>intmax10\\text{rev} > \\frac{intmax}{10}rev>10intmax​，那么 temp=rev⋅10+poptemp = \\text{rev} \\cdot 10 + \\text{pop}temp=rev⋅10+pop 一定会溢出。\n 3. 如果 rev==intmax10\\text{rev} == \\frac{intmax}{10}rev==10intmax​，那么只要 pop>7\\text{pop} > 7pop>7，temp=rev⋅10+poptemp = \\text{rev} \\cdot 10 + \\text{pop}temp=rev⋅10+pop 就会溢出。\n\n当 rev\\text{rev}rev 为负时可以应用类似的逻辑。\n\nclass solution {\npublic:\n    int reverse(int x) {\n        int rev = 0;\n        while (x != 0) {\n            int pop = x % 10;\n            x /= 10;\n            if (rev > int_max/10 || (rev == int_max / 10 && pop > 7)) return 0;\n            if (rev < int_min/10 || (rev == int_min / 10 && pop < -8)) return 0;\n            rev = rev * 10 + pop;\n        }\n        return rev;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\nclass solution {\n    public int reverse(int x) {\n        int rev = 0;\n        while (x != 0) {\n            int pop = x % 10;\n            x /= 10;\n            if (rev > integer.max_value/10 || (rev == integer.max_value / 10 && pop > 7)) return 0;\n            if (rev < integer.min_value/10 || (rev == integer.min_value / 10 && pop < -8)) return 0;\n            rev = rev * 10 + pop;\n        }\n        return rev;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n复杂度分析\n\n * 时间复杂度：o(log⁡(x))o(\\log(x))o(log(x))，xxx 中大约有 log⁡10(x)\\log_{10}(x)log10​(x) 位数字。\n * 空间复杂度：o(1)o(1)o(1)。\n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2017-11-14 23:53:17accepted [https://leetcode-cn.com//submissions/detail/1149018/]36 ms5.17%n/ajava2017-11-14 23:43:57wrong answer [https://leetcode-cn.com//submissions/detail/1149036/]n/an/an/ajava2017-11-14 23:37:40wrong answer [https://leetcode-cn.com//submissions/detail/1149035/]n/an/an/ajava# 统计信息\n通过次数提交次数ac比率25859777191233.5%# 相似题目\n题目难度字符串转换整数 (atoi) [https://leetcode-cn.com/problems/string-to-integer-atoi/]中等颠倒二进制位 [https://leetcode-cn.com/problems/reverse-bits/]简单"},{title:"9-回文数(Palindrome Number)",frontmatter:{title:"9-回文数(Palindrome Number)",date:"2017-11-16T00:00:00.000Z",categories:["简单"],tags:["数学<Math>"]},regularPath:"/views/%E7%AE%80%E5%8D%95/0009-%E5%9B%9E%E6%96%87%E6%95%B0.html",relativePath:"views/简单/0009-回文数.md",key:"v-1146fde9",path:"/views/%E7%AE%80%E5%8D%95/0009-%E5%9B%9E%E6%96%87%E6%95%B0.html",headers:[{level:2,title:"中文题目",slug:"中文题目",charIndex:2},{level:2,title:"通过代码",slug:"通过代码",charIndex:238},{level:2,title:"官方题解",slug:"官方题解",charIndex:737},{level:2,title:"提交历史",slug:"提交历史",charIndex:2484},{level:2,title:"统计信息",slug:"统计信息",charIndex:2811},{level:2,title:"相似题目",slug:"相似题目",charIndex:2847}],lastUpdated:"4/11/2021, 1:15:21 PM",headersStr:"中文题目 通过代码 官方题解 提交历史 统计信息 相似题目",content:'# 中文题目\n判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。\n\n示例 1:\n\n输入: 121\n输出: true\n\n\n示例 2:\n\n输入: -121\n输出: false\n解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。\n\n\n示例 3:\n\n输入: 10\n输出: false\n解释: 从右向左读, 为 01 。因此它不是一个回文数。\n\n\n进阶:\n\n你能不将整数转为字符串来解决这个问题吗？\n\n# 通过代码\nclass Solution {\n    public boolean isPalindrome(int x) {\n        if (x<0){\n            return false;\n        }\n        String str = x + "";\n        int len = str.length();\n        int i;\n        for (i = 0; i < len / 2; i++) {\n            if (str.charAt(i) != str.charAt(len - i-1)) {\n                break;\n            }\n        }\n        if (i==(len/2)){\n            return true;\n        }else {\n            return false;\n        }\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n# 官方题解\n# 方法：反转一半数字\n思路\n\n映入脑海的第一个想法是将数字转换为字符串，并检查字符串是否为回文。但是，这需要额外的非常量空间来创建问题描述中所不允许的字符串。\n\n第二个想法是将数字本身反转，然后将反转后的数字与原始数字进行比较，如果它们是相同的，那么这个数字就是回文。 但是，如果反转后的数字大于 int.MAX\\text{int.MAX}int.MAX，我们将遇到整数溢出问题。\n\n按照第二个想法，为了避免数字反转可能导致的溢出问题，为什么不考虑只反转 int\\text{int}int 数字的一半？毕竟，如果该数字是回文，其后半部分反转后应该与原始数字的前半部分相同。\n\n例如，输入 1221，我们可以将数字 “1221” 的后半部分从 “21” 反转为 “12”，并将其与前半部分 “12” 进行比较，因为二者相同，我们得知数字 1221 是回文。\n\n让我们看看如何将这个想法转化为一个算法。\n\n算法\n\n首先，我们应该处理一些临界情况。所有负数都不可能是回文，例如：-123 不是回文，因为 - 不等于 3。所以我们可以对所有负数返回 false。\n\n现在，让我们来考虑如何反转后半部分的数字。 对于数字 1221，如果执行 1221 % 10，我们将得到最后一位数字 1，要得到倒数第二位数字，我们可以先通过除以 10 把最后一位数字从 1221 中移除，1221 / 10 = 122，再求出上一步结果除以 10 的余数，122 % 10 = 2，就可以得到倒数第二位数字。如果我们把最后一位数字乘以 10，再加上倒数第二位数字，1 * 10 + 2 = 12，就得到了我们想要的反转后的数字。如果继续这个过程，我们将得到更多位数的反转数字。\n\n现在的问题是，我们如何知道反转数字的位数已经达到原始数字位数的一半？\n\n我们将原始数字除以 10，然后给反转后的数字乘上 10，所以，当原始数字小于反转后的数字时，就意味着我们已经处理了一半位数的数字。\n\npublic class Solution {\n    public bool IsPalindrome(int x) {\n        // 特殊情况：\n        // 如上所述，当 x < 0 时，x 不是回文数。\n        // 同样地，如果数字的最后一位是 0，为了使该数字为回文，\n        // 则其第一位数字也应该是 0\n        // 只有 0 满足这一属性\n        if(x < 0 || (x % 10 == 0 && x != 0)) {\n            return false;\n        }\n\n        int revertedNumber = 0;\n        while(x > revertedNumber) {\n            revertedNumber = revertedNumber * 10 + x % 10;\n            x /= 10;\n        }\n\n        // 当数字长度为奇数时，我们可以通过 revertedNumber/10 去除处于中位的数字。\n        // 例如，当输入为 12321 时，在 while 循环的末尾我们可以得到 x = 12，revertedNumber = 123，\n        // 由于处于中位的数字不影响回文（它总是与自己相等），所以我们可以简单地将其去除。\n        return x == revertedNumber || x == revertedNumber/10;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n复杂度分析\n\n * 时间复杂度：O(log⁡10(n))O(\\log_{10}(n))O(log10​(n))，对于每次迭代，我们会将输入除以10，因此时间复杂度为 O(log⁡10(n))O(\\log_{10}(n))O(log10​(n))。\n * 空间复杂度：O(1)O(1)O(1)。\n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2017-11-16 00:06:02Accepted [https://leetcode-cn.com//submissions/detail/1149029/]216 ms5.53%N/Ajava2017-11-16 00:01:42Wrong Answer [https://leetcode-cn.com//submissions/detail/1149023/]N/AN/AN/Ajava2017-11-15 23:54:09Wrong Answer [https://leetcode-cn.com//submissions/detail/1149022/]N/AN/AN/Ajava# 统计信息\n通过次数提交次数AC比率23369441040256.9%# 相似题目\n题目难度回文链表 [https://leetcode-cn.com/problems/palindrome-linked-list/]简单',contentLowercase:'# 中文题目\n判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。\n\n示例 1:\n\n输入: 121\n输出: true\n\n\n示例 2:\n\n输入: -121\n输出: false\n解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。\n\n\n示例 3:\n\n输入: 10\n输出: false\n解释: 从右向左读, 为 01 。因此它不是一个回文数。\n\n\n进阶:\n\n你能不将整数转为字符串来解决这个问题吗？\n\n# 通过代码\nclass solution {\n    public boolean ispalindrome(int x) {\n        if (x<0){\n            return false;\n        }\n        string str = x + "";\n        int len = str.length();\n        int i;\n        for (i = 0; i < len / 2; i++) {\n            if (str.charat(i) != str.charat(len - i-1)) {\n                break;\n            }\n        }\n        if (i==(len/2)){\n            return true;\n        }else {\n            return false;\n        }\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n# 官方题解\n# 方法：反转一半数字\n思路\n\n映入脑海的第一个想法是将数字转换为字符串，并检查字符串是否为回文。但是，这需要额外的非常量空间来创建问题描述中所不允许的字符串。\n\n第二个想法是将数字本身反转，然后将反转后的数字与原始数字进行比较，如果它们是相同的，那么这个数字就是回文。 但是，如果反转后的数字大于 int.max\\text{int.max}int.max，我们将遇到整数溢出问题。\n\n按照第二个想法，为了避免数字反转可能导致的溢出问题，为什么不考虑只反转 int\\text{int}int 数字的一半？毕竟，如果该数字是回文，其后半部分反转后应该与原始数字的前半部分相同。\n\n例如，输入 1221，我们可以将数字 “1221” 的后半部分从 “21” 反转为 “12”，并将其与前半部分 “12” 进行比较，因为二者相同，我们得知数字 1221 是回文。\n\n让我们看看如何将这个想法转化为一个算法。\n\n算法\n\n首先，我们应该处理一些临界情况。所有负数都不可能是回文，例如：-123 不是回文，因为 - 不等于 3。所以我们可以对所有负数返回 false。\n\n现在，让我们来考虑如何反转后半部分的数字。 对于数字 1221，如果执行 1221 % 10，我们将得到最后一位数字 1，要得到倒数第二位数字，我们可以先通过除以 10 把最后一位数字从 1221 中移除，1221 / 10 = 122，再求出上一步结果除以 10 的余数，122 % 10 = 2，就可以得到倒数第二位数字。如果我们把最后一位数字乘以 10，再加上倒数第二位数字，1 * 10 + 2 = 12，就得到了我们想要的反转后的数字。如果继续这个过程，我们将得到更多位数的反转数字。\n\n现在的问题是，我们如何知道反转数字的位数已经达到原始数字位数的一半？\n\n我们将原始数字除以 10，然后给反转后的数字乘上 10，所以，当原始数字小于反转后的数字时，就意味着我们已经处理了一半位数的数字。\n\npublic class solution {\n    public bool ispalindrome(int x) {\n        // 特殊情况：\n        // 如上所述，当 x < 0 时，x 不是回文数。\n        // 同样地，如果数字的最后一位是 0，为了使该数字为回文，\n        // 则其第一位数字也应该是 0\n        // 只有 0 满足这一属性\n        if(x < 0 || (x % 10 == 0 && x != 0)) {\n            return false;\n        }\n\n        int revertednumber = 0;\n        while(x > revertednumber) {\n            revertednumber = revertednumber * 10 + x % 10;\n            x /= 10;\n        }\n\n        // 当数字长度为奇数时，我们可以通过 revertednumber/10 去除处于中位的数字。\n        // 例如，当输入为 12321 时，在 while 循环的末尾我们可以得到 x = 12，revertednumber = 123，\n        // 由于处于中位的数字不影响回文（它总是与自己相等），所以我们可以简单地将其去除。\n        return x == revertednumber || x == revertednumber/10;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n复杂度分析\n\n * 时间复杂度：o(log⁡10(n))o(\\log_{10}(n))o(log10​(n))，对于每次迭代，我们会将输入除以10，因此时间复杂度为 o(log⁡10(n))o(\\log_{10}(n))o(log10​(n))。\n * 空间复杂度：o(1)o(1)o(1)。\n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2017-11-16 00:06:02accepted [https://leetcode-cn.com//submissions/detail/1149029/]216 ms5.53%n/ajava2017-11-16 00:01:42wrong answer [https://leetcode-cn.com//submissions/detail/1149023/]n/an/an/ajava2017-11-15 23:54:09wrong answer [https://leetcode-cn.com//submissions/detail/1149022/]n/an/an/ajava# 统计信息\n通过次数提交次数ac比率23369441040256.9%# 相似题目\n题目难度回文链表 [https://leetcode-cn.com/problems/palindrome-linked-list/]简单'},{title:"14-最长公共前缀(Longest Common Prefix)",frontmatter:{title:"14-最长公共前缀(Longest Common Prefix)",date:"2018-04-26T00:00:00.000Z",categories:["简单"],tags:["字符串<String>"]},regularPath:"/views/%E7%AE%80%E5%8D%95/0014-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80.html",relativePath:"views/简单/0014-最长公共前缀.md",key:"v-d999d50a",path:"/views/%E7%AE%80%E5%8D%95/0014-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80.html",headers:[{level:2,title:"中文题目",slug:"中文题目",charIndex:2},{level:2,title:"通过代码",slug:"通过代码",charIndex:185},{level:2,title:"官方题解",slug:"官方题解",charIndex:2554},{level:2,title:"提交历史",slug:"提交历史",charIndex:10978},{level:2,title:"统计信息",slug:"统计信息",charIndex:11901}],lastUpdated:"4/11/2021, 1:15:21 PM",headersStr:"中文题目 通过代码 官方题解 提交历史 统计信息",content:'# 中文题目\n编写一个函数来查找字符串数组中的最长公共前缀。\n\n如果不存在公共前缀，返回空字符串""。\n\n示例 1:\n\n输入: ["flower","flow","flight"]\n输出: "fl"\n\n\n示例 2:\n\n输入: ["dog","racecar","car"]\n输出: ""\n解释: 输入不存在公共前缀。\n\n\n说明:\n\n所有输入只包含小写字母a-z。\n\n# 通过代码\nclass Solution {\n    public String longestCommonPrefix(String[] strs) {\n         if (null==strs || strs.length<1){\n                return "";\n            }\n            if (strs.length==1){\n                return strs[0];\n            }\n            String string=strs[0];\n            int i=1;\n            while (i<strs.length){\n\n                while (strs[i].indexOf(string)!=0){\n                    string=string.substring(0,string.length()-1);\n                }\n                i++;\n            }\n            return string;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\nclass Solution {\n    public String longestCommonPrefix(String[] strs) {\n         if (strs.length==0){\n                return "";\n            }\n            StringBuilder stringBuilder=new StringBuilder();\n            boolean flag=true;\n            for (int i = 0; i < strs[0].length(); i++) {\n                stringBuilder.append(strs[0].charAt(i));\n                for (int j = 1; j <strs.length; j++) {\n                    if (strs[j].length()<=i ||strs[j].charAt(i)!=stringBuilder.charAt(i)){\n                        flag=false;\n                    }\n                }\n                if (!flag) break;\n            }\n            if (stringBuilder.length()>=1 && !flag)\n                return stringBuilder.deleteCharAt(stringBuilder.length()-1).toString();\n            else\n                return stringBuilder.toString();\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\nclass Solution {\n    public String longestCommonPrefix(String[] strs) {\n         if (strs.length==0){\n                return "";\n            }\n            StringBuilder stringBuilder=new StringBuilder();\n            boolean flag=true;\n            for (int i = 0; i < strs[0].length(); i++) {\n                stringBuilder.append(strs[0].charAt(i));\n                for (int j = 1; j <strs.length; j++) {\n                    if (strs[j].length()<=i ||strs[j].charAt(i)!=stringBuilder.charAt(i)){\n                        flag=false;\n                    }\n                }\n                if (!flag) break;\n            }\n            if (stringBuilder.length()>=1 && !flag)\n                return stringBuilder.deleteCharAt(stringBuilder.length()-1).toString();\n            else\n                return stringBuilder.toString();\n\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n# 官方题解\n# 方法一：水平扫描法\n思路\n\n首先，我们将描述一种查找一组字符串的最长公共前缀 LCP(S1…Sn)LCP(S_1 \\ldots S_n)LCP(S1​…Sn​) 的简单方法。 我们将会用到这样的结论：\n\nLCP(S1…Sn)=LCP(LCP(LCP(S1,S2),S3),…Sn)LCP(S_1 \\ldots S_n) = LCP(LCP(LCP(S_1, S_2),S_3),\\ldots S_n)LCP(S1​…Sn​)=LCP(LCP(LCP(S1​,S2​),S3​),…Sn​)\n\n算法\n\n为了运用这种思想，算法要依次遍历字符串 [S1…Sn][S_1 \\ldots S_n][S1​…Sn​]，当遍历到第 iii 个字符串的时候，找到最长公共前缀 LCP(S1…Si)LCP(S_1 \\ldots S_i)LCP(S1​…Si​)。当 LCP(S1…Si)LCP(S_1 \\ldots S_i)LCP(S1​…Si​) 是一个空串的时候，算法就结束了。 否则，在执行了 nnn 次遍历之后，算法就会返回最终答案 LCP(S1…Sn)LCP(S_1 \\ldots S_n)LCP(S1​…Sn​)。\n\n{:width="240px"} {:align="center"}\n\n图 1. 查找最长公共前缀 （水平扫描法）{:align="center"}\n\npublic String longestCommonPrefix(String[] strs) {\n   if (strs.length == 0) return "";\n   String prefix = strs[0];\n   for (int i = 1; i < strs.length; i++)\n       while (strs[i].indexOf(prefix) != 0) {\n           prefix = prefix.substring(0, prefix.length() - 1);\n           if (prefix.isEmpty()) return "";\n       }        \n   return prefix;\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n复杂度分析\n\n * 时间复杂度：O(S)O(S)O(S)，S 是所有字符串中字符数量的总和。\n   \n   最坏的情况下，nnn 个字符串都是相同的。算法会将 S1S1S1 与其他字符串 [S2…Sn][S_2 \\ldots S_n][S2​…Sn​] 都做一次比较。这样就会进行 SSS 次字符比较，其中 SSS 是输入数据中所有字符数量。\n   \n   \n * 空间复杂度：O(1)O(1)O(1)，我们只需要使用常数级别的额外空间。\n   \n   \n\n\n\n\n# 算法二：水平扫描\n算法\n\n想象数组的末尾有一个非常短的字符串，使用上述方法依旧会进行 S​S​S​ 次比较。优化这类情况的一种方法就是水平扫描。我们从前往后枚举字符串的每一列，先比较每个字符串相同列上的字符（即不同字符串相同下标的字符）然后再进行对下一列的比较。\n\npublic String longestCommonPrefix(String[] strs) {\n    if (strs == null || strs.length == 0) return "";\n    for (int i = 0; i < strs[0].length() ; i++){\n        char c = strs[0].charAt(i);\n        for (int j = 1; j < strs.length; j ++) {\n            if (i == strs[j].length() || strs[j].charAt(i) != c)\n                return strs[0].substring(0, i);             \n        }\n    }\n    return strs[0];\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n复杂度分析\n\n * 时间复杂度：O(S)O(S)O(S)，S 是所有字符串中字符数量的总和。\n   \n   最坏情况下，输入数据为 nnn 个长度为 mmm 的相同字符串，算法会进行 S=m∗nS = m*nS=m∗n 次比较。可以看到最坏情况下，本算法的效率与算法一相同，但是最好的情况下，算法只需要进行 n∗minLenn*minLenn∗minLen 次比较，其中 minLenminLenminLen 是数组中最短字符串的长度。\n   \n   \n * 空间复杂度：O(1)O(1)O(1)，我们只需要使用常数级别的额外空间。\n   \n   \n\n\n\n\n# 算法三：分治\n思路\n\n这个算法的思路来自于LCP操作的结合律。 我们可以发现：LCP(S1…Sn)=LCP(LCP(S1…Sk),LCP(Sk+1…Sn))LCP(S_1 \\ldots S_n) = LCP(LCP(S_1 \\ldots S_k), LCP (S_{k+1} \\ldots S_n))LCP(S1​…Sn​)=LCP(LCP(S1​…Sk​),LCP(Sk+1​…Sn​))，其中 LCP(S1…Sn)LCP(S_1 \\ldots S_n)LCP(S1​…Sn​) 是字符串 [S1…Sn][S_1 \\ldots S_n][S1​…Sn​] 的最长公共前缀，1<k<n1 < k < n1<k<n。\n\n算法\n\n为了应用上述的结论，我们使用分治的技巧，将原问题 LCP(Si⋯Sj)LCP(S_i\\cdots S_j)LCP(Si​⋯Sj​) 分成两个子问题 LCP(Si⋯Smid)LCP(S_i\\cdots S_{mid})LCP(Si​⋯Smid​) 与 LCP(Smid+1,Sj)LCP(S_{mid+1}, S_j)LCP(Smid+1​,Sj​) ，其中 mid = i+j2\\frac{i+j}{2}2i+j​。 我们用子问题的解 lcpLeft 与 lcpRight 构造原问题的解 LCP(Si⋯Sj)LCP(S_i \\cdots S_j)LCP(Si​⋯Sj​)。 从头到尾挨个比较 lcpLeft 与 lcpRight 中的字符，直到不能再匹配为止。 计算所得的 lcpLeft 与 lcpRight 最长公共前缀就是原问题的解 LCP(Si⋯Sj)LCP(S_i\\cdots S_j)LCP(Si​⋯Sj​)。\n\n{:width="300px"} {:align="center"}\n\n图 2. 查找最长公共前缀的分治方法{:align="center"}\n\npublic String longestCommonPrefix(String[] strs) {\n    if (strs == null || strs.length == 0) return "";    \n        return longestCommonPrefix(strs, 0 , strs.length - 1);\n}\n\nprivate String longestCommonPrefix(String[] strs, int l, int r) {\n    if (l == r) {\n        return strs[l];\n    }\n    else {\n        int mid = (l + r)/2;\n        String lcpLeft =   longestCommonPrefix(strs, l , mid);\n        String lcpRight =  longestCommonPrefix(strs, mid + 1,r);\n        return commonPrefix(lcpLeft, lcpRight);\n   }\n}\n\nString commonPrefix(String left,String right) {\n    int min = Math.min(left.length(), right.length());       \n    for (int i = 0; i < min; i++) {\n        if ( left.charAt(i) != right.charAt(i) )\n            return left.substring(0, i);\n    }\n    return left.substring(0, min);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n复杂度分析\n\n最坏情况下，我们有 nnn 个长度为 mmm 的相同字符串。\n\n * 时间复杂度：O(S)O(S)O(S)，SSS 是所有字符串中字符数量的总和，S=m∗nS=m*nS=m∗n。\n   \n   时间复杂度的递推式为 T(n)=2⋅T(n2)+O(m)T(n)=2\\cdot T(\\frac{n}{2})+O(m)T(n)=2⋅T(2n​)+O(m)， 化简后可知其就是 O(S)O(S)O(S)。最好情况下，算法会进行 minLen⋅nminLen\\cdot nminLen⋅n 次比较，其中 minLenminLenminLen 是数组中最短字符串的长度。\n   \n   \n * 空间复杂度：O(m⋅log(n))O(m \\cdot log(n))O(m⋅log(n))\n   \n   内存开支主要是递归过程中使用的栈空间所消耗的。 一共会进行 log(n)log(n)log(n) 次递归，每次需要 mmm 的空间存储返回结果，所以空间复杂度为 O(m⋅log(n))O(m\\cdot log(n))O(m⋅log(n))。\n   \n   \n\n\n\n\n# 方法四：二分查找法\n这个想法是应用二分查找法找到所有字符串的公共前缀的最大长度 L。 算法的查找区间是 (0…minLen)(0 \\ldots minLen)(0…minLen)，其中 minLen 是输入数据中最短的字符串的长度，同时也是答案的最长可能长度。 每一次将查找区间一分为二，然后丢弃一定不包含最终答案的那一个。算法进行的过程中一共会出现两种可能情况：\n\n * S[1...mid] 不是所有串的公共前缀。 这表明对于所有的 j > i S[1..j] 也不是公共前缀，于是我们就可以丢弃后半个查找区间。\n   \n   \n * S[1...mid] 是所有串的公共前缀。 这表示对于所有的 i < j S[1..i] 都是可行的公共前缀，因为我们要找最长的公共前缀，所以我们可以把前半个查找区间丢弃。\n   \n   \n\n{:width="340px"} {:align="center"}\n\n图 3. 使用二分查找法寻找最长公共前缀{:align="center"}\n\npublic String longestCommonPrefix(String[] strs) {\n    if (strs == null || strs.length == 0)\n        return "";\n    int minLen = Integer.MAX_VALUE;\n    for (String str : strs)\n        minLen = Math.min(minLen, str.length());\n    int low = 1;\n    int high = minLen;\n    while (low <= high) {\n        int middle = (low + high) / 2;\n        if (isCommonPrefix(strs, middle))\n            low = middle + 1;\n        else\n            high = middle - 1;\n    }\n    return strs[0].substring(0, (low + high) / 2);\n}\n\nprivate boolean isCommonPrefix(String[] strs, int len){\n    String str1 = strs[0].substring(0,len);\n    for (int i = 1; i < strs.length; i++)\n        if (!strs[i].startsWith(str1))\n            return false;\n    return true;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n复杂度分析\n\n最坏情况下，我们有 nnn 个长度为 mmm 的相同字符串。\n\n * 时间复杂度：O(S⋅log(n))O(S \\cdot log(n))O(S⋅log(n))，其中 SSS 所有字符串中字符数量的总和。\n   \n   算法一共会进行 log(n)log(n)log(n) 次迭代，每次一都会进行 S=m∗nS = m*nS=m∗n 次比较，所以总时间复杂度为 O(S⋅log(n))O(S \\cdot log(n))O(S⋅log(n))。\n   \n   \n * 空间复杂度：O(1)O(1)O(1)，我们只需要使用常数级别的额外空间。\n   \n   \n\n\n\n\n# 更进一步\n让我们看一个有些不同的问题：\n\n> 给定一些键值字符串 S = [S1,S2…Sn][S_1,S_2 \\ldots S_n][S1​,S2​…Sn​]，我们要找到字符串 q 与 S 的最长公共前缀。 这样的查询操作可能会非常频繁。\n\n\n我们可以通过将所有的键值 S 存储到一颗字典树中来优化最长公共前缀查询操作。 如果你想学习更多关于字典树的内容，可以从 208. 实现 Trie (前缀树) [https://leetcode-cn.com/problems/implement-trie-prefix-tree/solution/] 开始。在字典树中，从根向下的每一个节点都代表一些键值的公共前缀。 但是我们需要找到字符串q 和所有键值字符串的最长公共前缀。 这意味着我们需要从根找到一条最深的路径，满足以下条件：\n\n * 这是所查询的字符串 q 的一个前缀\n   \n   \n * 路径上的每一个节点都有且仅有一个孩子。 否则，找到的路径就不是所有字符串的公共前缀\n   \n   \n * 路径不包含被标记成某一个键值字符串结尾的节点。 因为最长公共前缀不可能比某个字符串本身长\n   \n   \n\n算法\n\n最后的问题就是如何找到字典树中满足上述所有要求的最深节点。 最有效的方法就是建立一颗包含字符串 [S1…Sn][S_1 \\ldots S_n][S1​…Sn​] 的字典树。 然后在这颗树中匹配 q 的前缀。 我们从根节点遍历这颗字典树，直到因为不能满足某个条件而不能再遍历为止。\n\n{:width="300px"} {:align="center"}\n\n图 4. 使用字典树查找最长公共前缀{:align="center"}\n\npublic String longestCommonPrefix(String q, String[] strs) {\n    if (strs == null || strs.length == 0)\n         return "";  \n    if (strs.length == 1)\n         return strs[0];\n    Trie trie = new Trie();      \n    for (int i = 1; i < strs.length ; i++) {\n        trie.insert(strs[i]);\n    }\n    return trie.searchLongestPrefix(q);\n}\n\nclass TrieNode {\n\n    // 子节点的链接数组\n    private TrieNode[] links;\n\n    private final int R = 26;\n\n    private boolean isEnd;\n\n    // 非空子节点的数量\n    private int size;    \n    public void put(char ch, TrieNode node) {\n        links[ch -\'a\'] = node;\n        size++;\n    }\n\n    public int getLinks() {\n        return size;\n    }\n    // 假设方法 containsKey、isEnd、get、put 都已经实现了\n    // 可以参考文章：https://leetcode.com/articles/implement-trie-prefix-tree/\n}\n\npublic class Trie {\n\n    private TrieNode root;\n\n    public Trie() {\n        root = new TrieNode();\n    }\n\n// 假设方法 insert、search、searchPrefix 都已经实现了\n// 可以参考文章：https://leetcode.com/articles/implement-trie-prefix-tree/\n    private String searchLongestPrefix(String word) {\n        TrieNode node = root;\n        StringBuilder prefix = new StringBuilder();\n        for (int i = 0; i < word.length(); i++) {\n            char curLetter = word.charAt(i);\n            if (node.containsKey(curLetter) && (node.getLinks() == 1) && (!node.isEnd())) {\n                prefix.append(curLetter);\n                node = node.get(curLetter);\n            }\n            else\n                return prefix.toString();\n\n         }\n         return prefix.toString();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n复杂度分析\n\n最坏情况下查询字符串 qqq 的长度为 mmm 并且它与数组中 nnn 个字符串均相同。\n\n * 时间复杂度：预处理过程 O(S)O(S)O(S)，其中 SSS 数组里所有字符串中字符数量的总和，最长公共前缀查询操作的复杂度为 O(m)O(m)O(m)。\n   \n   建立字典树的时间复杂度为 O(S)O(S)O(S)。在字典树中查找字符串 qqq 的最长公共前缀在最坏情况下需要 O(m)O(m)O(m) 的时间。\n   \n   \n * 空间复杂度：O(S)O(S)O(S)，我们只需要使用额外的 SSS 空间建立字典树。\n   \n   \n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-04-26 00:11:20Accepted [https://leetcode-cn.com//submissions/detail/1698170/]8 ms5.14%N/Ajava2018-04-26 00:09:35Accepted [https://leetcode-cn.com//submissions/detail/1698125/]15 ms5.14%N/Ajava2018-04-26 00:00:20Accepted [https://leetcode-cn.com//submissions/detail/1697932/]15 ms5.14%N/Ajava2018-04-25 23:59:00Wrong Answer [https://leetcode-cn.com//submissions/detail/1697888/]N/AN/AN/Ajava2018-04-25 23:58:33Wrong Answer [https://leetcode-cn.com//submissions/detail/1697874/]N/AN/AN/Ajava2018-04-25 23:55:00Runtime Error [https://leetcode-cn.com//submissions/detail/1697743/]N/AN/AN/Ajava2018-04-25 23:52:36Runtime Error [https://leetcode-cn.com//submissions/detail/1697674/]N/AN/AN/Ajava2018-04-25 23:50:57Runtime Error [https://leetcode-cn.com//submissions/detail/1697630/]N/AN/AN/Ajava2018-04-25 23:49:14Runtime Error [https://leetcode-cn.com//submissions/detail/1697609/]N/AN/AN/Ajava# 统计信息\n通过次数提交次数AC比率17421048616135.8%',contentLowercase:'# 中文题目\n编写一个函数来查找字符串数组中的最长公共前缀。\n\n如果不存在公共前缀，返回空字符串""。\n\n示例 1:\n\n输入: ["flower","flow","flight"]\n输出: "fl"\n\n\n示例 2:\n\n输入: ["dog","racecar","car"]\n输出: ""\n解释: 输入不存在公共前缀。\n\n\n说明:\n\n所有输入只包含小写字母a-z。\n\n# 通过代码\nclass solution {\n    public string longestcommonprefix(string[] strs) {\n         if (null==strs || strs.length<1){\n                return "";\n            }\n            if (strs.length==1){\n                return strs[0];\n            }\n            string string=strs[0];\n            int i=1;\n            while (i<strs.length){\n\n                while (strs[i].indexof(string)!=0){\n                    string=string.substring(0,string.length()-1);\n                }\n                i++;\n            }\n            return string;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\nclass solution {\n    public string longestcommonprefix(string[] strs) {\n         if (strs.length==0){\n                return "";\n            }\n            stringbuilder stringbuilder=new stringbuilder();\n            boolean flag=true;\n            for (int i = 0; i < strs[0].length(); i++) {\n                stringbuilder.append(strs[0].charat(i));\n                for (int j = 1; j <strs.length; j++) {\n                    if (strs[j].length()<=i ||strs[j].charat(i)!=stringbuilder.charat(i)){\n                        flag=false;\n                    }\n                }\n                if (!flag) break;\n            }\n            if (stringbuilder.length()>=1 && !flag)\n                return stringbuilder.deletecharat(stringbuilder.length()-1).tostring();\n            else\n                return stringbuilder.tostring();\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\nclass solution {\n    public string longestcommonprefix(string[] strs) {\n         if (strs.length==0){\n                return "";\n            }\n            stringbuilder stringbuilder=new stringbuilder();\n            boolean flag=true;\n            for (int i = 0; i < strs[0].length(); i++) {\n                stringbuilder.append(strs[0].charat(i));\n                for (int j = 1; j <strs.length; j++) {\n                    if (strs[j].length()<=i ||strs[j].charat(i)!=stringbuilder.charat(i)){\n                        flag=false;\n                    }\n                }\n                if (!flag) break;\n            }\n            if (stringbuilder.length()>=1 && !flag)\n                return stringbuilder.deletecharat(stringbuilder.length()-1).tostring();\n            else\n                return stringbuilder.tostring();\n\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n# 官方题解\n# 方法一：水平扫描法\n思路\n\n首先，我们将描述一种查找一组字符串的最长公共前缀 lcp(s1…sn)lcp(s_1 \\ldots s_n)lcp(s1​…sn​) 的简单方法。 我们将会用到这样的结论：\n\nlcp(s1…sn)=lcp(lcp(lcp(s1,s2),s3),…sn)lcp(s_1 \\ldots s_n) = lcp(lcp(lcp(s_1, s_2),s_3),\\ldots s_n)lcp(s1​…sn​)=lcp(lcp(lcp(s1​,s2​),s3​),…sn​)\n\n算法\n\n为了运用这种思想，算法要依次遍历字符串 [s1…sn][s_1 \\ldots s_n][s1​…sn​]，当遍历到第 iii 个字符串的时候，找到最长公共前缀 lcp(s1…si)lcp(s_1 \\ldots s_i)lcp(s1​…si​)。当 lcp(s1…si)lcp(s_1 \\ldots s_i)lcp(s1​…si​) 是一个空串的时候，算法就结束了。 否则，在执行了 nnn 次遍历之后，算法就会返回最终答案 lcp(s1…sn)lcp(s_1 \\ldots s_n)lcp(s1​…sn​)。\n\n{:width="240px"} {:align="center"}\n\n图 1. 查找最长公共前缀 （水平扫描法）{:align="center"}\n\npublic string longestcommonprefix(string[] strs) {\n   if (strs.length == 0) return "";\n   string prefix = strs[0];\n   for (int i = 1; i < strs.length; i++)\n       while (strs[i].indexof(prefix) != 0) {\n           prefix = prefix.substring(0, prefix.length() - 1);\n           if (prefix.isempty()) return "";\n       }        \n   return prefix;\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n复杂度分析\n\n * 时间复杂度：o(s)o(s)o(s)，s 是所有字符串中字符数量的总和。\n   \n   最坏的情况下，nnn 个字符串都是相同的。算法会将 s1s1s1 与其他字符串 [s2…sn][s_2 \\ldots s_n][s2​…sn​] 都做一次比较。这样就会进行 sss 次字符比较，其中 sss 是输入数据中所有字符数量。\n   \n   \n * 空间复杂度：o(1)o(1)o(1)，我们只需要使用常数级别的额外空间。\n   \n   \n\n\n\n\n# 算法二：水平扫描\n算法\n\n想象数组的末尾有一个非常短的字符串，使用上述方法依旧会进行 s​s​s​ 次比较。优化这类情况的一种方法就是水平扫描。我们从前往后枚举字符串的每一列，先比较每个字符串相同列上的字符（即不同字符串相同下标的字符）然后再进行对下一列的比较。\n\npublic string longestcommonprefix(string[] strs) {\n    if (strs == null || strs.length == 0) return "";\n    for (int i = 0; i < strs[0].length() ; i++){\n        char c = strs[0].charat(i);\n        for (int j = 1; j < strs.length; j ++) {\n            if (i == strs[j].length() || strs[j].charat(i) != c)\n                return strs[0].substring(0, i);             \n        }\n    }\n    return strs[0];\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n复杂度分析\n\n * 时间复杂度：o(s)o(s)o(s)，s 是所有字符串中字符数量的总和。\n   \n   最坏情况下，输入数据为 nnn 个长度为 mmm 的相同字符串，算法会进行 s=m∗ns = m*ns=m∗n 次比较。可以看到最坏情况下，本算法的效率与算法一相同，但是最好的情况下，算法只需要进行 n∗minlenn*minlenn∗minlen 次比较，其中 minlenminlenminlen 是数组中最短字符串的长度。\n   \n   \n * 空间复杂度：o(1)o(1)o(1)，我们只需要使用常数级别的额外空间。\n   \n   \n\n\n\n\n# 算法三：分治\n思路\n\n这个算法的思路来自于lcp操作的结合律。 我们可以发现：lcp(s1…sn)=lcp(lcp(s1…sk),lcp(sk+1…sn))lcp(s_1 \\ldots s_n) = lcp(lcp(s_1 \\ldots s_k), lcp (s_{k+1} \\ldots s_n))lcp(s1​…sn​)=lcp(lcp(s1​…sk​),lcp(sk+1​…sn​))，其中 lcp(s1…sn)lcp(s_1 \\ldots s_n)lcp(s1​…sn​) 是字符串 [s1…sn][s_1 \\ldots s_n][s1​…sn​] 的最长公共前缀，1<k<n1 < k < n1<k<n。\n\n算法\n\n为了应用上述的结论，我们使用分治的技巧，将原问题 lcp(si⋯sj)lcp(s_i\\cdots s_j)lcp(si​⋯sj​) 分成两个子问题 lcp(si⋯smid)lcp(s_i\\cdots s_{mid})lcp(si​⋯smid​) 与 lcp(smid+1,sj)lcp(s_{mid+1}, s_j)lcp(smid+1​,sj​) ，其中 mid = i+j2\\frac{i+j}{2}2i+j​。 我们用子问题的解 lcpleft 与 lcpright 构造原问题的解 lcp(si⋯sj)lcp(s_i \\cdots s_j)lcp(si​⋯sj​)。 从头到尾挨个比较 lcpleft 与 lcpright 中的字符，直到不能再匹配为止。 计算所得的 lcpleft 与 lcpright 最长公共前缀就是原问题的解 lcp(si⋯sj)lcp(s_i\\cdots s_j)lcp(si​⋯sj​)。\n\n{:width="300px"} {:align="center"}\n\n图 2. 查找最长公共前缀的分治方法{:align="center"}\n\npublic string longestcommonprefix(string[] strs) {\n    if (strs == null || strs.length == 0) return "";    \n        return longestcommonprefix(strs, 0 , strs.length - 1);\n}\n\nprivate string longestcommonprefix(string[] strs, int l, int r) {\n    if (l == r) {\n        return strs[l];\n    }\n    else {\n        int mid = (l + r)/2;\n        string lcpleft =   longestcommonprefix(strs, l , mid);\n        string lcpright =  longestcommonprefix(strs, mid + 1,r);\n        return commonprefix(lcpleft, lcpright);\n   }\n}\n\nstring commonprefix(string left,string right) {\n    int min = math.min(left.length(), right.length());       \n    for (int i = 0; i < min; i++) {\n        if ( left.charat(i) != right.charat(i) )\n            return left.substring(0, i);\n    }\n    return left.substring(0, min);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n复杂度分析\n\n最坏情况下，我们有 nnn 个长度为 mmm 的相同字符串。\n\n * 时间复杂度：o(s)o(s)o(s)，sss 是所有字符串中字符数量的总和，s=m∗ns=m*ns=m∗n。\n   \n   时间复杂度的递推式为 t(n)=2⋅t(n2)+o(m)t(n)=2\\cdot t(\\frac{n}{2})+o(m)t(n)=2⋅t(2n​)+o(m)， 化简后可知其就是 o(s)o(s)o(s)。最好情况下，算法会进行 minlen⋅nminlen\\cdot nminlen⋅n 次比较，其中 minlenminlenminlen 是数组中最短字符串的长度。\n   \n   \n * 空间复杂度：o(m⋅log(n))o(m \\cdot log(n))o(m⋅log(n))\n   \n   内存开支主要是递归过程中使用的栈空间所消耗的。 一共会进行 log(n)log(n)log(n) 次递归，每次需要 mmm 的空间存储返回结果，所以空间复杂度为 o(m⋅log(n))o(m\\cdot log(n))o(m⋅log(n))。\n   \n   \n\n\n\n\n# 方法四：二分查找法\n这个想法是应用二分查找法找到所有字符串的公共前缀的最大长度 l。 算法的查找区间是 (0…minlen)(0 \\ldots minlen)(0…minlen)，其中 minlen 是输入数据中最短的字符串的长度，同时也是答案的最长可能长度。 每一次将查找区间一分为二，然后丢弃一定不包含最终答案的那一个。算法进行的过程中一共会出现两种可能情况：\n\n * s[1...mid] 不是所有串的公共前缀。 这表明对于所有的 j > i s[1..j] 也不是公共前缀，于是我们就可以丢弃后半个查找区间。\n   \n   \n * s[1...mid] 是所有串的公共前缀。 这表示对于所有的 i < j s[1..i] 都是可行的公共前缀，因为我们要找最长的公共前缀，所以我们可以把前半个查找区间丢弃。\n   \n   \n\n{:width="340px"} {:align="center"}\n\n图 3. 使用二分查找法寻找最长公共前缀{:align="center"}\n\npublic string longestcommonprefix(string[] strs) {\n    if (strs == null || strs.length == 0)\n        return "";\n    int minlen = integer.max_value;\n    for (string str : strs)\n        minlen = math.min(minlen, str.length());\n    int low = 1;\n    int high = minlen;\n    while (low <= high) {\n        int middle = (low + high) / 2;\n        if (iscommonprefix(strs, middle))\n            low = middle + 1;\n        else\n            high = middle - 1;\n    }\n    return strs[0].substring(0, (low + high) / 2);\n}\n\nprivate boolean iscommonprefix(string[] strs, int len){\n    string str1 = strs[0].substring(0,len);\n    for (int i = 1; i < strs.length; i++)\n        if (!strs[i].startswith(str1))\n            return false;\n    return true;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n复杂度分析\n\n最坏情况下，我们有 nnn 个长度为 mmm 的相同字符串。\n\n * 时间复杂度：o(s⋅log(n))o(s \\cdot log(n))o(s⋅log(n))，其中 sss 所有字符串中字符数量的总和。\n   \n   算法一共会进行 log(n)log(n)log(n) 次迭代，每次一都会进行 s=m∗ns = m*ns=m∗n 次比较，所以总时间复杂度为 o(s⋅log(n))o(s \\cdot log(n))o(s⋅log(n))。\n   \n   \n * 空间复杂度：o(1)o(1)o(1)，我们只需要使用常数级别的额外空间。\n   \n   \n\n\n\n\n# 更进一步\n让我们看一个有些不同的问题：\n\n> 给定一些键值字符串 s = [s1,s2…sn][s_1,s_2 \\ldots s_n][s1​,s2​…sn​]，我们要找到字符串 q 与 s 的最长公共前缀。 这样的查询操作可能会非常频繁。\n\n\n我们可以通过将所有的键值 s 存储到一颗字典树中来优化最长公共前缀查询操作。 如果你想学习更多关于字典树的内容，可以从 208. 实现 trie (前缀树) [https://leetcode-cn.com/problems/implement-trie-prefix-tree/solution/] 开始。在字典树中，从根向下的每一个节点都代表一些键值的公共前缀。 但是我们需要找到字符串q 和所有键值字符串的最长公共前缀。 这意味着我们需要从根找到一条最深的路径，满足以下条件：\n\n * 这是所查询的字符串 q 的一个前缀\n   \n   \n * 路径上的每一个节点都有且仅有一个孩子。 否则，找到的路径就不是所有字符串的公共前缀\n   \n   \n * 路径不包含被标记成某一个键值字符串结尾的节点。 因为最长公共前缀不可能比某个字符串本身长\n   \n   \n\n算法\n\n最后的问题就是如何找到字典树中满足上述所有要求的最深节点。 最有效的方法就是建立一颗包含字符串 [s1…sn][s_1 \\ldots s_n][s1​…sn​] 的字典树。 然后在这颗树中匹配 q 的前缀。 我们从根节点遍历这颗字典树，直到因为不能满足某个条件而不能再遍历为止。\n\n{:width="300px"} {:align="center"}\n\n图 4. 使用字典树查找最长公共前缀{:align="center"}\n\npublic string longestcommonprefix(string q, string[] strs) {\n    if (strs == null || strs.length == 0)\n         return "";  \n    if (strs.length == 1)\n         return strs[0];\n    trie trie = new trie();      \n    for (int i = 1; i < strs.length ; i++) {\n        trie.insert(strs[i]);\n    }\n    return trie.searchlongestprefix(q);\n}\n\nclass trienode {\n\n    // 子节点的链接数组\n    private trienode[] links;\n\n    private final int r = 26;\n\n    private boolean isend;\n\n    // 非空子节点的数量\n    private int size;    \n    public void put(char ch, trienode node) {\n        links[ch -\'a\'] = node;\n        size++;\n    }\n\n    public int getlinks() {\n        return size;\n    }\n    // 假设方法 containskey、isend、get、put 都已经实现了\n    // 可以参考文章：https://leetcode.com/articles/implement-trie-prefix-tree/\n}\n\npublic class trie {\n\n    private trienode root;\n\n    public trie() {\n        root = new trienode();\n    }\n\n// 假设方法 insert、search、searchprefix 都已经实现了\n// 可以参考文章：https://leetcode.com/articles/implement-trie-prefix-tree/\n    private string searchlongestprefix(string word) {\n        trienode node = root;\n        stringbuilder prefix = new stringbuilder();\n        for (int i = 0; i < word.length(); i++) {\n            char curletter = word.charat(i);\n            if (node.containskey(curletter) && (node.getlinks() == 1) && (!node.isend())) {\n                prefix.append(curletter);\n                node = node.get(curletter);\n            }\n            else\n                return prefix.tostring();\n\n         }\n         return prefix.tostring();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n复杂度分析\n\n最坏情况下查询字符串 qqq 的长度为 mmm 并且它与数组中 nnn 个字符串均相同。\n\n * 时间复杂度：预处理过程 o(s)o(s)o(s)，其中 sss 数组里所有字符串中字符数量的总和，最长公共前缀查询操作的复杂度为 o(m)o(m)o(m)。\n   \n   建立字典树的时间复杂度为 o(s)o(s)o(s)。在字典树中查找字符串 qqq 的最长公共前缀在最坏情况下需要 o(m)o(m)o(m) 的时间。\n   \n   \n * 空间复杂度：o(s)o(s)o(s)，我们只需要使用额外的 sss 空间建立字典树。\n   \n   \n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-04-26 00:11:20accepted [https://leetcode-cn.com//submissions/detail/1698170/]8 ms5.14%n/ajava2018-04-26 00:09:35accepted [https://leetcode-cn.com//submissions/detail/1698125/]15 ms5.14%n/ajava2018-04-26 00:00:20accepted [https://leetcode-cn.com//submissions/detail/1697932/]15 ms5.14%n/ajava2018-04-25 23:59:00wrong answer [https://leetcode-cn.com//submissions/detail/1697888/]n/an/an/ajava2018-04-25 23:58:33wrong answer [https://leetcode-cn.com//submissions/detail/1697874/]n/an/an/ajava2018-04-25 23:55:00runtime error [https://leetcode-cn.com//submissions/detail/1697743/]n/an/an/ajava2018-04-25 23:52:36runtime error [https://leetcode-cn.com//submissions/detail/1697674/]n/an/an/ajava2018-04-25 23:50:57runtime error [https://leetcode-cn.com//submissions/detail/1697630/]n/an/an/ajava2018-04-25 23:49:14runtime error [https://leetcode-cn.com//submissions/detail/1697609/]n/an/an/ajava# 统计信息\n通过次数提交次数ac比率17421048616135.8%'},{title:"13-罗马数字转整数(Roman to Integer)",frontmatter:{title:"13-罗马数字转整数(Roman to Integer)",date:"2017-11-16T00:00:00.000Z",categories:["简单"],tags:["数学<Math>","字符串<String>"]},regularPath:"/views/%E7%AE%80%E5%8D%95/0013-%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%95%B4%E6%95%B0.html",relativePath:"views/简单/0013-罗马数字转整数.md",key:"v-72c7019a",path:"/views/%E7%AE%80%E5%8D%95/0013-%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%95%B4%E6%95%B0.html",headers:[{level:2,title:"中文题目",slug:"中文题目",charIndex:2},{level:2,title:"通过代码",slug:"通过代码",charIndex:722},{level:2,title:"高赞题解",slug:"高赞题解",charIndex:1786},{level:3,title:"代码解读",slug:"代码解读",charIndex:1793},{level:3,title:"代码行数：解析",slug:"代码行数：解析",charIndex:2587},{level:3,title:"知识拓展",slug:"知识拓展",charIndex:2906},{level:2,title:"提交历史",slug:"提交历史",charIndex:3215},{level:2,title:"统计信息",slug:"统计信息",charIndex:3343},{level:2,title:"相似题目",slug:"相似题目",charIndex:3379}],lastUpdated:"4/11/2021, 1:15:21 PM",headersStr:"中文题目 通过代码 高赞题解 代码解读 代码行数：解析 知识拓展 提交历史 统计信息 相似题目",content:"# 中文题目\n罗马数字包含以下七种字符:I，V，X，L，C，D和M。\n\n字符          数值\nI             1\nV             5\nX             10\nL             50\nC             100\nD             500\nM             1000\n\n例如， 罗马数字 2 写做II，即为两个并列的 1。12 写做XII，即为X+II。 27 写做XXVII, 即为XX+V+II。\n\n通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做IIII，而是IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为IX。这个特殊的规则只适用于以下六种情况：\n\n * I可以放在V(5) 和X(10) 的左边，来表示 4 和 9。\n * X可以放在L(50) 和C(100) 的左边，来表示 40 和 90。\n * C可以放在D(500) 和M(1000) 的左边，来表示 400 和 900。\n\n给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。\n\n示例 1:\n\n输入: \"III\"\n输出: 3\n\n示例 2:\n\n输入: \"IV\"\n输出: 4\n\n示例 3:\n\n输入: \"IX\"\n输出: 9\n\n示例 4:\n\n输入: \"LVIII\"\n输出: 58\n解释: L = 50, V= 5, III = 3.\n\n\n示例 5:\n\n输入: \"MCMXCIV\"\n输出: 1994\n解释: M = 1000, CM = 900, XC = 90, IV = 4.\n\n# 通过代码\nclass Solution{\n    public int romanToInt(String s){\n        int res=0;\n        if (s==null || s.length()==0)\n            return res;\n        int len=s.length()-1;\n        for (int i=len;i>=0;i--){\n            char c=s.charAt(i);\n            switch (c){\n                case 'M':\n                    res+=1000;\n                    break;\n                case 'D':\n                    res+=500;\n                    break;\n                case 'C':\n                    res+=100*(res>=500?-1:1);\n                    break;\n                case 'L':\n                    res+=50;\n                    break;\n                case 'X':\n                    res+=10*(res>=50?-1:1);\n                    break;\n                case 'V':\n                    res+=5;\n                    break;\n                case 'I':\n                    res+=(res>=5?-1:1);\n                    break;\n                    default:break;\n            }\n        }\n        return res;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n# 高赞题解\n# 代码解读\nclass Solution:\n    def romanToInt(self, s: str) -> int:\n        d = {'I':1, 'IV':3, 'V':5, 'IX':8, 'X':10, 'XL':30, 'L':50, 'XC':80, 'C':100, 'CD':300, 'D':500, 'CM':800, 'M':1000}\n        return sum(d.get(s[max(i-1, 0):i+1], d[n]) for i, n in enumerate(s))\n\n\n1\n2\n3\n4\nclass Solution {\npublic:\n    int romanToInt(string s) {\n        unordered_map<string, int> m = {{\"I\", 1}, {\"IV\", 3}, {\"IX\", 8}, {\"V\", 5}, {\"X\", 10}, {\"XL\", 30}, {\"XC\", 80}, {\"L\", 50}, {\"C\", 100}, {\"CD\", 300}, {\"CM\", 800}, {\"D\", 500}, {\"M\", 1000}};\n        int r = m[s.substr(0, 1)];\n        for(int i=1; i<s.size(); ++i){\n            string two = s.substr(i-1, 2);\n            string one = s.substr(i, 1);\n            r += m[two] ? m[two] : m[one];\n        }\n        return r;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n# 代码行数：解析\n 1. 构建一个字典记录所有罗马数字子串，注意长度为2的子串记录的值是（实际值 - 子串内左边罗马数字代表的数值）\n    \n    \n 2. 这样一来，遍历整个 sss 的时候判断当前位置和前一个位置的两个字符组成的字符串是否在字典内，如果在就记录值，不在就说明当前位置不存在小数字在前面的情况，直接记录当前位置字符对应值\n    \n    \n\n举个例子，遍历经过 IVIVIV 的时候先记录 III 的对应值 111 再往前移动一步记录 IVIVIV 的值 333，加起来正好是 IVIVIV 的真实值 444。max 函数在这里是为了防止遍历第一个字符的时候出现 [−1:0][-1:0][−1:0] 的情况\n\n# 知识拓展\n{:width=\"320px\"} {:align=center}\n\n【🃏知识卡片】哈希表存储的是由键（key）和值（value）组 成的数据。例如，我们将每个人的性别作为数 据进行存储，键为人名，值为对应的性别。\n\n * Python 中我们使用字典 {key : value} 来初始化哈希表\n   \n   \n * 通过 key 查找 value 的时间复杂度为 O(1)O(1)O(1)\n   \n   \n * 这题题解中的 d 就是一个字典，其中 get(key, default) 函数可以通过 key 从 d 中找出对应的值，如果 key 不存在则返回默认值 default\n   \n   \n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2017-11-16 22:41:43Accepted [https://leetcode-cn.com//submissions/detail/1149033/]92 ms5.19%N/Ajava# 统计信息\n通过次数提交次数AC比率13820122912760.3%# 相似题目\n题目难度整数转罗马数字 [https://leetcode-cn.com/problems/integer-to-roman/]中等",contentLowercase:"# 中文题目\n罗马数字包含以下七种字符:i，v，x，l，c，d和m。\n\n字符          数值\ni             1\nv             5\nx             10\nl             50\nc             100\nd             500\nm             1000\n\n例如， 罗马数字 2 写做ii，即为两个并列的 1。12 写做xii，即为x+ii。 27 写做xxvii, 即为xx+v+ii。\n\n通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做iiii，而是iv。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为ix。这个特殊的规则只适用于以下六种情况：\n\n * i可以放在v(5) 和x(10) 的左边，来表示 4 和 9。\n * x可以放在l(50) 和c(100) 的左边，来表示 40 和 90。\n * c可以放在d(500) 和m(1000) 的左边，来表示 400 和 900。\n\n给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。\n\n示例 1:\n\n输入: \"iii\"\n输出: 3\n\n示例 2:\n\n输入: \"iv\"\n输出: 4\n\n示例 3:\n\n输入: \"ix\"\n输出: 9\n\n示例 4:\n\n输入: \"lviii\"\n输出: 58\n解释: l = 50, v= 5, iii = 3.\n\n\n示例 5:\n\n输入: \"mcmxciv\"\n输出: 1994\n解释: m = 1000, cm = 900, xc = 90, iv = 4.\n\n# 通过代码\nclass solution{\n    public int romantoint(string s){\n        int res=0;\n        if (s==null || s.length()==0)\n            return res;\n        int len=s.length()-1;\n        for (int i=len;i>=0;i--){\n            char c=s.charat(i);\n            switch (c){\n                case 'm':\n                    res+=1000;\n                    break;\n                case 'd':\n                    res+=500;\n                    break;\n                case 'c':\n                    res+=100*(res>=500?-1:1);\n                    break;\n                case 'l':\n                    res+=50;\n                    break;\n                case 'x':\n                    res+=10*(res>=50?-1:1);\n                    break;\n                case 'v':\n                    res+=5;\n                    break;\n                case 'i':\n                    res+=(res>=5?-1:1);\n                    break;\n                    default:break;\n            }\n        }\n        return res;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n# 高赞题解\n# 代码解读\nclass solution:\n    def romantoint(self, s: str) -> int:\n        d = {'i':1, 'iv':3, 'v':5, 'ix':8, 'x':10, 'xl':30, 'l':50, 'xc':80, 'c':100, 'cd':300, 'd':500, 'cm':800, 'm':1000}\n        return sum(d.get(s[max(i-1, 0):i+1], d[n]) for i, n in enumerate(s))\n\n\n1\n2\n3\n4\nclass solution {\npublic:\n    int romantoint(string s) {\n        unordered_map<string, int> m = {{\"i\", 1}, {\"iv\", 3}, {\"ix\", 8}, {\"v\", 5}, {\"x\", 10}, {\"xl\", 30}, {\"xc\", 80}, {\"l\", 50}, {\"c\", 100}, {\"cd\", 300}, {\"cm\", 800}, {\"d\", 500}, {\"m\", 1000}};\n        int r = m[s.substr(0, 1)];\n        for(int i=1; i<s.size(); ++i){\n            string two = s.substr(i-1, 2);\n            string one = s.substr(i, 1);\n            r += m[two] ? m[two] : m[one];\n        }\n        return r;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n# 代码行数：解析\n 1. 构建一个字典记录所有罗马数字子串，注意长度为2的子串记录的值是（实际值 - 子串内左边罗马数字代表的数值）\n    \n    \n 2. 这样一来，遍历整个 sss 的时候判断当前位置和前一个位置的两个字符组成的字符串是否在字典内，如果在就记录值，不在就说明当前位置不存在小数字在前面的情况，直接记录当前位置字符对应值\n    \n    \n\n举个例子，遍历经过 iviviv 的时候先记录 iii 的对应值 111 再往前移动一步记录 iviviv 的值 333，加起来正好是 iviviv 的真实值 444。max 函数在这里是为了防止遍历第一个字符的时候出现 [−1:0][-1:0][−1:0] 的情况\n\n# 知识拓展\n{:width=\"320px\"} {:align=center}\n\n【🃏知识卡片】哈希表存储的是由键（key）和值（value）组 成的数据。例如，我们将每个人的性别作为数 据进行存储，键为人名，值为对应的性别。\n\n * python 中我们使用字典 {key : value} 来初始化哈希表\n   \n   \n * 通过 key 查找 value 的时间复杂度为 o(1)o(1)o(1)\n   \n   \n * 这题题解中的 d 就是一个字典，其中 get(key, default) 函数可以通过 key 从 d 中找出对应的值，如果 key 不存在则返回默认值 default\n   \n   \n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2017-11-16 22:41:43accepted [https://leetcode-cn.com//submissions/detail/1149033/]92 ms5.19%n/ajava# 统计信息\n通过次数提交次数ac比率13820122912760.3%# 相似题目\n题目难度整数转罗马数字 [https://leetcode-cn.com/problems/integer-to-roman/]中等"},{title:"21-合并两个有序链表(Merge Two Sorted Lists)",frontmatter:{title:"21-合并两个有序链表(Merge Two Sorted Lists)",date:"2018-04-26T00:00:00.000Z",categories:["简单"],tags:["链表<Linked List>"]},regularPath:"/views/%E7%AE%80%E5%8D%95/0021-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8.html",relativePath:"views/简单/0021-合并两个有序链表.md",key:"v-0aae0649",path:"/views/%E7%AE%80%E5%8D%95/0021-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8.html",headers:[{level:2,title:"中文题目",slug:"中文题目",charIndex:2},{level:2,title:"通过代码",slug:"通过代码",charIndex:104},{level:2,title:"官方题解",slug:"官方题解",charIndex:2060},{level:2,title:"提交历史",slug:"提交历史",charIndex:5938},{level:2,title:"统计信息",slug:"统计信息",charIndex:6167},{level:2,title:"相似题目",slug:"相似题目",charIndex:6203}],lastUpdated:"4/11/2021, 1:15:21 PM",headersStr:"中文题目 通过代码 官方题解 提交历史 统计信息 相似题目",content:'# 中文题目\n将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。\n\n示例：\n\n输入：1->2->4, 1->3->4\n输出：1->1->2->3->4->4\n\n\n# 通过代码\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {\n          if (l1==null){\n                return l2;\n            }\n            if (l2==null){\n                return l1;\n            }\n            ListNode head=null;\n            if (l1.val<l2.val){\n                head=l1;\n                head.next=mergeTwoLists(l1.next,l2);\n            }else {\n                head=l2;\n                head.next=mergeTwoLists(l1,l2.next);\n            }\n            return head;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {\n          ListNode listNode=new ListNode(0);\n            ListNode head=listNode;\n            while (l1!=null||l2!=null){\n                if (l1==null){\n                    listNode.next=l2;\n                    listNode=listNode.next;\n                    break;\n                }\n                if (l2==null){\n                    listNode.next=l1;\n                    listNode=listNode.next;\n                    break;\n                }\n                if (l1.val<=l2.val){\n                    listNode.next=l1;\n                    l1=l1.next;\n                    listNode=listNode.next;\n                    continue;\n                }\n                if (l2.val<l1.val){\n                    listNode.next=l2;\n                    l2=l2.next;\n                    listNode=listNode.next;\n                    continue;\n                }\n            }\n\n            return head.next;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n# 官方题解\n# 方法 1：递归\n想法\n\n我们可以如下递归地定义在两个链表里的 merge 操作（忽略边界情况，比如空链表等）：\n\n{list1[0]+merge(list1[1:],list2)list1[0]<list2[0]list2[0]+merge(list1,list2[1:])otherwise\\left\\{ \\begin{array}{ll} list1[0] + merge(list1[1:], list2) & list1[0] < list2[0] \\\\ list2[0] + merge(list1, list2[1:]) & otherwise \\end{array} \\right.{list1[0]+merge(list1[1:],list2)list2[0]+merge(list1,list2[1:])​list1[0]<list2[0]otherwise​\n\n也就是说，两个链表头部较小的一个与剩下元素的 merge 操作结果合并。\n\n算法我们直接将以上递归过程建模，首先考虑边界情况。 特殊的，如果 l1 或者 l2 一开始就是 null ，那么没有任何操作需要合并，所以我们只需要返回非空链表。否则，我们要判断 l1 和 l2 哪一个的头元素更小，然后递归地决定下一个添加到结果里的值。如果两个链表都是空的，那么过程终止，所以递归过程最终一定会终止。\n\nclass Solution {\n    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {\n        if (l1 == null) {\n            return l2;\n        }\n        else if (l2 == null) {\n            return l1;\n        }\n        else if (l1.val < l2.val) {\n            l1.next = mergeTwoLists(l1.next, l2);\n            return l1;\n        }\n        else {\n            l2.next = mergeTwoLists(l1, l2.next);\n            return l2;\n        }\n\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\nclass Solution:\n    def mergeTwoLists(self, l1, l2):\n        if l1 is None:\n            return l2\n        elif l2 is None:\n            return l1\n        elif l1.val < l2.val:\n            l1.next = self.mergeTwoLists(l1.next, l2)\n            return l1\n        else:\n            l2.next = self.mergeTwoLists(l1, l2.next)\n            return l2\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n复杂度分析\n\n * 时间复杂度：O(n+m)O(n + m)O(n+m)。 因为每次调用递归都会去掉 l1 或者 l2 的头元素（直到至少有一个链表为空），函数 mergeTwoList 中只会遍历每个元素一次。所以，时间复杂度与合并后的链表长度为线性关系。\n   \n   \n * 空间复杂度：O(n+m)O(n + m)O(n+m)。调用 mergeTwoLists 退出时 l1 和 l2 中每个元素都一定已经被遍历过了，所以 n+mn + mn+m 个栈帧会消耗 O(n+m)O(n + m)O(n+m) 的空间。\n   \n   \n\n# 方法 2：迭代\n想法\n\n我们可以用迭代的方法来实现上述算法。我们假设 l1 元素严格比 l2元素少，我们可以将 l2 中的元素逐一插入 l1 中正确的位置。\n\n算法\n\n首先，我们设定一个哨兵节点 "prehead" ，这可以在最后让我们比较容易地返回合并后的链表。我们维护一个 prev 指针，我们需要做的是调整它的 next 指针。然后，我们重复以下过程，直到 l1 或者 l2 指向了 null ：如果 l1 当前位置的值小于等于 l2 ，我们就把 l1 的值接在 prev 节点的后面同时将 l1 指针往后移一个。否则，我们对 l2 做同样的操作。不管我们将哪一个元素接在了后面，我们都把 prev 向后移一个元素。\n\n在循环终止的时候， l1 和 l2 至多有一个是非空的。由于输入的两个链表都是有序的，所以不管哪个链表是非空的，它包含的所有元素都比前面已经合并链表中的所有元素都要大。这意味着我们只需要简单地将非空链表接在合并链表的后面，并返回合并链表。\n\n<, , , , ,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,>\n\nclass Solution {\n    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {\n        // maintain an unchanging reference to node ahead of the return node.\n        ListNode prehead = new ListNode(-1);\n\n        ListNode prev = prehead;\n        while (l1 != null && l2 != null) {\n            if (l1.val <= l2.val) {\n                prev.next = l1;\n                l1 = l1.next;\n            } else {\n                prev.next = l2;\n                l2 = l2.next;\n            }\n            prev = prev.next;\n        }\n\n        // exactly one of l1 and l2 can be non-null at this point, so connect\n        // the non-null list to the end of the merged list.\n        prev.next = l1 == null ? l2 : l1;\n\n        return prehead.next;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\nclass Solution:\n    def mergeTwoLists(self, l1, l2):\n        # maintain an unchanging reference to node ahead of the return node.\n        prehead = ListNode(-1)\n\n        prev = prehead\n        while l1 and l2:\n            if l1.val <= l2.val:\n                prev.next = l1\n                l1 = l1.next\n            else:\n                prev.next = l2\n                l2 = l2.next            \n            prev = prev.next\n\n        # exactly one of l1 and l2 can be non-null at this point, so connect\n        # the non-null list to the end of the merged list.\n        prev.next = l1 if l1 is not None else l2\n\n        return prehead.next\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n复杂度分析\n\n * 时间复杂度：O(n+m)O(n + m)O(n+m) 。因为每次循环迭代中，l1 和 l2 只有一个元素会被放进合并链表中， while 循环的次数等于两个链表的总长度。所有其他工作都是常数级别的，所以总的时间复杂度是线性的。\n   \n   \n * 空间复杂度：O(1)O(1)O(1) 。迭代的过程只会产生几个指针，所以它所需要的空间是常数级别的。\n   \n   \n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-04-26 23:29:11Accepted [https://leetcode-cn.com//submissions/detail/1731093/]13 ms85.04%N/Ajava2018-04-26 23:25:34Accepted [https://leetcode-cn.com//submissions/detail/1730958/]37 ms85.04%N/Ajava# 统计信息\n通过次数提交次数AC比率16760928343059.1%# 相似题目\n题目难度合并K个排序链表 [https://leetcode-cn.com/problems/merge-k-sorted-lists/]困难合并两个有序数组 [https://leetcode-cn.com/problems/merge-sorted-array/]简单排序链表 [https://leetcode-cn.com/problems/sort-list/]中等最短单词距离 II [https://leetcode-cn.com/problems/shortest-word-distance-ii/]中等',contentLowercase:'# 中文题目\n将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。\n\n示例：\n\n输入：1->2->4, 1->3->4\n输出：1->1->2->3->4->4\n\n\n# 通过代码\n/**\n * definition for singly-linked list.\n * public class listnode {\n *     int val;\n *     listnode next;\n *     listnode(int x) { val = x; }\n * }\n */\nclass solution {\n    public listnode mergetwolists(listnode l1, listnode l2) {\n          if (l1==null){\n                return l2;\n            }\n            if (l2==null){\n                return l1;\n            }\n            listnode head=null;\n            if (l1.val<l2.val){\n                head=l1;\n                head.next=mergetwolists(l1.next,l2);\n            }else {\n                head=l2;\n                head.next=mergetwolists(l1,l2.next);\n            }\n            return head;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n/**\n * definition for singly-linked list.\n * public class listnode {\n *     int val;\n *     listnode next;\n *     listnode(int x) { val = x; }\n * }\n */\nclass solution {\n    public listnode mergetwolists(listnode l1, listnode l2) {\n          listnode listnode=new listnode(0);\n            listnode head=listnode;\n            while (l1!=null||l2!=null){\n                if (l1==null){\n                    listnode.next=l2;\n                    listnode=listnode.next;\n                    break;\n                }\n                if (l2==null){\n                    listnode.next=l1;\n                    listnode=listnode.next;\n                    break;\n                }\n                if (l1.val<=l2.val){\n                    listnode.next=l1;\n                    l1=l1.next;\n                    listnode=listnode.next;\n                    continue;\n                }\n                if (l2.val<l1.val){\n                    listnode.next=l2;\n                    l2=l2.next;\n                    listnode=listnode.next;\n                    continue;\n                }\n            }\n\n            return head.next;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n# 官方题解\n# 方法 1：递归\n想法\n\n我们可以如下递归地定义在两个链表里的 merge 操作（忽略边界情况，比如空链表等）：\n\n{list1[0]+merge(list1[1:],list2)list1[0]<list2[0]list2[0]+merge(list1,list2[1:])otherwise\\left\\{ \\begin{array}{ll} list1[0] + merge(list1[1:], list2) & list1[0] < list2[0] \\\\ list2[0] + merge(list1, list2[1:]) & otherwise \\end{array} \\right.{list1[0]+merge(list1[1:],list2)list2[0]+merge(list1,list2[1:])​list1[0]<list2[0]otherwise​\n\n也就是说，两个链表头部较小的一个与剩下元素的 merge 操作结果合并。\n\n算法我们直接将以上递归过程建模，首先考虑边界情况。 特殊的，如果 l1 或者 l2 一开始就是 null ，那么没有任何操作需要合并，所以我们只需要返回非空链表。否则，我们要判断 l1 和 l2 哪一个的头元素更小，然后递归地决定下一个添加到结果里的值。如果两个链表都是空的，那么过程终止，所以递归过程最终一定会终止。\n\nclass solution {\n    public listnode mergetwolists(listnode l1, listnode l2) {\n        if (l1 == null) {\n            return l2;\n        }\n        else if (l2 == null) {\n            return l1;\n        }\n        else if (l1.val < l2.val) {\n            l1.next = mergetwolists(l1.next, l2);\n            return l1;\n        }\n        else {\n            l2.next = mergetwolists(l1, l2.next);\n            return l2;\n        }\n\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\nclass solution:\n    def mergetwolists(self, l1, l2):\n        if l1 is none:\n            return l2\n        elif l2 is none:\n            return l1\n        elif l1.val < l2.val:\n            l1.next = self.mergetwolists(l1.next, l2)\n            return l1\n        else:\n            l2.next = self.mergetwolists(l1, l2.next)\n            return l2\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n复杂度分析\n\n * 时间复杂度：o(n+m)o(n + m)o(n+m)。 因为每次调用递归都会去掉 l1 或者 l2 的头元素（直到至少有一个链表为空），函数 mergetwolist 中只会遍历每个元素一次。所以，时间复杂度与合并后的链表长度为线性关系。\n   \n   \n * 空间复杂度：o(n+m)o(n + m)o(n+m)。调用 mergetwolists 退出时 l1 和 l2 中每个元素都一定已经被遍历过了，所以 n+mn + mn+m 个栈帧会消耗 o(n+m)o(n + m)o(n+m) 的空间。\n   \n   \n\n# 方法 2：迭代\n想法\n\n我们可以用迭代的方法来实现上述算法。我们假设 l1 元素严格比 l2元素少，我们可以将 l2 中的元素逐一插入 l1 中正确的位置。\n\n算法\n\n首先，我们设定一个哨兵节点 "prehead" ，这可以在最后让我们比较容易地返回合并后的链表。我们维护一个 prev 指针，我们需要做的是调整它的 next 指针。然后，我们重复以下过程，直到 l1 或者 l2 指向了 null ：如果 l1 当前位置的值小于等于 l2 ，我们就把 l1 的值接在 prev 节点的后面同时将 l1 指针往后移一个。否则，我们对 l2 做同样的操作。不管我们将哪一个元素接在了后面，我们都把 prev 向后移一个元素。\n\n在循环终止的时候， l1 和 l2 至多有一个是非空的。由于输入的两个链表都是有序的，所以不管哪个链表是非空的，它包含的所有元素都比前面已经合并链表中的所有元素都要大。这意味着我们只需要简单地将非空链表接在合并链表的后面，并返回合并链表。\n\n<, , , , ,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,>\n\nclass solution {\n    public listnode mergetwolists(listnode l1, listnode l2) {\n        // maintain an unchanging reference to node ahead of the return node.\n        listnode prehead = new listnode(-1);\n\n        listnode prev = prehead;\n        while (l1 != null && l2 != null) {\n            if (l1.val <= l2.val) {\n                prev.next = l1;\n                l1 = l1.next;\n            } else {\n                prev.next = l2;\n                l2 = l2.next;\n            }\n            prev = prev.next;\n        }\n\n        // exactly one of l1 and l2 can be non-null at this point, so connect\n        // the non-null list to the end of the merged list.\n        prev.next = l1 == null ? l2 : l1;\n\n        return prehead.next;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\nclass solution:\n    def mergetwolists(self, l1, l2):\n        # maintain an unchanging reference to node ahead of the return node.\n        prehead = listnode(-1)\n\n        prev = prehead\n        while l1 and l2:\n            if l1.val <= l2.val:\n                prev.next = l1\n                l1 = l1.next\n            else:\n                prev.next = l2\n                l2 = l2.next            \n            prev = prev.next\n\n        # exactly one of l1 and l2 can be non-null at this point, so connect\n        # the non-null list to the end of the merged list.\n        prev.next = l1 if l1 is not none else l2\n\n        return prehead.next\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n复杂度分析\n\n * 时间复杂度：o(n+m)o(n + m)o(n+m) 。因为每次循环迭代中，l1 和 l2 只有一个元素会被放进合并链表中， while 循环的次数等于两个链表的总长度。所有其他工作都是常数级别的，所以总的时间复杂度是线性的。\n   \n   \n * 空间复杂度：o(1)o(1)o(1) 。迭代的过程只会产生几个指针，所以它所需要的空间是常数级别的。\n   \n   \n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-04-26 23:29:11accepted [https://leetcode-cn.com//submissions/detail/1731093/]13 ms85.04%n/ajava2018-04-26 23:25:34accepted [https://leetcode-cn.com//submissions/detail/1730958/]37 ms85.04%n/ajava# 统计信息\n通过次数提交次数ac比率16760928343059.1%# 相似题目\n题目难度合并k个排序链表 [https://leetcode-cn.com/problems/merge-k-sorted-lists/]困难合并两个有序数组 [https://leetcode-cn.com/problems/merge-sorted-array/]简单排序链表 [https://leetcode-cn.com/problems/sort-list/]中等最短单词距离 ii [https://leetcode-cn.com/problems/shortest-word-distance-ii/]中等'},{title:"26-删除排序数组中的重复项(Remove Duplicates from Sorted Array)",frontmatter:{title:"26-删除排序数组中的重复项(Remove Duplicates from Sorted Array)",date:"2018-07-27T00:00:00.000Z",categories:["简单"],tags:["数组<Array>","双指针<Two Pointers>"]},regularPath:"/views/%E7%AE%80%E5%8D%95/0026-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9.html",relativePath:"views/简单/0026-删除排序数组中的重复项.md",key:"v-78f01504",path:"/views/%E7%AE%80%E5%8D%95/0026-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9.html",headers:[{level:2,title:"中文题目",slug:"中文题目",charIndex:2},{level:2,title:"通过代码",slug:"通过代码",charIndex:730},{level:2,title:"官方题解",slug:"官方题解",charIndex:2427},{level:2,title:"提交历史",slug:"提交历史",charIndex:3144},{level:2,title:"统计信息",slug:"统计信息",charIndex:3870},{level:2,title:"相似题目",slug:"相似题目",charIndex:3906}],lastUpdated:"4/11/2021, 1:15:21 PM",headersStr:"中文题目 通过代码 官方题解 提交历史 统计信息 相似题目",content:"# 中文题目\n给定一个排序数组，你需要在原地 [http://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95]删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。\n\n不要使用额外的数组空间，你必须在原地 [https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95]修改输入数组并在使用 O(1) 额外空间的条件下完成。\n\n示例 1:\n\n给定数组 nums = [1,1,2], \n\n函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 \n\n你不需要考虑数组中超出新长度后面的元素。\n\n示例 2:\n\n给定 nums = [0,0,1,1,1,2,2,3,3,4],\n\n函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。\n\n你不需要考虑数组中超出新长度后面的元素。\n\n\n说明:\n\n为什么返回数值是整数，但输出的答案是数组呢?\n\n请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。\n\n你可以想象内部操作如下:\n\n// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝\nint len = removeDuplicates(nums);\n\n// 在函数里修改输入数组对于调用者是可见的。\n// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。\nfor (int i = 0; i < len; i++) {\n    print(nums[i]);\n}\n\n\n# 通过代码\nclass Solution {\n    public int removeDuplicates(int[] nums) {\n        if (nums.length==0){\n            return 0;\n        }\n        int total=1;\n        int count=1;\n        for (int i = 1; i < nums.length; i++) {\n            if (nums[i]!=nums[i-count]){\n                //记得要把原来的数组改变过来，否者会出错\n                nums[total++]=nums[i];\n                count=1;\n            }else{\n                count++;\n            }\n        }\n        return total;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\nclass Solution {\n    public int removeDuplicates(int[] nums) {\n        if (nums.length==0){\n            return 0;\n        }\n        int total=1;\n        int count=1;\n        for (int i = 1; i < nums.length; i++) {\n            if (nums[i]!=nums[i-count]){\n                //记得要把原来的数组改变过来，否者会出错\n                nums[total++]=nums[i];\n                count=1;\n            }else{\n                count++;\n            }\n        }\n        return total;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\nclass Solution {\n    public int removeDuplicates(int[] nums) {\n        if (nums.length==0){\n            return 0;\n        }\n        int total=1;\n        int count=1;\n        for (int i = 1; i < nums.length; i++) {\n            if (nums[i]!=nums[i-count]){\n                nums[total++]=nums[i];\n                count=1;\n            }else{\n                count++;\n            }\n        }\n        return total;\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\nclass Solution {\n   public int removeDuplicates(int[] A) {\n    if (A.length==0) return 0;\n    int j=0;\n    for (int i=0; i<A.length; i++)\n        if (A[i]!=A[j]) A[++j]=A[i];\n    return ++j;\n}\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n# 官方题解\n# 方法：双指针法\n算法\n\n数组完成排序后，我们可以放置两个指针 iii 和 jjj，其中 iii 是慢指针，而 jjj 是快指针。只要 nums[i]=nums[j]nums[i] = nums[j]nums[i]=nums[j]，我们就增加 jjj 以跳过重复项。\n\n当我们遇到 nums[j]≠nums[i]nums[j] \\neq nums[i]nums[j]​=nums[i] 时，跳过重复项的运行已经结束，因此我们必须把它（nums[j]nums[j]nums[j]）的值复制到 nums[i+1]nums[i + 1]nums[i+1]。然后递增 iii，接着我们将再次重复相同的过程，直到 jjj 到达数组的末尾为止。\n\npublic int removeDuplicates(int[] nums) {\n    if (nums.length == 0) return 0;\n    int i = 0;\n    for (int j = 1; j < nums.length; j++) {\n        if (nums[j] != nums[i]) {\n            i++;\n            nums[i] = nums[j];\n        }\n    }\n    return i + 1;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n复杂度分析\n\n * 时间复杂度：O(n)O(n)O(n)，假设数组的长度是 nnn，那么 iii 和 jjj 分别最多遍历 nnn 步。\n   \n   \n * 空间复杂度：O(1)O(1)O(1)。\n   \n   \n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-07-27 19:47:52Accepted [https://leetcode-cn.com//submissions/detail/4739323/]17 ms10.79%N/Ajava2017-11-20 23:28:58Accepted [https://leetcode-cn.com//submissions/detail/1149013/]14 ms10.96%N/Ajava2017-11-20 23:27:49Accepted [https://leetcode-cn.com//submissions/detail/1149014/]13 ms10.99%N/Ajava2017-11-20 23:24:32Wrong Answer [https://leetcode-cn.com//submissions/detail/1149015/]N/AN/AN/Ajava2017-11-20 23:19:45Accepted [https://leetcode-cn.com//submissions/detail/1149012/]14 ms10.96%N/Ajava2017-11-20 23:17:28Wrong Answer [https://leetcode-cn.com//submissions/detail/1149037/]N/AN/AN/Ajava2017-11-20 23:13:20Wrong Answer [https://leetcode-cn.com//submissions/detail/1149027/]N/AN/AN/Ajava# 统计信息\n通过次数提交次数AC比率23050947968248.1%# 相似题目\n题目难度移除元素 [https://leetcode-cn.com/problems/remove-element/]简单删除排序数组中的重复项 II [https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array-ii/]中等",contentLowercase:"# 中文题目\n给定一个排序数组，你需要在原地 [http://baike.baidu.com/item/%e5%8e%9f%e5%9c%b0%e7%ae%97%e6%b3%95]删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。\n\n不要使用额外的数组空间，你必须在原地 [https://baike.baidu.com/item/%e5%8e%9f%e5%9c%b0%e7%ae%97%e6%b3%95]修改输入数组并在使用 o(1) 额外空间的条件下完成。\n\n示例 1:\n\n给定数组 nums = [1,1,2], \n\n函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 \n\n你不需要考虑数组中超出新长度后面的元素。\n\n示例 2:\n\n给定 nums = [0,0,1,1,1,2,2,3,3,4],\n\n函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。\n\n你不需要考虑数组中超出新长度后面的元素。\n\n\n说明:\n\n为什么返回数值是整数，但输出的答案是数组呢?\n\n请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。\n\n你可以想象内部操作如下:\n\n// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝\nint len = removeduplicates(nums);\n\n// 在函数里修改输入数组对于调用者是可见的。\n// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。\nfor (int i = 0; i < len; i++) {\n    print(nums[i]);\n}\n\n\n# 通过代码\nclass solution {\n    public int removeduplicates(int[] nums) {\n        if (nums.length==0){\n            return 0;\n        }\n        int total=1;\n        int count=1;\n        for (int i = 1; i < nums.length; i++) {\n            if (nums[i]!=nums[i-count]){\n                //记得要把原来的数组改变过来，否者会出错\n                nums[total++]=nums[i];\n                count=1;\n            }else{\n                count++;\n            }\n        }\n        return total;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\nclass solution {\n    public int removeduplicates(int[] nums) {\n        if (nums.length==0){\n            return 0;\n        }\n        int total=1;\n        int count=1;\n        for (int i = 1; i < nums.length; i++) {\n            if (nums[i]!=nums[i-count]){\n                //记得要把原来的数组改变过来，否者会出错\n                nums[total++]=nums[i];\n                count=1;\n            }else{\n                count++;\n            }\n        }\n        return total;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\nclass solution {\n    public int removeduplicates(int[] nums) {\n        if (nums.length==0){\n            return 0;\n        }\n        int total=1;\n        int count=1;\n        for (int i = 1; i < nums.length; i++) {\n            if (nums[i]!=nums[i-count]){\n                nums[total++]=nums[i];\n                count=1;\n            }else{\n                count++;\n            }\n        }\n        return total;\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\nclass solution {\n   public int removeduplicates(int[] a) {\n    if (a.length==0) return 0;\n    int j=0;\n    for (int i=0; i<a.length; i++)\n        if (a[i]!=a[j]) a[++j]=a[i];\n    return ++j;\n}\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n# 官方题解\n# 方法：双指针法\n算法\n\n数组完成排序后，我们可以放置两个指针 iii 和 jjj，其中 iii 是慢指针，而 jjj 是快指针。只要 nums[i]=nums[j]nums[i] = nums[j]nums[i]=nums[j]，我们就增加 jjj 以跳过重复项。\n\n当我们遇到 nums[j]≠nums[i]nums[j] \\neq nums[i]nums[j]​=nums[i] 时，跳过重复项的运行已经结束，因此我们必须把它（nums[j]nums[j]nums[j]）的值复制到 nums[i+1]nums[i + 1]nums[i+1]。然后递增 iii，接着我们将再次重复相同的过程，直到 jjj 到达数组的末尾为止。\n\npublic int removeduplicates(int[] nums) {\n    if (nums.length == 0) return 0;\n    int i = 0;\n    for (int j = 1; j < nums.length; j++) {\n        if (nums[j] != nums[i]) {\n            i++;\n            nums[i] = nums[j];\n        }\n    }\n    return i + 1;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n复杂度分析\n\n * 时间复杂度：o(n)o(n)o(n)，假设数组的长度是 nnn，那么 iii 和 jjj 分别最多遍历 nnn 步。\n   \n   \n * 空间复杂度：o(1)o(1)o(1)。\n   \n   \n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-07-27 19:47:52accepted [https://leetcode-cn.com//submissions/detail/4739323/]17 ms10.79%n/ajava2017-11-20 23:28:58accepted [https://leetcode-cn.com//submissions/detail/1149013/]14 ms10.96%n/ajava2017-11-20 23:27:49accepted [https://leetcode-cn.com//submissions/detail/1149014/]13 ms10.99%n/ajava2017-11-20 23:24:32wrong answer [https://leetcode-cn.com//submissions/detail/1149015/]n/an/an/ajava2017-11-20 23:19:45accepted [https://leetcode-cn.com//submissions/detail/1149012/]14 ms10.96%n/ajava2017-11-20 23:17:28wrong answer [https://leetcode-cn.com//submissions/detail/1149037/]n/an/an/ajava2017-11-20 23:13:20wrong answer [https://leetcode-cn.com//submissions/detail/1149027/]n/an/an/ajava# 统计信息\n通过次数提交次数ac比率23050947968248.1%# 相似题目\n题目难度移除元素 [https://leetcode-cn.com/problems/remove-element/]简单删除排序数组中的重复项 ii [https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array-ii/]中等"},{title:"35-搜索插入位置(Search Insert Position)",frontmatter:{title:"35-搜索插入位置(Search Insert Position)",date:"2021-05-23T00:00:00.000Z",categories:["简单"],tags:["数组<Array>","二分查找<Binary Search>"]},regularPath:"/views/%E7%AE%80%E5%8D%95/0035-%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE.html",relativePath:"views/简单/0035-搜索插入位置.md",key:"v-7cecf4db",path:"/views/%E7%AE%80%E5%8D%95/0035-%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE.html",headers:[{level:2,title:"中文题目",slug:"中文题目",charIndex:2},{level:2,title:"通过代码",slug:"通过代码",charIndex:215},{level:2,title:"高赞题解",slug:"高赞题解",charIndex:1450},{level:3,title:"0. 前言",slug:"_0-前言",charIndex:1875},{level:3,title:"1. 二分查找的基本问题",slug:"_1-二分查找的基本问题",charIndex:2283},{level:3,title:"2. 二分查找的问题变种",slug:"_2-二分查找的问题变种",charIndex:3545},{level:3,title:"3. 把待搜索区间分成两个部分（重点、最重要的部分在这里）",slug:"_3-把待搜索区间分成两个部分（重点、最重要的部分在这里）",charIndex:4100},{level:3,title:"4. 例题讲解：「力扣」第 35 题：搜索插入位置",slug:"_4-例题讲解：「力扣」第-35-题：搜索插入位置",charIndex:1841},{level:3,title:"5. 两种写法对比",slug:"_5-两种写法对比",charIndex:9079},{level:3,title:"6. 一些细节（以问答形式呈现）",slug:"_6-一些细节（以问答形式呈现）",charIndex:10552},{level:3,title:"7. 练习",slug:"_7-练习",charIndex:12045},{level:3,title:"8. 总结",slug:"_8-总结",charIndex:17363},{level:3,title:"9.参考资料",slug:"_9-参考资料",charIndex:18321},{level:2,title:"提交历史",slug:"提交历史",charIndex:18412},{level:2,title:"统计信息",slug:"统计信息",charIndex:18661},{level:2,title:"相似题目",slug:"相似题目",charIndex:18697}],lastUpdated:"4/11/2021, 1:15:21 PM",headersStr:"中文题目 通过代码 高赞题解 0. 前言 1. 二分查找的基本问题 2. 二分查找的问题变种 3. 把待搜索区间分成两个部分（重点、最重要的部分在这里） 4. 例题讲解：「力扣」第 35 题：搜索插入位置 5. 两种写法对比 6. 一些细节（以问答形式呈现） 7. 练习 8. 总结 9.参考资料 提交历史 统计信息 相似题目",content:'# 中文题目\n给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。\n\n你可以假设数组中无重复元素。\n\n示例 1:\n\n输入: [1,3,5,6], 5\n输出: 2\n\n\n示例 2:\n\n输入: [1,3,5,6], 2\n输出: 1\n\n\n示例 3:\n\n输入: [1,3,5,6], 7\n输出: 4\n\n\n示例 4:\n\n输入: [1,3,5,6], 0\n输出: 0\n\n\n# 通过代码\n    class Solution {\n        public int searchInsert(int[] nums, int target) {\n            int left=0;\n            int right=nums.length-1;\n            int mid;\n            while (left<=right){\n                mid=left+(right-left)/2;\n                if (nums[mid] == target){\n                    return mid;\n                }\n                if (nums[mid]<target){\n                    left=mid+1;\n                }\n                if (nums[mid]>target){\n                    right=mid-1;\n                }\n            }\n            return left;\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n    class Solution {\n        public int searchInsert(int[] nums, int target) {\n            int left=0;\n            int right=nums.length-1;\n            int mid;\n            while (left<=right){\n                mid=left+(right-left)/2;\n                if (nums[mid] == target){\n                    return mid;\n                }\n                if (nums[mid]<target){\n                    left=mid+1;\n                }\n                if (nums[mid]>target){\n                    right=mid-1;\n                }\n            }\n            return left;\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n# 高赞题解\n说明：这篇题解专治二分疑难杂症。\n\n大家不要看篇幅多，这是因为我做了很多问题，所以总结出了这么多需要注意的地方。掌握了二分查找算法的朋友，也绝对不是因为看了我写的二分才真正掌握的，更关键的原因是他们把二分查找的思想进行了足够多的应用。事实上，二分查找法需要学习的、和需要注意的事项并不多，而且很多细节完全不需要记忆。和学习绝大多数算法与数据结构知识一样，多练习、多思考，就能很好地掌握它们。\n\n为了讲清楚我想说的部分，文字部分有点多。实在不想看那么多文字的朋友，可以只看第 3 部分「把待搜索区间分成两个部分」，并且把第 7 部分给出的「练习」做一下。相信会对大家有帮助。\n\n> 掌握二分查找（甚至是其它的算法和数据结构）不可以只看别人写的题解，一定要自己多加练习，配合上自己的思考和总结，才可能做到融会贯通，举一三反。\n\n\n想看「第 35 题」代码的朋友，可以直接跳到「4. 例题讲解：「力扣」第 35 题：搜索插入位置」。\n\n\n\n\n# 0. 前言\n「二分查找」作为一种基础算法，本不该很难，所以希望借这道题的讲解和大家谈谈如何学习算法：\n\n * 「二分查找」就那么几行代码，我们完全有理由充分掌握它，而不可以用记忆模板、背例题的方式；\n * 「二分查找」虽然看起来有很多种写法，「递归」和「非递归」，「非递归」又有好几种写法：while (left <= right)、while (left < right)、while (left + 1 < right)。但核心的思想就一个：逐渐缩小问题规模。我们在学习和练习的时候需要 首先着眼于掌握算法的思想，而不该去纠结二分的几种写法的区别和细节，这样会让自己更乱；\n * 在面对问题的时候，应该将主要精力放在 如何分析，利用单调性（绝大多数二分查找问题利用的是单调性，也有一些例外）或者题目本身蕴含的可以逐渐缩小问题规模的特性解决问题，而不应该纠结在「二分查找」该怎么写。\n\n下面开始正文。\n\n\n\n\n# 1. 二分查找的基本问题\n二分查找的基本问题是「力扣」第 704 题：二分查找 [https://leetcode-cn.com/problems/binary-search/]。\n\n参考代码 1：（第 704 题代码）\n\nclass Solution {\n    public int search(int[] nums, int target) {\n        int len = nums.length;\n        int left = 0;\n        int right = len - 1;\n        // 在 [left..right] 里查找 target\n        while (left <= right) {\n            // 为了防止 left + right 整形溢出，写成这样\n            int mid = left + (right - left) / 2;\n            if (nums[mid] == target) {\n                return mid;\n            } else if (nums[mid] > target) {\n                // 下一轮搜索区间：[left..mid - 1]\n                right = mid - 1;\n            } else {\n                // 此时：nums[mid] < target，下一轮搜索区间：[mid + 1..right]\n                left = mid + 1;\n            }\n        }\n        return -1;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n说明：\n\n二分查找的思路是：根据待搜索区间里的中间元素 nums[mid] 与 target 的值的大小关系，判断下一轮搜索需要在哪个区间里查找，进而设置 left 和 right 的值。分为如下三种情况：\n\n * 如果 nums[mid] == target，运气很好，找到了目标元素，返回 mid ；\n * 如果 nums[mid] > target，说明 mid 以及 mid 的 右边 的所有元素一定都比 target 大，下一轮搜索需要在区间 [left..mid - 1] 里查找，此时设置 right = mid - 1；\n * 如果 nums[mid] < target，说明 mid 以及 mid 的 左边 的所有元素一定都比 target 小，下一轮搜索需要在区间 [mid + 1..right] 里查找，此时设置 left = mid + 1。\n\n退出循环的时候，说明区间里不存在目标元素，返回 −1-1−1。\n\n\n\n\n# 2. 二分查找的问题变种\n事实上，「力扣」上的「二分查找」问题没有那么简单。例如，让我们找：\n\n * 大于等于 target 的下标最小的元素；\n * 小于等于 target 的下标最大的元素。\n\n这样的问题有一个特点：当看到了 nums[mid] 恰好等于 target 的时候，还得继续查找，继续看看左边的元素的值，或者继续看看右边元素的值。如果不小心，很可能逻辑写错。如果还用「1. 二分查找的基本问题」介绍的方式编写代码，就没有那么容易：\n\n * while 里面的 if 、else 该怎么写，有没有什么固定的思路？\n * 退出循环以后，right 在左，left 在右，返回 left 还是 right 需要分类讨论。\n\n本题解要介绍的「二分查找」的思想其实不是什么新鲜的事儿。如下图所示，它像极了「双指针」算法，left 和 right 向中间走，直到它们重合在一起。\n\n\n\n这种二分查找的思考路径，不是我发明的（「参考资料」在题解最后）。我一开始看到这种写法也觉得很惊讶，也搞不明白到底怎么回事，但是我看到的解释就只有「这是模板」，但没有看到为什么有这个模板。因此我 尝试去了解它，并使用它，然后整理成这篇题解。用这种二分查找的思路，可以解决「力扣」上 所有的 「二分查找」问题。\n\n\n\n\n# 3. 把待搜索区间分成两个部分（重点、最重要的部分在这里）\n根据看到的中间位置的元素的值 nums[mid] 可以把待搜索区间分为两个部分：\n\n * 一定不存在 目标元素的区间：下一轮搜索的时候，不用考虑它；\n * 可能存在 目标元素的区间：下一轮搜索的时候，需要考虑它。\n\n由于 mid 只可能被分到这两个区间的其中一个，即：while 里面的 if 和 else 就两种写法：\n\n * 如果 mid 分到左边区间，即区间分成 [left..mid] 与 [mid + 1..right]，此时分别设置 right = mid 与 left = mid + 1；\n * 如果 mid 分到右边区间，即区间分成 [left..mid - 1] 与 [mid..right]，此时分别设置 right = mid - 1 与 left = mid。\n\n并且把 循环可以继续的条件 写成 while (left < right)。在上面把待搜索区间分成两个部分的情况下，退出循环以后一定会有 left == right 成立，因此在退出循环以后，不需要考虑到底返回 left 还是返回 right。\n\n这里介绍一个 「重要的经验」：\n\n> 在 写 if 语句的时候，通常把容易想到的，不容易出错的逻辑写在 if 的里面，这样就把复杂的、容易出错的情况放在了 else 的部分，这样编写代码不容易出错。\n\n\n什么情况是容易想到的，不容易出错的呢？我的经验是：题目要我们找符合条件 a 的元素，我们就对条件 a 取反面，这样分析不容易出错。\n\n例如本题（「力扣」第 35 题），题目要我们找出第一个大于等于 target 的元素的下标，那么小于 target 的元素就一定不是我们要找的。因此 if 语句就是\n\nif (nums[mid] < target) {\n\t// 下一轮搜索区间是 [mid + 1..right]\n\tleft = mid + 1;\n}\n\n\n1\n2\n3\n4\n剩下的情况放在 else 中，我们 甚至可以不用分析 else 是什么情况。if 的区间是 [mid + 1..right]，它的反面区间就是 [left..mid]，此时 else 就应该设置 right = mid。\n\n因此完整的逻辑就是：\n\nif (nums[mid] < target) {\n\t// 下一轮搜索区间是 [mid + 1..right]\n\tleft = mid + 1;\n} else {\n\tright = mid;\n}\n\n\n1\n2\n3\n4\n5\n6\n上面的叙述，总结起来就一句话：我们 总是在区间 [left..right] 里查找元素目标。\n\n注意：我们说的是 左闭右闭区间。为什么不是「左闭右开」呢？「左闭右开」当然可以，但是我们 不想把精力花在思考「右边界是不是可以取到」这件事情上，这是因为 任意一个「左闭右开 [left..right) 」区间一定唯一对应一个「左闭右闭 [left..right - 1]」区间，所以到底是开区间还是闭区间，前后保持一致就可以。\n\n根据 mid 位置是不是目标元素，进而判断 mid 的左边是否存在目标元素，mid 的右边是否存在目标元素，只把搜索区间分为两个部分，然后设置 left 和 right，在设置 left 和 right 的时候，左闭右闭区间的形式是最直观的，这是因为如果是开区间，还需要在脑子里反应一下，右端点不包括。如果我们觉得二分问题复杂，复杂问题应该简单做。\n\n我们再说说把区间分成两个部分的好处：\n\n在代码层面，只可能有以下两种情况：\n\n * while(left < right) 与 left = mid + 1 、 right = mid 的搭配；\n * while(left < right) 与 left = mid 、 right = mid - 1 的搭配；\n\n只有在这两种把区间分成两个部分的划分下，退出循环以后有 left == right 成立，我们不用去讨论返回 left 还是 right（这句话非常重要，大家可以在做题的过程中慢慢体会）。\n\n> 补充说明：有的朋友觉得把区间分为三个部分更清晰，但是一旦分成三个部分，有 mid + 1、mid - 1 出现，退出循环以后就不一定有 left 和 right 重合。我们完全可以这样做，分类讨论的时候分成三个部分，然后把它们的逻辑合并起来。\n\n\n在我们的讲解中 while(left < right) 与「定义的区间是 [left..right) 」没有任何关系，请大家不要做多余的解读，我们不讲循环不变量是 [left..right) 的情况，我们只认为区间是「左闭右闭」区间，理由上面也说了，每一个位置的值是不是可以取到，我们需要非常清楚，而不想看到一个开区间，我们在脑子里需要想一下「右端点不包括」。\n\n至于为什么是 left = mid + 1 、 right = mid 搭配使用，而 left = mid 、 right = mid - 1 搭配使用，这一点完全不用记忆，我们画图说明。\n\n{:style="width:500px"}\n\n因此我们再次和大家强调：永远去思考下一轮搜索应该在哪个区间里，就能考虑清楚到底下一轮更新的是 left 还是 right ，到底加不加 1，到底减不减 1。\n\n\n\n\n# 4. 例题讲解：「力扣」第 35 题：搜索插入位置\n思路分析：\n\n根据示例 3：\n\n输入: [1, 3, 5, 6], 7\n输出: 4\n\n\n1\n2\n如果目标元素大于输入数组中的最后一个元素，返回数组的最后一个元素的下标 + 1。\n\n根据示例 2：\n\n输入: [1,3,5,6], 2\n输出: 1\n\n\n1\n2\n需要返回第 1 个 大于等于（等于的情况可以看示例 1，这里省略） 目标元素 2 的下标，因此输出 1。因此 如果当前 mid 看到的数值严格小于 target，那么 mid 以及 mid 左边的所有元素就一定不是题目要求的输出，就根据这一点可以写出本题二分查找算法的完整逻辑。\n\n参考代码 2：（第 35 题代码）\n\npublic class Solution {\n\n    public int searchInsert(int[] nums, int target) {\n        int len = nums.length;\n        // 特殊判断\n        if (nums[len - 1] < target) {\n            return len;\n        }\n\n        // 程序走到这里一定有 target <= nums[len - 1]\n        int left = 0;\n        int right = len - 1;\n        // 在区间 nums[left..right] 里查找第 1 个大于等于 target 的元素的下标\n        while (left < right) {\n            int mid = left + (right - left) / 2;\n            if (nums[mid] < target){\n                // 下一轮搜索的区间是 [mid + 1..right]\n                left = mid + 1;\n            } else {\n                // 下一轮搜索的区间是 [left..mid]\n                right = mid;\n            }\n        }\n        return left;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n值得一提的是：由于执行到最后 nums[left..right] 里一定存在插入元素的位置，并且退出循环的时候一定有 left == right 成立，因此直接返回 left 或者 right 均可。\n\n这样的思路还可以完成第 704 题。\n\n参考代码 3：（第 704 题代码）\n\nclass Solution {\n    public int search(int[] nums, int target) {\n        int len = nums.length;\n        int left = 0;\n        int right = len - 1;\n        // 在 nums[left..right] 里查找 target\n        while (left < right) {\n            // 为了防止 left + right 整形溢出，写成这样\n            int mid = left + (right - left) / 2;\n            if (nums[mid] < target) {\n                // 下一轮搜索区间：[mid + 1..right]\n                left = mid + 1;\n            } else {\n                // 下一轮搜索区间：[left..mid]\n                right = mid;\n            }\n        }\n        \n        if (nums[left] == target){\n            return left;\n        }\n        return -1;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\nclass Solution {\n    public int search(int[] nums, int target) {\n        int len = nums.length;\n        int left = 0;\n        int right = len - 1;\n        // 在 nums[left..right] 里查找 target\n        while (left < right) {\n            // 为了防止 left + right 整形溢出，写成这样\n            int mid = left + (right - left + 1) / 2;\n            if (nums[mid] > target) {\n                // 下一轮搜索区间：[left..mid - 1]\n                right = mid - 1;\n            } else {\n                // 下一轮搜索区间：[mid..right]\n                left = mid;\n            }\n        }\n        \n        if (nums[left] == target){\n            return left;\n        }\n        return -1;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n * 退出循环的时候，我们不能确定 nums[left] 是否等于 target，因此还需要单独做一次判断；\n * 「选项卡二」我们还给出了一版代码，具体细节大家可以在阅读完本题解以后再来理解它。\n\n\n\n\n# 5. 两种写法对比\n写法 1： while(left <= right) 这种写法可以认为我们在循环体内部直接查找元素，把当前搜索区间分为三个部分。\n\n程序开始的时候，我们对输入数组一无所知。\n\n{:style="width: 400px"}\n\n我们选择 nums[mid] 的值看一下。\n\n{:style="width: 400px"}\n\n如果中间位置的元素的值等于目标元素就直接返回。如果中间位置的元素不是目标元素，可以根据中间位置元素的值决定在中间位置的左边还是右边继续查找。这种查找方式把待搜索区间分为三个部分：左、中、右。\n\n{:style="width: 400px"}\n\n重要经验：如果我们要找的元素性质非常明确、并且简单，通常这样写就可以。例如「力扣」第 704 题（二分查找 [https://leetcode-cn.com/problems/binary-search]），第 633 题（平方数之和 [https://leetcode-cn.com/problems/sum-of-square-numbers]）。\n\n写法 2：while(left < right) 这种写法表示在循环体内部排除元素，把当前搜索区间分为两个部分。\n\n这种思路可以很形象地理解为「两边夹」，在解决复杂问题的时候，会使得思考的过程变得简单。\n\n程序开始的时候，我们对输入数组一无所知（这一步和写法 1 一样）。\n\n{:style="width: 400px"}\n\n我们选择 nums[mid] 的值看一下（这一步和写法 1 一样）。\n\n{:style="width: 400px"}\n\n然后我们只分析：在什么情况下，目标元素位于哪个区间里，把区间分成「一定不存在目标元素的区间」和「可能存在目标元素的区间」。而 mid 只可能位于这两个区间的其中一个，可以分为下面 4 种情况。\n\n{:style="width: 400px"}\n\n虽然看起来比较多，但是归结起来就 2 种情况：mid 在左边区间和 mid 在右边区间。即：根据 mid 的值，可以判断 nums[mid] 是「一定不是目标元素」还是「有可能是目标元素」，进而判断 mid 的左右两边的区间的性质。\n\n重要经验：\n\n如果我们要找的元素的性质比较复杂：例如需要满足「条件 1」并且「条件 2」。我们在编写 if 语句的时候，就可以把其中一个条件取反，就可以达到缩减搜索区间的目的。\n\n这一点也不难想明白，「条件 1」并且「条件 2」的反面就是「取反条件 1」或者「取反条件 2」。再举一个具体的例子：例如我们要找一个数 xxx，需要满足 4≤x≤94 \\le x \\le 94≤x≤9，即 x≥4x \\ge 4x≥4 并且 x≤9x \\le 9x≤9。如果我们看到一个数小于 444，我们就知道此时需要在当前位置的右边继续查找，可以得到缩减问题区间的目的。\n\n「力扣」第 4 题（寻找两个正序数组的中位数 [https://leetcode-cn.com/problems/median-of-two-sorted-arrays/]）的 视频题解 [https://leetcode-cn.com/problems/median-of-two-sorted-arrays/solution/xun-zhao-liang-ge-you-xu-shu-zu-de-zhong-wei-s-114/]，我们详细介绍了用这种思路分析问题的方法，并给出了 2 版等价的代码。\n\n\n\n\n# 6. 一些细节（以问答形式呈现）\n# 细节一：为什么有些时候取 mid 的时候需要上取整？\n回答：是否需要上取整，只和区间划分的逻辑有关。如果不调整，会出现死循环。\n\n\n\n初次接触的时候，很多朋友觉得这件事情非常难以理解，我们的建议是：一旦遇到死循环，可以在程序中输出 left、right 和 mid 的值看一下就很清楚了。「力扣」第 69 题：x 的平方根 [https://leetcode-cn.com/problems/sqrtx/] 的 题解 [https://leetcode-cn.com/problems/sqrtx/solution/er-fen-cha-zhao-niu-dun-fa-python-dai-ma-by-liweiw/] ，我们演示了如何打印变量、观察到死循环。\n\n结论：当区间只剩下两个元素的时候，left = mid 和 right = mid - 1 这种划分方式，如果 mid 使用默认下取整的方式，在数值上 left = mid，而它对应的其中一个区间是 [mid..right]，在这种情况下，下一轮搜索区间还是 [left..right]，搜索区间没有减少，会进入死循环。\n\n提示：「看到边界设置的代码是 left = mid 时，需要把 mid 的取法调整为上取整，以避免死循环」，这件事情也完全不用记忆，题目做得多了，自然而然就记住了。还是我们在题解中和大家多次强调的一件事情：遇到代码出错的时候，一定要耐心调试，把变量打印出来看一下，是最好的学习的方法。\n\n# 细节二：有些学习资料上说 while (left < right) 表示区间是 [left..rihgt) ，为什么你这里是 [left..rihgt]？\n回答：区间的右端点到底是开还是闭，完全由编写代码的人决定，不需要固定。只要编码的人逻辑前后一致，并且保持不变（这件事情叫遵守「循环不变量」），就是正确的。\n\n我们通篇讲的都是 左闭右闭 区间，理由是这样定义更直接。\n\n# 细节三：有些学习资料给出了三种模板，例如「力扣」推出的 LeetBook 之 「二分查找专题 [https://leetcode-cn.com/leetbook/detail/binary-search/]」，应该如何看待它们？\n回答：我在学习的时候，LeetBook 也是我重要的学习材料之一。三种模板其实区别仅在于退出循环的时候，区间 [left..right] 里有几个数。\n\n * while (left <= right) ：退出循环的时候，right 在左，left 在右，区间为空区间，所以要讨论返回 left 和 right；\n * while (left < right) ：退出循环的时候，left 与 right 重合，区间里只有一个元素，这一点是我们很喜欢的；\n * while (left + 1< right) ：退出循环的时候，left 在左，right 在右，区间里有 2 个元素，需要编写专门的逻辑。这种写法在设置 left 和 right 的时候不需要加 1 和减 1。看似简化了思考的难度，但实际上屏蔽了我们应该且完全可以分析清楚的细节。退出循环以后一定需要编写专门的逻辑，讨论返回哪一个，也增加了编码的难度。\n\n我个人的经验是：完全不用第三个，理由是不会使得问题变得更简单，反而很累赘。\n\n我常用头两个，第一个在简单问题中用，第二个在复杂问题中用。在题解的第 5 部分「5. 两种写法对比」的「重要经验」里也叙述了用它们的理由和场景。\n\n\n\n\n# 7. 练习\n提示：这些问题都不应该当做模板问题来看待，逻辑严密的分析与思考是更关键的。我们针对这些问题都提供了题解，重点分析了应该如何思考，讲解了如何编写正确的代码，希望能够对大家有所帮助。\n\n# 题型一：二分下标（在数组中查找符合条件的元素的下标）\n一般而言这个数组是有序的，也可能是半有序的（旋转有序数组或者山脉数组）。\n\n题目题解说明704. 二分查找（简单） [https://leetcode-cn.com/problems/binary-search/]二分查找的最原始问题，使用本题解介绍的方法就要注意，需要后处理。34. 在排序数组中查找元素的第一个和最后一个位置（中等） [https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/]文字题解 [https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/solution/si-lu-hen-jian-dan-xi-jie-fei-mo-gui-de-er-fen-cha/]、视频题解 [https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/solution/zai-pai-xu-shu-zu-zhong-cha-zhao-yuan-su-de-di-3-4/]查找边界问题。33. 搜索旋转排序数组（中等） [https://leetcode-cn.com/problems/search-in-rotated-sorted-array/]文字题解 [https://leetcode-cn.com/problems/search-in-rotated-sorted-array/solution/er-fen-fa-python-dai-ma-java-dai-ma-by-liweiwei141/]利用局部单调性，逐步缩小搜索区间（其它问题类似）。81. 搜索旋转排序数组 II（中等） [https://leetcode-cn.com/problems/search-in-rotated-sorted-array-ii/]文字题解 [https://leetcode-cn.com/problems/search-in-rotated-sorted-array-ii/solution/er-fen-cha-zhao-by-liweiwei1419/]153. 寻找旋转排序数组中的最小值（中等） [https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/]文字题解 [https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/solution/er-fen-fa-fen-zhi-fa-python-dai-ma-java-dai-ma-by-/]154. 寻找旋转排序数组中的最小值 II（中等） [https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/]文字题解 [https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/solution/er-fen-fa-fen-zhi-fa-python-dai-ma-by-liweiwei1419/]300. 最长上升子序列（中等） [https://leetcode-cn.com/problems/longest-increasing-subsequence/]文字题解 [https://leetcode-cn.com/problems/longest-increasing-subsequence/solution/dong-tai-gui-hua-er-fen-cha-zhao-tan-xin-suan-fa-p/]。特别经典的一道「动态规划」，二分查找的思路基于「动态规划」的状态定义得到，代码很像第 35 题。275. H指数 II（中等） [https://leetcode-cn.com/problems/h-index-ii/]文字题解 [https://leetcode-cn.com/problems/h-index-ii/solution/jian-er-zhi-zhi-er-fen-cha-zhao-by-liweiwei1419-2/]这个问题题目的描述让人迷惑，可以跳过不做。852. 山脉数组的峰顶索引（简单） [https://leetcode-cn.com/problems/peak-index-in-a-mountain-array/]利用局部单调性，逐步缩小搜索区间。1095. 山脉数组中查找目标值（中等） [https://leetcode-cn.com/problems/find-in-mountain-array/]文字题解 [https://leetcode-cn.com/problems/find-in-mountain-array/solution/shi-yong-chao-hao-yong-de-er-fen-fa-mo-ban-python-/]、视频题解 [https://leetcode-cn.com/problems/find-in-mountain-array/solution/shan-mai-shu-zu-zhong-cha-zhao-mu-biao-zhi-by-leet/]4. 寻找两个有序数组的中位数（困难） [https://leetcode-cn.com/problems/median-of-two-sorted-arrays/]文字题解 [https://leetcode-cn.com/problems/median-of-two-sorted-arrays/solution/he-bing-yi-hou-zhao-gui-bing-guo-cheng-zhong-zhao-/]、视频题解 [https://leetcode-cn.com/problems/median-of-two-sorted-arrays/solution/xun-zhao-liang-ge-you-xu-shu-zu-de-zhong-wei-s-114/]658. 找到 K 个最接近的元素（中等） [https://leetcode-cn.com/problems/find-k-closest-elements/]文字题解 [https://leetcode-cn.com/problems/find-k-closest-elements/solution/pai-chu-fa-shuang-zhi-zhen-er-fen-fa-python-dai-ma/]这个问题二分的写法需要做复杂的分类讨论，可以放在以后做。# 题型二：二分答案（在一个有范围的区间里搜索一个整数）\n定位一个有范围的整数，这件事情也叫「二分答案」或者叫「二分结果」。如果题目要求的是一个整数，这个整数有明确的范围，可以考虑使用二分查找。\n\n事实上，二分答案是我们最早接触的二分查找的场景。「幸运 52」里猜价格游戏，就是「二分查找」算法的典型应用：先随便猜一个数，如果猜中，游戏结束。如果猜大了，往小猜；如果猜小了，往大猜。\n\n题目题解说明69. 平方根（简单） [https://leetcode-cn.com/problems/sqrtx/]文字题解 [https://leetcode-cn.com/problems/sqrtx/solution/er-fen-cha-zhao-niu-dun-fa-python-dai-ma-by-liweiw/]在一个整数范围里查找一个整数，也是二分查找法的应用场景。287. 寻找重复数（中等） [https://leetcode-cn.com/problems/find-the-duplicate-number/]文字题解 [https://leetcode-cn.com/problems/find-the-duplicate-number/solution/er-fen-fa-si-lu-ji-dai-ma-python-by-liweiwei1419/]在一个整数范围里查找一个整数。这个问题二分查找的解法很反常规（不应该用时间换空间，这么做太傻了），知道即可。374. 猜数字大小（简单） [https://leetcode-cn.com/problems/guess-number-higher-or-lower/]文字题解 [https://leetcode-cn.com/problems/guess-number-higher-or-lower/solution/shi-fen-hao-yong-de-er-fen-cha-zhao-fa-mo-ban-pyth/]1300. 转变数组后最接近目标值的数组和 [https://leetcode-cn.com/problems/sum-of-mutated-array-closest-to-target/]文字题解 [https://leetcode-cn.com/problems/sum-of-mutated-array-closest-to-target/solution/er-fen-cha-zhao-by-liweiwei1419-2/]# 题型三：二分答案的升级版：判别条件需要遍历数组\n说明：这里给出的问题解法都一样，会一题等于会其它题。问题的场景会告诉我们：目标变量和另一个变量有相关关系（一般是线性关系），目标变量的性质不好推测，但是另一个变量的性质相对容易推测（满足某种意义上的单调性）。这样的问题的判别函数通常会写成一个函数的形式。\n\n这一类问题可以统称为「 最大值极小化 」问题，最原始的问题场景是木棍切割问题，这道题的原始问题是「力扣」第 410 题（分割数组的最大值（困难） [https://leetcode-cn.com/problems/split-array-largest-sum/]）。\n\n思路是这样的：\n\n * 分析出题目要我们找一个整数，这个整数有范围，所以可以用二分查找；\n * 分析出 单调性，一般来说是一个变量 a 的值大了，另一个变量 b 的值就变小，而「另一个变量的值」 b 有限制，因此可以通过调整 a 的值达到控制 b 的效果；\n * 这一类问题的题目条件一定会给出 连续、正整数 这样的关键字。如果没有，问题场景也一定蕴含了这两个关键信息。\n\n以下给出的问题无一例外。\n\n题目提示与题解说明410. 分割数组的最大值（困难） [https://leetcode-cn.com/problems/split-array-largest-sum/]文字题解 [https://leetcode-cn.com/problems/split-array-largest-sum/solution/er-fen-cha-zhao-by-liweiwei1419-4/]875. 爱吃香蕉的珂珂（中等） [https://leetcode-cn.com/problems/koko-eating-bananas/]文字题解 [https://leetcode-cn.com/problems/koko-eating-bananas/solution/er-fen-cha-zhao-ding-wei-su-du-by-liweiwei1419/]LCP 12. 小张刷题计划（中等） [https://leetcode-cn.com/problems/xiao-zhang-shua-ti-ji-hua/]题解在第 410 题题解里1482. 制作 m 束花所需的最少天数（中等） [https://leetcode-cn.com/problems/minimum-number-of-days-to-make-m-bouquets/]题解在第 1300 题题解里1552. 两球之间的磁力（中等） [https://leetcode-cn.com/problems/magnetic-force-between-two-balls/]\n\n\n# 8. 总结\n 1. 首先想清楚这道问题为什么可以用二分查找解决（而不应该先纠结二分查找该怎么写），利用题目中给出的单调性或者可以缩减问题规模的特点：已知某个猜测的答案的结果，就可以推测出比当前猜测小的时候结果如何，比当前猜测大的时候结果如何。常见应用为：有序或者半有序数组中找下标，确定一个有范围的整数。\n    \n    \n 2. 首先确定搜索的范围，如果搜索的范围就把正确答案排除在外，那么是无论如何也搜不出正确结果的；\n    \n    \n 3. 可以从「看到的中间元素什么时候不是解」开始思考 if 的语句怎么写，if 的逻辑越简单越好，这样才能保证不会错，剩下的复杂的情况留给 else，else 的区间就是剩下的区间；\n    \n    \n 4. 只把区间分成两个部分，代码也写成两个部分，这样，在 while (left < right) 的循环体退出以后，left == right 才成立（理解这一点非常重要，理解的基础是做适当的练习，进行必要的调试）；\n    \n    \n 5. 看到 if 和 else 里有 left = mid 的时候，需要将 mid 调整为上取整，原因是当区间里只剩下两个元素的时候，mid 看到右边元素，这样落入 left = mid 的时候，区间才会缩减。如果觉得这一点很难理解的朋友，打印变量看一下就非常清楚了；\n    \n    \n 6. 如果搜索区间里一定存在目标元素，退出 while (left < right) 以后，返回 left 或者 left 代表的值就可以，否则还需要单独做一次判断；\n    \n    \n 7. 不要纠结左闭右闭区间和左闭右开区间。如果你觉得左闭右开区间理解一点问题都没有，当然可以用左闭右开区间定义你的循环不变量。我们通篇介绍的二分查找算法的循环不变量是 [left..right] 里可能存在目标元素，left 包括、right 也包括。\n    \n    \n 8. 一旦掌握了二分查找算法的思想，用哪种二分查找的写法就是习惯的问题了。模板也是人设计出来的，而且就算是模板，也要有理由。生搬硬套模板是不可以的，一定要明白原理，有一些模板声称是捷径，很有可能是弯路。写算法问题，不可以靠模板。\n    \n    \n\n\n\n\n# 9.参考资料\n * 李煜东 著《算法竞赛进阶指南》（河南电子音像出版社）第 0x04 章《二分》\n * 胡凡、曾磊 主编 《算法笔记》（机械工业出版社）第 4.5 节《二分》\n\n# 提交历史\n提交时间提交结果标记状态我的注释执行时间战胜比例内存消耗语言2021-05-23 16:46:32Accepted [https://leetcode-cn.com/submissions/detail/180113992/]🚩🚩🚩二分查找0 ms100.0%37.9 MBjava2018-04-30 22:09:37Accepted [https://leetcode-cn.com/submissions/detail/1833698/]4 ms100.0%N/Ajava# 统计信息\n通过次数提交次数AC比率38239181296947.0%# 相似题目\n题目难度第一个错误的版本 [https://leetcode-cn.com/problems/first-bad-version/]简单',contentLowercase:'# 中文题目\n给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。\n\n你可以假设数组中无重复元素。\n\n示例 1:\n\n输入: [1,3,5,6], 5\n输出: 2\n\n\n示例 2:\n\n输入: [1,3,5,6], 2\n输出: 1\n\n\n示例 3:\n\n输入: [1,3,5,6], 7\n输出: 4\n\n\n示例 4:\n\n输入: [1,3,5,6], 0\n输出: 0\n\n\n# 通过代码\n    class solution {\n        public int searchinsert(int[] nums, int target) {\n            int left=0;\n            int right=nums.length-1;\n            int mid;\n            while (left<=right){\n                mid=left+(right-left)/2;\n                if (nums[mid] == target){\n                    return mid;\n                }\n                if (nums[mid]<target){\n                    left=mid+1;\n                }\n                if (nums[mid]>target){\n                    right=mid-1;\n                }\n            }\n            return left;\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n    class solution {\n        public int searchinsert(int[] nums, int target) {\n            int left=0;\n            int right=nums.length-1;\n            int mid;\n            while (left<=right){\n                mid=left+(right-left)/2;\n                if (nums[mid] == target){\n                    return mid;\n                }\n                if (nums[mid]<target){\n                    left=mid+1;\n                }\n                if (nums[mid]>target){\n                    right=mid-1;\n                }\n            }\n            return left;\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n# 高赞题解\n说明：这篇题解专治二分疑难杂症。\n\n大家不要看篇幅多，这是因为我做了很多问题，所以总结出了这么多需要注意的地方。掌握了二分查找算法的朋友，也绝对不是因为看了我写的二分才真正掌握的，更关键的原因是他们把二分查找的思想进行了足够多的应用。事实上，二分查找法需要学习的、和需要注意的事项并不多，而且很多细节完全不需要记忆。和学习绝大多数算法与数据结构知识一样，多练习、多思考，就能很好地掌握它们。\n\n为了讲清楚我想说的部分，文字部分有点多。实在不想看那么多文字的朋友，可以只看第 3 部分「把待搜索区间分成两个部分」，并且把第 7 部分给出的「练习」做一下。相信会对大家有帮助。\n\n> 掌握二分查找（甚至是其它的算法和数据结构）不可以只看别人写的题解，一定要自己多加练习，配合上自己的思考和总结，才可能做到融会贯通，举一三反。\n\n\n想看「第 35 题」代码的朋友，可以直接跳到「4. 例题讲解：「力扣」第 35 题：搜索插入位置」。\n\n\n\n\n# 0. 前言\n「二分查找」作为一种基础算法，本不该很难，所以希望借这道题的讲解和大家谈谈如何学习算法：\n\n * 「二分查找」就那么几行代码，我们完全有理由充分掌握它，而不可以用记忆模板、背例题的方式；\n * 「二分查找」虽然看起来有很多种写法，「递归」和「非递归」，「非递归」又有好几种写法：while (left <= right)、while (left < right)、while (left + 1 < right)。但核心的思想就一个：逐渐缩小问题规模。我们在学习和练习的时候需要 首先着眼于掌握算法的思想，而不该去纠结二分的几种写法的区别和细节，这样会让自己更乱；\n * 在面对问题的时候，应该将主要精力放在 如何分析，利用单调性（绝大多数二分查找问题利用的是单调性，也有一些例外）或者题目本身蕴含的可以逐渐缩小问题规模的特性解决问题，而不应该纠结在「二分查找」该怎么写。\n\n下面开始正文。\n\n\n\n\n# 1. 二分查找的基本问题\n二分查找的基本问题是「力扣」第 704 题：二分查找 [https://leetcode-cn.com/problems/binary-search/]。\n\n参考代码 1：（第 704 题代码）\n\nclass solution {\n    public int search(int[] nums, int target) {\n        int len = nums.length;\n        int left = 0;\n        int right = len - 1;\n        // 在 [left..right] 里查找 target\n        while (left <= right) {\n            // 为了防止 left + right 整形溢出，写成这样\n            int mid = left + (right - left) / 2;\n            if (nums[mid] == target) {\n                return mid;\n            } else if (nums[mid] > target) {\n                // 下一轮搜索区间：[left..mid - 1]\n                right = mid - 1;\n            } else {\n                // 此时：nums[mid] < target，下一轮搜索区间：[mid + 1..right]\n                left = mid + 1;\n            }\n        }\n        return -1;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n说明：\n\n二分查找的思路是：根据待搜索区间里的中间元素 nums[mid] 与 target 的值的大小关系，判断下一轮搜索需要在哪个区间里查找，进而设置 left 和 right 的值。分为如下三种情况：\n\n * 如果 nums[mid] == target，运气很好，找到了目标元素，返回 mid ；\n * 如果 nums[mid] > target，说明 mid 以及 mid 的 右边 的所有元素一定都比 target 大，下一轮搜索需要在区间 [left..mid - 1] 里查找，此时设置 right = mid - 1；\n * 如果 nums[mid] < target，说明 mid 以及 mid 的 左边 的所有元素一定都比 target 小，下一轮搜索需要在区间 [mid + 1..right] 里查找，此时设置 left = mid + 1。\n\n退出循环的时候，说明区间里不存在目标元素，返回 −1-1−1。\n\n\n\n\n# 2. 二分查找的问题变种\n事实上，「力扣」上的「二分查找」问题没有那么简单。例如，让我们找：\n\n * 大于等于 target 的下标最小的元素；\n * 小于等于 target 的下标最大的元素。\n\n这样的问题有一个特点：当看到了 nums[mid] 恰好等于 target 的时候，还得继续查找，继续看看左边的元素的值，或者继续看看右边元素的值。如果不小心，很可能逻辑写错。如果还用「1. 二分查找的基本问题」介绍的方式编写代码，就没有那么容易：\n\n * while 里面的 if 、else 该怎么写，有没有什么固定的思路？\n * 退出循环以后，right 在左，left 在右，返回 left 还是 right 需要分类讨论。\n\n本题解要介绍的「二分查找」的思想其实不是什么新鲜的事儿。如下图所示，它像极了「双指针」算法，left 和 right 向中间走，直到它们重合在一起。\n\n\n\n这种二分查找的思考路径，不是我发明的（「参考资料」在题解最后）。我一开始看到这种写法也觉得很惊讶，也搞不明白到底怎么回事，但是我看到的解释就只有「这是模板」，但没有看到为什么有这个模板。因此我 尝试去了解它，并使用它，然后整理成这篇题解。用这种二分查找的思路，可以解决「力扣」上 所有的 「二分查找」问题。\n\n\n\n\n# 3. 把待搜索区间分成两个部分（重点、最重要的部分在这里）\n根据看到的中间位置的元素的值 nums[mid] 可以把待搜索区间分为两个部分：\n\n * 一定不存在 目标元素的区间：下一轮搜索的时候，不用考虑它；\n * 可能存在 目标元素的区间：下一轮搜索的时候，需要考虑它。\n\n由于 mid 只可能被分到这两个区间的其中一个，即：while 里面的 if 和 else 就两种写法：\n\n * 如果 mid 分到左边区间，即区间分成 [left..mid] 与 [mid + 1..right]，此时分别设置 right = mid 与 left = mid + 1；\n * 如果 mid 分到右边区间，即区间分成 [left..mid - 1] 与 [mid..right]，此时分别设置 right = mid - 1 与 left = mid。\n\n并且把 循环可以继续的条件 写成 while (left < right)。在上面把待搜索区间分成两个部分的情况下，退出循环以后一定会有 left == right 成立，因此在退出循环以后，不需要考虑到底返回 left 还是返回 right。\n\n这里介绍一个 「重要的经验」：\n\n> 在 写 if 语句的时候，通常把容易想到的，不容易出错的逻辑写在 if 的里面，这样就把复杂的、容易出错的情况放在了 else 的部分，这样编写代码不容易出错。\n\n\n什么情况是容易想到的，不容易出错的呢？我的经验是：题目要我们找符合条件 a 的元素，我们就对条件 a 取反面，这样分析不容易出错。\n\n例如本题（「力扣」第 35 题），题目要我们找出第一个大于等于 target 的元素的下标，那么小于 target 的元素就一定不是我们要找的。因此 if 语句就是\n\nif (nums[mid] < target) {\n\t// 下一轮搜索区间是 [mid + 1..right]\n\tleft = mid + 1;\n}\n\n\n1\n2\n3\n4\n剩下的情况放在 else 中，我们 甚至可以不用分析 else 是什么情况。if 的区间是 [mid + 1..right]，它的反面区间就是 [left..mid]，此时 else 就应该设置 right = mid。\n\n因此完整的逻辑就是：\n\nif (nums[mid] < target) {\n\t// 下一轮搜索区间是 [mid + 1..right]\n\tleft = mid + 1;\n} else {\n\tright = mid;\n}\n\n\n1\n2\n3\n4\n5\n6\n上面的叙述，总结起来就一句话：我们 总是在区间 [left..right] 里查找元素目标。\n\n注意：我们说的是 左闭右闭区间。为什么不是「左闭右开」呢？「左闭右开」当然可以，但是我们 不想把精力花在思考「右边界是不是可以取到」这件事情上，这是因为 任意一个「左闭右开 [left..right) 」区间一定唯一对应一个「左闭右闭 [left..right - 1]」区间，所以到底是开区间还是闭区间，前后保持一致就可以。\n\n根据 mid 位置是不是目标元素，进而判断 mid 的左边是否存在目标元素，mid 的右边是否存在目标元素，只把搜索区间分为两个部分，然后设置 left 和 right，在设置 left 和 right 的时候，左闭右闭区间的形式是最直观的，这是因为如果是开区间，还需要在脑子里反应一下，右端点不包括。如果我们觉得二分问题复杂，复杂问题应该简单做。\n\n我们再说说把区间分成两个部分的好处：\n\n在代码层面，只可能有以下两种情况：\n\n * while(left < right) 与 left = mid + 1 、 right = mid 的搭配；\n * while(left < right) 与 left = mid 、 right = mid - 1 的搭配；\n\n只有在这两种把区间分成两个部分的划分下，退出循环以后有 left == right 成立，我们不用去讨论返回 left 还是 right（这句话非常重要，大家可以在做题的过程中慢慢体会）。\n\n> 补充说明：有的朋友觉得把区间分为三个部分更清晰，但是一旦分成三个部分，有 mid + 1、mid - 1 出现，退出循环以后就不一定有 left 和 right 重合。我们完全可以这样做，分类讨论的时候分成三个部分，然后把它们的逻辑合并起来。\n\n\n在我们的讲解中 while(left < right) 与「定义的区间是 [left..right) 」没有任何关系，请大家不要做多余的解读，我们不讲循环不变量是 [left..right) 的情况，我们只认为区间是「左闭右闭」区间，理由上面也说了，每一个位置的值是不是可以取到，我们需要非常清楚，而不想看到一个开区间，我们在脑子里需要想一下「右端点不包括」。\n\n至于为什么是 left = mid + 1 、 right = mid 搭配使用，而 left = mid 、 right = mid - 1 搭配使用，这一点完全不用记忆，我们画图说明。\n\n{:style="width:500px"}\n\n因此我们再次和大家强调：永远去思考下一轮搜索应该在哪个区间里，就能考虑清楚到底下一轮更新的是 left 还是 right ，到底加不加 1，到底减不减 1。\n\n\n\n\n# 4. 例题讲解：「力扣」第 35 题：搜索插入位置\n思路分析：\n\n根据示例 3：\n\n输入: [1, 3, 5, 6], 7\n输出: 4\n\n\n1\n2\n如果目标元素大于输入数组中的最后一个元素，返回数组的最后一个元素的下标 + 1。\n\n根据示例 2：\n\n输入: [1,3,5,6], 2\n输出: 1\n\n\n1\n2\n需要返回第 1 个 大于等于（等于的情况可以看示例 1，这里省略） 目标元素 2 的下标，因此输出 1。因此 如果当前 mid 看到的数值严格小于 target，那么 mid 以及 mid 左边的所有元素就一定不是题目要求的输出，就根据这一点可以写出本题二分查找算法的完整逻辑。\n\n参考代码 2：（第 35 题代码）\n\npublic class solution {\n\n    public int searchinsert(int[] nums, int target) {\n        int len = nums.length;\n        // 特殊判断\n        if (nums[len - 1] < target) {\n            return len;\n        }\n\n        // 程序走到这里一定有 target <= nums[len - 1]\n        int left = 0;\n        int right = len - 1;\n        // 在区间 nums[left..right] 里查找第 1 个大于等于 target 的元素的下标\n        while (left < right) {\n            int mid = left + (right - left) / 2;\n            if (nums[mid] < target){\n                // 下一轮搜索的区间是 [mid + 1..right]\n                left = mid + 1;\n            } else {\n                // 下一轮搜索的区间是 [left..mid]\n                right = mid;\n            }\n        }\n        return left;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n值得一提的是：由于执行到最后 nums[left..right] 里一定存在插入元素的位置，并且退出循环的时候一定有 left == right 成立，因此直接返回 left 或者 right 均可。\n\n这样的思路还可以完成第 704 题。\n\n参考代码 3：（第 704 题代码）\n\nclass solution {\n    public int search(int[] nums, int target) {\n        int len = nums.length;\n        int left = 0;\n        int right = len - 1;\n        // 在 nums[left..right] 里查找 target\n        while (left < right) {\n            // 为了防止 left + right 整形溢出，写成这样\n            int mid = left + (right - left) / 2;\n            if (nums[mid] < target) {\n                // 下一轮搜索区间：[mid + 1..right]\n                left = mid + 1;\n            } else {\n                // 下一轮搜索区间：[left..mid]\n                right = mid;\n            }\n        }\n        \n        if (nums[left] == target){\n            return left;\n        }\n        return -1;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\nclass solution {\n    public int search(int[] nums, int target) {\n        int len = nums.length;\n        int left = 0;\n        int right = len - 1;\n        // 在 nums[left..right] 里查找 target\n        while (left < right) {\n            // 为了防止 left + right 整形溢出，写成这样\n            int mid = left + (right - left + 1) / 2;\n            if (nums[mid] > target) {\n                // 下一轮搜索区间：[left..mid - 1]\n                right = mid - 1;\n            } else {\n                // 下一轮搜索区间：[mid..right]\n                left = mid;\n            }\n        }\n        \n        if (nums[left] == target){\n            return left;\n        }\n        return -1;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n * 退出循环的时候，我们不能确定 nums[left] 是否等于 target，因此还需要单独做一次判断；\n * 「选项卡二」我们还给出了一版代码，具体细节大家可以在阅读完本题解以后再来理解它。\n\n\n\n\n# 5. 两种写法对比\n写法 1： while(left <= right) 这种写法可以认为我们在循环体内部直接查找元素，把当前搜索区间分为三个部分。\n\n程序开始的时候，我们对输入数组一无所知。\n\n{:style="width: 400px"}\n\n我们选择 nums[mid] 的值看一下。\n\n{:style="width: 400px"}\n\n如果中间位置的元素的值等于目标元素就直接返回。如果中间位置的元素不是目标元素，可以根据中间位置元素的值决定在中间位置的左边还是右边继续查找。这种查找方式把待搜索区间分为三个部分：左、中、右。\n\n{:style="width: 400px"}\n\n重要经验：如果我们要找的元素性质非常明确、并且简单，通常这样写就可以。例如「力扣」第 704 题（二分查找 [https://leetcode-cn.com/problems/binary-search]），第 633 题（平方数之和 [https://leetcode-cn.com/problems/sum-of-square-numbers]）。\n\n写法 2：while(left < right) 这种写法表示在循环体内部排除元素，把当前搜索区间分为两个部分。\n\n这种思路可以很形象地理解为「两边夹」，在解决复杂问题的时候，会使得思考的过程变得简单。\n\n程序开始的时候，我们对输入数组一无所知（这一步和写法 1 一样）。\n\n{:style="width: 400px"}\n\n我们选择 nums[mid] 的值看一下（这一步和写法 1 一样）。\n\n{:style="width: 400px"}\n\n然后我们只分析：在什么情况下，目标元素位于哪个区间里，把区间分成「一定不存在目标元素的区间」和「可能存在目标元素的区间」。而 mid 只可能位于这两个区间的其中一个，可以分为下面 4 种情况。\n\n{:style="width: 400px"}\n\n虽然看起来比较多，但是归结起来就 2 种情况：mid 在左边区间和 mid 在右边区间。即：根据 mid 的值，可以判断 nums[mid] 是「一定不是目标元素」还是「有可能是目标元素」，进而判断 mid 的左右两边的区间的性质。\n\n重要经验：\n\n如果我们要找的元素的性质比较复杂：例如需要满足「条件 1」并且「条件 2」。我们在编写 if 语句的时候，就可以把其中一个条件取反，就可以达到缩减搜索区间的目的。\n\n这一点也不难想明白，「条件 1」并且「条件 2」的反面就是「取反条件 1」或者「取反条件 2」。再举一个具体的例子：例如我们要找一个数 xxx，需要满足 4≤x≤94 \\le x \\le 94≤x≤9，即 x≥4x \\ge 4x≥4 并且 x≤9x \\le 9x≤9。如果我们看到一个数小于 444，我们就知道此时需要在当前位置的右边继续查找，可以得到缩减问题区间的目的。\n\n「力扣」第 4 题（寻找两个正序数组的中位数 [https://leetcode-cn.com/problems/median-of-two-sorted-arrays/]）的 视频题解 [https://leetcode-cn.com/problems/median-of-two-sorted-arrays/solution/xun-zhao-liang-ge-you-xu-shu-zu-de-zhong-wei-s-114/]，我们详细介绍了用这种思路分析问题的方法，并给出了 2 版等价的代码。\n\n\n\n\n# 6. 一些细节（以问答形式呈现）\n# 细节一：为什么有些时候取 mid 的时候需要上取整？\n回答：是否需要上取整，只和区间划分的逻辑有关。如果不调整，会出现死循环。\n\n\n\n初次接触的时候，很多朋友觉得这件事情非常难以理解，我们的建议是：一旦遇到死循环，可以在程序中输出 left、right 和 mid 的值看一下就很清楚了。「力扣」第 69 题：x 的平方根 [https://leetcode-cn.com/problems/sqrtx/] 的 题解 [https://leetcode-cn.com/problems/sqrtx/solution/er-fen-cha-zhao-niu-dun-fa-python-dai-ma-by-liweiw/] ，我们演示了如何打印变量、观察到死循环。\n\n结论：当区间只剩下两个元素的时候，left = mid 和 right = mid - 1 这种划分方式，如果 mid 使用默认下取整的方式，在数值上 left = mid，而它对应的其中一个区间是 [mid..right]，在这种情况下，下一轮搜索区间还是 [left..right]，搜索区间没有减少，会进入死循环。\n\n提示：「看到边界设置的代码是 left = mid 时，需要把 mid 的取法调整为上取整，以避免死循环」，这件事情也完全不用记忆，题目做得多了，自然而然就记住了。还是我们在题解中和大家多次强调的一件事情：遇到代码出错的时候，一定要耐心调试，把变量打印出来看一下，是最好的学习的方法。\n\n# 细节二：有些学习资料上说 while (left < right) 表示区间是 [left..rihgt) ，为什么你这里是 [left..rihgt]？\n回答：区间的右端点到底是开还是闭，完全由编写代码的人决定，不需要固定。只要编码的人逻辑前后一致，并且保持不变（这件事情叫遵守「循环不变量」），就是正确的。\n\n我们通篇讲的都是 左闭右闭 区间，理由是这样定义更直接。\n\n# 细节三：有些学习资料给出了三种模板，例如「力扣」推出的 leetbook 之 「二分查找专题 [https://leetcode-cn.com/leetbook/detail/binary-search/]」，应该如何看待它们？\n回答：我在学习的时候，leetbook 也是我重要的学习材料之一。三种模板其实区别仅在于退出循环的时候，区间 [left..right] 里有几个数。\n\n * while (left <= right) ：退出循环的时候，right 在左，left 在右，区间为空区间，所以要讨论返回 left 和 right；\n * while (left < right) ：退出循环的时候，left 与 right 重合，区间里只有一个元素，这一点是我们很喜欢的；\n * while (left + 1< right) ：退出循环的时候，left 在左，right 在右，区间里有 2 个元素，需要编写专门的逻辑。这种写法在设置 left 和 right 的时候不需要加 1 和减 1。看似简化了思考的难度，但实际上屏蔽了我们应该且完全可以分析清楚的细节。退出循环以后一定需要编写专门的逻辑，讨论返回哪一个，也增加了编码的难度。\n\n我个人的经验是：完全不用第三个，理由是不会使得问题变得更简单，反而很累赘。\n\n我常用头两个，第一个在简单问题中用，第二个在复杂问题中用。在题解的第 5 部分「5. 两种写法对比」的「重要经验」里也叙述了用它们的理由和场景。\n\n\n\n\n# 7. 练习\n提示：这些问题都不应该当做模板问题来看待，逻辑严密的分析与思考是更关键的。我们针对这些问题都提供了题解，重点分析了应该如何思考，讲解了如何编写正确的代码，希望能够对大家有所帮助。\n\n# 题型一：二分下标（在数组中查找符合条件的元素的下标）\n一般而言这个数组是有序的，也可能是半有序的（旋转有序数组或者山脉数组）。\n\n题目题解说明704. 二分查找（简单） [https://leetcode-cn.com/problems/binary-search/]二分查找的最原始问题，使用本题解介绍的方法就要注意，需要后处理。34. 在排序数组中查找元素的第一个和最后一个位置（中等） [https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/]文字题解 [https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/solution/si-lu-hen-jian-dan-xi-jie-fei-mo-gui-de-er-fen-cha/]、视频题解 [https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/solution/zai-pai-xu-shu-zu-zhong-cha-zhao-yuan-su-de-di-3-4/]查找边界问题。33. 搜索旋转排序数组（中等） [https://leetcode-cn.com/problems/search-in-rotated-sorted-array/]文字题解 [https://leetcode-cn.com/problems/search-in-rotated-sorted-array/solution/er-fen-fa-python-dai-ma-java-dai-ma-by-liweiwei141/]利用局部单调性，逐步缩小搜索区间（其它问题类似）。81. 搜索旋转排序数组 ii（中等） [https://leetcode-cn.com/problems/search-in-rotated-sorted-array-ii/]文字题解 [https://leetcode-cn.com/problems/search-in-rotated-sorted-array-ii/solution/er-fen-cha-zhao-by-liweiwei1419/]153. 寻找旋转排序数组中的最小值（中等） [https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/]文字题解 [https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/solution/er-fen-fa-fen-zhi-fa-python-dai-ma-java-dai-ma-by-/]154. 寻找旋转排序数组中的最小值 ii（中等） [https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/]文字题解 [https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/solution/er-fen-fa-fen-zhi-fa-python-dai-ma-by-liweiwei1419/]300. 最长上升子序列（中等） [https://leetcode-cn.com/problems/longest-increasing-subsequence/]文字题解 [https://leetcode-cn.com/problems/longest-increasing-subsequence/solution/dong-tai-gui-hua-er-fen-cha-zhao-tan-xin-suan-fa-p/]。特别经典的一道「动态规划」，二分查找的思路基于「动态规划」的状态定义得到，代码很像第 35 题。275. h指数 ii（中等） [https://leetcode-cn.com/problems/h-index-ii/]文字题解 [https://leetcode-cn.com/problems/h-index-ii/solution/jian-er-zhi-zhi-er-fen-cha-zhao-by-liweiwei1419-2/]这个问题题目的描述让人迷惑，可以跳过不做。852. 山脉数组的峰顶索引（简单） [https://leetcode-cn.com/problems/peak-index-in-a-mountain-array/]利用局部单调性，逐步缩小搜索区间。1095. 山脉数组中查找目标值（中等） [https://leetcode-cn.com/problems/find-in-mountain-array/]文字题解 [https://leetcode-cn.com/problems/find-in-mountain-array/solution/shi-yong-chao-hao-yong-de-er-fen-fa-mo-ban-python-/]、视频题解 [https://leetcode-cn.com/problems/find-in-mountain-array/solution/shan-mai-shu-zu-zhong-cha-zhao-mu-biao-zhi-by-leet/]4. 寻找两个有序数组的中位数（困难） [https://leetcode-cn.com/problems/median-of-two-sorted-arrays/]文字题解 [https://leetcode-cn.com/problems/median-of-two-sorted-arrays/solution/he-bing-yi-hou-zhao-gui-bing-guo-cheng-zhong-zhao-/]、视频题解 [https://leetcode-cn.com/problems/median-of-two-sorted-arrays/solution/xun-zhao-liang-ge-you-xu-shu-zu-de-zhong-wei-s-114/]658. 找到 k 个最接近的元素（中等） [https://leetcode-cn.com/problems/find-k-closest-elements/]文字题解 [https://leetcode-cn.com/problems/find-k-closest-elements/solution/pai-chu-fa-shuang-zhi-zhen-er-fen-fa-python-dai-ma/]这个问题二分的写法需要做复杂的分类讨论，可以放在以后做。# 题型二：二分答案（在一个有范围的区间里搜索一个整数）\n定位一个有范围的整数，这件事情也叫「二分答案」或者叫「二分结果」。如果题目要求的是一个整数，这个整数有明确的范围，可以考虑使用二分查找。\n\n事实上，二分答案是我们最早接触的二分查找的场景。「幸运 52」里猜价格游戏，就是「二分查找」算法的典型应用：先随便猜一个数，如果猜中，游戏结束。如果猜大了，往小猜；如果猜小了，往大猜。\n\n题目题解说明69. 平方根（简单） [https://leetcode-cn.com/problems/sqrtx/]文字题解 [https://leetcode-cn.com/problems/sqrtx/solution/er-fen-cha-zhao-niu-dun-fa-python-dai-ma-by-liweiw/]在一个整数范围里查找一个整数，也是二分查找法的应用场景。287. 寻找重复数（中等） [https://leetcode-cn.com/problems/find-the-duplicate-number/]文字题解 [https://leetcode-cn.com/problems/find-the-duplicate-number/solution/er-fen-fa-si-lu-ji-dai-ma-python-by-liweiwei1419/]在一个整数范围里查找一个整数。这个问题二分查找的解法很反常规（不应该用时间换空间，这么做太傻了），知道即可。374. 猜数字大小（简单） [https://leetcode-cn.com/problems/guess-number-higher-or-lower/]文字题解 [https://leetcode-cn.com/problems/guess-number-higher-or-lower/solution/shi-fen-hao-yong-de-er-fen-cha-zhao-fa-mo-ban-pyth/]1300. 转变数组后最接近目标值的数组和 [https://leetcode-cn.com/problems/sum-of-mutated-array-closest-to-target/]文字题解 [https://leetcode-cn.com/problems/sum-of-mutated-array-closest-to-target/solution/er-fen-cha-zhao-by-liweiwei1419-2/]# 题型三：二分答案的升级版：判别条件需要遍历数组\n说明：这里给出的问题解法都一样，会一题等于会其它题。问题的场景会告诉我们：目标变量和另一个变量有相关关系（一般是线性关系），目标变量的性质不好推测，但是另一个变量的性质相对容易推测（满足某种意义上的单调性）。这样的问题的判别函数通常会写成一个函数的形式。\n\n这一类问题可以统称为「 最大值极小化 」问题，最原始的问题场景是木棍切割问题，这道题的原始问题是「力扣」第 410 题（分割数组的最大值（困难） [https://leetcode-cn.com/problems/split-array-largest-sum/]）。\n\n思路是这样的：\n\n * 分析出题目要我们找一个整数，这个整数有范围，所以可以用二分查找；\n * 分析出 单调性，一般来说是一个变量 a 的值大了，另一个变量 b 的值就变小，而「另一个变量的值」 b 有限制，因此可以通过调整 a 的值达到控制 b 的效果；\n * 这一类问题的题目条件一定会给出 连续、正整数 这样的关键字。如果没有，问题场景也一定蕴含了这两个关键信息。\n\n以下给出的问题无一例外。\n\n题目提示与题解说明410. 分割数组的最大值（困难） [https://leetcode-cn.com/problems/split-array-largest-sum/]文字题解 [https://leetcode-cn.com/problems/split-array-largest-sum/solution/er-fen-cha-zhao-by-liweiwei1419-4/]875. 爱吃香蕉的珂珂（中等） [https://leetcode-cn.com/problems/koko-eating-bananas/]文字题解 [https://leetcode-cn.com/problems/koko-eating-bananas/solution/er-fen-cha-zhao-ding-wei-su-du-by-liweiwei1419/]lcp 12. 小张刷题计划（中等） [https://leetcode-cn.com/problems/xiao-zhang-shua-ti-ji-hua/]题解在第 410 题题解里1482. 制作 m 束花所需的最少天数（中等） [https://leetcode-cn.com/problems/minimum-number-of-days-to-make-m-bouquets/]题解在第 1300 题题解里1552. 两球之间的磁力（中等） [https://leetcode-cn.com/problems/magnetic-force-between-two-balls/]\n\n\n# 8. 总结\n 1. 首先想清楚这道问题为什么可以用二分查找解决（而不应该先纠结二分查找该怎么写），利用题目中给出的单调性或者可以缩减问题规模的特点：已知某个猜测的答案的结果，就可以推测出比当前猜测小的时候结果如何，比当前猜测大的时候结果如何。常见应用为：有序或者半有序数组中找下标，确定一个有范围的整数。\n    \n    \n 2. 首先确定搜索的范围，如果搜索的范围就把正确答案排除在外，那么是无论如何也搜不出正确结果的；\n    \n    \n 3. 可以从「看到的中间元素什么时候不是解」开始思考 if 的语句怎么写，if 的逻辑越简单越好，这样才能保证不会错，剩下的复杂的情况留给 else，else 的区间就是剩下的区间；\n    \n    \n 4. 只把区间分成两个部分，代码也写成两个部分，这样，在 while (left < right) 的循环体退出以后，left == right 才成立（理解这一点非常重要，理解的基础是做适当的练习，进行必要的调试）；\n    \n    \n 5. 看到 if 和 else 里有 left = mid 的时候，需要将 mid 调整为上取整，原因是当区间里只剩下两个元素的时候，mid 看到右边元素，这样落入 left = mid 的时候，区间才会缩减。如果觉得这一点很难理解的朋友，打印变量看一下就非常清楚了；\n    \n    \n 6. 如果搜索区间里一定存在目标元素，退出 while (left < right) 以后，返回 left 或者 left 代表的值就可以，否则还需要单独做一次判断；\n    \n    \n 7. 不要纠结左闭右闭区间和左闭右开区间。如果你觉得左闭右开区间理解一点问题都没有，当然可以用左闭右开区间定义你的循环不变量。我们通篇介绍的二分查找算法的循环不变量是 [left..right] 里可能存在目标元素，left 包括、right 也包括。\n    \n    \n 8. 一旦掌握了二分查找算法的思想，用哪种二分查找的写法就是习惯的问题了。模板也是人设计出来的，而且就算是模板，也要有理由。生搬硬套模板是不可以的，一定要明白原理，有一些模板声称是捷径，很有可能是弯路。写算法问题，不可以靠模板。\n    \n    \n\n\n\n\n# 9.参考资料\n * 李煜东 著《算法竞赛进阶指南》（河南电子音像出版社）第 0x04 章《二分》\n * 胡凡、曾磊 主编 《算法笔记》（机械工业出版社）第 4.5 节《二分》\n\n# 提交历史\n提交时间提交结果标记状态我的注释执行时间战胜比例内存消耗语言2021-05-23 16:46:32accepted [https://leetcode-cn.com/submissions/detail/180113992/]🚩🚩🚩二分查找0 ms100.0%37.9 mbjava2018-04-30 22:09:37accepted [https://leetcode-cn.com/submissions/detail/1833698/]4 ms100.0%n/ajava# 统计信息\n通过次数提交次数ac比率38239181296947.0%# 相似题目\n题目难度第一个错误的版本 [https://leetcode-cn.com/problems/first-bad-version/]简单'},{title:"20-有效的括号(Valid Parentheses)",frontmatter:{title:"20-有效的括号(Valid Parentheses)",date:"2021-04-17T00:00:00.000Z",categories:["简单"],tags:["栈<Stack>","字符串<String>"]},regularPath:"/views/%E7%AE%80%E5%8D%95/0020-%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7.html",relativePath:"views/简单/0020-有效的括号.md",key:"v-dd4bf7e4",path:"/views/%E7%AE%80%E5%8D%95/0020-%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7.html",headers:[{level:2,title:"中文题目",slug:"中文题目",charIndex:2},{level:2,title:"通过代码",slug:"通过代码",charIndex:311},{level:2,title:"我的笔记",slug:"我的笔记",charIndex:4700},{level:2,title:"高赞题解",slug:"高赞题解",charIndex:4726},{level:2,title:"提交历史",slug:"提交历史",charIndex:6557},{level:2,title:"统计信息",slug:"统计信息",charIndex:7288},{level:2,title:"相似题目",slug:"相似题目",charIndex:7325}],lastUpdated:"4/11/2021, 1:15:21 PM",headersStr:"中文题目 通过代码 我的笔记 高赞题解 提交历史 统计信息 相似题目",content:"# 中文题目\n给定一个只包括 '('，')'，'{'，'}'，'['，']'的字符串 s ，判断字符串是否有效。\n\n有效字符串需满足：\n\n 1. 左括号必须用相同类型的右括号闭合。\n 2. 左括号必须以正确的顺序闭合。\n\n\n\n示例 1：\n\n\n输入：s = \"()\"\n输出：true\n\n\n示例 2：\n\n\n输入：s = \"()[]{}\"\n输出：true\n\n\n示例 3：\n\n\n输入：s = \"(]\"\n输出：false\n\n\n示例 4：\n\n\n输入：s = \"([)]\"\n输出：false\n\n\n示例 5：\n\n\n输入：s = \"{[]}\"\n输出：true\n\n\n\n提示：\n\n * 1 4\n * s 仅由括号 '()[]{}' 组成\n\n# 通过代码\n    class Solution {\n        public boolean isValid(String s) {\n            while (s.length()>0){\n                if (s.contains(\"()\")) {\n                    s=s.replace(\"()\", \"\");\n                    continue;\n                }\n                if (s.contains(\"[]\")){\n                    s=s.replace(\"[]\",\"\");\n                    continue;\n                }\n                if (s.contains(\"{}\")) {\n                    s=s.replace(\"{}\", \"\");\n                    continue;\n                }\n                if (s.length()>0){\n                    return false;\n                }\n            }\n            return true;\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\npublic class Solution {\n    public boolean isValid(String s) {\n        Stack<Integer> p = new Stack<>();\n        for(int i = 0; i < s.length(); i++) {\n            int q = \"(){}[]\".indexOf(s.substring(i, i + 1));\n            if(q % 2 == 1) {\n                if(p.isEmpty() || p.pop() != q - 1) return false;\n            } else p.push(q);\n        }\n        return p.isEmpty();\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\nclass Solution {\n    public boolean isValid(String s) {\n        Stack<Character> stack = new Stack<Character>();\n        int n = s.length();\n\n        for (int i = 0; i < n; i++) {\n            char c = s.charAt(i);\n            if (c == '(' || c == '[' || c == '{')\n                stack.push(c);\n            else if ((c == ')' && (stack.isEmpty() || stack.pop() != '(')) ||\n                    (c == ']' && (stack.isEmpty() || stack.pop() != '[')) ||\n                    (c == '}' && (stack.isEmpty() || stack.pop() != '{')))\n                return false;\n        }\n        return stack.isEmpty();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\nclass Solution {\n    public boolean isValid(String s) {\n        Stack<Character> stack = new Stack<Character>();\n        int n = s.length();\n\n        for (int i = 0; i < n; i++) {\n            char c = s.charAt(i);\n            if (c == '(' || c == '[' || c == '{')\n                stack.push(c);\n            else if ((c == ')' && (stack.isEmpty() || stack.pop() != '(')) ||\n                    (c == ']' && (stack.isEmpty() || stack.pop() != '[')) ||\n                    (c == '}' && (stack.isEmpty() || stack.pop() != '{')))\n                return false;\n        }\n        return stack.isEmpty();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\nclass Solution {\npublic boolean isValid(String s) {\n       if(s.length() % 2 == 1)\n       return false;\n    \n\t\tchar[] stack = new char[s.length()];\n\t\tint head = 0;\n\t\tfor(char c : s.toCharArray()) {\n\t\t\tswitch(c) {\n\t\t\t\tcase '{':\n\t\t\t\tcase '[':\n\t\t\t\tcase '(':\n\t\t\t\t\tstack[head++] = c;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '}':\n\t\t\t\t\tif(head == 0 || stack[--head] != '{') return false;\n\t\t\t\t\tbreak;\n\t\t\t\tcase ')':\n\t\t\t\t\tif(head == 0 || stack[--head] != '(') return false;\n\t\t\t\t\tbreak;\n\t\t\t\tcase ']':\n\t\t\t\t\tif(head == 0 || stack[--head] != '[') return false;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn head == 0;\n\n\t}\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\nclass Solution {\n    public boolean isValid(String s) {\n        Stack<Character> stack = new Stack<Character>();\n        int n = s.length();\n\n        for (int i = 0; i < n; i++) {\n            char c = s.charAt(i);\n            if (c == '(' || c == '[' || c == '{')\n                stack.push(c);\n            else if ((c == ')' && (stack.isEmpty() || stack.pop() != '(')) ||\n                    (c == ']' && (stack.isEmpty() || stack.pop() != '[')) ||\n                    (c == '}' && (stack.isEmpty() || stack.pop() != '{')))\n                return false;\n        }\n        return stack.isEmpty();\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n    class Solution {\n        public boolean isValid(String s) {\n            while (s.length()>0){\n                if (s.contains(\"()\")) {\n                    s=s.replace(\"()\", \"\");\n                    continue;\n                }\n                if (s.contains(\"[]\")){\n                    s=s.replace(\"[]\",\"\");\n                    continue;\n                }\n                if (s.contains(\"{}\")) {\n                    s=s.replace(\"{}\", \"\");\n                    continue;\n                }\n                if (s.length()>0){\n                    return false;\n                }\n            }\n            return true;\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n# 我的笔记\n可以不使用栈，使用字符串替换的方式\n\n# 高赞题解\n# 解题思路：\n * 算法原理\n   \n    * 栈先入后出特点恰好与本题括号排序特点一致，即若遇到左括号入栈，遇到右括号时将对应栈顶左括号出栈，则遍历完所有括号后 stack 仍然为空；\n    * 建立哈希表 dic 构建左右括号对应关系：keykeykey 左括号，valuevaluevalue 右括号；这样查询 222 个括号是否对应只需 O(1)O(1)O(1) 时间复杂度；建立栈 stack，遍历字符串 s 并按照算法流程一一判断。\n   \n   \n * 算法流程\n   \n    1. 如果 c 是左括号，则入栈 pushpushpush；\n    2. 否则通过哈希表判断括号对应关系，若 stack 栈顶出栈括号 stack.pop() 与当前遍历括号 c 不对应，则提前返回 falsefalsefalse。\n   \n   \n * 提前返回 falsefalsefalse\n   \n    * 提前返回优点： 在迭代过程中，提前发现不符合的括号并且返回，提升算法效率。\n    * 解决边界问题： * 栈 stack 为空： 此时 stack.pop() 操作会报错；因此，我们采用一个取巧方法，给 stack 赋初值 ??? ，并在哈希表 dic 中建立 key:′?′，value:′?′key: '?'，value:'?'key:′?′，value:′?′ 的对应关系予以配合。此时当 stack 为空且 c 为右括号时，可以正常提前返回 falsefalsefalse；\n       * 字符串 s 以左括号结尾： 此情况下可以正常遍历完整个 s，但 stack 中遗留未出栈的左括号；因此，最后需返回 len(stack) == 1，以判断是否是有效的括号组合。\n      \n      \n   \n   \n * 复杂度分析\n   \n    * 时间复杂度 O(N)O(N)O(N)：正确的括号组合需要遍历 111 遍 s；\n    * 空间复杂度 O(N)O(N)O(N)：哈希表和栈使用线性的空间大小。\n   \n   \n\n<,,,,,>\n\n# 代码：\nclass Solution:\n    def isValid(self, s: str) -> bool:\n        dic = {'{': '}',  '[': ']', '(': ')', '?': '?'}\n        stack = ['?']\n        for c in s:\n            if c in dic: stack.append(c)\n            elif dic[stack.pop()] != c: return False \n        return len(stack) == 1\n\n\n1\n2\n3\n4\n5\n6\n7\n8\nclass Solution {\n    private static final Map<Character,Character> map = new HashMap<Character,Character>(){{\n        put('{','}'); put('[',']'); put('(',')'); put('?','?');\n    }};\n    public boolean isValid(String s) {\n        if(s.length() > 0 && !map.containsKey(s.charAt(0))) return false;\n        LinkedList<Character> stack = new LinkedList<Character>() {{ add('?'); }};\n        for(Character c : s.toCharArray()){\n            if(map.containsKey(c)) stack.addLast(c);\n            else if(map.get(stack.removeLast()) != c) return false;\n        }\n        return stack.size() == 1;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2021-04-17 13:57:53Accepted [https://leetcode-cn.com//submissions/detail/168858435/]51 ms100.0%39.2 MBjava2018-07-16 19:35:09Accepted [https://leetcode-cn.com//submissions/detail/4250168/]11 ms100.0%N/Ajava2017-11-19 22:40:49Accepted [https://leetcode-cn.com//submissions/detail/1149031/]9 ms100.0%N/Ajava2017-11-19 22:39:27Accepted [https://leetcode-cn.com//submissions/detail/1149019/]9 ms100.0%N/Ajava2017-11-19 22:36:54Accepted [https://leetcode-cn.com//submissions/detail/1149020/]12 ms100.0%N/Ajava2017-11-19 22:35:20Accepted [https://leetcode-cn.com//submissions/detail/1149017/]6 ms100.0%N/Ajava2017-11-19 22:32:26Accepted [https://leetcode-cn.com//submissions/detail/1149028/]7 ms100.0%N/Ajava# 统计信息\n通过次数提交次数AC比率605425137686344.0%# 相似题目\n题目难度括号生成 [https://leetcode-cn.com/problems/generate-parentheses/]中等最长有效括号 [https://leetcode-cn.com/problems/longest-valid-parentheses/]困难删除无效的括号 [https://leetcode-cn.com/problems/remove-invalid-parentheses/]困难检查替换后的词是否有效 [https://leetcode-cn.com/problems/check-if-word-is-valid-after-substitutions/]中等",contentLowercase:"# 中文题目\n给定一个只包括 '('，')'，'{'，'}'，'['，']'的字符串 s ，判断字符串是否有效。\n\n有效字符串需满足：\n\n 1. 左括号必须用相同类型的右括号闭合。\n 2. 左括号必须以正确的顺序闭合。\n\n\n\n示例 1：\n\n\n输入：s = \"()\"\n输出：true\n\n\n示例 2：\n\n\n输入：s = \"()[]{}\"\n输出：true\n\n\n示例 3：\n\n\n输入：s = \"(]\"\n输出：false\n\n\n示例 4：\n\n\n输入：s = \"([)]\"\n输出：false\n\n\n示例 5：\n\n\n输入：s = \"{[]}\"\n输出：true\n\n\n\n提示：\n\n * 1 4\n * s 仅由括号 '()[]{}' 组成\n\n# 通过代码\n    class solution {\n        public boolean isvalid(string s) {\n            while (s.length()>0){\n                if (s.contains(\"()\")) {\n                    s=s.replace(\"()\", \"\");\n                    continue;\n                }\n                if (s.contains(\"[]\")){\n                    s=s.replace(\"[]\",\"\");\n                    continue;\n                }\n                if (s.contains(\"{}\")) {\n                    s=s.replace(\"{}\", \"\");\n                    continue;\n                }\n                if (s.length()>0){\n                    return false;\n                }\n            }\n            return true;\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\npublic class solution {\n    public boolean isvalid(string s) {\n        stack<integer> p = new stack<>();\n        for(int i = 0; i < s.length(); i++) {\n            int q = \"(){}[]\".indexof(s.substring(i, i + 1));\n            if(q % 2 == 1) {\n                if(p.isempty() || p.pop() != q - 1) return false;\n            } else p.push(q);\n        }\n        return p.isempty();\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\nclass solution {\n    public boolean isvalid(string s) {\n        stack<character> stack = new stack<character>();\n        int n = s.length();\n\n        for (int i = 0; i < n; i++) {\n            char c = s.charat(i);\n            if (c == '(' || c == '[' || c == '{')\n                stack.push(c);\n            else if ((c == ')' && (stack.isempty() || stack.pop() != '(')) ||\n                    (c == ']' && (stack.isempty() || stack.pop() != '[')) ||\n                    (c == '}' && (stack.isempty() || stack.pop() != '{')))\n                return false;\n        }\n        return stack.isempty();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\nclass solution {\n    public boolean isvalid(string s) {\n        stack<character> stack = new stack<character>();\n        int n = s.length();\n\n        for (int i = 0; i < n; i++) {\n            char c = s.charat(i);\n            if (c == '(' || c == '[' || c == '{')\n                stack.push(c);\n            else if ((c == ')' && (stack.isempty() || stack.pop() != '(')) ||\n                    (c == ']' && (stack.isempty() || stack.pop() != '[')) ||\n                    (c == '}' && (stack.isempty() || stack.pop() != '{')))\n                return false;\n        }\n        return stack.isempty();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\nclass solution {\npublic boolean isvalid(string s) {\n       if(s.length() % 2 == 1)\n       return false;\n    \n\t\tchar[] stack = new char[s.length()];\n\t\tint head = 0;\n\t\tfor(char c : s.tochararray()) {\n\t\t\tswitch(c) {\n\t\t\t\tcase '{':\n\t\t\t\tcase '[':\n\t\t\t\tcase '(':\n\t\t\t\t\tstack[head++] = c;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '}':\n\t\t\t\t\tif(head == 0 || stack[--head] != '{') return false;\n\t\t\t\t\tbreak;\n\t\t\t\tcase ')':\n\t\t\t\t\tif(head == 0 || stack[--head] != '(') return false;\n\t\t\t\t\tbreak;\n\t\t\t\tcase ']':\n\t\t\t\t\tif(head == 0 || stack[--head] != '[') return false;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn head == 0;\n\n\t}\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\nclass solution {\n    public boolean isvalid(string s) {\n        stack<character> stack = new stack<character>();\n        int n = s.length();\n\n        for (int i = 0; i < n; i++) {\n            char c = s.charat(i);\n            if (c == '(' || c == '[' || c == '{')\n                stack.push(c);\n            else if ((c == ')' && (stack.isempty() || stack.pop() != '(')) ||\n                    (c == ']' && (stack.isempty() || stack.pop() != '[')) ||\n                    (c == '}' && (stack.isempty() || stack.pop() != '{')))\n                return false;\n        }\n        return stack.isempty();\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n    class solution {\n        public boolean isvalid(string s) {\n            while (s.length()>0){\n                if (s.contains(\"()\")) {\n                    s=s.replace(\"()\", \"\");\n                    continue;\n                }\n                if (s.contains(\"[]\")){\n                    s=s.replace(\"[]\",\"\");\n                    continue;\n                }\n                if (s.contains(\"{}\")) {\n                    s=s.replace(\"{}\", \"\");\n                    continue;\n                }\n                if (s.length()>0){\n                    return false;\n                }\n            }\n            return true;\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n# 我的笔记\n可以不使用栈，使用字符串替换的方式\n\n# 高赞题解\n# 解题思路：\n * 算法原理\n   \n    * 栈先入后出特点恰好与本题括号排序特点一致，即若遇到左括号入栈，遇到右括号时将对应栈顶左括号出栈，则遍历完所有括号后 stack 仍然为空；\n    * 建立哈希表 dic 构建左右括号对应关系：keykeykey 左括号，valuevaluevalue 右括号；这样查询 222 个括号是否对应只需 o(1)o(1)o(1) 时间复杂度；建立栈 stack，遍历字符串 s 并按照算法流程一一判断。\n   \n   \n * 算法流程\n   \n    1. 如果 c 是左括号，则入栈 pushpushpush；\n    2. 否则通过哈希表判断括号对应关系，若 stack 栈顶出栈括号 stack.pop() 与当前遍历括号 c 不对应，则提前返回 falsefalsefalse。\n   \n   \n * 提前返回 falsefalsefalse\n   \n    * 提前返回优点： 在迭代过程中，提前发现不符合的括号并且返回，提升算法效率。\n    * 解决边界问题： * 栈 stack 为空： 此时 stack.pop() 操作会报错；因此，我们采用一个取巧方法，给 stack 赋初值 ??? ，并在哈希表 dic 中建立 key:′?′，value:′?′key: '?'，value:'?'key:′?′，value:′?′ 的对应关系予以配合。此时当 stack 为空且 c 为右括号时，可以正常提前返回 falsefalsefalse；\n       * 字符串 s 以左括号结尾： 此情况下可以正常遍历完整个 s，但 stack 中遗留未出栈的左括号；因此，最后需返回 len(stack) == 1，以判断是否是有效的括号组合。\n      \n      \n   \n   \n * 复杂度分析\n   \n    * 时间复杂度 o(n)o(n)o(n)：正确的括号组合需要遍历 111 遍 s；\n    * 空间复杂度 o(n)o(n)o(n)：哈希表和栈使用线性的空间大小。\n   \n   \n\n<,,,,,>\n\n# 代码：\nclass solution:\n    def isvalid(self, s: str) -> bool:\n        dic = {'{': '}',  '[': ']', '(': ')', '?': '?'}\n        stack = ['?']\n        for c in s:\n            if c in dic: stack.append(c)\n            elif dic[stack.pop()] != c: return false \n        return len(stack) == 1\n\n\n1\n2\n3\n4\n5\n6\n7\n8\nclass solution {\n    private static final map<character,character> map = new hashmap<character,character>(){{\n        put('{','}'); put('[',']'); put('(',')'); put('?','?');\n    }};\n    public boolean isvalid(string s) {\n        if(s.length() > 0 && !map.containskey(s.charat(0))) return false;\n        linkedlist<character> stack = new linkedlist<character>() {{ add('?'); }};\n        for(character c : s.tochararray()){\n            if(map.containskey(c)) stack.addlast(c);\n            else if(map.get(stack.removelast()) != c) return false;\n        }\n        return stack.size() == 1;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2021-04-17 13:57:53accepted [https://leetcode-cn.com//submissions/detail/168858435/]51 ms100.0%39.2 mbjava2018-07-16 19:35:09accepted [https://leetcode-cn.com//submissions/detail/4250168/]11 ms100.0%n/ajava2017-11-19 22:40:49accepted [https://leetcode-cn.com//submissions/detail/1149031/]9 ms100.0%n/ajava2017-11-19 22:39:27accepted [https://leetcode-cn.com//submissions/detail/1149019/]9 ms100.0%n/ajava2017-11-19 22:36:54accepted [https://leetcode-cn.com//submissions/detail/1149020/]12 ms100.0%n/ajava2017-11-19 22:35:20accepted [https://leetcode-cn.com//submissions/detail/1149017/]6 ms100.0%n/ajava2017-11-19 22:32:26accepted [https://leetcode-cn.com//submissions/detail/1149028/]7 ms100.0%n/ajava# 统计信息\n通过次数提交次数ac比率605425137686344.0%# 相似题目\n题目难度括号生成 [https://leetcode-cn.com/problems/generate-parentheses/]中等最长有效括号 [https://leetcode-cn.com/problems/longest-valid-parentheses/]困难删除无效的括号 [https://leetcode-cn.com/problems/remove-invalid-parentheses/]困难检查替换后的词是否有效 [https://leetcode-cn.com/problems/check-if-word-is-valid-after-substitutions/]中等"},{title:"27-移除元素(Remove Element)",frontmatter:{title:"27-移除元素(Remove Element)",date:"2018-04-29T00:00:00.000Z",categories:["简单"],tags:["数组<Array>","双指针<Two Pointers>"]},regularPath:"/views/%E7%AE%80%E5%8D%95/0027-%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0.html",relativePath:"views/简单/0027-移除元素.md",key:"v-3caa00fc",path:"/views/%E7%AE%80%E5%8D%95/0027-%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0.html",headers:[{level:2,title:"中文题目",slug:"中文题目",charIndex:2},{level:2,title:"通过代码",slug:"通过代码",charIndex:785},{level:2,title:"官方题解",slug:"官方题解",charIndex:2581},{level:2,title:"概要",slug:"概要",charIndex:2588},{level:2,title:"提示",slug:"提示",charIndex:2652},{level:2,title:"解决方案",slug:"解决方案",charIndex:2716},{level:2,title:"提交历史",slug:"提交历史",charIndex:4436},{level:2,title:"统计信息",slug:"统计信息",charIndex:4864},{level:2,title:"相似题目",slug:"相似题目",charIndex:4900}],lastUpdated:"4/11/2021, 1:15:21 PM",headersStr:"中文题目 通过代码 官方题解 概要 提示 解决方案 提交历史 统计信息 相似题目",content:"# 中文题目\n给定一个数组 nums和一个值 val，你需要原地 [https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95]移除所有数值等于val的元素，返回移除后数组的新长度。\n\n不要使用额外的数组空间，你必须在原地 [https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95]修改输入数组并在使用 O(1) 额外空间的条件下完成。\n\n元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。\n\n示例 1:\n\n给定 nums = [3,2,2,3], val = 3,\n\n函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。\n\n你不需要考虑数组中超出新长度后面的元素。\n\n\n示例 2:\n\n给定 nums = [0,1,2,2,3,0,4,2], val = 2,\n\n函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。\n\n注意这五个元素可为任意顺序。\n\n你不需要考虑数组中超出新长度后面的元素。\n\n\n说明:\n\n为什么返回数值是整数，但输出的答案是数组呢?\n\n请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。\n\n你可以想象内部操作如下:\n\n// nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝\nint len = removeElement(nums, val);\n\n// 在函数里修改输入数组对于调用者是可见的。\n// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。\nfor (int i = 0; i < len; i++) {\n    print(nums[i]);\n}\n\n\n# 通过代码\nclass Solution {\n    public int removeElement(int[] nums, int val) {\n        if (nums == null || nums.length == 0) {\n                return 0;\n            }\n            int last = nums.length;\n            for (int i = 0; i < last; i++) {\n                if (nums[i] == val) {\n                    while (last>i){\n                        if (nums[--last]!=val){\n                            nums[i]=nums[last];\n                            break;\n                        }\n                    }\n                }\n            }\n            return last;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\nclass Solution {\n    public int removeElement(int[] nums, int val) {\n        if (nums == null || nums.length == 0) {\n                return 0;\n            }\n            int last = nums.length;\n            for (int i = 0; i < last; i++) {\n                if (nums[i] == val) {\n                    while (last>i){\n                        if (nums[--last]!=val){\n                            nums[i]=nums[last];\n                            break;\n                        }\n                    }\n                }\n            }\n            return last;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\nclass Solution {\n    public int removeElement(int[] nums, int val) {\n             if (nums==null || nums.length==0){\n                return 0;\n            }\n            LinkedList<Integer> list=new LinkedList<>();\n            for (int i = 0; i < nums.length; i++) {\n                if (nums[i]!=val){\n                    list.add(nums[i]);\n                }\n            }\n            int size=list.size();\n            for (int i = 0; i < size; i++) {\n                nums[i]=list.removeFirst();\n            }\n            return size;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n# 官方题解\n# 概要\n这是一个相当简单的问题，但人们可能会对“就地”一词感到困惑，并认为在不复制数组的情况下从数组中删除元素是不可能的。\n\n# 提示\n 1. 尝试双指针法。\n 2. 你是否使用“元素顺序可以更改”这一属性？\n 3. 当要删除的元素很少时会发生什么？\n\n# 解决方案\n# 方法一：双指针\n思路\n\n既然问题要求我们就地删除给定值的所有元素，我们就必须用 O(1)O(1)O(1) 的额外空间来处理它。如何解决？我们可以保留两个指针 iii 和 jjj，其中 iii 是慢指针，jjj 是快指针。\n\n算法\n\n当 nums[j]nums[j]nums[j] 与给定的值相等时，递增 jjj 以跳过该元素。只要 nums[j]≠valnums[j] \\neq valnums[j]​=val，我们就复制 nums[j]nums[j]nums[j] 到 nums[i]nums[i]nums[i] 并同时递增两个索引。重复这一过程，直到 jjj 到达数组的末尾，该数组的新长度为 iii。\n\n该解法与 删除排序数组中的重复项 [https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/solution/shan-chu-pai-xu-shu-zu-zhong-de-zhong-fu-xiang-by-/] 的解法十分相似。\n\npublic int removeElement(int[] nums, int val) {\n    int i = 0;\n    for (int j = 0; j < nums.length; j++) {\n        if (nums[j] != val) {\n            nums[i] = nums[j];\n            i++;\n        }\n    }\n    return i;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n复杂度分析\n\n * 时间复杂度：O(n)O(n)O(n)， 假设数组总共有 nnn 个元素，iii 和 jjj 至少遍历 2n2n2n 步。\n   \n   \n * 空间复杂度：O(1)O(1)O(1)。\n   \n   \n\n# 方法二：双指针 —— 当要删除的元素很少时\n思路\n\n现在考虑数组包含很少的要删除的元素的情况。例如，num=[1，2，3，5，4]，Val=4num=[1，2，3，5，4]，Val=4num=[1，2，3，5，4]，Val=4。之前的算法会对前四个元素做不必要的复制操作。另一个例子是 num=[4，1，2，3，5]，Val=4num=[4，1，2，3，5]，Val=4num=[4，1，2，3，5]，Val=4。似乎没有必要将 [1，2，3，5][1，2，3，5][1，2，3，5] 这几个元素左移一步，因为问题描述中提到元素的顺序可以更改。\n\n算法\n\n当我们遇到 nums[i]=valnums[i] = valnums[i]=val 时，我们可以将当前元素与最后一个元素进行交换，并释放最后一个元素。这实际上使数组的大小减少了 1。\n\n请注意，被交换的最后一个元素可能是您想要移除的值。但是不要担心，在下一次迭代中，我们仍然会检查这个元素。\n\npublic int removeElement(int[] nums, int val) {\n    int i = 0;\n    int n = nums.length;\n    while (i < n) {\n        if (nums[i] == val) {\n            nums[i] = nums[n - 1];\n            // reduce array size by one\n            n--;\n        } else {\n            i++;\n        }\n    }\n    return n;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n复杂度分析\n\n * 时间复杂度：O(n)O(n)O(n)，iii 和 nnn 最多遍历 nnn 步。在这个方法中，赋值操作的次数等于要删除的元素的数量。因此，如果要移除的元素很少，效率会更高。\n   \n   \n * 空间复杂度：O(1)O(1)O(1)。\n   \n   \n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-04-29 22:11:03Accepted [https://leetcode-cn.com//submissions/detail/1807200/]7 ms11.77%N/Ajava2018-04-29 22:10:03Accepted [https://leetcode-cn.com//submissions/detail/1807188/]23 ms11.77%N/Ajava2018-04-29 21:53:09Accepted [https://leetcode-cn.com//submissions/detail/1806945/]16 ms11.77%N/Ajava2018-04-27 23:46:29Runtime Error [https://leetcode-cn.com//submissions/detail/1765762/]N/AN/AN/Ajava# 统计信息\n通过次数提交次数AC比率12516321919457.1%# 相似题目\n题目难度删除排序数组中的重复项 [https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/]简单移除链表元素 [https://leetcode-cn.com/problems/remove-linked-list-elements/]简单移动零 [https://leetcode-cn.com/problems/move-zeroes/]简单",contentLowercase:"# 中文题目\n给定一个数组 nums和一个值 val，你需要原地 [https://baike.baidu.com/item/%e5%8e%9f%e5%9c%b0%e7%ae%97%e6%b3%95]移除所有数值等于val的元素，返回移除后数组的新长度。\n\n不要使用额外的数组空间，你必须在原地 [https://baike.baidu.com/item/%e5%8e%9f%e5%9c%b0%e7%ae%97%e6%b3%95]修改输入数组并在使用 o(1) 额外空间的条件下完成。\n\n元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。\n\n示例 1:\n\n给定 nums = [3,2,2,3], val = 3,\n\n函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。\n\n你不需要考虑数组中超出新长度后面的元素。\n\n\n示例 2:\n\n给定 nums = [0,1,2,2,3,0,4,2], val = 2,\n\n函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。\n\n注意这五个元素可为任意顺序。\n\n你不需要考虑数组中超出新长度后面的元素。\n\n\n说明:\n\n为什么返回数值是整数，但输出的答案是数组呢?\n\n请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。\n\n你可以想象内部操作如下:\n\n// nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝\nint len = removeelement(nums, val);\n\n// 在函数里修改输入数组对于调用者是可见的。\n// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。\nfor (int i = 0; i < len; i++) {\n    print(nums[i]);\n}\n\n\n# 通过代码\nclass solution {\n    public int removeelement(int[] nums, int val) {\n        if (nums == null || nums.length == 0) {\n                return 0;\n            }\n            int last = nums.length;\n            for (int i = 0; i < last; i++) {\n                if (nums[i] == val) {\n                    while (last>i){\n                        if (nums[--last]!=val){\n                            nums[i]=nums[last];\n                            break;\n                        }\n                    }\n                }\n            }\n            return last;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\nclass solution {\n    public int removeelement(int[] nums, int val) {\n        if (nums == null || nums.length == 0) {\n                return 0;\n            }\n            int last = nums.length;\n            for (int i = 0; i < last; i++) {\n                if (nums[i] == val) {\n                    while (last>i){\n                        if (nums[--last]!=val){\n                            nums[i]=nums[last];\n                            break;\n                        }\n                    }\n                }\n            }\n            return last;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\nclass solution {\n    public int removeelement(int[] nums, int val) {\n             if (nums==null || nums.length==0){\n                return 0;\n            }\n            linkedlist<integer> list=new linkedlist<>();\n            for (int i = 0; i < nums.length; i++) {\n                if (nums[i]!=val){\n                    list.add(nums[i]);\n                }\n            }\n            int size=list.size();\n            for (int i = 0; i < size; i++) {\n                nums[i]=list.removefirst();\n            }\n            return size;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n# 官方题解\n# 概要\n这是一个相当简单的问题，但人们可能会对“就地”一词感到困惑，并认为在不复制数组的情况下从数组中删除元素是不可能的。\n\n# 提示\n 1. 尝试双指针法。\n 2. 你是否使用“元素顺序可以更改”这一属性？\n 3. 当要删除的元素很少时会发生什么？\n\n# 解决方案\n# 方法一：双指针\n思路\n\n既然问题要求我们就地删除给定值的所有元素，我们就必须用 o(1)o(1)o(1) 的额外空间来处理它。如何解决？我们可以保留两个指针 iii 和 jjj，其中 iii 是慢指针，jjj 是快指针。\n\n算法\n\n当 nums[j]nums[j]nums[j] 与给定的值相等时，递增 jjj 以跳过该元素。只要 nums[j]≠valnums[j] \\neq valnums[j]​=val，我们就复制 nums[j]nums[j]nums[j] 到 nums[i]nums[i]nums[i] 并同时递增两个索引。重复这一过程，直到 jjj 到达数组的末尾，该数组的新长度为 iii。\n\n该解法与 删除排序数组中的重复项 [https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/solution/shan-chu-pai-xu-shu-zu-zhong-de-zhong-fu-xiang-by-/] 的解法十分相似。\n\npublic int removeelement(int[] nums, int val) {\n    int i = 0;\n    for (int j = 0; j < nums.length; j++) {\n        if (nums[j] != val) {\n            nums[i] = nums[j];\n            i++;\n        }\n    }\n    return i;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n复杂度分析\n\n * 时间复杂度：o(n)o(n)o(n)， 假设数组总共有 nnn 个元素，iii 和 jjj 至少遍历 2n2n2n 步。\n   \n   \n * 空间复杂度：o(1)o(1)o(1)。\n   \n   \n\n# 方法二：双指针 —— 当要删除的元素很少时\n思路\n\n现在考虑数组包含很少的要删除的元素的情况。例如，num=[1，2，3，5，4]，val=4num=[1，2，3，5，4]，val=4num=[1，2，3，5，4]，val=4。之前的算法会对前四个元素做不必要的复制操作。另一个例子是 num=[4，1，2，3，5]，val=4num=[4，1，2，3，5]，val=4num=[4，1，2，3，5]，val=4。似乎没有必要将 [1，2，3，5][1，2，3，5][1，2，3，5] 这几个元素左移一步，因为问题描述中提到元素的顺序可以更改。\n\n算法\n\n当我们遇到 nums[i]=valnums[i] = valnums[i]=val 时，我们可以将当前元素与最后一个元素进行交换，并释放最后一个元素。这实际上使数组的大小减少了 1。\n\n请注意，被交换的最后一个元素可能是您想要移除的值。但是不要担心，在下一次迭代中，我们仍然会检查这个元素。\n\npublic int removeelement(int[] nums, int val) {\n    int i = 0;\n    int n = nums.length;\n    while (i < n) {\n        if (nums[i] == val) {\n            nums[i] = nums[n - 1];\n            // reduce array size by one\n            n--;\n        } else {\n            i++;\n        }\n    }\n    return n;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n复杂度分析\n\n * 时间复杂度：o(n)o(n)o(n)，iii 和 nnn 最多遍历 nnn 步。在这个方法中，赋值操作的次数等于要删除的元素的数量。因此，如果要移除的元素很少，效率会更高。\n   \n   \n * 空间复杂度：o(1)o(1)o(1)。\n   \n   \n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-04-29 22:11:03accepted [https://leetcode-cn.com//submissions/detail/1807200/]7 ms11.77%n/ajava2018-04-29 22:10:03accepted [https://leetcode-cn.com//submissions/detail/1807188/]23 ms11.77%n/ajava2018-04-29 21:53:09accepted [https://leetcode-cn.com//submissions/detail/1806945/]16 ms11.77%n/ajava2018-04-27 23:46:29runtime error [https://leetcode-cn.com//submissions/detail/1765762/]n/an/an/ajava# 统计信息\n通过次数提交次数ac比率12516321919457.1%# 相似题目\n题目难度删除排序数组中的重复项 [https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/]简单移除链表元素 [https://leetcode-cn.com/problems/remove-linked-list-elements/]简单移动零 [https://leetcode-cn.com/problems/move-zeroes/]简单"},{title:"28-实现 strStr()(Implement strStr())",frontmatter:{title:"28-实现 strStr()(Implement strStr())",date:"2018-04-29T00:00:00.000Z",categories:["简单"],tags:["双指针<Two Pointers>","字符串<String>"]},regularPath:"/views/%E7%AE%80%E5%8D%95/0028-%E5%AE%9E%E7%8E%B0%20strStr().html",relativePath:"views/简单/0028-实现 strStr().md",key:"v-22fe62f0",path:"/views/%E7%AE%80%E5%8D%95/0028-%E5%AE%9E%E7%8E%B0%20strStr().html",headers:[{level:2,title:"中文题目",slug:"中文题目",charIndex:2},{level:2,title:"通过代码",slug:"通过代码",charIndex:519},{level:2,title:"高赞题解",slug:"高赞题解",charIndex:2032},{level:3,title:"一、KMP 算法概述",slug:"一、kmp-算法概述",charIndex:2833},{level:3,title:"二、状态机概述",slug:"二、状态机概述",charIndex:5061},{level:3,title:"三、构建状态转移图",slug:"三、构建状态转移图",charIndex:6903},{level:3,title:"四、代码实现",slug:"四、代码实现",charIndex:8305},{level:3,title:"五、最后总结",slug:"五、最后总结",charIndex:11131},{level:2,title:"提交历史",slug:"提交历史",charIndex:12031},{level:2,title:"统计信息",slug:"统计信息",charIndex:12756},{level:2,title:"相似题目",slug:"相似题目",charIndex:12792}],lastUpdated:"4/11/2021, 1:15:21 PM",headersStr:"中文题目 通过代码 高赞题解 一、KMP 算法概述 二、状态机概述 三、构建状态转移图 四、代码实现 五、最后总结 提交历史 统计信息 相似题目",content:'# 中文题目\n实现strStr() [https://baike.baidu.com/item/strstr/811469]函数。\n\n给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回 -1。\n\n示例 1:\n\n输入: haystack = "hello", needle = "ll"\n输出: 2\n\n\n示例 2:\n\n输入: haystack = "aaaaa", needle = "bba"\n输出: -1\n\n\n说明:\n\n当needle是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。\n\n对于本题而言，当needle是空字符串时我们应当返回 0 。这与C语言的strstr() [https://baike.baidu.com/item/strstr/811469]以及 Java的indexOf() [https://docs.oracle.com/javase/7/docs/api/java/lang/String.html#indexOf(java.lang.String)]定义相符。\n\n# 通过代码\nclass Solution {\n    public int strStr(String haystack, String needle) {\n        if (null == haystack || null == needle) {\n                return 0;\n            }\n            if ("".equals(needle)){\n                return 0;\n            }\n            for (int i = 0; i < haystack.length(); i++) {\n                int begin = i;\n                int start = 0;\n                while (begin<haystack.length() && start<needle.length() && haystack.charAt(begin) == needle.charAt(start)) {\n                    begin++;\n                    start++;\n                }\n                if (start==needle.length()){\n                    return i;\n                }\n            }\n            return -1;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\nclass Solution {\n    public int strStr(String haystack, String needle) {\n        if (null == haystack || null == needle) {\n                return 0;\n            }\n            if ("".equals(needle)){\n                return 0;\n            }\n            for (int i = 0; i < haystack.length(); i++) {\n                int begin = i;\n                int start = 0;\n                while (begin<haystack.length() && start<needle.length() && haystack.charAt(begin) == needle.charAt(start)) {\n                    begin++;\n                    start++;\n                }\n                if (start==needle.length()){\n                    return i;\n                }\n            }\n            return -1;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n# 高赞题解\nKMP 算法（Knuth-Morris-Pratt 算法）是一个著名的字符串匹配算法，效率很高，但是确实有点复杂。\n\n很多读者抱怨 KMP 算法无法理解，这很正常，想到大学教材上关于 KMP 算法的讲解，也不知道有多少未来的 Knuth、Morris、Pratt 被提前劝退了。有一些优秀的同学通过手推 KMP 算法的过程来辅助理解该算法，这是一种办法，不过本文要从逻辑层面帮助读者理解算法的原理。十行代码之间，KMP 灰飞烟灭。\n\n先在开头约定，本文用 pat 表示模式串，长度为 M，txt 表示文本串，长度为 N。KMP 算法是在 txt 中查找子串 pat，如果存在，返回这个子串的起始索引，否则返回 -1。\n\n为什么我认为 KMP 算法就是个动态规划问题呢，等会再解释。对于动态规划，之前多次强调了要明确 dp 数组的含义，而且同一个问题可能有不止一种定义 dp 数组含义的方法，不同的定义会有不同的解法。\n\n读者见过的 KMP 算法应该是，一波诡异的操作处理 pat 后形成一个一维的数组 next，然后根据这个数组经过又一波复杂操作去匹配 txt。时间复杂度 O(N)，空间复杂度 O(M)。其实它这个 next 数组就相当于 dp 数组，其中元素的含义跟 pat 的前缀和后缀有关，判定规则比较复杂，不好理解。本文则用一个二维的 dp 数组（但空间复杂度还是 O(M)），重新定义其中元素的含义，使得代码长度大大减少，可解释性大大提高。\n\nPS：本文的代码参考《算法4》，原代码使用的数组名称是 dfa（确定有限状态机），因为我们的公众号之前有一系列动态规划的文章，就不说这么高大上的名词了，我对书中代码进行了一点修改，并沿用 dp 数组的名称。\n\n本文会用到动态规划算法的设计技巧（归纳思想），所以希望读者看过这篇文章「动态规划设计之最长递增子序列」，很容易理解的。\n\n# 一、KMP 算法概述\n首先还是简单介绍一下 KMP 算法和暴力匹配算法的不同在哪里，难点在哪里，和动态规划有啥关系。\n\n暴力的字符串匹配算法很容易写，看一下它的运行逻辑：\n\n// 暴力匹配（伪码）\nint search(String pat, String txt) {\n    int M = pat.length;\n    int N = txt.length;\n    for (int i = 0; i < N - M; i++) {\n        int j;\n        for (j = 0; j < M; j++) {\n            if (pat[j] != txt[i+j])\n                break;\n        }\n        // pat 全都匹配了\n        if (j == M) return i;\n    }\n    // txt 中不存在 pat 子串\n    return -1;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n对于暴力算法，如果出现不匹配字符，同时回退 txt 和 pat 的指针，嵌套 for 循环，时间复杂度 O(MN)O(MN)O(MN)，空间复杂度O(1)O(1)O(1)。最主要的问题是，如果字符串中重复的字符比较多，该算法就显得很蠢。\n\n比如 txt = "aaacaaab" pat = "aaab"：\n\n{:width=400} {:align=center}\n\n很明显，pat 中根本没有字符 c，根本没必要回退指针 i，暴力解法明显多做了很多不必要的操作。\n\nKMP 算法的不同之处在于，它会花费空间来记录一些信息，在上述情况中就会显得很聪明：\n\n{:width=400} {:align=center}\n\n再比如类似的 txt = "aaaaaaab" pat = "aaab"，暴力解法还会和上面那个例子一样蠢蠢地回退指针 i，而 KMP 算法又会耍聪明：\n\n{:width=400} {:align=center}\n\n因为 KMP 算法知道字符 b 之前的字符 a 都是匹配的，所以每次只需要比较字符 b 是否被匹配就行了。\n\nKMP 算法永不回退 txt 的指针 i，不走回头路（不会重复扫描 txt），而是借助 dp 数组中储存的信息把 pat 移到正确的位置继续匹配，时间复杂度只需 O(N)，用空间换时间，所以我认为它是一种动态规划算法。\n\nKMP 算法的难点在于，如何计算 dp 数组中的信息？如何根据这些信息正确地移动 pat 的指针？这个就需要确定有限状态自动机来辅助了，别怕这种高大上的文学词汇，其实和动态规划的 dp 数组如出一辙，等你学会了也可以拿这个词去吓唬别人。\n\n还有一点需要明确的是：计算这个 dp 数组，只和 pat 串有关。意思是说，只要给我个 pat，我就能通过这个模式串计算出 dp 数组，然后你可以给我不同的 txt，我都不怕，利用这个 dp 数组我都能在 O(N) 时间完成字符串匹配。\n\n具体来说，比如上文举的两个例子：\n\ntxt1 = "aaacaaab" \npat = "aaab"\ntxt2 = "aaaaaaab" \npat = "aaab"\n\n\n1\n2\n3\n4\n我们的 txt 不同，但是 pat 是一样的，所以 KMP 算法使用的 dp 数组是同一个。\n\n只不过对于 txt1 的下面这个即将出现的未匹配情况：\n\n{:width=400} {:align=center}\n\ndp 数组指示 pat 这样移动：\n\n{:width=400} {:align=center}\n\nPS：这个j 不要理解为索引，它的含义更准确地说应该是状态（state），所以它会出现这个奇怪的位置，后文会详述。\n\n而对于 txt2 的下面这个即将出现的未匹配情况：\n\n{:width=400} {:align=center}\n\ndp 数组指示 pat 这样移动：\n\n{:width=400} {:align=center}\n\n明白了 dp 数组只和 pat 有关，那么我们这样设计 KMP 算法就会比较漂亮：\n\npublic class KMP {\n    private int[][] dp;\n    private String pat;\n\n    public KMP(String pat) {\n        this.pat = pat;\n        // 通过 pat 构建 dp 数组\n        // 需要 O(M) 时间\n    }\n\n    public int search(String txt) {\n        // 借助 dp 数组去匹配 txt\n        // 需要 O(N) 时间\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n这样，当我们需要用同一 pat 去匹配不同 txt 时，就不需要浪费时间构造 dp 数组了：\n\nKMP kmp = new KMP("aaab");\nint pos1 = kmp.search("aaacaaab"); //4\nint pos2 = kmp.search("aaaaaaab"); //4\n\n\n1\n2\n3\n# 二、状态机概述\n为什么说 KMP 算法和状态机有关呢？是这样的，我们可以认为 pat 的匹配就是状态的转移。比如当 pat = "ABABC"：\n\n{:width=400} {:align=center}\n\n如上图，圆圈内的数字就是状态，状态 0 是起始状态，状态 5（pat.length）是终止状态。开始匹配时 pat 处于起始状态，一旦转移到终止状态，就说明在 txt 中找到了 pat。比如说当前处于状态 2，就说明字符 "AB" 被匹配：\n\n{:width=400} {:align=center}\n\n另外，处于不同状态时，pat 状态转移的行为也不同。比如说假设现在匹配到了状态 4，如果遇到字符 A 就应该转移到状态 3，遇到字符 C 就应该转移到状态 5，如果遇到字符 B 就应该转移到状态 0：\n\n{:width=400} {:align=center}\n\n具体什么意思呢，我们来一个个举例看看。用变量 j 表示指向当前状态的指针，当前 pat 匹配到了状态 4：\n\n{:width=400} {:align=center}\n\n如果遇到了字符 "A"，根据箭头指示，转移到状态 3 是最聪明的：\n\n{:width=400} {:align=center}\n\n如果遇到了字符 "B"，根据箭头指示，只能转移到状态 0（一夜回到解放前）：\n\n{:width=400} {:align=center}\n\n如果遇到了字符 "C"，根据箭头指示，应该转移到终止状态 5，这也就意味着匹配完成：\n\n{:width=400} {:align=center}\n\n当然了，还可能遇到其他字符，比如 Z，但是显然应该转移到起始状态 0，因为 pat 中根本都没有字符 Z：\n\n{:width=400} {:align=center}\n\n这里为了清晰起见，我们画状态图时就把其他字符转移到状态 0 的箭头省略，只画 pat 中出现的字符的状态转移：\n\n{:width=400} {:align=center}\n\nKMP 算法最关键的步骤就是构造这个状态转移图。要确定状态转移的行为，得明确两个变量，一个是当前的匹配状态，另一个是遇到的字符；确定了这两个变量后，就可以知道这个情况下应该转移到哪个状态。\n\n下面看一下 KMP 算法根据这幅状态转移图匹配字符串 txt 的过程：\n\n{:width=400} {:align=center}\n\n请记住这个 GIF 的匹配过程，这就是 KMP 算法的核心逻辑！\n\n为了描述状态转移图，我们定义一个二维 dp 数组，它的含义如下：\n\ndp[j][c] = next\n0 <= j < M，代表当前的状态\n0 <= c < 256，代表遇到的字符（ASCII 码）\n0 <= next <= M，代表下一个状态\n\ndp[4][\'A\'] = 3 表示：\n当前是状态 4，如果遇到字符 A，\npat 应该转移到状态 3\n\ndp[1][\'B\'] = 2 表示：\n当前是状态 1，如果遇到字符 B，\npat 应该转移到状态 2\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n根据我们这个 dp 数组的定义和刚才状态转移的过程，我们可以先写出 KMP 算法的 search 函数代码：\n\npublic int search(String txt) {\n    int M = pat.length();\n    int N = txt.length();\n    // pat 的初始态为 0\n    int j = 0;\n    for (int i = 0; i < N; i++) {\n        // 当前是状态 j，遇到字符 txt[i]，\n        // pat 应该转移到哪个状态？\n        j = dp[j][txt.charAt(i)];\n        // 如果达到终止态，返回匹配开头的索引\n        if (j == M) return i - M + 1;\n    }\n    // 没到达终止态，匹配失败\n    return -1;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n到这里，应该还是很好理解的吧，dp 数组就是我们刚才画的那幅状态转移图，如果不清楚的话回去看下 GIF 的算法演进过程。下面讲解：如何通过 pat 构建这个 dp 数组？\n\n# 三、构建状态转移图\n回想刚才说的：要确定状态转移的行为，必须明确两个变量，一个是当前的匹配状态，另一个是遇到的字符，而且我们已经根据这个逻辑确定了 dp 数组的含义，那么构造 dp 数组的框架就是这样：\n\nfor 0 <= j < M: # 状态\n    for 0 <= c < 256: # 字符\n        dp[j][c] = next\n\n\n1\n2\n3\n这个 next 状态应该怎么求呢？显然，如果遇到的字符 c 和 pat[j] 匹配的话，状态就应该向前推进一个，也就是说 next = j + 1，我们不妨称这种情况为状态推进：\n\n{:width=400} {:align=center}\n\n如果字符 c 和 pat[j] 不匹配的话，状态就要回退（或者原地不动），我们不妨称这种情况为状态重启：\n\n{:width=400} {:align=center}\n\n那么，如何得知在哪个状态重启呢？解答这个问题之前，我们再定义一个名字：影子状态（我编的名字），用变量 X 表示。所谓影子状态，就是和当前状态具有相同的前缀。比如下面这种情况：\n\n{:width=400} {:align=center}\n\n当前状态 j = 4，其影子状态为 X = 2，它们都有相同的前缀 "AB"。因为状态 X 和状态 j 存在相同的前缀，所以当状态 j 准备进行状态重启的时候（遇到的字符 c 和 pat[j] 不匹配），可以通过 X 的状态转移图来获得最近的重启位置。\n\n比如说刚才的情况，如果状态 j 遇到一个字符 "A"，应该转移到哪里呢？首先只有遇到 "C" 才能推进状态，遇到 "A" 显然只能进行状态重启。状态 j 会把这个字符委托给状态 X 处理，也就是 dp[j][\'A\'] = dp[X][\'A\']：\n\n{:width=400} {:align=center}\n\n为什么这样可以呢？因为：既然 j 这边已经确定字符 "A" 无法推进状态，只能回退，而且 KMP 就是要尽可能少的回退，以免多余的计算。那么 j 就可以去问问和自己具有相同前缀的 X，如果 X 遇见 "A" 可以进行「状态推进」，那就转移过去，因为这样回退最少。\n\n{:width=400} {:align=center}\n\n当然，如果遇到的字符是 "B"，状态 X 也不能进行「状态推进」，只能回退，j 只要跟着 X 指引的方向回退就行了：\n\n{:width=400} {:align=center}\n\n你也许会问，这个 X 怎么知道遇到字符 "B" 要回退到状态 0 呢？因为 X 永远跟在 j 的身后，状态 X 如何转移，在之前就已经算出来了。动态规划算法不就是利用过去的结果解决现在的问题吗？\n\n这样，我们就细化一下刚才的框架代码：\n\nint X # 影子状态\nfor 0 <= j < M:\n    for 0 <= c < 256:\n        if c == pat[j]:\n            # 状态推进\n            dp[j][c] = j + 1\n        else: \n            # 状态重启\n            # 委托 X 计算重启位置\n            dp[j][c] = dp[X][c] \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n# 四、代码实现\n如果之前的内容你都能理解，恭喜你，现在就剩下一个问题：影子状态 X 是如何得到的呢？下面先直接看完整代码吧。\n\npublic class KMP {\n    private int[][] dp;\n    private String pat;\n\n    public KMP(String pat) {\n        this.pat = pat;\n        int M = pat.length();\n        // dp[状态][字符] = 下个状态\n        dp = new int[M][256];\n        // base case\n        dp[0][pat.charAt(0)] = 1;\n        // 影子状态 X 初始为 0\n        int X = 0;\n        // 当前状态 j 从 1 开始\n        for (int j = 1; j < M; j++) {\n            for (int c = 0; c < 256; c++) {\n                if (pat.charAt(j) == c) \n                    dp[j][c] = j + 1;\n                else \n                    dp[j][c] = dp[X][c];\n            }\n            // 更新影子状态\n            X = dp[X][pat.charAt(j)];\n        }\n    }\n\n    public int search(String txt) {...}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n先解释一下这一行代码：\n\n// base case\ndp[0][pat.charAt(0)] = 1;\n\n\n1\n2\n这行代码是 base case，只有遇到 pat[0] 这个字符才能使状态从 0 转移到 1，遇到其它字符的话还是停留在状态 0（Java 默认初始化数组全为 0）。\n\n影子状态 X 是先初始化为 0，然后随着 j 的前进而不断更新的。下面看看到底应该如何更新影子状态 X：\n\nint X = 0;\nfor (int j = 1; j < M; j++) {\n    ...\n    // 更新影子状态\n    // 当前是状态 X，遇到字符 pat[j]，\n    // pat 应该转移到哪个状态？\n    X = dp[X][pat.charAt(j)];\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n更新 X 其实和 search 函数中更新状态 j 的过程是非常相似的：\n\nint j = 0;\nfor (int i = 0; i < N; i++) {\n    // 当前是状态 j，遇到字符 txt[i]，\n    // pat 应该转移到哪个状态？\n    j = dp[j][txt.charAt(i)];\n    ...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n其中的原理非常微妙，注意代码中 for 循环的变量初始值，可以这样理解：后者是在 txt 中匹配 pat，前者是在 pat 中匹配 pat[1..end]，状态 X 总是落后状态 j 一个状态，与 j 具有最长的相同前缀。所以我把 X 比喻为影子状态，似乎也有一点贴切。\n\n另外，构建 dp 数组是根据 base case dp[0][..] 向后推演。这就是我认为 KMP 算法就是一种动态规划算法的原因。\n\n下面来看一下状态转移图的完整构造过程，你就能理解状态 X 作用之精妙了：\n\n{:width=400} {:align=center}\n\n至此，KMP 算法的核心终于写完啦啦啦啦！看下 KMP 算法的完整代码吧：\n\npublic class KMP {\n    private int[][] dp;\n    private String pat;\n\n    public KMP(String pat) {\n        this.pat = pat;\n        int M = pat.length();\n        // dp[状态][字符] = 下个状态\n        dp = new int[M][256];\n        // base case\n        dp[0][pat.charAt(0)] = 1;\n        // 影子状态 X 初始为 0\n        int X = 0;\n        // 构建状态转移图（稍改的更紧凑了）\n        for (int j = 1; j < M; j++) {\n            for (int c = 0; c < 256; c++) {\n                dp[j][c] = dp[X][c];\n            dp[j][pat.charAt(j)] = j + 1;\n            // 更新影子状态\n            X = dp[X][pat.charAt(j)];\n        }\n    }\n\n    public int search(String txt) {\n        int M = pat.length();\n        int N = txt.length();\n        // pat 的初始态为 0\n        int j = 0;\n        for (int i = 0; i < N; i++) {\n            // 计算 pat 的下一个状态\n            j = dp[j][txt.charAt(i)];\n            // 到达终止态，返回结果\n            if (j == M) return i - M + 1;\n        }\n        // 没到达终止态，匹配失败\n        return -1;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n经过之前的详细举例讲解，你应该可以理解这段代码的含义了，当然你也可以把 KMP 算法写成一个函数。核心代码也就是两个函数中 for 循环的部分，数一下有超过十行吗？\n\n# 五、最后总结\n传统的 KMP 算法是使用一个一维数组 next 记录前缀信息，而本文是使用一个二维数组 dp 以状态转移的角度解决字符匹配问题，但是空间复杂度仍然是 O(256M) = O(M)。\n\n在 pat 匹配 txt 的过程中，只要明确了「当前处在哪个状态」和「遇到的字符是什么」这两个问题，就可以确定应该转移到哪个状态（推进或回退）。\n\n对于一个模式串 pat，其总共就有 M 个状态，对于 ASCII 字符，总共不会超过 256 种。所以我们就构造一个数组 dp[M][256] 来包含所有情况，并且明确 dp 数组的含义：\n\ndp[j][c] = next 表示，当前是状态 j，遇到了字符 c，应该转移到状态 next。\n\n明确了其含义，就可以很容易写出 search 函数的代码。\n\n对于如何构建这个 dp 数组，需要一个辅助状态 X，它永远比当前状态 j 落后一个状态，拥有和 j 最长的相同前缀，我们给它起了个名字叫「影子状态」。\n\n在构建当前状态 j 的转移方向时，只有字符 pat[j] 才能使状态推进（dp[j][pat[j]] = j+1）；而对于其他字符只能进行状态回退，应该去请教影子状态 X 应该回退到哪里（dp[j][other] = dp[X][other]，其中 other 是除了 pat[j] 之外所有字符）。\n\n对于影子状态 X，我们把它初始化为 0，并且随着 j 的前进进行更新，更新的方式和 search 过程更新 j 的过程非常相似（X = dp[X][pat[j]]）。\n\nKMP 算法也就是动态规划那点事，我们的公众号文章目录有一系列专门讲动态规划的，而且都是按照一套框架来的，无非就是描述问题逻辑，明确 dp 数组含义，定义 base case 这点破事。希望这篇文章能让大家对动态规划有更深的理解。\n\n点击我的头像还有更多详细题解，如果本文对你有帮助，欢迎关注我的公众号 labuladong，致力于把算法问题讲清楚～ 后台回复关键词【资料】可获得我精选的经典技术书籍～\n\n{:width=400} {:align=center}\n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-04-29 22:47:13Accepted [https://leetcode-cn.com//submissions/detail/1807884/]785 ms5.01%N/Ajava2018-04-29 22:46:56Accepted [https://leetcode-cn.com//submissions/detail/1807872/]814 ms5.01%N/Ajava2018-04-29 22:42:59Wrong Answer [https://leetcode-cn.com//submissions/detail/1807749/]N/AN/AN/Ajava2018-04-29 22:42:18Wrong Answer [https://leetcode-cn.com//submissions/detail/1807717/]N/AN/AN/Ajava2018-04-29 22:37:58Wrong Answer [https://leetcode-cn.com//submissions/detail/1807566/]N/AN/AN/Ajava2018-04-29 22:37:40Wrong Answer [https://leetcode-cn.com//submissions/detail/1807563/]N/AN/AN/Ajava2018-04-29 22:36:21Runtime Error [https://leetcode-cn.com//submissions/detail/1807549/]N/AN/AN/Ajava# 统计信息\n通过次数提交次数AC比率11841030101739.3%# 相似题目\n题目难度最短回文串 [https://leetcode-cn.com/problems/shortest-palindrome/]困难重复的子字符串 [https://leetcode-cn.com/problems/repeated-substring-pattern/]简单',contentLowercase:'# 中文题目\n实现strstr() [https://baike.baidu.com/item/strstr/811469]函数。\n\n给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回 -1。\n\n示例 1:\n\n输入: haystack = "hello", needle = "ll"\n输出: 2\n\n\n示例 2:\n\n输入: haystack = "aaaaa", needle = "bba"\n输出: -1\n\n\n说明:\n\n当needle是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。\n\n对于本题而言，当needle是空字符串时我们应当返回 0 。这与c语言的strstr() [https://baike.baidu.com/item/strstr/811469]以及 java的indexof() [https://docs.oracle.com/javase/7/docs/api/java/lang/string.html#indexof(java.lang.string)]定义相符。\n\n# 通过代码\nclass solution {\n    public int strstr(string haystack, string needle) {\n        if (null == haystack || null == needle) {\n                return 0;\n            }\n            if ("".equals(needle)){\n                return 0;\n            }\n            for (int i = 0; i < haystack.length(); i++) {\n                int begin = i;\n                int start = 0;\n                while (begin<haystack.length() && start<needle.length() && haystack.charat(begin) == needle.charat(start)) {\n                    begin++;\n                    start++;\n                }\n                if (start==needle.length()){\n                    return i;\n                }\n            }\n            return -1;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\nclass solution {\n    public int strstr(string haystack, string needle) {\n        if (null == haystack || null == needle) {\n                return 0;\n            }\n            if ("".equals(needle)){\n                return 0;\n            }\n            for (int i = 0; i < haystack.length(); i++) {\n                int begin = i;\n                int start = 0;\n                while (begin<haystack.length() && start<needle.length() && haystack.charat(begin) == needle.charat(start)) {\n                    begin++;\n                    start++;\n                }\n                if (start==needle.length()){\n                    return i;\n                }\n            }\n            return -1;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n# 高赞题解\nkmp 算法（knuth-morris-pratt 算法）是一个著名的字符串匹配算法，效率很高，但是确实有点复杂。\n\n很多读者抱怨 kmp 算法无法理解，这很正常，想到大学教材上关于 kmp 算法的讲解，也不知道有多少未来的 knuth、morris、pratt 被提前劝退了。有一些优秀的同学通过手推 kmp 算法的过程来辅助理解该算法，这是一种办法，不过本文要从逻辑层面帮助读者理解算法的原理。十行代码之间，kmp 灰飞烟灭。\n\n先在开头约定，本文用 pat 表示模式串，长度为 m，txt 表示文本串，长度为 n。kmp 算法是在 txt 中查找子串 pat，如果存在，返回这个子串的起始索引，否则返回 -1。\n\n为什么我认为 kmp 算法就是个动态规划问题呢，等会再解释。对于动态规划，之前多次强调了要明确 dp 数组的含义，而且同一个问题可能有不止一种定义 dp 数组含义的方法，不同的定义会有不同的解法。\n\n读者见过的 kmp 算法应该是，一波诡异的操作处理 pat 后形成一个一维的数组 next，然后根据这个数组经过又一波复杂操作去匹配 txt。时间复杂度 o(n)，空间复杂度 o(m)。其实它这个 next 数组就相当于 dp 数组，其中元素的含义跟 pat 的前缀和后缀有关，判定规则比较复杂，不好理解。本文则用一个二维的 dp 数组（但空间复杂度还是 o(m)），重新定义其中元素的含义，使得代码长度大大减少，可解释性大大提高。\n\nps：本文的代码参考《算法4》，原代码使用的数组名称是 dfa（确定有限状态机），因为我们的公众号之前有一系列动态规划的文章，就不说这么高大上的名词了，我对书中代码进行了一点修改，并沿用 dp 数组的名称。\n\n本文会用到动态规划算法的设计技巧（归纳思想），所以希望读者看过这篇文章「动态规划设计之最长递增子序列」，很容易理解的。\n\n# 一、kmp 算法概述\n首先还是简单介绍一下 kmp 算法和暴力匹配算法的不同在哪里，难点在哪里，和动态规划有啥关系。\n\n暴力的字符串匹配算法很容易写，看一下它的运行逻辑：\n\n// 暴力匹配（伪码）\nint search(string pat, string txt) {\n    int m = pat.length;\n    int n = txt.length;\n    for (int i = 0; i < n - m; i++) {\n        int j;\n        for (j = 0; j < m; j++) {\n            if (pat[j] != txt[i+j])\n                break;\n        }\n        // pat 全都匹配了\n        if (j == m) return i;\n    }\n    // txt 中不存在 pat 子串\n    return -1;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n对于暴力算法，如果出现不匹配字符，同时回退 txt 和 pat 的指针，嵌套 for 循环，时间复杂度 o(mn)o(mn)o(mn)，空间复杂度o(1)o(1)o(1)。最主要的问题是，如果字符串中重复的字符比较多，该算法就显得很蠢。\n\n比如 txt = "aaacaaab" pat = "aaab"：\n\n{:width=400} {:align=center}\n\n很明显，pat 中根本没有字符 c，根本没必要回退指针 i，暴力解法明显多做了很多不必要的操作。\n\nkmp 算法的不同之处在于，它会花费空间来记录一些信息，在上述情况中就会显得很聪明：\n\n{:width=400} {:align=center}\n\n再比如类似的 txt = "aaaaaaab" pat = "aaab"，暴力解法还会和上面那个例子一样蠢蠢地回退指针 i，而 kmp 算法又会耍聪明：\n\n{:width=400} {:align=center}\n\n因为 kmp 算法知道字符 b 之前的字符 a 都是匹配的，所以每次只需要比较字符 b 是否被匹配就行了。\n\nkmp 算法永不回退 txt 的指针 i，不走回头路（不会重复扫描 txt），而是借助 dp 数组中储存的信息把 pat 移到正确的位置继续匹配，时间复杂度只需 o(n)，用空间换时间，所以我认为它是一种动态规划算法。\n\nkmp 算法的难点在于，如何计算 dp 数组中的信息？如何根据这些信息正确地移动 pat 的指针？这个就需要确定有限状态自动机来辅助了，别怕这种高大上的文学词汇，其实和动态规划的 dp 数组如出一辙，等你学会了也可以拿这个词去吓唬别人。\n\n还有一点需要明确的是：计算这个 dp 数组，只和 pat 串有关。意思是说，只要给我个 pat，我就能通过这个模式串计算出 dp 数组，然后你可以给我不同的 txt，我都不怕，利用这个 dp 数组我都能在 o(n) 时间完成字符串匹配。\n\n具体来说，比如上文举的两个例子：\n\ntxt1 = "aaacaaab" \npat = "aaab"\ntxt2 = "aaaaaaab" \npat = "aaab"\n\n\n1\n2\n3\n4\n我们的 txt 不同，但是 pat 是一样的，所以 kmp 算法使用的 dp 数组是同一个。\n\n只不过对于 txt1 的下面这个即将出现的未匹配情况：\n\n{:width=400} {:align=center}\n\ndp 数组指示 pat 这样移动：\n\n{:width=400} {:align=center}\n\nps：这个j 不要理解为索引，它的含义更准确地说应该是状态（state），所以它会出现这个奇怪的位置，后文会详述。\n\n而对于 txt2 的下面这个即将出现的未匹配情况：\n\n{:width=400} {:align=center}\n\ndp 数组指示 pat 这样移动：\n\n{:width=400} {:align=center}\n\n明白了 dp 数组只和 pat 有关，那么我们这样设计 kmp 算法就会比较漂亮：\n\npublic class kmp {\n    private int[][] dp;\n    private string pat;\n\n    public kmp(string pat) {\n        this.pat = pat;\n        // 通过 pat 构建 dp 数组\n        // 需要 o(m) 时间\n    }\n\n    public int search(string txt) {\n        // 借助 dp 数组去匹配 txt\n        // 需要 o(n) 时间\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n这样，当我们需要用同一 pat 去匹配不同 txt 时，就不需要浪费时间构造 dp 数组了：\n\nkmp kmp = new kmp("aaab");\nint pos1 = kmp.search("aaacaaab"); //4\nint pos2 = kmp.search("aaaaaaab"); //4\n\n\n1\n2\n3\n# 二、状态机概述\n为什么说 kmp 算法和状态机有关呢？是这样的，我们可以认为 pat 的匹配就是状态的转移。比如当 pat = "ababc"：\n\n{:width=400} {:align=center}\n\n如上图，圆圈内的数字就是状态，状态 0 是起始状态，状态 5（pat.length）是终止状态。开始匹配时 pat 处于起始状态，一旦转移到终止状态，就说明在 txt 中找到了 pat。比如说当前处于状态 2，就说明字符 "ab" 被匹配：\n\n{:width=400} {:align=center}\n\n另外，处于不同状态时，pat 状态转移的行为也不同。比如说假设现在匹配到了状态 4，如果遇到字符 a 就应该转移到状态 3，遇到字符 c 就应该转移到状态 5，如果遇到字符 b 就应该转移到状态 0：\n\n{:width=400} {:align=center}\n\n具体什么意思呢，我们来一个个举例看看。用变量 j 表示指向当前状态的指针，当前 pat 匹配到了状态 4：\n\n{:width=400} {:align=center}\n\n如果遇到了字符 "a"，根据箭头指示，转移到状态 3 是最聪明的：\n\n{:width=400} {:align=center}\n\n如果遇到了字符 "b"，根据箭头指示，只能转移到状态 0（一夜回到解放前）：\n\n{:width=400} {:align=center}\n\n如果遇到了字符 "c"，根据箭头指示，应该转移到终止状态 5，这也就意味着匹配完成：\n\n{:width=400} {:align=center}\n\n当然了，还可能遇到其他字符，比如 z，但是显然应该转移到起始状态 0，因为 pat 中根本都没有字符 z：\n\n{:width=400} {:align=center}\n\n这里为了清晰起见，我们画状态图时就把其他字符转移到状态 0 的箭头省略，只画 pat 中出现的字符的状态转移：\n\n{:width=400} {:align=center}\n\nkmp 算法最关键的步骤就是构造这个状态转移图。要确定状态转移的行为，得明确两个变量，一个是当前的匹配状态，另一个是遇到的字符；确定了这两个变量后，就可以知道这个情况下应该转移到哪个状态。\n\n下面看一下 kmp 算法根据这幅状态转移图匹配字符串 txt 的过程：\n\n{:width=400} {:align=center}\n\n请记住这个 gif 的匹配过程，这就是 kmp 算法的核心逻辑！\n\n为了描述状态转移图，我们定义一个二维 dp 数组，它的含义如下：\n\ndp[j][c] = next\n0 <= j < m，代表当前的状态\n0 <= c < 256，代表遇到的字符（ascii 码）\n0 <= next <= m，代表下一个状态\n\ndp[4][\'a\'] = 3 表示：\n当前是状态 4，如果遇到字符 a，\npat 应该转移到状态 3\n\ndp[1][\'b\'] = 2 表示：\n当前是状态 1，如果遇到字符 b，\npat 应该转移到状态 2\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n根据我们这个 dp 数组的定义和刚才状态转移的过程，我们可以先写出 kmp 算法的 search 函数代码：\n\npublic int search(string txt) {\n    int m = pat.length();\n    int n = txt.length();\n    // pat 的初始态为 0\n    int j = 0;\n    for (int i = 0; i < n; i++) {\n        // 当前是状态 j，遇到字符 txt[i]，\n        // pat 应该转移到哪个状态？\n        j = dp[j][txt.charat(i)];\n        // 如果达到终止态，返回匹配开头的索引\n        if (j == m) return i - m + 1;\n    }\n    // 没到达终止态，匹配失败\n    return -1;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n到这里，应该还是很好理解的吧，dp 数组就是我们刚才画的那幅状态转移图，如果不清楚的话回去看下 gif 的算法演进过程。下面讲解：如何通过 pat 构建这个 dp 数组？\n\n# 三、构建状态转移图\n回想刚才说的：要确定状态转移的行为，必须明确两个变量，一个是当前的匹配状态，另一个是遇到的字符，而且我们已经根据这个逻辑确定了 dp 数组的含义，那么构造 dp 数组的框架就是这样：\n\nfor 0 <= j < m: # 状态\n    for 0 <= c < 256: # 字符\n        dp[j][c] = next\n\n\n1\n2\n3\n这个 next 状态应该怎么求呢？显然，如果遇到的字符 c 和 pat[j] 匹配的话，状态就应该向前推进一个，也就是说 next = j + 1，我们不妨称这种情况为状态推进：\n\n{:width=400} {:align=center}\n\n如果字符 c 和 pat[j] 不匹配的话，状态就要回退（或者原地不动），我们不妨称这种情况为状态重启：\n\n{:width=400} {:align=center}\n\n那么，如何得知在哪个状态重启呢？解答这个问题之前，我们再定义一个名字：影子状态（我编的名字），用变量 x 表示。所谓影子状态，就是和当前状态具有相同的前缀。比如下面这种情况：\n\n{:width=400} {:align=center}\n\n当前状态 j = 4，其影子状态为 x = 2，它们都有相同的前缀 "ab"。因为状态 x 和状态 j 存在相同的前缀，所以当状态 j 准备进行状态重启的时候（遇到的字符 c 和 pat[j] 不匹配），可以通过 x 的状态转移图来获得最近的重启位置。\n\n比如说刚才的情况，如果状态 j 遇到一个字符 "a"，应该转移到哪里呢？首先只有遇到 "c" 才能推进状态，遇到 "a" 显然只能进行状态重启。状态 j 会把这个字符委托给状态 x 处理，也就是 dp[j][\'a\'] = dp[x][\'a\']：\n\n{:width=400} {:align=center}\n\n为什么这样可以呢？因为：既然 j 这边已经确定字符 "a" 无法推进状态，只能回退，而且 kmp 就是要尽可能少的回退，以免多余的计算。那么 j 就可以去问问和自己具有相同前缀的 x，如果 x 遇见 "a" 可以进行「状态推进」，那就转移过去，因为这样回退最少。\n\n{:width=400} {:align=center}\n\n当然，如果遇到的字符是 "b"，状态 x 也不能进行「状态推进」，只能回退，j 只要跟着 x 指引的方向回退就行了：\n\n{:width=400} {:align=center}\n\n你也许会问，这个 x 怎么知道遇到字符 "b" 要回退到状态 0 呢？因为 x 永远跟在 j 的身后，状态 x 如何转移，在之前就已经算出来了。动态规划算法不就是利用过去的结果解决现在的问题吗？\n\n这样，我们就细化一下刚才的框架代码：\n\nint x # 影子状态\nfor 0 <= j < m:\n    for 0 <= c < 256:\n        if c == pat[j]:\n            # 状态推进\n            dp[j][c] = j + 1\n        else: \n            # 状态重启\n            # 委托 x 计算重启位置\n            dp[j][c] = dp[x][c] \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n# 四、代码实现\n如果之前的内容你都能理解，恭喜你，现在就剩下一个问题：影子状态 x 是如何得到的呢？下面先直接看完整代码吧。\n\npublic class kmp {\n    private int[][] dp;\n    private string pat;\n\n    public kmp(string pat) {\n        this.pat = pat;\n        int m = pat.length();\n        // dp[状态][字符] = 下个状态\n        dp = new int[m][256];\n        // base case\n        dp[0][pat.charat(0)] = 1;\n        // 影子状态 x 初始为 0\n        int x = 0;\n        // 当前状态 j 从 1 开始\n        for (int j = 1; j < m; j++) {\n            for (int c = 0; c < 256; c++) {\n                if (pat.charat(j) == c) \n                    dp[j][c] = j + 1;\n                else \n                    dp[j][c] = dp[x][c];\n            }\n            // 更新影子状态\n            x = dp[x][pat.charat(j)];\n        }\n    }\n\n    public int search(string txt) {...}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n先解释一下这一行代码：\n\n// base case\ndp[0][pat.charat(0)] = 1;\n\n\n1\n2\n这行代码是 base case，只有遇到 pat[0] 这个字符才能使状态从 0 转移到 1，遇到其它字符的话还是停留在状态 0（java 默认初始化数组全为 0）。\n\n影子状态 x 是先初始化为 0，然后随着 j 的前进而不断更新的。下面看看到底应该如何更新影子状态 x：\n\nint x = 0;\nfor (int j = 1; j < m; j++) {\n    ...\n    // 更新影子状态\n    // 当前是状态 x，遇到字符 pat[j]，\n    // pat 应该转移到哪个状态？\n    x = dp[x][pat.charat(j)];\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n更新 x 其实和 search 函数中更新状态 j 的过程是非常相似的：\n\nint j = 0;\nfor (int i = 0; i < n; i++) {\n    // 当前是状态 j，遇到字符 txt[i]，\n    // pat 应该转移到哪个状态？\n    j = dp[j][txt.charat(i)];\n    ...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n其中的原理非常微妙，注意代码中 for 循环的变量初始值，可以这样理解：后者是在 txt 中匹配 pat，前者是在 pat 中匹配 pat[1..end]，状态 x 总是落后状态 j 一个状态，与 j 具有最长的相同前缀。所以我把 x 比喻为影子状态，似乎也有一点贴切。\n\n另外，构建 dp 数组是根据 base case dp[0][..] 向后推演。这就是我认为 kmp 算法就是一种动态规划算法的原因。\n\n下面来看一下状态转移图的完整构造过程，你就能理解状态 x 作用之精妙了：\n\n{:width=400} {:align=center}\n\n至此，kmp 算法的核心终于写完啦啦啦啦！看下 kmp 算法的完整代码吧：\n\npublic class kmp {\n    private int[][] dp;\n    private string pat;\n\n    public kmp(string pat) {\n        this.pat = pat;\n        int m = pat.length();\n        // dp[状态][字符] = 下个状态\n        dp = new int[m][256];\n        // base case\n        dp[0][pat.charat(0)] = 1;\n        // 影子状态 x 初始为 0\n        int x = 0;\n        // 构建状态转移图（稍改的更紧凑了）\n        for (int j = 1; j < m; j++) {\n            for (int c = 0; c < 256; c++) {\n                dp[j][c] = dp[x][c];\n            dp[j][pat.charat(j)] = j + 1;\n            // 更新影子状态\n            x = dp[x][pat.charat(j)];\n        }\n    }\n\n    public int search(string txt) {\n        int m = pat.length();\n        int n = txt.length();\n        // pat 的初始态为 0\n        int j = 0;\n        for (int i = 0; i < n; i++) {\n            // 计算 pat 的下一个状态\n            j = dp[j][txt.charat(i)];\n            // 到达终止态，返回结果\n            if (j == m) return i - m + 1;\n        }\n        // 没到达终止态，匹配失败\n        return -1;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n经过之前的详细举例讲解，你应该可以理解这段代码的含义了，当然你也可以把 kmp 算法写成一个函数。核心代码也就是两个函数中 for 循环的部分，数一下有超过十行吗？\n\n# 五、最后总结\n传统的 kmp 算法是使用一个一维数组 next 记录前缀信息，而本文是使用一个二维数组 dp 以状态转移的角度解决字符匹配问题，但是空间复杂度仍然是 o(256m) = o(m)。\n\n在 pat 匹配 txt 的过程中，只要明确了「当前处在哪个状态」和「遇到的字符是什么」这两个问题，就可以确定应该转移到哪个状态（推进或回退）。\n\n对于一个模式串 pat，其总共就有 m 个状态，对于 ascii 字符，总共不会超过 256 种。所以我们就构造一个数组 dp[m][256] 来包含所有情况，并且明确 dp 数组的含义：\n\ndp[j][c] = next 表示，当前是状态 j，遇到了字符 c，应该转移到状态 next。\n\n明确了其含义，就可以很容易写出 search 函数的代码。\n\n对于如何构建这个 dp 数组，需要一个辅助状态 x，它永远比当前状态 j 落后一个状态，拥有和 j 最长的相同前缀，我们给它起了个名字叫「影子状态」。\n\n在构建当前状态 j 的转移方向时，只有字符 pat[j] 才能使状态推进（dp[j][pat[j]] = j+1）；而对于其他字符只能进行状态回退，应该去请教影子状态 x 应该回退到哪里（dp[j][other] = dp[x][other]，其中 other 是除了 pat[j] 之外所有字符）。\n\n对于影子状态 x，我们把它初始化为 0，并且随着 j 的前进进行更新，更新的方式和 search 过程更新 j 的过程非常相似（x = dp[x][pat[j]]）。\n\nkmp 算法也就是动态规划那点事，我们的公众号文章目录有一系列专门讲动态规划的，而且都是按照一套框架来的，无非就是描述问题逻辑，明确 dp 数组含义，定义 base case 这点破事。希望这篇文章能让大家对动态规划有更深的理解。\n\n点击我的头像还有更多详细题解，如果本文对你有帮助，欢迎关注我的公众号 labuladong，致力于把算法问题讲清楚～ 后台回复关键词【资料】可获得我精选的经典技术书籍～\n\n{:width=400} {:align=center}\n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-04-29 22:47:13accepted [https://leetcode-cn.com//submissions/detail/1807884/]785 ms5.01%n/ajava2018-04-29 22:46:56accepted [https://leetcode-cn.com//submissions/detail/1807872/]814 ms5.01%n/ajava2018-04-29 22:42:59wrong answer [https://leetcode-cn.com//submissions/detail/1807749/]n/an/an/ajava2018-04-29 22:42:18wrong answer [https://leetcode-cn.com//submissions/detail/1807717/]n/an/an/ajava2018-04-29 22:37:58wrong answer [https://leetcode-cn.com//submissions/detail/1807566/]n/an/an/ajava2018-04-29 22:37:40wrong answer [https://leetcode-cn.com//submissions/detail/1807563/]n/an/an/ajava2018-04-29 22:36:21runtime error [https://leetcode-cn.com//submissions/detail/1807549/]n/an/an/ajava# 统计信息\n通过次数提交次数ac比率11841030101739.3%# 相似题目\n题目难度最短回文串 [https://leetcode-cn.com/problems/shortest-palindrome/]困难重复的子字符串 [https://leetcode-cn.com/problems/repeated-substring-pattern/]简单'},{title:"67-二进制求和(Add Binary)",frontmatter:{title:"67-二进制求和(Add Binary)",date:"2018-05-06T00:00:00.000Z",categories:["简单"],tags:["数学<Math>","字符串<String>"]},regularPath:"/views/%E7%AE%80%E5%8D%95/0067-%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%B1%82%E5%92%8C.html",relativePath:"views/简单/0067-二进制求和.md",key:"v-964e1e2e",path:"/views/%E7%AE%80%E5%8D%95/0067-%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%B1%82%E5%92%8C.html",headers:[{level:2,title:"中文题目",slug:"中文题目",charIndex:2},{level:2,title:"通过代码",slug:"通过代码",charIndex:144},{level:2,title:"高赞题解",slug:"高赞题解",charIndex:1701},{level:2,title:"解题方案",slug:"解题方案",charIndex:1708},{level:3,title:"思路",slug:"思路",charIndex:1715},{level:3,title:"代码",slug:"代码",charIndex:146},{level:3,title:"画解",slug:"画解",charIndex:3001},{level:2,title:"提交历史",slug:"提交历史",charIndex:3012},{level:2,title:"统计信息",slug:"统计信息",charIndex:3438},{level:2,title:"相似题目",slug:"相似题目",charIndex:3473}],lastUpdated:"4/11/2021, 1:15:21 PM",headersStr:"中文题目 通过代码 高赞题解 解题方案 思路 代码 画解 提交历史 统计信息 相似题目",content:'# 中文题目\n给定两个二进制字符串，返回他们的和（用二进制表示）。\n\n输入为非空字符串且只包含数字1和0。\n\n示例 1:\n\n输入: a = "11", b = "1"\n输出: "100"\n\n示例 2:\n\n输入: a = "1010", b = "1011"\n输出: "10101"\n\n# 通过代码\nclass Solution {\n    public String addBinary(String a, String b) {\n         StringBuilder sb = new StringBuilder();\n            int i = a.length() - 1, j = b.length() -1, carry = 0;\n            while (i >= 0 || j >= 0) {\n                /**\n                 * 一共四种情况 0+0+0=0   sb+0 carry=0\n                 *             1+0+0=1   sb+1 carry=0\n                 *             1+1+0=2   sb+0 carry=1\n                 *             1+1+1=3   sb+1 carry=1\n                 */\n                int sum = carry;\n                if (j >= 0) sum += b.charAt(j--) - \'0\';\n                if (i >= 0) sum += a.charAt(i--) - \'0\';\n\n                sb.append(sum % 2);\n                carry = sum / 2;\n            }\n            if (carry != 0) sb.append(carry);\n            return sb.reverse().toString();\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\nimport java.math.BigInteger;\nclass Solution {\n    public String addBinary(String a, String b) {\n        BigInteger decimal_a=new BigInteger(a,2);\n            BigInteger decimal_b=new BigInteger(b,2);\n            BigInteger sum =decimal_a.add(decimal_b);\n            String temp=sum.toString(2);\n            return temp; \n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\nimport java.math.BigInteger;\nclass Solution {\n    public String addBinary(String a, String b) {\n        BigInteger decimal_a=new BigInteger(a,2);\n            BigInteger decimal_b=new BigInteger(b,2);\n            BigInteger sum =decimal_a.add(decimal_b);\n            String temp=sum.toString(2);\n            return temp; \n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n# 高赞题解\n# 解题方案\n# 思路\n整体思路是将两个字符串较短的用 000 补齐，使得两个字符串长度一致，然后从末尾进行遍历计算，得到最终结果。\n\n本题解中大致思路与上述一致，但由于字符串操作原因，不确定最后的结果是否会多出一位进位，所以会有 2 种处理方式：\n\n * 第一种，在进行计算时直接拼接字符串，会得到一个反向字符，需要最后再进行翻转\n * 第二种，按照位置给结果字符赋值，最后如果有进位，则在前方进行字符串拼接添加进位\n\n时间复杂度：O(n)O(n)O(n)\n\n# 代码\nclass Solution {\n    public String addBinary(String a, String b) {\n        StringBuilder ans = new StringBuilder();\n        int ca = 0;\n        for(int i = a.length() - 1, j = b.length() - 1;i >= 0 || j >= 0; i--, j--) {\n            int sum = ca;\n            sum += i >= 0 ? a.charAt(i) - \'0\' : 0;\n            sum += j >= 0 ? b.charAt(j) - \'0\' : 0;\n            ans.append(sum % 2);\n            ca = sum / 2;\n        }\n        ans.append(ca == 1 ? ca : "");\n        return ans.reverse().toString();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n/**\n * @param {string} a\n * @param {string} b\n * @return {string}\n */\nvar addBinary = function(a, b) {\n    let ans = "";\n    let ca = 0;\n    for(let i = a.length - 1, j = b.length - 1;i >= 0 || j >= 0; i--, j--) {\n        let sum = ca;\n        sum += i >= 0 ? parseInt(a[i]) : 0;\n        sum += j >= 0 ? parseInt(b[j]) : 0;\n        ans += sum % 2;\n        ca = Math.floor(sum / 2);\n    }\n    ans += ca == 1 ? ca : "";\n    return ans.split(\'\').reverse().join(\'\');\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n# 画解\n<,,>\n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-05-06 22:36:29Accepted [https://leetcode-cn.com//submissions/detail/2026408/]3 ms62.95%N/Ajava2018-05-06 22:36:01Accepted [https://leetcode-cn.com//submissions/detail/2026388/]11 ms5.35%N/Ajava2018-05-06 22:35:46Accepted [https://leetcode-cn.com//submissions/detail/2026382/]11 ms5.35%N/Ajava2018-05-06 22:35:32Compile Error [https://leetcode-cn.com//submissions/detail/2026375/]N/AN/AN/Ajava# 统计信息\n通过次数提交次数AC比率5771611127851.9%# 相似题目\n题目难度两数相加 [https://leetcode-cn.com/problems/add-two-numbers/]中等字符串相乘 [https://leetcode-cn.com/problems/multiply-strings/]中等加一 [https://leetcode-cn.com/problems/plus-one/]简单数组形式的整数加法 [https://leetcode-cn.com/problems/add-to-array-form-of-integer/]简单',contentLowercase:'# 中文题目\n给定两个二进制字符串，返回他们的和（用二进制表示）。\n\n输入为非空字符串且只包含数字1和0。\n\n示例 1:\n\n输入: a = "11", b = "1"\n输出: "100"\n\n示例 2:\n\n输入: a = "1010", b = "1011"\n输出: "10101"\n\n# 通过代码\nclass solution {\n    public string addbinary(string a, string b) {\n         stringbuilder sb = new stringbuilder();\n            int i = a.length() - 1, j = b.length() -1, carry = 0;\n            while (i >= 0 || j >= 0) {\n                /**\n                 * 一共四种情况 0+0+0=0   sb+0 carry=0\n                 *             1+0+0=1   sb+1 carry=0\n                 *             1+1+0=2   sb+0 carry=1\n                 *             1+1+1=3   sb+1 carry=1\n                 */\n                int sum = carry;\n                if (j >= 0) sum += b.charat(j--) - \'0\';\n                if (i >= 0) sum += a.charat(i--) - \'0\';\n\n                sb.append(sum % 2);\n                carry = sum / 2;\n            }\n            if (carry != 0) sb.append(carry);\n            return sb.reverse().tostring();\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\nimport java.math.biginteger;\nclass solution {\n    public string addbinary(string a, string b) {\n        biginteger decimal_a=new biginteger(a,2);\n            biginteger decimal_b=new biginteger(b,2);\n            biginteger sum =decimal_a.add(decimal_b);\n            string temp=sum.tostring(2);\n            return temp; \n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\nimport java.math.biginteger;\nclass solution {\n    public string addbinary(string a, string b) {\n        biginteger decimal_a=new biginteger(a,2);\n            biginteger decimal_b=new biginteger(b,2);\n            biginteger sum =decimal_a.add(decimal_b);\n            string temp=sum.tostring(2);\n            return temp; \n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n# 高赞题解\n# 解题方案\n# 思路\n整体思路是将两个字符串较短的用 000 补齐，使得两个字符串长度一致，然后从末尾进行遍历计算，得到最终结果。\n\n本题解中大致思路与上述一致，但由于字符串操作原因，不确定最后的结果是否会多出一位进位，所以会有 2 种处理方式：\n\n * 第一种，在进行计算时直接拼接字符串，会得到一个反向字符，需要最后再进行翻转\n * 第二种，按照位置给结果字符赋值，最后如果有进位，则在前方进行字符串拼接添加进位\n\n时间复杂度：o(n)o(n)o(n)\n\n# 代码\nclass solution {\n    public string addbinary(string a, string b) {\n        stringbuilder ans = new stringbuilder();\n        int ca = 0;\n        for(int i = a.length() - 1, j = b.length() - 1;i >= 0 || j >= 0; i--, j--) {\n            int sum = ca;\n            sum += i >= 0 ? a.charat(i) - \'0\' : 0;\n            sum += j >= 0 ? b.charat(j) - \'0\' : 0;\n            ans.append(sum % 2);\n            ca = sum / 2;\n        }\n        ans.append(ca == 1 ? ca : "");\n        return ans.reverse().tostring();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n/**\n * @param {string} a\n * @param {string} b\n * @return {string}\n */\nvar addbinary = function(a, b) {\n    let ans = "";\n    let ca = 0;\n    for(let i = a.length - 1, j = b.length - 1;i >= 0 || j >= 0; i--, j--) {\n        let sum = ca;\n        sum += i >= 0 ? parseint(a[i]) : 0;\n        sum += j >= 0 ? parseint(b[j]) : 0;\n        ans += sum % 2;\n        ca = math.floor(sum / 2);\n    }\n    ans += ca == 1 ? ca : "";\n    return ans.split(\'\').reverse().join(\'\');\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n# 画解\n<,,>\n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-05-06 22:36:29accepted [https://leetcode-cn.com//submissions/detail/2026408/]3 ms62.95%n/ajava2018-05-06 22:36:01accepted [https://leetcode-cn.com//submissions/detail/2026388/]11 ms5.35%n/ajava2018-05-06 22:35:46accepted [https://leetcode-cn.com//submissions/detail/2026382/]11 ms5.35%n/ajava2018-05-06 22:35:32compile error [https://leetcode-cn.com//submissions/detail/2026375/]n/an/an/ajava# 统计信息\n通过次数提交次数ac比率5771611127851.9%# 相似题目\n题目难度两数相加 [https://leetcode-cn.com/problems/add-two-numbers/]中等字符串相乘 [https://leetcode-cn.com/problems/multiply-strings/]中等加一 [https://leetcode-cn.com/problems/plus-one/]简单数组形式的整数加法 [https://leetcode-cn.com/problems/add-to-array-form-of-integer/]简单'},{title:"58-最后一个单词的长度(Length of Last Word)",frontmatter:{title:"58-最后一个单词的长度(Length of Last Word)",date:"2018-05-01T00:00:00.000Z",categories:["简单"],tags:["字符串<String>"]},regularPath:"/views/%E7%AE%80%E5%8D%95/0058-%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E5%8D%95%E8%AF%8D%E7%9A%84%E9%95%BF%E5%BA%A6.html",relativePath:"views/简单/0058-最后一个单词的长度.md",key:"v-eab508ce",path:"/views/%E7%AE%80%E5%8D%95/0058-%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E5%8D%95%E8%AF%8D%E7%9A%84%E9%95%BF%E5%BA%A6.html",headers:[{level:2,title:"中文题目",slug:"中文题目",charIndex:2},{level:2,title:"通过代码",slug:"通过代码",charIndex:171},{level:2,title:"高赞题解",slug:"高赞题解",charIndex:599},{level:3,title:"思路",slug:"思路",charIndex:606},{level:3,title:"代码",slug:"代码",charIndex:173},{level:3,title:"画解",slug:"画解",charIndex:1525},{level:2,title:"提交历史",slug:"提交历史",charIndex:1540},{level:2,title:"统计信息",slug:"统计信息",charIndex:1667}],lastUpdated:"4/11/2021, 1:15:21 PM",headersStr:"中文题目 通过代码 高赞题解 思路 代码 画解 提交历史 统计信息",content:'# 中文题目\n给定一个仅包含大小写字母和空格\' \'的字符串 s，返回其最后一个单词的长度。\n\n如果字符串从左向右滚动显示，那么最后一个单词就是最后出现的单词。\n\n如果不存在最后一个单词，请返回 0 。\n\n说明：一个单词是指仅由字母组成、不包含任何空格的 最大子字符串。\n\n\n\n示例:\n\n输入: "Hello World"\n输出: 5\n\n\n# 通过代码\nclass Solution {\n    public int lengthOfLastWord(String s) {\n        if (null==s || "".equals(s)||" ".equals(s)){\n                return 0;\n            }\n            s=s.trim();\n            int i;\n            for ( i= s.length()-1; i >=0; i--) {\n                if (s.charAt(i)==\' \'){\n                    break;\n                }\n            }\n            return s.length()-i-1;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n# 高赞题解\n# 思路\n * 标签：字符串遍历\n * 从字符串末尾开始向前遍历，其中主要有两种情况\n * 第一种情况，以字符串"Hello World"为例，从后向前遍历直到遍历到头或者遇到空格为止，即为最后一个单词"World"的长度5\n * 第二种情况，以字符串"Hello World "为例，需要先将末尾的空格过滤掉，再进行第一种情况的操作，即认为最后一个单词为"World"，长度为5\n * 所以完整过程为先从后过滤掉空格找到单词尾部，再从尾部向前遍历，找到单词头部，最后两者相减，即为单词的长度\n * 时间复杂度：O(n)，n为结尾空格和结尾单词总体长度\n\n# 代码\nclass Solution {\n    public int lengthOfLastWord(String s) {\n        int end = s.length() - 1;\n        while(end >= 0 && s.charAt(end) == \' \') end--;\n        if(end < 0) return 0;\n        int start = end;\n        while(start >= 0 && s.charAt(start) != \' \') start--;\n        return end - start;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n/**\n * @param {string} s\n * @return {number}\n */\nvar lengthOfLastWord = function(s) {\n    let end = s.length - 1;\n    while(end >= 0 && s[end] == \' \') end--;\n    if(end < 0) return 0;\n    let start = end;\n    while(start >= 0 && s[start] != \' \') start--;\n    return end - start;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n# 画解\n<,,,,,,>\n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-05-01 22:09:04Accepted [https://leetcode-cn.com//submissions/detail/1859960/]4 ms7.11%N/Ajava# 统计信息\n通过次数提交次数AC比率6249719465432.1%',contentLowercase:'# 中文题目\n给定一个仅包含大小写字母和空格\' \'的字符串 s，返回其最后一个单词的长度。\n\n如果字符串从左向右滚动显示，那么最后一个单词就是最后出现的单词。\n\n如果不存在最后一个单词，请返回 0 。\n\n说明：一个单词是指仅由字母组成、不包含任何空格的 最大子字符串。\n\n\n\n示例:\n\n输入: "hello world"\n输出: 5\n\n\n# 通过代码\nclass solution {\n    public int lengthoflastword(string s) {\n        if (null==s || "".equals(s)||" ".equals(s)){\n                return 0;\n            }\n            s=s.trim();\n            int i;\n            for ( i= s.length()-1; i >=0; i--) {\n                if (s.charat(i)==\' \'){\n                    break;\n                }\n            }\n            return s.length()-i-1;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n# 高赞题解\n# 思路\n * 标签：字符串遍历\n * 从字符串末尾开始向前遍历，其中主要有两种情况\n * 第一种情况，以字符串"hello world"为例，从后向前遍历直到遍历到头或者遇到空格为止，即为最后一个单词"world"的长度5\n * 第二种情况，以字符串"hello world "为例，需要先将末尾的空格过滤掉，再进行第一种情况的操作，即认为最后一个单词为"world"，长度为5\n * 所以完整过程为先从后过滤掉空格找到单词尾部，再从尾部向前遍历，找到单词头部，最后两者相减，即为单词的长度\n * 时间复杂度：o(n)，n为结尾空格和结尾单词总体长度\n\n# 代码\nclass solution {\n    public int lengthoflastword(string s) {\n        int end = s.length() - 1;\n        while(end >= 0 && s.charat(end) == \' \') end--;\n        if(end < 0) return 0;\n        int start = end;\n        while(start >= 0 && s.charat(start) != \' \') start--;\n        return end - start;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n/**\n * @param {string} s\n * @return {number}\n */\nvar lengthoflastword = function(s) {\n    let end = s.length - 1;\n    while(end >= 0 && s[end] == \' \') end--;\n    if(end < 0) return 0;\n    let start = end;\n    while(start >= 0 && s[start] != \' \') start--;\n    return end - start;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n# 画解\n<,,,,,,>\n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-05-01 22:09:04accepted [https://leetcode-cn.com//submissions/detail/1859960/]4 ms7.11%n/ajava# 统计信息\n通过次数提交次数ac比率6249719465432.1%'},{title:"53-最大子序和(Maximum Subarray)",frontmatter:{title:"53-最大子序和(Maximum Subarray)",date:"2018-04-30T00:00:00.000Z",categories:["简单"],tags:["数组<Array>","分治算法<Divide and Conquer>","动态规划<Dynamic Programming>"]},regularPath:"/views/%E7%AE%80%E5%8D%95/0053-%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C.html",relativePath:"views/简单/0053-最大子序和.md",key:"v-86ef19d0",path:"/views/%E7%AE%80%E5%8D%95/0053-%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C.html",headers:[{level:2,title:"中文题目",slug:"中文题目",charIndex:2},{level:2,title:"通过代码",slug:"通过代码",charIndex:177},{level:2,title:"官方题解",slug:"官方题解",charIndex:6103},{level:2,title:"提交历史",slug:"提交历史",charIndex:10603},{level:2,title:"统计信息",slug:"统计信息",charIndex:11821},{level:2,title:"相似题目",slug:"相似题目",charIndex:11857}],lastUpdated:"4/11/2021, 1:15:21 PM",headersStr:"中文题目 通过代码 官方题解 提交历史 统计信息 相似题目",content:"# 中文题目\n给定一个整数数组 nums，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。\n\n示例:\n\n输入: [-2,1,-3,4,-1,2,1,-5,4],\n输出: 6\n解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。\n\n\n进阶:\n\n如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。\n\n# 通过代码\nclass Solution {\n    public int maxSubArray(int[] nums) {\n         if (nums.length==0 || nums==null){\n                return 0;\n            }\n            if (nums.length==1){\n                return nums[0];\n            }\n            int maxNum=nums[0];\n            int total=nums[0];\n            for (int i = 1; i < nums.length; i++) {\n                if (total<0){\n                    total=nums[i];\n                }else {\n                    total+=nums[i];\n                }\n                maxNum=(total>maxNum?total:maxNum);\n            }\n            return maxNum;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\nclass Solution {\n    public int maxSubArray(int[] nums) {\n         if (nums.length==0 || nums==null){\n                return 0;\n            }\n            if (nums.length==1){\n                return nums[0];\n            }\n            int maxNum=nums[0];\n            int total=nums[0];\n            for (int i = 1; i < nums.length; i++) {\n                if (total<0){\n                    total=nums[i];\n                }else {\n                    total+=nums[i];\n                }\n                maxNum=(total>maxNum?total:maxNum);\n            }\n            return maxNum;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\nclass Solution {\n    public int maxSubArray(int[] nums) {\n         if (nums.length==0 || nums==null){\n                return 0;\n            }\n            if (nums.length==1){\n                return nums[0];\n            }\n            int maxNum=nums[0];\n            int total=nums[0];\n            for (int i = 1; i < nums.length; i++) {\n                if (total<0){\n                    total=nums[i];\n                }else {\n                    total+=nums[i];\n                }\n                maxNum=(total>maxNum?total:maxNum);\n            }\n            return maxNum;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\nclass Solution {\n    public int maxSubArray(int[] nums) {\n         if (nums.length==0 || nums==null){\n                return 0;\n            }\n            if (nums.length==1){\n                return nums[0];\n            }\n            int maxNum=nums[0];\n            int total=nums[0];\n            for (int i = 1; i < nums.length; i++) {\n                if (total<0){\n                    total=nums[i];\n                }else {\n                    total+=nums[i];\n                }\n                maxNum=(total>maxNum?total:maxNum);\n            }\n            return maxNum;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\nclass Solution {\n    public int maxSubArray(int[] nums) {\n         if (nums.length==0 || nums==null){\n                return 0;\n            }\n            if (nums.length==1){\n                return nums[0];\n            }\n            int maxNum=nums[0];\n            int total=nums[0];\n            for (int i = 1; i < nums.length; i++) {\n                if (total<0){\n                    total=nums[i];\n                }else {\n                    total+=nums[i];\n                }\n                maxNum=(total>maxNum?total:maxNum);\n            }\n            return maxNum;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\nclass Solution {\n    public int maxSubArray(int[] nums) {\n         if (nums.length==0 || nums==null){\n                return 0;\n            }\n            if (nums.length==1){\n                return nums[0];\n            }\n            int maxNum=nums[0];\n            int total=nums[0];\n            for (int i = 1; i < nums.length; i++) {\n                if (total<0){\n                    total=nums[i];\n                }else {\n                    total+=nums[i];\n                }\n                maxNum=(total>maxNum?total:maxNum);\n            }\n            return maxNum;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\nclass Solution {\n    public int maxSubArray(int[] nums) {\n         if (nums.length==0 || nums==null){\n                return 0;\n            }\n            int maxNum=Integer.MIN_VALUE;\n            int total=0;\n            for (int i = 0; i < nums.length; i++) {\n                if (total<0){\n                    total=nums[i];\n                    if (total>maxNum){\n                        maxNum=total;\n                    }\n                }else {\n                    total+=nums[i];\n                    if (total>maxNum){\n                        maxNum=total;\n                    }\n                }\n            }\n            return maxNum;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\nclass Solution {\n    public int maxSubArray(int[] nums) {\n         if (nums.length==0 || nums==null){\n                return 0;\n            }\n            int maxNum=Integer.MIN_VALUE;\n            int total=0;\n            for (int i = 0; i < nums.length; i++) {\n                if (total<0){\n                    total=nums[i];\n                    if (total>maxNum){\n                        maxNum=total;\n                    }\n                }else {\n                    total+=nums[i];\n                    if (total>maxNum){\n                        maxNum=total;\n                    }\n                }\n            }\n            return maxNum;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\nclass Solution {\n    public int maxSubArray(int[] nums) {\n         if (nums.length==0 || nums==null){\n                return 0;\n            }\n            int maxNum=Integer.MIN_VALUE;\n            int total=0;\n            for (int i = 0; i < nums.length; i++) {\n                if (total<0){\n                    total=nums[i];\n                    if (total>maxNum){\n                        maxNum=total;\n                    }\n                }else {\n                    total+=nums[i];\n                    if (total>maxNum){\n                        maxNum=total;\n                    }\n                }\n            }\n            return maxNum;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n# 官方题解\n# 方法一：分治法\n这个是使用分治法解决问题的典型的例子，并且可以用与合并排序相似的算法求解。下面是用分治法解决问题的模板：\n\n * 定义基本情况。\n * 将问题分解为子问题并递归地解决它们。\n * 合并子问题的解以获得原始问题的解。\n\n算法：当最大子数组有 n 个数字时：\n\n * 若 n==1，返回此元素。\n * left_sum 为最大子数组前 n/2 个元素，在索引为 (left + right) / 2 的元素属于左子数组。\n * right_sum 为最大子数组的右子数组，为最后 n/2 的元素。\n * cross_sum 是包含左右子数组且含索引 (left + right) / 2 的最大值。\n\n{:width=600}\n\nclass Solution:\n    def cross_sum(self, nums, left, right, p): \n            if left == right:\n                return nums[left]\n\n            left_subsum = float('-inf')\n            curr_sum = 0\n            for i in range(p, left - 1, -1):\n                curr_sum += nums[i]\n                left_subsum = max(left_subsum, curr_sum)\n\n            right_subsum = float('-inf')\n            curr_sum = 0\n            for i in range(p + 1, right + 1):\n                curr_sum += nums[i]\n                right_subsum = max(right_subsum, curr_sum)\n\n            return left_subsum + right_subsum   \n    \n    def helper(self, nums, left, right): \n        if left == right:\n            return nums[left]\n        \n        p = (left + right) // 2\n            \n        left_sum = self.helper(nums, left, p)\n        right_sum = self.helper(nums, p + 1, right)\n        cross_sum = self.cross_sum(nums, left, right, p)\n        \n        return max(left_sum, right_sum, cross_sum)\n        \n    def maxSubArray(self, nums: 'List[int]') -> 'int':\n        return self.helper(nums, 0, len(nums) - 1)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\nclass Solution {\n  public int crossSum(int[] nums, int left, int right, int p) {\n    if (left == right) return nums[left];\n\n    int leftSubsum = Integer.MIN_VALUE;\n    int currSum = 0;\n    for(int i = p; i > left - 1; --i) {\n      currSum += nums[i];\n      leftSubsum = Math.max(leftSubsum, currSum);\n    }\n\n    int rightSubsum = Integer.MIN_VALUE;\n    currSum = 0;\n    for(int i = p + 1; i < right + 1; ++i) {\n      currSum += nums[i];\n      rightSubsum = Math.max(rightSubsum, currSum);\n    }\n\n    return leftSubsum + rightSubsum;\n  }\n\n  public int helper(int[] nums, int left, int right) {\n    if (left == right) return nums[left];\n\n    int p = (left + right) / 2;\n\n    int leftSum = helper(nums, left, p);\n    int rightSum = helper(nums, p + 1, right);\n    int crossSum = crossSum(nums, left, right, p);\n\n    return Math.max(Math.max(leftSum, rightSum), crossSum);\n  }\n\n  public int maxSubArray(int[] nums) {\n    return helper(nums, 0, nums.length - 1);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n复杂度分析\n\n * 时间复杂度：O(Nlog⁡N)\\mathcal{O}(N \\log N)O(NlogN)。\n * 空间复杂度：O(log⁡N)\\mathcal{O}(\\log N)O(logN)，递归时栈使用的空间。\n\n# 方法二：贪心\n * 使用单个数组作为输入来查找最大（或最小）元素（或总和）的问题，贪心算法是可以在线性时间解决的方法之一。\n * 每一步都选择最佳方案，到最后就是全局最优的方案。\n\n算法：该算法通用且简单：遍历数组并在每个步骤中更新：\n\n * 当前元素\n * 当前元素位置的最大和\n * 迄今为止的最大和\n\nclass Solution:\n    def maxSubArray(self, nums: 'List[int]') -> 'int':\n        n = len(nums)\n        curr_sum = max_sum = nums[0]\n\n        for i in range(1, n):\n            curr_sum = max(nums[i], curr_sum + nums[i])\n            max_sum = max(max_sum, curr_sum)\n            \n        return max_sum\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\nclass Solution {\n  public int maxSubArray(int[] nums) {\n    int n = nums.length;\n    int currSum = nums[0], maxSum = nums[0];\n\n    for(int i = 1; i < n; ++i) {\n      currSum = Math.max(nums[i], currSum + nums[i]);\n      maxSum = Math.max(maxSum, currSum);\n    }\n    return maxSum;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n复杂度分析\n\n * 时间复杂度：O(N)\\mathcal{O}(N)O(N)。只遍历一次数组。\n * 空间复杂度：O(1)\\mathcal{O}(1)O(1)，只使用了常数空间。\n\n# 方法三：动态规划（Kadane 算法）\n算法：\n\n * 在整个数组或在固定大小的滑动窗口中找到总和或最大值或最小值的问题可以通过动态规划（DP）在线性时间内解决。\n * 有两种标准 DP 方法适用于数组：\n\n 1. 常数空间，沿数组移动并在原数组修改。\n 2. 线性空间，首先沿 left->right 方向移动，然后再沿 right->left 方向移动。 合并结果。\n\n * 我们在这里使用第一种方法，因为可以修改数组跟踪当前位置的最大和。\n * 下一步是在知道当前位置的最大和后更新全局最大和。\n\nclass Solution:\n    def maxSubArray(self, nums: 'List[int]') -> 'int':\n        n = len(nums)\n        max_sum = nums[0]\n        for i in range(1, n):\n            if nums[i - 1] > 0:\n                nums[i] += nums[i - 1] \n            max_sum = max(nums[i], max_sum)\n\n        return max_sum\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\nclass Solution {\n  public int maxSubArray(int[] nums) {\n    int n = nums.length, maxSum = nums[0];\n    for(int i = 1; i < n; ++i) {\n      if (nums[i - 1] > 0) nums[i] += nums[i - 1];\n      maxSum = Math.max(nums[i], maxSum);\n    }\n    return maxSum;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n复杂度分析\n\n * 时间复杂度：O(N)\\mathcal{O}(N)O(N)。只遍历了一次数组。\n * 空间复杂度：O(1)\\mathcal{O}(1)O(1)，使用了常数的空间。\n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-04-30 22:40:01Accepted [https://leetcode-cn.com//submissions/detail/1834223/]29 ms9.82%N/Ajava2018-04-30 22:39:52Accepted [https://leetcode-cn.com//submissions/detail/1834218/]30 ms9.82%N/Ajava2018-04-30 22:37:55Accepted [https://leetcode-cn.com//submissions/detail/1834185/]28 ms9.82%N/Ajava2018-04-30 22:37:43Accepted [https://leetcode-cn.com//submissions/detail/1834182/]27 ms9.82%N/Ajava2018-04-30 22:37:34Accepted [https://leetcode-cn.com//submissions/detail/1834178/]27 ms9.82%N/Ajava2018-04-30 22:37:19Accepted [https://leetcode-cn.com//submissions/detail/1834173/]10 ms10.03%N/Ajava2018-04-30 22:35:44Wrong Answer [https://leetcode-cn.com//submissions/detail/1834142/]N/AN/AN/Ajava2018-04-30 22:31:51Accepted [https://leetcode-cn.com//submissions/detail/1834076/]36 ms9.78%N/Ajava2018-04-30 22:31:39Accepted [https://leetcode-cn.com//submissions/detail/1834073/]31 ms9.82%N/Ajava2018-04-30 22:30:50Accepted [https://leetcode-cn.com//submissions/detail/1834054/]19 ms9.85%N/Ajava2018-04-30 22:28:04Wrong Answer [https://leetcode-cn.com//submissions/detail/1833992/]N/AN/AN/Ajava2018-04-30 22:26:40Wrong Answer [https://leetcode-cn.com//submissions/detail/1833966/]N/AN/AN/Ajava# 统计信息\n通过次数提交次数AC比率14574829934848.7%# 相似题目\n题目难度买卖股票的最佳时机 [https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/]简单乘积最大子序列 [https://leetcode-cn.com/problems/maximum-product-subarray/]中等数组的度 [https://leetcode-cn.com/problems/degree-of-an-array/]简单最长湍流子数组 [https://leetcode-cn.com/problems/longest-turbulent-subarray/]中等",contentLowercase:"# 中文题目\n给定一个整数数组 nums，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。\n\n示例:\n\n输入: [-2,1,-3,4,-1,2,1,-5,4],\n输出: 6\n解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。\n\n\n进阶:\n\n如果你已经实现复杂度为 o(n) 的解法，尝试使用更为精妙的分治法求解。\n\n# 通过代码\nclass solution {\n    public int maxsubarray(int[] nums) {\n         if (nums.length==0 || nums==null){\n                return 0;\n            }\n            if (nums.length==1){\n                return nums[0];\n            }\n            int maxnum=nums[0];\n            int total=nums[0];\n            for (int i = 1; i < nums.length; i++) {\n                if (total<0){\n                    total=nums[i];\n                }else {\n                    total+=nums[i];\n                }\n                maxnum=(total>maxnum?total:maxnum);\n            }\n            return maxnum;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\nclass solution {\n    public int maxsubarray(int[] nums) {\n         if (nums.length==0 || nums==null){\n                return 0;\n            }\n            if (nums.length==1){\n                return nums[0];\n            }\n            int maxnum=nums[0];\n            int total=nums[0];\n            for (int i = 1; i < nums.length; i++) {\n                if (total<0){\n                    total=nums[i];\n                }else {\n                    total+=nums[i];\n                }\n                maxnum=(total>maxnum?total:maxnum);\n            }\n            return maxnum;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\nclass solution {\n    public int maxsubarray(int[] nums) {\n         if (nums.length==0 || nums==null){\n                return 0;\n            }\n            if (nums.length==1){\n                return nums[0];\n            }\n            int maxnum=nums[0];\n            int total=nums[0];\n            for (int i = 1; i < nums.length; i++) {\n                if (total<0){\n                    total=nums[i];\n                }else {\n                    total+=nums[i];\n                }\n                maxnum=(total>maxnum?total:maxnum);\n            }\n            return maxnum;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\nclass solution {\n    public int maxsubarray(int[] nums) {\n         if (nums.length==0 || nums==null){\n                return 0;\n            }\n            if (nums.length==1){\n                return nums[0];\n            }\n            int maxnum=nums[0];\n            int total=nums[0];\n            for (int i = 1; i < nums.length; i++) {\n                if (total<0){\n                    total=nums[i];\n                }else {\n                    total+=nums[i];\n                }\n                maxnum=(total>maxnum?total:maxnum);\n            }\n            return maxnum;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\nclass solution {\n    public int maxsubarray(int[] nums) {\n         if (nums.length==0 || nums==null){\n                return 0;\n            }\n            if (nums.length==1){\n                return nums[0];\n            }\n            int maxnum=nums[0];\n            int total=nums[0];\n            for (int i = 1; i < nums.length; i++) {\n                if (total<0){\n                    total=nums[i];\n                }else {\n                    total+=nums[i];\n                }\n                maxnum=(total>maxnum?total:maxnum);\n            }\n            return maxnum;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\nclass solution {\n    public int maxsubarray(int[] nums) {\n         if (nums.length==0 || nums==null){\n                return 0;\n            }\n            if (nums.length==1){\n                return nums[0];\n            }\n            int maxnum=nums[0];\n            int total=nums[0];\n            for (int i = 1; i < nums.length; i++) {\n                if (total<0){\n                    total=nums[i];\n                }else {\n                    total+=nums[i];\n                }\n                maxnum=(total>maxnum?total:maxnum);\n            }\n            return maxnum;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\nclass solution {\n    public int maxsubarray(int[] nums) {\n         if (nums.length==0 || nums==null){\n                return 0;\n            }\n            int maxnum=integer.min_value;\n            int total=0;\n            for (int i = 0; i < nums.length; i++) {\n                if (total<0){\n                    total=nums[i];\n                    if (total>maxnum){\n                        maxnum=total;\n                    }\n                }else {\n                    total+=nums[i];\n                    if (total>maxnum){\n                        maxnum=total;\n                    }\n                }\n            }\n            return maxnum;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\nclass solution {\n    public int maxsubarray(int[] nums) {\n         if (nums.length==0 || nums==null){\n                return 0;\n            }\n            int maxnum=integer.min_value;\n            int total=0;\n            for (int i = 0; i < nums.length; i++) {\n                if (total<0){\n                    total=nums[i];\n                    if (total>maxnum){\n                        maxnum=total;\n                    }\n                }else {\n                    total+=nums[i];\n                    if (total>maxnum){\n                        maxnum=total;\n                    }\n                }\n            }\n            return maxnum;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\nclass solution {\n    public int maxsubarray(int[] nums) {\n         if (nums.length==0 || nums==null){\n                return 0;\n            }\n            int maxnum=integer.min_value;\n            int total=0;\n            for (int i = 0; i < nums.length; i++) {\n                if (total<0){\n                    total=nums[i];\n                    if (total>maxnum){\n                        maxnum=total;\n                    }\n                }else {\n                    total+=nums[i];\n                    if (total>maxnum){\n                        maxnum=total;\n                    }\n                }\n            }\n            return maxnum;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n# 官方题解\n# 方法一：分治法\n这个是使用分治法解决问题的典型的例子，并且可以用与合并排序相似的算法求解。下面是用分治法解决问题的模板：\n\n * 定义基本情况。\n * 将问题分解为子问题并递归地解决它们。\n * 合并子问题的解以获得原始问题的解。\n\n算法：当最大子数组有 n 个数字时：\n\n * 若 n==1，返回此元素。\n * left_sum 为最大子数组前 n/2 个元素，在索引为 (left + right) / 2 的元素属于左子数组。\n * right_sum 为最大子数组的右子数组，为最后 n/2 的元素。\n * cross_sum 是包含左右子数组且含索引 (left + right) / 2 的最大值。\n\n{:width=600}\n\nclass solution:\n    def cross_sum(self, nums, left, right, p): \n            if left == right:\n                return nums[left]\n\n            left_subsum = float('-inf')\n            curr_sum = 0\n            for i in range(p, left - 1, -1):\n                curr_sum += nums[i]\n                left_subsum = max(left_subsum, curr_sum)\n\n            right_subsum = float('-inf')\n            curr_sum = 0\n            for i in range(p + 1, right + 1):\n                curr_sum += nums[i]\n                right_subsum = max(right_subsum, curr_sum)\n\n            return left_subsum + right_subsum   \n    \n    def helper(self, nums, left, right): \n        if left == right:\n            return nums[left]\n        \n        p = (left + right) // 2\n            \n        left_sum = self.helper(nums, left, p)\n        right_sum = self.helper(nums, p + 1, right)\n        cross_sum = self.cross_sum(nums, left, right, p)\n        \n        return max(left_sum, right_sum, cross_sum)\n        \n    def maxsubarray(self, nums: 'list[int]') -> 'int':\n        return self.helper(nums, 0, len(nums) - 1)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\nclass solution {\n  public int crosssum(int[] nums, int left, int right, int p) {\n    if (left == right) return nums[left];\n\n    int leftsubsum = integer.min_value;\n    int currsum = 0;\n    for(int i = p; i > left - 1; --i) {\n      currsum += nums[i];\n      leftsubsum = math.max(leftsubsum, currsum);\n    }\n\n    int rightsubsum = integer.min_value;\n    currsum = 0;\n    for(int i = p + 1; i < right + 1; ++i) {\n      currsum += nums[i];\n      rightsubsum = math.max(rightsubsum, currsum);\n    }\n\n    return leftsubsum + rightsubsum;\n  }\n\n  public int helper(int[] nums, int left, int right) {\n    if (left == right) return nums[left];\n\n    int p = (left + right) / 2;\n\n    int leftsum = helper(nums, left, p);\n    int rightsum = helper(nums, p + 1, right);\n    int crosssum = crosssum(nums, left, right, p);\n\n    return math.max(math.max(leftsum, rightsum), crosssum);\n  }\n\n  public int maxsubarray(int[] nums) {\n    return helper(nums, 0, nums.length - 1);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n复杂度分析\n\n * 时间复杂度：o(nlog⁡n)\\mathcal{o}(n \\log n)o(nlogn)。\n * 空间复杂度：o(log⁡n)\\mathcal{o}(\\log n)o(logn)，递归时栈使用的空间。\n\n# 方法二：贪心\n * 使用单个数组作为输入来查找最大（或最小）元素（或总和）的问题，贪心算法是可以在线性时间解决的方法之一。\n * 每一步都选择最佳方案，到最后就是全局最优的方案。\n\n算法：该算法通用且简单：遍历数组并在每个步骤中更新：\n\n * 当前元素\n * 当前元素位置的最大和\n * 迄今为止的最大和\n\nclass solution:\n    def maxsubarray(self, nums: 'list[int]') -> 'int':\n        n = len(nums)\n        curr_sum = max_sum = nums[0]\n\n        for i in range(1, n):\n            curr_sum = max(nums[i], curr_sum + nums[i])\n            max_sum = max(max_sum, curr_sum)\n            \n        return max_sum\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\nclass solution {\n  public int maxsubarray(int[] nums) {\n    int n = nums.length;\n    int currsum = nums[0], maxsum = nums[0];\n\n    for(int i = 1; i < n; ++i) {\n      currsum = math.max(nums[i], currsum + nums[i]);\n      maxsum = math.max(maxsum, currsum);\n    }\n    return maxsum;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n复杂度分析\n\n * 时间复杂度：o(n)\\mathcal{o}(n)o(n)。只遍历一次数组。\n * 空间复杂度：o(1)\\mathcal{o}(1)o(1)，只使用了常数空间。\n\n# 方法三：动态规划（kadane 算法）\n算法：\n\n * 在整个数组或在固定大小的滑动窗口中找到总和或最大值或最小值的问题可以通过动态规划（dp）在线性时间内解决。\n * 有两种标准 dp 方法适用于数组：\n\n 1. 常数空间，沿数组移动并在原数组修改。\n 2. 线性空间，首先沿 left->right 方向移动，然后再沿 right->left 方向移动。 合并结果。\n\n * 我们在这里使用第一种方法，因为可以修改数组跟踪当前位置的最大和。\n * 下一步是在知道当前位置的最大和后更新全局最大和。\n\nclass solution:\n    def maxsubarray(self, nums: 'list[int]') -> 'int':\n        n = len(nums)\n        max_sum = nums[0]\n        for i in range(1, n):\n            if nums[i - 1] > 0:\n                nums[i] += nums[i - 1] \n            max_sum = max(nums[i], max_sum)\n\n        return max_sum\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\nclass solution {\n  public int maxsubarray(int[] nums) {\n    int n = nums.length, maxsum = nums[0];\n    for(int i = 1; i < n; ++i) {\n      if (nums[i - 1] > 0) nums[i] += nums[i - 1];\n      maxsum = math.max(nums[i], maxsum);\n    }\n    return maxsum;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n复杂度分析\n\n * 时间复杂度：o(n)\\mathcal{o}(n)o(n)。只遍历了一次数组。\n * 空间复杂度：o(1)\\mathcal{o}(1)o(1)，使用了常数的空间。\n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-04-30 22:40:01accepted [https://leetcode-cn.com//submissions/detail/1834223/]29 ms9.82%n/ajava2018-04-30 22:39:52accepted [https://leetcode-cn.com//submissions/detail/1834218/]30 ms9.82%n/ajava2018-04-30 22:37:55accepted [https://leetcode-cn.com//submissions/detail/1834185/]28 ms9.82%n/ajava2018-04-30 22:37:43accepted [https://leetcode-cn.com//submissions/detail/1834182/]27 ms9.82%n/ajava2018-04-30 22:37:34accepted [https://leetcode-cn.com//submissions/detail/1834178/]27 ms9.82%n/ajava2018-04-30 22:37:19accepted [https://leetcode-cn.com//submissions/detail/1834173/]10 ms10.03%n/ajava2018-04-30 22:35:44wrong answer [https://leetcode-cn.com//submissions/detail/1834142/]n/an/an/ajava2018-04-30 22:31:51accepted [https://leetcode-cn.com//submissions/detail/1834076/]36 ms9.78%n/ajava2018-04-30 22:31:39accepted [https://leetcode-cn.com//submissions/detail/1834073/]31 ms9.82%n/ajava2018-04-30 22:30:50accepted [https://leetcode-cn.com//submissions/detail/1834054/]19 ms9.85%n/ajava2018-04-30 22:28:04wrong answer [https://leetcode-cn.com//submissions/detail/1833992/]n/an/an/ajava2018-04-30 22:26:40wrong answer [https://leetcode-cn.com//submissions/detail/1833966/]n/an/an/ajava# 统计信息\n通过次数提交次数ac比率14574829934848.7%# 相似题目\n题目难度买卖股票的最佳时机 [https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/]简单乘积最大子序列 [https://leetcode-cn.com/problems/maximum-product-subarray/]中等数组的度 [https://leetcode-cn.com/problems/degree-of-an-array/]简单最长湍流子数组 [https://leetcode-cn.com/problems/longest-turbulent-subarray/]中等"},{title:"66-加一(Plus One)",frontmatter:{title:"66-加一(Plus One)",date:"2018-05-03T00:00:00.000Z",categories:["简单"],tags:["数组<Array>"]},regularPath:"/views/%E7%AE%80%E5%8D%95/0066-%E5%8A%A0%E4%B8%80.html",relativePath:"views/简单/0066-加一.md",key:"v-08aa0349",path:"/views/%E7%AE%80%E5%8D%95/0066-%E5%8A%A0%E4%B8%80.html",headers:[{level:2,title:"中文题目",slug:"中文题目",charIndex:2},{level:2,title:"通过代码",slug:"通过代码",charIndex:211},{level:2,title:"高赞题解",slug:"高赞题解",charIndex:681},{level:2,title:"提交历史",slug:"提交历史",charIndex:1346},{level:2,title:"统计信息",slug:"统计信息",charIndex:1474},{level:2,title:"相似题目",slug:"相似题目",charIndex:1510}],lastUpdated:"4/11/2021, 1:15:21 PM",headersStr:"中文题目 通过代码 高赞题解 提交历史 统计信息 相似题目",content:"# 中文题目\n给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。\n\n最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。\n\n你可以假设除了整数 0 之外，这个整数不会以零开头。\n\n示例 1:\n\n输入: [1,2,3]\n输出: [1,2,4]\n解释: 输入数组表示数字 123。\n\n\n示例 2:\n\n输入: [4,3,2,1]\n输出: [4,3,2,2]\n解释: 输入数组表示数字 4321。\n\n\n# 通过代码\nclass Solution {\n    public int[] plusOne(int[] digits) {\n        for (int i = digits.length-1; i >=0 ; i--) {\n                if (digits[i]<9){\n                    digits[i]++;\n                    return digits;\n                }else {\n                    digits[i]=0;\n                }\n            }\n\n            int[] new_digits=new int[digits.length+1];\n            new_digits[0]=1;\n            return new_digits;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n# 高赞题解\n根据题意加一，没错就是加一这很重要，因为它是只加一的所以有可能的情况就只有两种：\n\n 1. 除 999 之外的数字加一；\n 2. 数字 999。\n\n加一得十进一位个位数为 000 加法运算如不出现进位就运算结束了且进位只会是一。\n\n所以只需要判断有没有进位并模拟出它的进位方式，如十位数加 111 个位数置为 000，如此循环直到判断没有再进位就退出循环返回结果。\n\n然后还有一些特殊情况就是当出现 999999、999999999 之类的数字时，循环到最后也需要进位，出现这种情况时需要手动将它进一位。\n\nclass Solution {\n    public int[] plusOne(int[] digits) {\n        for (int i = digits.length - 1; i >= 0; i--) {\n            digits[i]++;\n            digits[i] = digits[i] % 10;\n            if (digits[i] != 0) return digits;\n        }\n        digits = new int[digits.length + 1];\n        digits[0] = 1;\n        return digits;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\nPS：本人并非大佬，这是第一次写思路解释，如有写的不好的地方请多多包涵，哈哈哈\n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-05-03 22:56:59Accepted [https://leetcode-cn.com//submissions/detail/1941023/]0 ms100.0%N/Ajava# 统计信息\n通过次数提交次数AC比率10969525789642.5%# 相似题目\n题目难度字符串相乘 [https://leetcode-cn.com/problems/multiply-strings/]中等二进制求和 [https://leetcode-cn.com/problems/add-binary/]简单给单链表加一 [https://leetcode-cn.com/problems/plus-one-linked-list/]中等数组形式的整数加法 [https://leetcode-cn.com/problems/add-to-array-form-of-integer/]简单",contentLowercase:"# 中文题目\n给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。\n\n最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。\n\n你可以假设除了整数 0 之外，这个整数不会以零开头。\n\n示例 1:\n\n输入: [1,2,3]\n输出: [1,2,4]\n解释: 输入数组表示数字 123。\n\n\n示例 2:\n\n输入: [4,3,2,1]\n输出: [4,3,2,2]\n解释: 输入数组表示数字 4321。\n\n\n# 通过代码\nclass solution {\n    public int[] plusone(int[] digits) {\n        for (int i = digits.length-1; i >=0 ; i--) {\n                if (digits[i]<9){\n                    digits[i]++;\n                    return digits;\n                }else {\n                    digits[i]=0;\n                }\n            }\n\n            int[] new_digits=new int[digits.length+1];\n            new_digits[0]=1;\n            return new_digits;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n# 高赞题解\n根据题意加一，没错就是加一这很重要，因为它是只加一的所以有可能的情况就只有两种：\n\n 1. 除 999 之外的数字加一；\n 2. 数字 999。\n\n加一得十进一位个位数为 000 加法运算如不出现进位就运算结束了且进位只会是一。\n\n所以只需要判断有没有进位并模拟出它的进位方式，如十位数加 111 个位数置为 000，如此循环直到判断没有再进位就退出循环返回结果。\n\n然后还有一些特殊情况就是当出现 999999、999999999 之类的数字时，循环到最后也需要进位，出现这种情况时需要手动将它进一位。\n\nclass solution {\n    public int[] plusone(int[] digits) {\n        for (int i = digits.length - 1; i >= 0; i--) {\n            digits[i]++;\n            digits[i] = digits[i] % 10;\n            if (digits[i] != 0) return digits;\n        }\n        digits = new int[digits.length + 1];\n        digits[0] = 1;\n        return digits;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\nps：本人并非大佬，这是第一次写思路解释，如有写的不好的地方请多多包涵，哈哈哈\n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-05-03 22:56:59accepted [https://leetcode-cn.com//submissions/detail/1941023/]0 ms100.0%n/ajava# 统计信息\n通过次数提交次数ac比率10969525789642.5%# 相似题目\n题目难度字符串相乘 [https://leetcode-cn.com/problems/multiply-strings/]中等二进制求和 [https://leetcode-cn.com/problems/add-binary/]简单给单链表加一 [https://leetcode-cn.com/problems/plus-one-linked-list/]中等数组形式的整数加法 [https://leetcode-cn.com/problems/add-to-array-form-of-integer/]简单"},{title:"83-删除排序链表中的重复元素(Remove Duplicates from Sorted List)",frontmatter:{title:"83-删除排序链表中的重复元素(Remove Duplicates from Sorted List)",date:"2018-09-03T00:00:00.000Z",categories:["简单"],tags:["链表<Linked List>"]},regularPath:"/views/%E7%AE%80%E5%8D%95/0083-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0.html",relativePath:"views/简单/0083-删除排序链表中的重复元素.md",key:"v-f3ca02fe",path:"/views/%E7%AE%80%E5%8D%95/0083-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0.html",headers:[{level:2,title:"中文题目",slug:"中文题目",charIndex:2},{level:2,title:"通过代码",slug:"通过代码",charIndex:110},{level:2,title:"官方题解",slug:"官方题解",charIndex:2376},{level:2,title:"提交历史",slug:"提交历史",charIndex:3677},{level:2,title:"统计信息",slug:"统计信息",charIndex:4200},{level:2,title:"相似题目",slug:"相似题目",charIndex:4235}],lastUpdated:"4/11/2021, 1:15:21 PM",headersStr:"中文题目 通过代码 官方题解 提交历史 统计信息 相似题目",content:"# 中文题目\n给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。\n\n示例 1:\n\n输入: 1->1->2\n输出: 1->2\n\n\n示例 2:\n\n输入: 1->1->2->3->3\n输出: 1->2->3\n\n# 通过代码\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public ListNode deleteDuplicates(ListNode head) {\n        if (head == null) {\n                return null;\n            }\n            ListNode temp1 = head;\n            ListNode temp2 = head.next;\n            while (temp2 != null) {\n                if (temp2.val != temp1.val) {\n                    temp1.next = temp2;\n                    temp1 = temp2;\n                } else {\n                    temp2 = temp2.next;\n                }\n            }\n            temp1.next = null;\n            return head;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public ListNode deleteDuplicates(ListNode head) {\n        if (head == null) {\n                return null;\n            }\n            ListNode temp1 = head;\n            ListNode temp2 = head.next;\n            while (temp2 != null) {\n                if (temp2.val != temp1.val) {\n                    temp1.next = temp2;\n                    temp1 = temp2;\n                } else {\n                    temp2 = temp2.next;\n                }\n            }\n            temp1.next = null;\n            return head;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public ListNode deleteDuplicates(ListNode head) {\n        if (head==null){\n                return null;\n            }\n        ListNode temp1=head;\n            ListNode temp2=head.next;\n            while (temp2!=null){\n                if (temp2.val != temp1.val){\n                    temp1.next=temp2;\n                    temp1=temp2;\n                }else {\n                    temp2=temp2.next;\n                }\n            }\n                    temp1.next=null;\n\n            return head;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n# 官方题解\n# 方法：直接法\n算法\n\n这是一个简单的问题，仅测试你操作列表的结点指针的能力。由于输入的列表已排序，因此我们可以通过将结点的值与它之后的结点进行比较来确定它是否为重复结点。如果它是重复的，我们更改当前结点的 next 指针，以便它跳过下一个结点并直接指向下一个结点之后的结点。\n\npublic ListNode deleteDuplicates(ListNode head) {\n    ListNode current = head;\n    while (current != null && current.next != null) {\n        if (current.next.val == current.val) {\n            current.next = current.next.next;\n        } else {\n            current = current.next;\n        }\n    }\n    return head;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n复杂度分析\n\n * 时间复杂度：O(n)O(n)O(n)，因为列表中的每个结点都检查一次以确定它是否重复，所以总运行时间为 O(n)O(n)O(n)，其中 nnn 是列表中的结点数。\n   \n   \n * 空间复杂度：O(1)O(1)O(1)，没有使用额外的空间。\n   \n   \n\n正确性\n\n我们可以通过定义循环不变式来证明此代码的正确性。循环不变式是在循环的每次迭代之前和之后为真的条件。在这种情况下，一个帮助我们证明正确性的循环不变式是这样的：\n\n> 列表中直到指针 current 的所有结点都不包含重复的元素。\n\n\n我们可以用归纳法证明这种情况确实是循环不变式。在进入循环之前，current 指向列表的头部。因此，列表中直到 current 的部分只包含头部。因此它不能包含任何重复的元素。现在假设current 现在指向列表中的某个结点（但不是最后一个元素），并且列表中直到 current 的部分不包含重复元素。在另一个循环迭代之后，发生两件事之一。\n\n 1. current.next 是 current 的副本。在这种情况下，删除 current.next 中的重复结点，并且current保持指向与之前相同的结点。因此，情况仍然成立；一直到 current 仍然没有重复项。\n    \n    \n 2. current.next 不是 current 的副本（并且，因为列表已经排序，current.next 也不是 current 之前出现的任何其他元素的副本）。在这种情况下，current 向前移动一步指向 current.next。因此，情况仍然成立；一直到 current 仍然没有重复项。\n    \n    \n\n在循环的最后一次迭代中，current 必定指向最后一个元素，因为再往后，current.next = null。因此，在循环结束后，直到最后一个元素的所有元素都不包含重复项。\n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-09-03 21:03:43Accepted [https://leetcode-cn.com//submissions/detail/6484966/]2 ms6.67%N/Ajava2018-09-03 21:03:31Accepted [https://leetcode-cn.com//submissions/detail/6484947/]2 ms6.67%N/Ajava2018-09-03 21:02:51Accepted [https://leetcode-cn.com//submissions/detail/6484909/]1 ms98.64%N/Ajava2018-09-03 20:57:18Wrong Answer [https://leetcode-cn.com//submissions/detail/6484579/]N/AN/AN/Ajava2018-09-03 20:56:36Runtime Error [https://leetcode-cn.com//submissions/detail/6484543/]N/AN/AN/Ajava# 统计信息\n通过次数提交次数AC比率6663713665648.8%# 相似题目\n题目难度删除排序链表中的重复元素 II [https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/]中等",contentLowercase:"# 中文题目\n给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。\n\n示例 1:\n\n输入: 1->1->2\n输出: 1->2\n\n\n示例 2:\n\n输入: 1->1->2->3->3\n输出: 1->2->3\n\n# 通过代码\n/**\n * definition for singly-linked list.\n * public class listnode {\n *     int val;\n *     listnode next;\n *     listnode(int x) { val = x; }\n * }\n */\nclass solution {\n    public listnode deleteduplicates(listnode head) {\n        if (head == null) {\n                return null;\n            }\n            listnode temp1 = head;\n            listnode temp2 = head.next;\n            while (temp2 != null) {\n                if (temp2.val != temp1.val) {\n                    temp1.next = temp2;\n                    temp1 = temp2;\n                } else {\n                    temp2 = temp2.next;\n                }\n            }\n            temp1.next = null;\n            return head;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n/**\n * definition for singly-linked list.\n * public class listnode {\n *     int val;\n *     listnode next;\n *     listnode(int x) { val = x; }\n * }\n */\nclass solution {\n    public listnode deleteduplicates(listnode head) {\n        if (head == null) {\n                return null;\n            }\n            listnode temp1 = head;\n            listnode temp2 = head.next;\n            while (temp2 != null) {\n                if (temp2.val != temp1.val) {\n                    temp1.next = temp2;\n                    temp1 = temp2;\n                } else {\n                    temp2 = temp2.next;\n                }\n            }\n            temp1.next = null;\n            return head;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n/**\n * definition for singly-linked list.\n * public class listnode {\n *     int val;\n *     listnode next;\n *     listnode(int x) { val = x; }\n * }\n */\nclass solution {\n    public listnode deleteduplicates(listnode head) {\n        if (head==null){\n                return null;\n            }\n        listnode temp1=head;\n            listnode temp2=head.next;\n            while (temp2!=null){\n                if (temp2.val != temp1.val){\n                    temp1.next=temp2;\n                    temp1=temp2;\n                }else {\n                    temp2=temp2.next;\n                }\n            }\n                    temp1.next=null;\n\n            return head;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n# 官方题解\n# 方法：直接法\n算法\n\n这是一个简单的问题，仅测试你操作列表的结点指针的能力。由于输入的列表已排序，因此我们可以通过将结点的值与它之后的结点进行比较来确定它是否为重复结点。如果它是重复的，我们更改当前结点的 next 指针，以便它跳过下一个结点并直接指向下一个结点之后的结点。\n\npublic listnode deleteduplicates(listnode head) {\n    listnode current = head;\n    while (current != null && current.next != null) {\n        if (current.next.val == current.val) {\n            current.next = current.next.next;\n        } else {\n            current = current.next;\n        }\n    }\n    return head;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n复杂度分析\n\n * 时间复杂度：o(n)o(n)o(n)，因为列表中的每个结点都检查一次以确定它是否重复，所以总运行时间为 o(n)o(n)o(n)，其中 nnn 是列表中的结点数。\n   \n   \n * 空间复杂度：o(1)o(1)o(1)，没有使用额外的空间。\n   \n   \n\n正确性\n\n我们可以通过定义循环不变式来证明此代码的正确性。循环不变式是在循环的每次迭代之前和之后为真的条件。在这种情况下，一个帮助我们证明正确性的循环不变式是这样的：\n\n> 列表中直到指针 current 的所有结点都不包含重复的元素。\n\n\n我们可以用归纳法证明这种情况确实是循环不变式。在进入循环之前，current 指向列表的头部。因此，列表中直到 current 的部分只包含头部。因此它不能包含任何重复的元素。现在假设current 现在指向列表中的某个结点（但不是最后一个元素），并且列表中直到 current 的部分不包含重复元素。在另一个循环迭代之后，发生两件事之一。\n\n 1. current.next 是 current 的副本。在这种情况下，删除 current.next 中的重复结点，并且current保持指向与之前相同的结点。因此，情况仍然成立；一直到 current 仍然没有重复项。\n    \n    \n 2. current.next 不是 current 的副本（并且，因为列表已经排序，current.next 也不是 current 之前出现的任何其他元素的副本）。在这种情况下，current 向前移动一步指向 current.next。因此，情况仍然成立；一直到 current 仍然没有重复项。\n    \n    \n\n在循环的最后一次迭代中，current 必定指向最后一个元素，因为再往后，current.next = null。因此，在循环结束后，直到最后一个元素的所有元素都不包含重复项。\n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-09-03 21:03:43accepted [https://leetcode-cn.com//submissions/detail/6484966/]2 ms6.67%n/ajava2018-09-03 21:03:31accepted [https://leetcode-cn.com//submissions/detail/6484947/]2 ms6.67%n/ajava2018-09-03 21:02:51accepted [https://leetcode-cn.com//submissions/detail/6484909/]1 ms98.64%n/ajava2018-09-03 20:57:18wrong answer [https://leetcode-cn.com//submissions/detail/6484579/]n/an/an/ajava2018-09-03 20:56:36runtime error [https://leetcode-cn.com//submissions/detail/6484543/]n/an/an/ajava# 统计信息\n通过次数提交次数ac比率6663713665648.8%# 相似题目\n题目难度删除排序链表中的重复元素 ii [https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/]中等"},{title:"69-x 的平方根(Sqrt(x))",frontmatter:{title:"69-x 的平方根(Sqrt(x))",date:"2018-05-06T00:00:00.000Z",categories:["简单"],tags:["数学<Math>","二分查找<Binary Search>"]},regularPath:"/views/%E7%AE%80%E5%8D%95/0069-x%20%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9.html",relativePath:"views/简单/0069-x 的平方根.md",key:"v-31ede314",path:"/views/%E7%AE%80%E5%8D%95/0069-x%20%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9.html",headers:[{level:2,title:"中文题目",slug:"中文题目",charIndex:2},{level:2,title:"通过代码",slug:"通过代码",charIndex:178},{level:2,title:"高赞题解",slug:"高赞题解",charIndex:286},{level:3,title:"方法一：二分法",slug:"方法一：二分法",charIndex:442},{level:3,title:"方法二：牛顿法",slug:"方法二：牛顿法",charIndex:7891},{level:2,title:"提交历史",slug:"提交历史",charIndex:9357},{level:2,title:"统计信息",slug:"统计信息",charIndex:9485},{level:2,title:"相似题目",slug:"相似题目",charIndex:9520}],lastUpdated:"4/11/2021, 1:15:21 PM",headersStr:"中文题目 通过代码 高赞题解 方法一：二分法 方法二：牛顿法 提交历史 统计信息 相似题目",content:"# 中文题目\n实现int sqrt(int x)函数。\n\n计算并返回x的平方根，其中x 是非负整数。\n\n由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。\n\n示例 1:\n\n输入: 4\n输出: 2\n\n\n示例 2:\n\n输入: 8\n输出: 2\n说明: 8 的平方根是 2.82842..., \n     由于返回类型是整数，小数部分将被舍去。\n\n\n# 通过代码\nclass Solution {\n    public int mySqrt(int x) {\n         return (int) Math.sqrt(x);\n    }\n}\n\n1\n2\n3\n4\n# 高赞题解\n二分查找法应用于搜索平方根的思想很简单，其实就是“猜”，但是是有策略的“猜”，用“排除法”在有限的区间里，一次排除一半的区间元素，最后只剩下一个数，这个数就是题目要求的向下取整的平方根整数。\n\n牛顿法最初提出的时候，是用于求解方程的根，它的基本思想是“以直代曲”，在迭代中搜索得到方程的近似解。\n\n# 方法一：二分法\n思路分析：使用二分法搜索平方根的思想很简单，就类似于小时候我们看的电视节目中的“猜价格”游戏，高了就往低了猜，低了就往高了猜，范围越来越小。因此，使用二分法猜算术平方根就很自然。\n\n一个数的平方根肯定不会超过它自己，不过直觉还告诉我们，一个数的平方根最多不会超过它的一半，例如 888 的平方根，888 的一半是 444，42=16>84^2=16>842=16>8，如果这个数越大越是如此，因此我们要计算一下，这个边界是多少。为此，解如下不等式：\n\n(a2)2≥a\\left(\\cfrac{a}{2}\\right)^2 \\ge a(2a​)2≥a\n\n意即：如果一个数的一半的平方大于它自己，那么这个数的取值范围。解以上不等式得 a≥4a \\ge 4a≥4 或者 a≤0a \\le 0a≤0。\n\n于是边界值就是 444，那么对 000、111、222、333 分别计算结果，很容易知道，这 444 个数的平方根依次是 000、111、111、111。\n\n注意：这 444 个特值如果没有考虑到，有可能导致你设置的搜索边界不正确。在使用二分法寻找平方根的时候，要特别注意边界值的选择，以下给出两个参考代码。\n\n参考代码 1：所有的数都放在一起考虑，为了照顾到 000 把左边界设置为 000，为了照顾到 111 把右边界设置为 x // 2 + 1。\n\nclass Solution:\n    def mySqrt(self, x: int) -> int:\n        # 为了照顾到 0 把左边界设置为 0\n        left = 0\n        # 为了照顾到 1 把右边界设置为 x // 2 + 1\n        right = x // 2 + 1\n        while left < right:\n            # 注意：这里一定取右中位数，如果取左中位数，代码可能会进入死循环\n            # mid = left + (right - left + 1) // 2\n            mid = (left + right + 1) >> 1\n            square = mid * mid\n\n            if square > x:\n                right = mid - 1\n            else:\n                left = mid\n        # 因为一定存在，因此无需后处理\n        return left\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\npublic class Solution {\n\n    public int mySqrt(int x) {\n        // 注意：针对特殊测试用例，例如 2147395599\n        // 要把搜索的范围设置成长整型\n        // 为了照顾到 0 把左边界设置为 0\n        long left = 0;\n        // # 为了照顾到 1 把右边界设置为 x // 2 + 1\n        long right = x / 2 + 1;\n        while (left < right) {\n            // 注意：这里一定取右中位数，如果取左中位数，代码会进入死循环\n            // long mid = left + (right - left + 1) / 2;\n            long mid = (left + right + 1) >>> 1;\n            long square = mid * mid;\n            if (square > x) {\n                right = mid - 1;\n            } else {\n                left = mid;\n            }\n        }\n        // 因为一定存在，因此无需后处理\n        return (int) left;\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\nJava 代码要注意到：如果中点 mid 声明为 int 类型，针对大整型测试用例通不过，因此变量需要声明为 long 类型，下同。\n\n参考代码 2：事实上，只要单独照顾一下 000 这个特例就可以了。\n\nclass Solution:\n    def mySqrt(self, x: int) -> int:\n        if x == 0:\n            return 0\n\n        left = 1\n        right = x // 2\n\n        while left < right:\n            # 注意：这里一定取右中位数，如果取左中位数，代码可能会进入死循环\n            # mid = left + (right - left + 1) // 2\n            mid = (left + right + 1) >> 1\n            square = mid * mid\n\n            if square > x:\n                right = mid - 1\n            else:\n                left = mid\n        # 因为一定存在，因此无需后处理\n        return left\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\npublic class Solution {\n\n    public int mySqrt(int x) {\n        if (x == 0) {\n            return 0;\n        }\n        // 注意：针对特殊测试用例，例如 2147395599\n        // 要把搜索的范围设置成长整型\n        long left = 1;\n        long right = x / 2;\n        while (left < right) {\n            // 注意：这里一定取右中位数，如果取左中位数，代码会进入死循环\n            // long mid = left + (right - left + 1) / 2;\n            long mid = (left + right + 1) >>> 1;\n            long square = mid * mid;\n            if (square > x) {\n                right = mid - 1;\n            } else {\n                left = mid;\n            }\n        }\n        // 因为一定存在，因此无需后处理\n        return (int) left;\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n注意： 这里二分法的使用是有技巧的（如果你没有意识到，这里很可能是个“坑”），下面我就上面注释中提到的：\n\n> 注意：这里一定取右中位数，如果取左中位数，代码可能会进入死循环。\n\n\n做一些解释。当 x = 9 的时候，我们不妨给“错误的”代码加上一些调试语句，这样你就会更清晰地发现死循环在什么时候出现，例如：\n\nPython 代码：\n\nclass Solution:\n    def mySqrt(self, x: int) -> int:\n        if x == 0:\n            return 0\n\n        left = 1\n        right = x // 2\n        while left < right:\n            # 调试代码开始：为了仔细观察区间左右端点，我们每进入一次循环，让线程休眠 1 秒\n            import time\n            time.sleep(1)\n            print('调试代码，观察区间左右端点、中位数，和进入的分支： left = {} , right = {} , '.format(left, right), end='')\n            # 调试代码结束\n\n            # 错误代码，在分支左区间不发生收缩的情况下，中位数应该取右中位数\n            # mid = left + (right - left) // 2\n            mid = (left + right) >> 1\n            # 调试代码\n            print('mid = {} ,'.format(mid), end=' ')\n            square = mid * mid\n\n            if square > x:\n                # 调试代码\n                print('进入 right = mid - 1 这个分支。')\n                right = mid - 1\n            else:\n                # 调试代码\n                print('进入 left = mid 这个分支。')\n                left = mid\n        return left\n\n\nif __name__ == '__main__':\n    # 当 x = 8 的时候，代码能得出正确答案\n    x = 9\n    solution = Solution()\n    res = solution.mySqrt(x)\n    print(res)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n控制台输出：\n\n调试代码，观察区间左右端点、中位数，和进入的分支： left = 2 , right = 4 , mid = 3 , 进入 left = mid 这个分支。\n调试代码，观察区间左右端点、中位数，和进入的分支： left = 3 , right = 4 , mid = 3 , 进入 left = mid 这个分支。\n调试代码，观察区间左右端点、中位数，和进入的分支： left = 3 , right = 4 , mid = 3 , 进入 left = mid 这个分支。\n调试代码，观察区间左右端点、中位数，和进入的分支： left = 3 , right = 4 , mid = 3 , 进入 left = mid 这个分支。\n调试代码，观察区间左右端点、中位数，和进入的分支： left = 3 , right = 4 , mid = 3 , 进入 left = mid 这个分支。\nTraceback (most recent call last):\n  File \"/Users/liwei/（按照惯例这里不让你们看，虽然真的没有什么秘密，就是皮一下子很开心啊有木有）/LeetCode-Solution-Python/17-二分查找/0069-x 的平方根-2（平方根）.py\", line 37, in <module>\n    res = solution.mySqrt(x)\n  File \"/Users/liwei/（按照惯例这里不让你们看，虽然真的没有什么秘密，就是皮一下子很开心啊有木有）/LeetCode-Solution-Python/17-二分查找/0069-x 的平方根-2（平方根）.py\", line 11, in mySqrt\n    time.sleep(1)\nKeyboardInterrupt\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n分析：如果取中点为左中位数，你看到死循环发生在 left = 3， right = 4 的时候，此时区间只有 2 个元素。这是为什么呢？\n\n此时索引区间 [3, 4] 的中位数为左中位数，即 mid = 3 ，此时 square = 9 < 9 不成立，进入 left = mid 这个分支，你发现问题了吗，区间不发生收缩，即下一轮循环的索引区间还是 [3, 4]，此时中位数还取左中位数，即 mid = 3 ，square = 9 < 9 不成立，又进入 left = mid 这个分支，死循环就是这样产生的。\n\n接着，请你把 mid = left + (right - left) // 2 改成 mid = left + (right - left + 1) // 2 ，即选择右中位数，再观察一下控制台输出，就知道此时为什么要选右中位数了。\n\n这个二分法模板我用了很久，感觉非常好用。于是我专门把这个二分法模板好用的地方、使用它的技巧和注意事项整理在了「力扣 」第 35 题：搜索插入位置的题解《特别好用的二分查找法模板（Python 代码、Java 代码）》 [https://leetcode-cn.com/problems/search-insert-position/solution/te-bie-hao-yong-de-er-fen-cha-fa-fa-mo-ban-python-/]，希望能对大家有所帮助。\n\n复杂度分析：\n\n * 时间复杂度：O(log⁡N)O(\\log N)O(logN)，二分法的时间复杂度是对数级别的。\n * 空间复杂度：O(1)O(1)O(1)，使用了常数个数的辅助空间用于存储和比较。\n\n总结： 使用二分查找法搜索，注意特值对搜索边界的影响。\n\n以下这部分内容是根据与用户 @lukas [/u/18482187634] 在本题解下的讨论而添加的。\n\n在这里补充一下，如果你实在不太想分析 a 的平方根可能的上界，之前说了，它肯定不会超过 a 自己，即使你把上界写成一个很大的数，例如 999999999999999999，这个数必须得是力扣的测试用例都达不到的数，在二分查找的过程中，不符合要求的数每次会被很快砍掉一半。\n\n参考代码 3：干脆我不讨论 a 的边界，让二分法去排除不符合的区间吧，对数级别的时间复杂度对性能不会有很大影响。\n\nclass Solution:\n\n    def mySqrt(self, x):\n        left = 0\n        right = 999999\n        while left < right:\n            # 这种取中位数的方法又快又好，是我刚学会的，原因在下面这篇文章的评论区\n            # https://www.liwei.party/2019/06/17/leetcode-solution-new/search-insert-position/\n            mid = (left + right + 1) >> 1\n            square = mid * mid\n            if square > x:\n                right = mid - 1\n            else:\n                left = mid\n\n        return left\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\npublic class Solution {\n\n    public int mySqrt(int x) {\n        long left = 0;\n        long right = Integer.MAX_VALUE;\n        while (left < right) {\n            // 这种取中位数的方法又快又好，是我刚学会的，原因在下面这篇文章的评论区\n            // https://www.liwei.party/2019/06/17/leetcode-solution-new/search-insert-position/\n            // 注意：这里得用无符号右移\n            long mid = (left + right + 1) >>> 1;\n            long square = mid * mid;\n            if (square > x) {\n                right = mid - 1;\n            } else {\n                left = mid;\n            }\n        }\n        return (int) left;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n# 方法二：牛顿法\n使用牛顿法可以得到一个正实数的算术平方根，因为题目中说“结果只保留整数部分”，因此，我们把使用牛顿法得到的浮点数转换为整数即可。\n\n这里给出牛顿法的思想：\n\n> 在迭代过程中，以直线代替曲线，用一阶泰勒展式（即在当前点的切线）代替原曲线，求直线与 xxx 轴的交点，重复这个过程直到收敛。\n\n\n\n\n说明： 1、以上图片来自《牛顿法与拟牛顿法》 [https://blog.csdn.net/batuwuhanpei/article/details/51979831]；\n\n2、@LOAFER 的题解《牛顿迭代法》 [https://leetcode-cn.com/problems/sqrtx/solution/niu-dun-die-dai-fa-by-loafer/] 的图和文字说明更好，而知乎问答《如何通俗易懂地讲解牛顿迭代法求开方？数值分析？》 [https://www.zhihu.com/question/20690553]里面干货就更多了，建议大家出门左转观看，我这篇题解只是展示一下迭代公式如何计算。\n\n{:width=550} {:align=center}\n\n注意：牛顿法得到的是平方根的浮点型精确值（可能会有一定误差），根据题目中的要求，把最后得到的这个数转换为 int 型，即去掉小数部分即可。\n\n对“牛顿法”感兴趣的朋友们可以查一下牛顿法的应用：一个是求方程的根，另一个是求解最优化问题，在这里就不展开了。\n\n参考代码 4：\n\nclass Solution:\n\n    def mySqrt(self, x):\n        if x < 0:\n            raise Exception('不能输入负数')\n        if x == 0:\n            return 0\n        # 起始的时候在 1 ，这可以比较随意设置\n        cur = 1\n        while True:\n            pre = cur\n            cur = (cur + x / cur) / 2\n            if abs(cur - pre) < 1e-6:\n                return int(cur)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\npublic class Solution {\n\n    public int mySqrt(int a) {\n        long x = a;\n        while (x * x > a) {\n            x = (x + a / x) / 2;\n        }\n        return (int) x;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n说明：1e-6 是科学计数法，表示 111 乘以 101010 的负 666 次方，也就是 0.0000010.0000010.000001。有的地方使用 epsilon（ϵ\\epsilonϵ）表示 1e-6 ，用来抵消浮点运算中因为误差造成的相等无法判断的情况，它通常是一个非常小的数字，具体多小要根据你的精度需求来设置。\n\n复杂度分析：\n\n * 时间复杂度：（待讨论，反正很快很快就是了 ^_^，调皮一下显示我的无知）。\n * 空间复杂度：O(1)O(1)O(1)，使用了常数个数的辅助空间用于存储和比较。\n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-05-06 22:40:08Accepted [https://leetcode-cn.com//submissions/detail/2026523/]27 ms6.89%N/Ajava# 统计信息\n通过次数提交次数AC比率8564622908737.4%# 相似题目\n题目难度Pow(x, n) [https://leetcode-cn.com/problems/powx-n/]中等有效的完全平方数 [https://leetcode-cn.com/problems/valid-perfect-square/]简单",contentLowercase:"# 中文题目\n实现int sqrt(int x)函数。\n\n计算并返回x的平方根，其中x 是非负整数。\n\n由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。\n\n示例 1:\n\n输入: 4\n输出: 2\n\n\n示例 2:\n\n输入: 8\n输出: 2\n说明: 8 的平方根是 2.82842..., \n     由于返回类型是整数，小数部分将被舍去。\n\n\n# 通过代码\nclass solution {\n    public int mysqrt(int x) {\n         return (int) math.sqrt(x);\n    }\n}\n\n1\n2\n3\n4\n# 高赞题解\n二分查找法应用于搜索平方根的思想很简单，其实就是“猜”，但是是有策略的“猜”，用“排除法”在有限的区间里，一次排除一半的区间元素，最后只剩下一个数，这个数就是题目要求的向下取整的平方根整数。\n\n牛顿法最初提出的时候，是用于求解方程的根，它的基本思想是“以直代曲”，在迭代中搜索得到方程的近似解。\n\n# 方法一：二分法\n思路分析：使用二分法搜索平方根的思想很简单，就类似于小时候我们看的电视节目中的“猜价格”游戏，高了就往低了猜，低了就往高了猜，范围越来越小。因此，使用二分法猜算术平方根就很自然。\n\n一个数的平方根肯定不会超过它自己，不过直觉还告诉我们，一个数的平方根最多不会超过它的一半，例如 888 的平方根，888 的一半是 444，42=16>84^2=16>842=16>8，如果这个数越大越是如此，因此我们要计算一下，这个边界是多少。为此，解如下不等式：\n\n(a2)2≥a\\left(\\cfrac{a}{2}\\right)^2 \\ge a(2a​)2≥a\n\n意即：如果一个数的一半的平方大于它自己，那么这个数的取值范围。解以上不等式得 a≥4a \\ge 4a≥4 或者 a≤0a \\le 0a≤0。\n\n于是边界值就是 444，那么对 000、111、222、333 分别计算结果，很容易知道，这 444 个数的平方根依次是 000、111、111、111。\n\n注意：这 444 个特值如果没有考虑到，有可能导致你设置的搜索边界不正确。在使用二分法寻找平方根的时候，要特别注意边界值的选择，以下给出两个参考代码。\n\n参考代码 1：所有的数都放在一起考虑，为了照顾到 000 把左边界设置为 000，为了照顾到 111 把右边界设置为 x // 2 + 1。\n\nclass solution:\n    def mysqrt(self, x: int) -> int:\n        # 为了照顾到 0 把左边界设置为 0\n        left = 0\n        # 为了照顾到 1 把右边界设置为 x // 2 + 1\n        right = x // 2 + 1\n        while left < right:\n            # 注意：这里一定取右中位数，如果取左中位数，代码可能会进入死循环\n            # mid = left + (right - left + 1) // 2\n            mid = (left + right + 1) >> 1\n            square = mid * mid\n\n            if square > x:\n                right = mid - 1\n            else:\n                left = mid\n        # 因为一定存在，因此无需后处理\n        return left\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\npublic class solution {\n\n    public int mysqrt(int x) {\n        // 注意：针对特殊测试用例，例如 2147395599\n        // 要把搜索的范围设置成长整型\n        // 为了照顾到 0 把左边界设置为 0\n        long left = 0;\n        // # 为了照顾到 1 把右边界设置为 x // 2 + 1\n        long right = x / 2 + 1;\n        while (left < right) {\n            // 注意：这里一定取右中位数，如果取左中位数，代码会进入死循环\n            // long mid = left + (right - left + 1) / 2;\n            long mid = (left + right + 1) >>> 1;\n            long square = mid * mid;\n            if (square > x) {\n                right = mid - 1;\n            } else {\n                left = mid;\n            }\n        }\n        // 因为一定存在，因此无需后处理\n        return (int) left;\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\njava 代码要注意到：如果中点 mid 声明为 int 类型，针对大整型测试用例通不过，因此变量需要声明为 long 类型，下同。\n\n参考代码 2：事实上，只要单独照顾一下 000 这个特例就可以了。\n\nclass solution:\n    def mysqrt(self, x: int) -> int:\n        if x == 0:\n            return 0\n\n        left = 1\n        right = x // 2\n\n        while left < right:\n            # 注意：这里一定取右中位数，如果取左中位数，代码可能会进入死循环\n            # mid = left + (right - left + 1) // 2\n            mid = (left + right + 1) >> 1\n            square = mid * mid\n\n            if square > x:\n                right = mid - 1\n            else:\n                left = mid\n        # 因为一定存在，因此无需后处理\n        return left\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\npublic class solution {\n\n    public int mysqrt(int x) {\n        if (x == 0) {\n            return 0;\n        }\n        // 注意：针对特殊测试用例，例如 2147395599\n        // 要把搜索的范围设置成长整型\n        long left = 1;\n        long right = x / 2;\n        while (left < right) {\n            // 注意：这里一定取右中位数，如果取左中位数，代码会进入死循环\n            // long mid = left + (right - left + 1) / 2;\n            long mid = (left + right + 1) >>> 1;\n            long square = mid * mid;\n            if (square > x) {\n                right = mid - 1;\n            } else {\n                left = mid;\n            }\n        }\n        // 因为一定存在，因此无需后处理\n        return (int) left;\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n注意： 这里二分法的使用是有技巧的（如果你没有意识到，这里很可能是个“坑”），下面我就上面注释中提到的：\n\n> 注意：这里一定取右中位数，如果取左中位数，代码可能会进入死循环。\n\n\n做一些解释。当 x = 9 的时候，我们不妨给“错误的”代码加上一些调试语句，这样你就会更清晰地发现死循环在什么时候出现，例如：\n\npython 代码：\n\nclass solution:\n    def mysqrt(self, x: int) -> int:\n        if x == 0:\n            return 0\n\n        left = 1\n        right = x // 2\n        while left < right:\n            # 调试代码开始：为了仔细观察区间左右端点，我们每进入一次循环，让线程休眠 1 秒\n            import time\n            time.sleep(1)\n            print('调试代码，观察区间左右端点、中位数，和进入的分支： left = {} , right = {} , '.format(left, right), end='')\n            # 调试代码结束\n\n            # 错误代码，在分支左区间不发生收缩的情况下，中位数应该取右中位数\n            # mid = left + (right - left) // 2\n            mid = (left + right) >> 1\n            # 调试代码\n            print('mid = {} ,'.format(mid), end=' ')\n            square = mid * mid\n\n            if square > x:\n                # 调试代码\n                print('进入 right = mid - 1 这个分支。')\n                right = mid - 1\n            else:\n                # 调试代码\n                print('进入 left = mid 这个分支。')\n                left = mid\n        return left\n\n\nif __name__ == '__main__':\n    # 当 x = 8 的时候，代码能得出正确答案\n    x = 9\n    solution = solution()\n    res = solution.mysqrt(x)\n    print(res)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n控制台输出：\n\n调试代码，观察区间左右端点、中位数，和进入的分支： left = 2 , right = 4 , mid = 3 , 进入 left = mid 这个分支。\n调试代码，观察区间左右端点、中位数，和进入的分支： left = 3 , right = 4 , mid = 3 , 进入 left = mid 这个分支。\n调试代码，观察区间左右端点、中位数，和进入的分支： left = 3 , right = 4 , mid = 3 , 进入 left = mid 这个分支。\n调试代码，观察区间左右端点、中位数，和进入的分支： left = 3 , right = 4 , mid = 3 , 进入 left = mid 这个分支。\n调试代码，观察区间左右端点、中位数，和进入的分支： left = 3 , right = 4 , mid = 3 , 进入 left = mid 这个分支。\ntraceback (most recent call last):\n  file \"/users/liwei/（按照惯例这里不让你们看，虽然真的没有什么秘密，就是皮一下子很开心啊有木有）/leetcode-solution-python/17-二分查找/0069-x 的平方根-2（平方根）.py\", line 37, in <module>\n    res = solution.mysqrt(x)\n  file \"/users/liwei/（按照惯例这里不让你们看，虽然真的没有什么秘密，就是皮一下子很开心啊有木有）/leetcode-solution-python/17-二分查找/0069-x 的平方根-2（平方根）.py\", line 11, in mysqrt\n    time.sleep(1)\nkeyboardinterrupt\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n分析：如果取中点为左中位数，你看到死循环发生在 left = 3， right = 4 的时候，此时区间只有 2 个元素。这是为什么呢？\n\n此时索引区间 [3, 4] 的中位数为左中位数，即 mid = 3 ，此时 square = 9 < 9 不成立，进入 left = mid 这个分支，你发现问题了吗，区间不发生收缩，即下一轮循环的索引区间还是 [3, 4]，此时中位数还取左中位数，即 mid = 3 ，square = 9 < 9 不成立，又进入 left = mid 这个分支，死循环就是这样产生的。\n\n接着，请你把 mid = left + (right - left) // 2 改成 mid = left + (right - left + 1) // 2 ，即选择右中位数，再观察一下控制台输出，就知道此时为什么要选右中位数了。\n\n这个二分法模板我用了很久，感觉非常好用。于是我专门把这个二分法模板好用的地方、使用它的技巧和注意事项整理在了「力扣 」第 35 题：搜索插入位置的题解《特别好用的二分查找法模板（python 代码、java 代码）》 [https://leetcode-cn.com/problems/search-insert-position/solution/te-bie-hao-yong-de-er-fen-cha-fa-fa-mo-ban-python-/]，希望能对大家有所帮助。\n\n复杂度分析：\n\n * 时间复杂度：o(log⁡n)o(\\log n)o(logn)，二分法的时间复杂度是对数级别的。\n * 空间复杂度：o(1)o(1)o(1)，使用了常数个数的辅助空间用于存储和比较。\n\n总结： 使用二分查找法搜索，注意特值对搜索边界的影响。\n\n以下这部分内容是根据与用户 @lukas [/u/18482187634] 在本题解下的讨论而添加的。\n\n在这里补充一下，如果你实在不太想分析 a 的平方根可能的上界，之前说了，它肯定不会超过 a 自己，即使你把上界写成一个很大的数，例如 999999999999999999，这个数必须得是力扣的测试用例都达不到的数，在二分查找的过程中，不符合要求的数每次会被很快砍掉一半。\n\n参考代码 3：干脆我不讨论 a 的边界，让二分法去排除不符合的区间吧，对数级别的时间复杂度对性能不会有很大影响。\n\nclass solution:\n\n    def mysqrt(self, x):\n        left = 0\n        right = 999999\n        while left < right:\n            # 这种取中位数的方法又快又好，是我刚学会的，原因在下面这篇文章的评论区\n            # https://www.liwei.party/2019/06/17/leetcode-solution-new/search-insert-position/\n            mid = (left + right + 1) >> 1\n            square = mid * mid\n            if square > x:\n                right = mid - 1\n            else:\n                left = mid\n\n        return left\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\npublic class solution {\n\n    public int mysqrt(int x) {\n        long left = 0;\n        long right = integer.max_value;\n        while (left < right) {\n            // 这种取中位数的方法又快又好，是我刚学会的，原因在下面这篇文章的评论区\n            // https://www.liwei.party/2019/06/17/leetcode-solution-new/search-insert-position/\n            // 注意：这里得用无符号右移\n            long mid = (left + right + 1) >>> 1;\n            long square = mid * mid;\n            if (square > x) {\n                right = mid - 1;\n            } else {\n                left = mid;\n            }\n        }\n        return (int) left;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n# 方法二：牛顿法\n使用牛顿法可以得到一个正实数的算术平方根，因为题目中说“结果只保留整数部分”，因此，我们把使用牛顿法得到的浮点数转换为整数即可。\n\n这里给出牛顿法的思想：\n\n> 在迭代过程中，以直线代替曲线，用一阶泰勒展式（即在当前点的切线）代替原曲线，求直线与 xxx 轴的交点，重复这个过程直到收敛。\n\n\n\n\n说明： 1、以上图片来自《牛顿法与拟牛顿法》 [https://blog.csdn.net/batuwuhanpei/article/details/51979831]；\n\n2、@loafer 的题解《牛顿迭代法》 [https://leetcode-cn.com/problems/sqrtx/solution/niu-dun-die-dai-fa-by-loafer/] 的图和文字说明更好，而知乎问答《如何通俗易懂地讲解牛顿迭代法求开方？数值分析？》 [https://www.zhihu.com/question/20690553]里面干货就更多了，建议大家出门左转观看，我这篇题解只是展示一下迭代公式如何计算。\n\n{:width=550} {:align=center}\n\n注意：牛顿法得到的是平方根的浮点型精确值（可能会有一定误差），根据题目中的要求，把最后得到的这个数转换为 int 型，即去掉小数部分即可。\n\n对“牛顿法”感兴趣的朋友们可以查一下牛顿法的应用：一个是求方程的根，另一个是求解最优化问题，在这里就不展开了。\n\n参考代码 4：\n\nclass solution:\n\n    def mysqrt(self, x):\n        if x < 0:\n            raise exception('不能输入负数')\n        if x == 0:\n            return 0\n        # 起始的时候在 1 ，这可以比较随意设置\n        cur = 1\n        while true:\n            pre = cur\n            cur = (cur + x / cur) / 2\n            if abs(cur - pre) < 1e-6:\n                return int(cur)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\npublic class solution {\n\n    public int mysqrt(int a) {\n        long x = a;\n        while (x * x > a) {\n            x = (x + a / x) / 2;\n        }\n        return (int) x;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n说明：1e-6 是科学计数法，表示 111 乘以 101010 的负 666 次方，也就是 0.0000010.0000010.000001。有的地方使用 epsilon（ϵ\\epsilonϵ）表示 1e-6 ，用来抵消浮点运算中因为误差造成的相等无法判断的情况，它通常是一个非常小的数字，具体多小要根据你的精度需求来设置。\n\n复杂度分析：\n\n * 时间复杂度：（待讨论，反正很快很快就是了 ^_^，调皮一下显示我的无知）。\n * 空间复杂度：o(1)o(1)o(1)，使用了常数个数的辅助空间用于存储和比较。\n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-05-06 22:40:08accepted [https://leetcode-cn.com//submissions/detail/2026523/]27 ms6.89%n/ajava# 统计信息\n通过次数提交次数ac比率8564622908737.4%# 相似题目\n题目难度pow(x, n) [https://leetcode-cn.com/problems/powx-n/]中等有效的完全平方数 [https://leetcode-cn.com/problems/valid-perfect-square/]简单"},{title:"70-爬楼梯(Climbing Stairs)",frontmatter:{title:"70-爬楼梯(Climbing Stairs)",date:"2021-04-14T00:00:00.000Z",categories:["简单"],tags:["动态规划<Dynamic Programming>"]},regularPath:"/views/%E7%AE%80%E5%8D%95/0070-%E7%88%AC%E6%A5%BC%E6%A2%AF.html",relativePath:"views/简单/0070-爬楼梯.md",key:"v-49990e49",path:"/views/%E7%AE%80%E5%8D%95/0070-%E7%88%AC%E6%A5%BC%E6%A2%AF.html",headers:[{level:2,title:"中文题目",slug:"中文题目",charIndex:2},{level:2,title:"通过代码",slug:"通过代码",charIndex:232},{level:2,title:"我的笔记",slug:"我的笔记",charIndex:6079},{level:2,title:"高赞题解",slug:"高赞题解",charIndex:6193},{level:3,title:"📺 视频题解",slug:"📺-视频题解",charIndex:6200},{level:2,title:"提交历史",slug:"提交历史",charIndex:17258},{level:2,title:"统计信息",slug:"统计信息",charIndex:18500},{level:2,title:"相似题目",slug:"相似题目",charIndex:18536}],lastUpdated:"4/11/2021, 1:15:21 PM",headersStr:"中文题目 通过代码 我的笔记 高赞题解 📺 视频题解 提交历史 统计信息 相似题目",content:"# 中文题目\n假设你正在爬楼梯。需要 n阶你才能到达楼顶。\n\n每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？\n\n注意：给定 n 是一个正整数。\n\n示例 1：\n\n输入： 2\n输出： 2\n解释： 有两种方法可以爬到楼顶。\n1.  1 阶 + 1 阶\n2.  2 阶\n\n示例 2：\n\n输入： 3\n输出： 3\n解释： 有三种方法可以爬到楼顶。\n1.  1 阶 + 1 阶 + 1 阶\n2.  1 阶 + 2 阶\n3.  2 阶 + 1 阶\n\n\n# 通过代码\n    class Solution {\n        public int climbStairs(int n) {\n            // 就是斐波拉契数列\n            // 第一层：1\n            // 第二层：2\n            // 第三层，可以从第一层跨2步，可以从第二层跨一步\n            // 故第三层：f(3)=f(1)+f(2)，由于最后一步的不同，方法肯定不同\n            // 故第n层：f(n)=f(n-1)+f(n-2)\n\n            if (n==1){\n                return 1;\n            }\n            if (n==2){\n                return 2;\n            }\n            int[] arr=new int[n+1];\n            arr[1]=1;\n            arr[2]=2;\n            for (int i = 3; i <= n; i++) {\n                arr[i]=arr[i-1]+arr[i-2];\n            }\n            return arr[n];\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\nclass Solution {\n    int[] memo;\n\n        int calcWays(int n){\n            if (n == 1) {\n                return 1;\n            }\n            if (n == 2) {\n                return 2;\n            }\n            if (memo[n]==-1){\n                memo[n]=calcWays(n-1)+calcWays(n-2);\n            }\n            return memo[n];\n        }\n\n        public  int climbStairs(int n) {\n            memo =new int[n+1];\n            Arrays.fill(memo,-1);\n            return calcWays(n);\n        }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\nclass Solution {\n    int[] memo;\n\n        int calcWays(int n){\n            if (n == 1) {\n                return 1;\n            }\n            if (n == 2) {\n                return 2;\n            }\n            if (memo[n]==-1){\n                memo[n]=calcWays(n-1)+calcWays(n-2);\n            }\n            return memo[n];\n        }\n\n        public  int climbStairs(int n) {\n            memo =new int[n+1];\n            Arrays.fill(memo,-1);\n            return calcWays(n);\n        }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\nclass Solution {\n    public int climbStairs(int n) {\n        if (n<=2){\n                return n;\n            }\n            int[] ways=new int[n+1];\n            ways[1]=1;\n            ways[2]=2;\n            for (int i = 3; i <=n ; i++) {\n                ways[i]=ways[i-1]+ways[i-2];\n            }\n            return ways[n];\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n    class Solution {\n        public int climbStairs(int n) {\n            // 就是斐波拉契数列\n            // 第一层：1\n            // 第二层：2\n            // 第三层，可以从第一层跨2步，可以从第二层跨一步\n            // 故第三层：f(3)=f(1)+f(2)，由于最后一步的不同，方法肯定不同\n            // 故第n层：f(n)=f(n-1)+f(n-2)\n\n            if (n==1){\n                return 1;\n            }\n            if (n==2){\n                return 2;\n            }\n            // 由于只需要计算最后一个值，我们可以只保存前面两个的状态\n            int a1=1;\n            int a2=2;\n            int a3=a1+a2;\n            for (int i = 3; i <= n; i++) {\n                a3=a1+a2;\n                a1=a2;\n                a2=a3;\n            }\n            return a3;\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n    class Solution {\n        public int climbStairs(int n) {\n            // 就是斐波拉契数列\n            // 第一层：1\n            // 第二层：2\n            // 第三层，可以从第一层跨2步，可以从第二层跨一步\n            // 故第三层：f(3)=f(1)+f(2)，由于最后一步的不同，方法肯定不同\n            // 故第n层：f(n)=f(n-1)+f(n-2)\n\n            if (n==1){\n                return 1;\n            }\n            if (n==2){\n                return 2;\n            }\n            int[] arr=new int[n+1];\n            arr[1]=1;\n            arr[2]=2;\n            for (int i = 3; i <= n; i++) {\n                arr[i]=arr[i-1]+arr[i-2];\n            }\n            return arr[n];\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\nclass Solution {\n//===============方法一:动态规划\n        public static int climbStairs(int n) {\n            if (n <= 2) {\n                return n;\n            }\n            int[] ways = new int[n + 1];\n            ways[1] = 1;\n            ways[2] = 2;\n            for (int i = 3; i <= n; i++) {\n                ways[i] = ways[i - 1] + ways[i - 2];\n            }\n            return ways[n];\n        }\n\n//================方法二：记忆化搜索\n\n//         int[] memo;\n\n//         int calcWays(int n){\n//             if (n == 1) {\n//                 return 1;\n//             }\n//             if (n == 2) {\n//                 return 2;\n//             }\n//             if (memo[n]==-1){\n//                 memo[n]=calcWays(n-1)+calcWays(n-2);\n//             }\n//             return memo[n];\n//         }\n\n//         public  int climbStairs2(int n) {\n//             memo =new int[n+1];\n//             Arrays.fill(memo,-1);\n//             return calcWays(n);\n//         }\n    }\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\nclass Solution {\n    int[] memo;\n\n        int calcWays(int n){\n            if (n == 1) {\n                return 1;\n            }\n            if (n == 2) {\n                return 2;\n            }\n            if (memo[n]==-1){\n                memo[n]=calcWays(n-1)+calcWays(n-2);\n            }\n            return memo[n];\n        }\n\n        public  int climbStairs(int n) {\n            memo =new int[n+1];\n            Arrays.fill(memo,-1);\n            return calcWays(n);\n        }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\nclass Solution {\n    public int climbStairs(int n) {\n        if (n<=2){\n                return n;\n            }\n            int[] ways=new int[n+1];\n            ways[1]=1;\n            ways[2]=2;\n            for (int i = 3; i <=n ; i++) {\n                ways[i]=ways[i-1]+ways[i-2];\n            }\n            return ways[n];\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\nclass Solution {\n    public int climbStairs(int n) {\n        if (n<=2){\n                return n;\n            }\n            int[] ways=new int[n+1];\n            ways[1]=1;\n            ways[2]=2;\n            for (int i = 3; i <=n ; i++) {\n                ways[i]=ways[i-1]+ways[i-2];\n            }\n            return ways[n];\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n# 我的笔记\n就是斐波拉契数列 第一层：1 第二层：2 第三层，可以从第一层跨2步，可以从第二层跨一步 故第三层：f(3)=f(1)+f(2)，由于最后一步的不同，方法肯定不同 故第n层：f(n)=f(n-1)+f(n-2)\n\n# 高赞题解\n# 📺 视频题解\n\n\n# 方法一：动态规划\n思路和算法\n\n我们用 f(x)f(x)f(x) 表示爬到第 xxx 级台阶的方案数，考虑最后一步可能跨了一级台阶，也可能跨了两级台阶，所以我们可以列出如下式子：\n\nf(x)=f(x−1)+f(x−2)f(x) = f(x - 1) + f(x - 2)f(x)=f(x−1)+f(x−2)\n\n它意味着爬到第 xxx 级台阶的方案数是爬到第 x−1x - 1x−1 级台阶的方案数和爬到第 x−2x - 2x−2 级台阶的方案数的和。很好理解，因为每次只能爬 111 级或 222 级，所以 f(x)f(x)f(x) 只能从 f(x−1)f(x - 1)f(x−1) 和 f(x−2)f(x - 2)f(x−2) 转移过来，而这里要统计方案总数，我们就需要对这两项的贡献求和。\n\n以上是动态规划的转移方程，下面我们来讨论边界条件。我们是从第 000 级开始爬的，所以从第 000 级爬到第 000 级我们可以看作只有一种方案，即 f(0)=1f(0) = 1f(0)=1；从第 000 级到第 111 级也只有一种方案，即爬一级，f(1)=1f(1) = 1f(1)=1。这两个作为边界条件就可以继续向后推导出第 nnn 级的正确结果。我们不妨写几项来验证一下，根据转移方程得到 f(2)=2f(2) = 2f(2)=2，f(3)=3f(3) = 3f(3)=3，f(4)=5f(4) = 5f(4)=5，……，我们把这些情况都枚举出来，发现计算的结果是正确的。\n\n我们不难通过转移方程和边界条件给出一个时间复杂度和空间复杂度都是 O(n)O(n)O(n) 的实现，但是由于这里的 f(x)f(x)f(x) 只和 f(x−1)f(x - 1)f(x−1) 与 f(x−2)f(x - 2)f(x−2) 有关，所以我们可以用「滚动数组思想」把空间复杂度优化成 O(1)O(1)O(1)。下面的代码中给出的就是这种实现。\n\n\n\n代码\n\nclass Solution {\npublic:\n    int climbStairs(int n) {\n        int p = 0, q = 0, r = 1;\n        for (int i = 1; i <= n; ++i) {\n            p = q; \n            q = r; \n            r = p + q;\n        }\n        return r;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\nclass Solution {\n    public int climbStairs(int n) {\n        int p = 0, q = 0, r = 1;\n        for (int i = 1; i <= n; ++i) {\n            p = q; \n            q = r; \n            r = p + q;\n        }\n        return r;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\nfunction climbStairs(n: number): number {\n    let p: number = 0, q: number = 0, r: number = 1;\n    for (let i = 1; i <= n; ++i) {\n        p = q; \n        q = r; \n        r = p + q;\n    }\n    return r;\n};\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\nfunc climbStairs(n int) int {\n    p, q, r := 0, 0, 1\n    for i := 1; i <= n; i++ {\n        p = q\n        q = r\n        r = p + q\n    }\n    return r\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\nvar climbStairs = function(n) {\n    let p = 0, q = 0, r = 1;\n    for (let i = 1; i <= n; ++i) {\n        p = q;\n        q = r;\n        r = p + q;\n    }\n    return r;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\nint climbStairs(int n) {\n    int p = 0, q = 0, r = 1;\n    for (int i = 1; i <= n; ++i) {\n        p = q;\n        q = r;\n        r = p + q;\n    }\n    return r;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n复杂度分析\n\n * 时间复杂度：循环执行 nnn 次，每次花费常数的时间代价，故渐进时间复杂度为 O(n)O(n)O(n)。\n * 空间复杂度：这里只用了常数个变量作为辅助空间，故渐进空间复杂度为 O(1)O(1)O(1)。\n\n# 方法二：矩阵快速幂\n思路\n\n以上的方法适用于 nnn 比较小的情况，在 nnn 变大之后，O(n)O(n)O(n) 的时间复杂度会让这个算法看起来有些捉襟见肘。我们可以用「矩阵快速幂」的方法来优化这个过程。\n\n首先我们可以构建这样一个递推关系：\n\n[1110][f(n)f(n−1)]=[f(n)+f(n−1)f(n)]=[f(n+1)f(n)]\\left[ \\begin{matrix} 1 & 1 \\\\ 1 & 0 \\end{matrix} \\right] \\left[ \\begin{matrix} f(n)\\\\ f(n - 1) \\end{matrix} \\right] = \\left[ \\begin{matrix} f(n) + f(n - 1)\\\\ f(n) \\end{matrix} \\right] = \\left[ \\begin{matrix} f(n + 1)\\\\ f(n) \\end{matrix} \\right][11​10​][f(n)f(n−1)​]=[f(n)+f(n−1)f(n)​]=[f(n+1)f(n)​]\n\n因此：\n\n[f(n+1)f(n)]=[1110]n[f(1)f(0)]\\left[ \\begin{matrix} f(n + 1)\\\\ f(n) \\end{matrix} \\right] = \\left[ \\begin{matrix} 1 & 1 \\\\ 1 & 0 \\end{matrix} \\right] ^n \\left[ \\begin{matrix} f(1)\\\\ f(0) \\end{matrix} \\right][f(n+1)f(n)​]=[11​10​]n[f(1)f(0)​]\n\n令：\n\nM=[1110]M = \\left[ \\begin{matrix} 1 & 1 \\\\ 1 & 0 \\end{matrix} \\right]M=[11​10​]\n\n因此我们只要能快速计算矩阵 MMM 的 nnn 次幂，就可以得到 f(n)f(n)f(n) 的值。如果直接求取 MnM^nMn，时间复杂度是 O(n)O(n)O(n) 的，我们可以定义矩阵乘法，然后用快速幂算法来加速这里 MnM^nMn 的求取。\n\n如何想到使用矩阵快速幂？\n\n * 如果一个问题可与转化为求解一个矩阵的 nnn 次方的形式，那么可以用快速幂来加速计算\n * 如果一个递归式形如 f(n)=∑i=1maif(n−i)f(n) = \\sum_{i = 1}^{m} a_i f(n - i)f(n)=∑i=1m​ai​f(n−i)，即齐次线性递推式，我们就可以把数列的递推关系转化为矩阵的递推关系，即构造出一个矩阵的 nnn 次方乘以一个列向量得到一个列向量，这个列向量中包含我们要求的 f(n)f(n)f(n)。一般情况下，形如 f(n)=∑i=1maif(n−i)f(n) = \\sum_{i = 1}^{m} a_i f(n - i)f(n)=∑i=1m​ai​f(n−i) 可以构造出这样的 m×mm \\times mm×m 的矩阵：\n\n[a1a2a3⋯am100⋯0010⋯0001⋯0⋮⋮⋮⋱⋮000⋯1]\\left[ \\begin{matrix} a_1 & a_2 & a_3 & \\cdots & a_m \\\\ 1 & 0 & 0 & \\cdots & 0 \\\\ 0 & 1 & 0 & \\cdots & 0 \\\\ 0 & 0 & 1 & \\cdots & 0 \\\\ \\vdots & \\vdots & \\vdots & \\ddots & \\vdots \\\\ 0 & 0 & 0 & \\cdots & 1 \\\\ \\end{matrix} \\right]⎣⎢⎢⎢⎢⎢⎢⎢⎡​a1​100⋮0​a2​010⋮0​a3​001⋮0​⋯⋯⋯⋯⋱⋯​am​000⋮1​⎦⎥⎥⎥⎥⎥⎥⎥⎤​\n\n * 那么遇到非齐次线性递推我们是不是就束手无策了呢？其实未必。有些时候我们可以把非齐次线性递推转化为其次线性递推，比如这样一个递推：\n\nf(x)=(2x−6)c+f(x−1)+f(x−2)+f(x−3)f(x) = (2x-6)c + f(x - 1) + f(x - 2) + f(x - 3)f(x)=(2x−6)c+f(x−1)+f(x−2)+f(x−3)\n\n我们可以做这样的变换：\n\nf(x)+xc=[f(x−1)+(x−1)c]+[f(x−2)+(x−2)c]+[f(x−3)+(x−3)c]f(x) + xc = [f(x - 1) + (x - 1)c] + [f(x - 2) + (x - 2)c] + [f(x - 3) + (x - 3)c]f(x)+xc=[f(x−1)+(x−1)c]+[f(x−2)+(x−2)c]+[f(x−3)+(x−3)c]\n\n令 g(x)=f(x)+xcg(x) = f(x) + xcg(x)=f(x)+xc，那么我们又得到了一个齐次线性递：\n\ng(x)=g(x−1)+g(x−2)+g(x−3)g(x) = g(x - 1) + g(x - 2) + g(x - 3)g(x)=g(x−1)+g(x−2)+g(x−3)\n\n于是就可以使用矩阵快速幂求解了。当然并不是所有非齐次线性都可以化成齐次线性，我们还是要具体问题具体分析。\n\n> 留两个思考题：\n\n * 你能把 f(x)=2f(x−1)+3f(x−2)+4cf(x) = 2f(x - 1) + 3f(x - 2) + 4cf(x)=2f(x−1)+3f(x−2)+4c 化成齐次线性递推吗？欢迎大家在评论区留言。\n * 如果一个非齐次线性递推可以转化成齐次线性递推，那么一般方法是什么？这个问题也欢迎大家在评论区总结。\n\n\n代码\n\npublic class Solution {\n    public int climbStairs(int n) {\n        int[][] q = {{1, 1}, {1, 0}};\n        int[][] res = pow(q, n);\n        return res[0][0];\n    }\n\n    public int[][] pow(int[][] a, int n) {\n        int[][] ret = {{1, 0}, {0, 1}};\n        while (n > 0) {\n            if ((n & 1) == 1) {\n                ret = multiply(ret, a);\n            }\n            n >>= 1;\n            a = multiply(a, a);\n        }\n        return ret;\n    }\n\n    public int[][] multiply(int[][] a, int[][] b) {\n        int[][] c = new int[2][2];\n        for (int i = 0; i < 2; i++) {\n            for (int j = 0; j < 2; j++) {\n                c[i][j] = a[i][0] * b[0][j] + a[i][1] * b[1][j];\n            }\n        }\n        return c;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\nclass Solution {\npublic:\n    vector<vector<long long>> multiply(vector<vector<long long>> &a, vector<vector<long long>> &b) {\n        vector<vector<long long>> c(2, vector<long long>(2));\n        for (int i = 0; i < 2; i++) {\n            for (int j = 0; j < 2; j++) {\n                c[i][j] = a[i][0] * b[0][j] + a[i][1] * b[1][j];\n            }\n        }\n        return c;\n    }\n\n    vector<vector<long long>> matrixPow(vector<vector<long long>> a, int n) {\n        vector<vector<long long>> ret = {{1, 0}, {0, 1}};\n        while (n > 0) {\n            if ((n & 1) == 1) {\n                ret = multiply(ret, a);\n            }\n            n >>= 1;\n            a = multiply(a, a);\n        }\n        return ret;\n    }\n\n    int climbStairs(int n) {\n        vector<vector<long long>> ret = {{1, 1}, {1, 0}};\n        vector<vector<long long>> res = matrixPow(ret, n);\n        return res[0][0];\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\nvar climbStairs = function(n) {\n    const q = [[1, 1], [1, 0]];\n    const res = pow(q, n);\n    return res[0][0];\n};\n\nconst pow = (a, n) => {\n    let ret = [[1, 0], [0, 1]];\n    while (n > 0) {\n        if ((n & 1) === 1) {\n            ret = multiply(ret, a);\n        }\n        n >>= 1;\n        a = multiply(a, a);\n    }\n    return ret;\n}\n\nconst multiply = (a, b) => {\n    const c = new Array(2).fill(0).map(() => new Array(2).fill(0));\n    for (let i = 0; i < 2; i++) {\n        for (let j = 0; j < 2; j++) {\n            c[i][j] = a[i][0] * b[0][j] + a[i][1] * b[1][j];\n        }\n    }\n    return c;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\ntype matrix [2][2]int\n\nfunc mul(a, b matrix) (c matrix) {\n    for i := 0; i < 2; i++ {\n        for j := 0; j < 2; j++ {\n            c[i][j] = a[i][0]*b[0][j] + a[i][1]*b[1][j]\n        }\n    }\n    return c\n}\n\nfunc pow(a matrix, n int) matrix {\n    res := matrix{{1, 0}, {0, 1}}\n    for ; n > 0; n >>= 1 {\n        if n&1 == 1 {\n            res = mul(res, a)\n        }\n        a = mul(a, a)\n    }\n    return res\n}\n\nfunc climbStairs(n int) int {\n    res := pow(matrix{{1, 1}, {1, 0}}, n)\n    return res[0][0]\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\nstruct Matrix {\n    long long mat[2][2];\n};\n\nstruct Matrix multiply(struct Matrix a, struct Matrix b) {\n    struct Matrix c;\n    for (int i = 0; i < 2; i++) {\n        for (int j = 0; j < 2; j++) {\n            c.mat[i][j] = a.mat[i][0] * b.mat[0][j] + a.mat[i][1] * b.mat[1][j];\n        }\n    }\n    return c;\n}\n\nstruct Matrix matrixPow(struct Matrix a, int n) {\n    struct Matrix ret;\n    ret.mat[0][0] = ret.mat[1][1] = 1;\n    ret.mat[0][1] = ret.mat[1][0] = 0;\n    while (n > 0) {\n        if ((n & 1) == 1) {\n            ret = multiply(ret, a);\n        }\n        n >>= 1;\n        a = multiply(a, a);\n    }\n    return ret;\n}\n\nint climbStairs(int n) {\n    struct Matrix ret;\n    ret.mat[1][1] = 0;\n    ret.mat[0][0] = ret.mat[0][1] = ret.mat[1][0] = 1;\n    struct Matrix res = matrixPow(ret, n);\n    return res.mat[0][0];\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n复杂度分析\n\n * 时间复杂度：同快速幂，O(log⁡n)O(\\log n)O(logn)。\n * 空间复杂度：O(1)O(1)O(1)。\n\n# 方法三：通项公式\n思路\n\n之前的方法我们已经讨论了 f(n)f(n)f(n) 是齐次线性递推，根据递推方程 f(n)=f(n−1)+f(n−2)f(n) = f(n - 1) + f(n - 2)f(n)=f(n−1)+f(n−2)，我们可以写出这样的特征方程：\n\nx2=x+1x^2 = x + 1x2=x+1\n\n求得 x1=1+52x_1 = \\frac{1+\\sqrt{5}}{2}x1​=21+5​​，x2=1−52x_2 = \\frac{1-\\sqrt{5}}{2}x2​=21−5​​，设通解为 f(n)=c1x1n+c2x2nf(n) = c_1 x_1 ^n + c_2 x_2 ^ nf(n)=c1​x1n​+c2​x2n​，代入初始条件 f(1)=1f(1) = 1f(1)=1，f(2)=1f(2) = 1f(2)=1，得 c1=15c_1 = \\frac{1}{\\sqrt{5}}c1​=5​1​，c2=−15c_2 = -\\frac{1}{\\sqrt{5}}c2​=−5​1​，我们得到了这个递推数列的通项公式：\n\nf(n)=15[(1+52)n−(1−52)n]f(n) = \\frac{1}{\\sqrt{5}}\\left[ \\left(\\frac{1+\\sqrt{5}}{2}\\right)^{n} - \\left(\\frac{1-\\sqrt{5}}{2}\\right)^{n} \\right]f(n)=5​1​[(21+5​​)n−(21−5​​)n]\n\n接着我们就可以通过这个公式直接求第 nnn 项了。\n\n代码\n\npublic class Solution {\n    public int climbStairs(int n) {\n        double sqrt5 = Math.sqrt(5);\n        double fibn = Math.pow((1 + sqrt5) / 2, n + 1) - Math.pow((1 - sqrt5) / 2, n + 1);\n        return (int) Math.round(fibn / sqrt5);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\nclass Solution {\npublic:\n    int climbStairs(int n) {\n        double sqrt5 = sqrt(5);\n        double fibn = pow((1 + sqrt5) / 2, n + 1) - pow((1 - sqrt5) / 2, n + 1);\n        return (int)round(fibn / sqrt5);\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\nvar climbStairs = function(n) {\n    const sqrt5 = Math.sqrt(5);\n    const fibn = Math.pow((1 + sqrt5) / 2, n + 1) - Math.pow((1 - sqrt5) / 2, n + 1);\n    return Math.round(fibn / sqrt5);\n};\n\n\n1\n2\n3\n4\n5\nfunc climbStairs(n int) int {\n    sqrt5 := math.Sqrt(5)\n    pow1 := math.Pow((1+sqrt5)/2, float64(n+1))\n    pow2 := math.Pow((1-sqrt5)/2, float64(n+1))\n    return int(math.Round((pow1 - pow2) / sqrt5))\n}\n\n\n1\n2\n3\n4\n5\n6\nint climbStairs(int n) {\n    double sqrt5 = sqrt(5);\n    double fibn = pow((1 + sqrt5) / 2, n + 1) - pow((1 - sqrt5) / 2, n + 1);\n    return (int) round(fibn / sqrt5);\n}\n\n\n1\n2\n3\n4\n5\n复杂度分析\n\n代码中使用的 pow\\texttt{pow}pow 函数的时空复杂度与 CPU 支持的指令集相关，这里不深入分析。\n\n# 总结\n这里形成的数列正好是斐波那契数列，答案要求的 f(n)f(n)f(n) 即是斐波那契数列的第 nnn 项（下标从 000 开始）。我们来总结一下斐波那契数列第 nnn 项的求解方法：\n\n * nnn 比较小的时候，可以直接使用过递归法求解，不做任何记忆化操作，时间复杂度是 O(2n)O(2^n)O(2n)，存在很多冗余计算。\n * 一般情况下，我们使用「记忆化搜索」或者「迭代」的方法，实现这个转移方程，时间复杂度和空间复杂度都可以做到 O(n)O(n)O(n)。\n * 为了优化空间复杂度，我们可以不用保存 f(x−2)f(x - 2)f(x−2) 之前的项，我们只用三个变量来维护 f(x)f(x)f(x)、f(x−1)f(x - 1)f(x−1) 和 f(x−2)f(x - 2)f(x−2)，你可以理解成是把「滚动数组思想」应用在了动态规划中，也可以理解成是一种递推，这样把空间复杂度优化到了 O(1)O(1)O(1)。\n * 随着 nnn 的不断增大 O(n)O(n)O(n) 可能已经不能满足我们的需要了，我们可以用「矩阵快速幂」的方法把算法加速到 O(log⁡n)O(\\log n)O(logn)。\n * 我们也可以把 nnn 代入斐波那契数列的通项公式计算结果，但是如果我们用浮点数计算来实现，可能会产生精度误差。\n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2021-04-14 21:58:32Accepted [https://leetcode-cn.com//submissions/detail/167942214/]0 ms100.0%35.3 MBjava2021-04-14 21:54:49Accepted [https://leetcode-cn.com//submissions/detail/167940424/]0 ms100.0%35.4 MBjava2021-04-14 21:53:55Runtime Error [https://leetcode-cn.com//submissions/detail/167939980/]N/AN/AN/Ajava2018-09-14 14:43:36Compile Error [https://leetcode-cn.com//submissions/detail/7085945/]N/AN/AN/Ajava2018-09-14 14:43:03Accepted [https://leetcode-cn.com//submissions/detail/7085908/]4 ms100.0%N/Ajava2018-09-14 14:42:52Compile Error [https://leetcode-cn.com//submissions/detail/7085901/]N/AN/AN/Ajava2018-07-23 21:16:17Accepted [https://leetcode-cn.com//submissions/detail/4554229/]3 ms100.0%N/Ajava2018-07-23 21:14:37Wrong Answer [https://leetcode-cn.com//submissions/detail/4554126/]N/AN/AN/Ajava2018-07-23 21:13:50Runtime Error [https://leetcode-cn.com//submissions/detail/4554072/]N/AN/AN/Ajava2018-07-23 21:13:06Accepted [https://leetcode-cn.com//submissions/detail/4554020/]3 ms100.0%N/Ajava2018-05-06 23:04:51Accepted [https://leetcode-cn.com//submissions/detail/2027427/]3 ms100.0%N/Ajava2018-05-06 23:00:52Time Limit Exceeded [https://leetcode-cn.com//submissions/detail/2027291/]N/AN/AN/Ajava# 统计信息\n通过次数提交次数AC比率41835080779451.8%# 相似题目\n题目难度使用最小花费爬楼梯 [https://leetcode-cn.com/problems/min-cost-climbing-stairs/]简单斐波那契数 [https://leetcode-cn.com/problems/fibonacci-number/]简单第 N 个泰波那契数 [https://leetcode-cn.com/problems/n-th-tribonacci-number/]简单",contentLowercase:"# 中文题目\n假设你正在爬楼梯。需要 n阶你才能到达楼顶。\n\n每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？\n\n注意：给定 n 是一个正整数。\n\n示例 1：\n\n输入： 2\n输出： 2\n解释： 有两种方法可以爬到楼顶。\n1.  1 阶 + 1 阶\n2.  2 阶\n\n示例 2：\n\n输入： 3\n输出： 3\n解释： 有三种方法可以爬到楼顶。\n1.  1 阶 + 1 阶 + 1 阶\n2.  1 阶 + 2 阶\n3.  2 阶 + 1 阶\n\n\n# 通过代码\n    class solution {\n        public int climbstairs(int n) {\n            // 就是斐波拉契数列\n            // 第一层：1\n            // 第二层：2\n            // 第三层，可以从第一层跨2步，可以从第二层跨一步\n            // 故第三层：f(3)=f(1)+f(2)，由于最后一步的不同，方法肯定不同\n            // 故第n层：f(n)=f(n-1)+f(n-2)\n\n            if (n==1){\n                return 1;\n            }\n            if (n==2){\n                return 2;\n            }\n            int[] arr=new int[n+1];\n            arr[1]=1;\n            arr[2]=2;\n            for (int i = 3; i <= n; i++) {\n                arr[i]=arr[i-1]+arr[i-2];\n            }\n            return arr[n];\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\nclass solution {\n    int[] memo;\n\n        int calcways(int n){\n            if (n == 1) {\n                return 1;\n            }\n            if (n == 2) {\n                return 2;\n            }\n            if (memo[n]==-1){\n                memo[n]=calcways(n-1)+calcways(n-2);\n            }\n            return memo[n];\n        }\n\n        public  int climbstairs(int n) {\n            memo =new int[n+1];\n            arrays.fill(memo,-1);\n            return calcways(n);\n        }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\nclass solution {\n    int[] memo;\n\n        int calcways(int n){\n            if (n == 1) {\n                return 1;\n            }\n            if (n == 2) {\n                return 2;\n            }\n            if (memo[n]==-1){\n                memo[n]=calcways(n-1)+calcways(n-2);\n            }\n            return memo[n];\n        }\n\n        public  int climbstairs(int n) {\n            memo =new int[n+1];\n            arrays.fill(memo,-1);\n            return calcways(n);\n        }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\nclass solution {\n    public int climbstairs(int n) {\n        if (n<=2){\n                return n;\n            }\n            int[] ways=new int[n+1];\n            ways[1]=1;\n            ways[2]=2;\n            for (int i = 3; i <=n ; i++) {\n                ways[i]=ways[i-1]+ways[i-2];\n            }\n            return ways[n];\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n    class solution {\n        public int climbstairs(int n) {\n            // 就是斐波拉契数列\n            // 第一层：1\n            // 第二层：2\n            // 第三层，可以从第一层跨2步，可以从第二层跨一步\n            // 故第三层：f(3)=f(1)+f(2)，由于最后一步的不同，方法肯定不同\n            // 故第n层：f(n)=f(n-1)+f(n-2)\n\n            if (n==1){\n                return 1;\n            }\n            if (n==2){\n                return 2;\n            }\n            // 由于只需要计算最后一个值，我们可以只保存前面两个的状态\n            int a1=1;\n            int a2=2;\n            int a3=a1+a2;\n            for (int i = 3; i <= n; i++) {\n                a3=a1+a2;\n                a1=a2;\n                a2=a3;\n            }\n            return a3;\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n    class solution {\n        public int climbstairs(int n) {\n            // 就是斐波拉契数列\n            // 第一层：1\n            // 第二层：2\n            // 第三层，可以从第一层跨2步，可以从第二层跨一步\n            // 故第三层：f(3)=f(1)+f(2)，由于最后一步的不同，方法肯定不同\n            // 故第n层：f(n)=f(n-1)+f(n-2)\n\n            if (n==1){\n                return 1;\n            }\n            if (n==2){\n                return 2;\n            }\n            int[] arr=new int[n+1];\n            arr[1]=1;\n            arr[2]=2;\n            for (int i = 3; i <= n; i++) {\n                arr[i]=arr[i-1]+arr[i-2];\n            }\n            return arr[n];\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\nclass solution {\n//===============方法一:动态规划\n        public static int climbstairs(int n) {\n            if (n <= 2) {\n                return n;\n            }\n            int[] ways = new int[n + 1];\n            ways[1] = 1;\n            ways[2] = 2;\n            for (int i = 3; i <= n; i++) {\n                ways[i] = ways[i - 1] + ways[i - 2];\n            }\n            return ways[n];\n        }\n\n//================方法二：记忆化搜索\n\n//         int[] memo;\n\n//         int calcways(int n){\n//             if (n == 1) {\n//                 return 1;\n//             }\n//             if (n == 2) {\n//                 return 2;\n//             }\n//             if (memo[n]==-1){\n//                 memo[n]=calcways(n-1)+calcways(n-2);\n//             }\n//             return memo[n];\n//         }\n\n//         public  int climbstairs2(int n) {\n//             memo =new int[n+1];\n//             arrays.fill(memo,-1);\n//             return calcways(n);\n//         }\n    }\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\nclass solution {\n    int[] memo;\n\n        int calcways(int n){\n            if (n == 1) {\n                return 1;\n            }\n            if (n == 2) {\n                return 2;\n            }\n            if (memo[n]==-1){\n                memo[n]=calcways(n-1)+calcways(n-2);\n            }\n            return memo[n];\n        }\n\n        public  int climbstairs(int n) {\n            memo =new int[n+1];\n            arrays.fill(memo,-1);\n            return calcways(n);\n        }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\nclass solution {\n    public int climbstairs(int n) {\n        if (n<=2){\n                return n;\n            }\n            int[] ways=new int[n+1];\n            ways[1]=1;\n            ways[2]=2;\n            for (int i = 3; i <=n ; i++) {\n                ways[i]=ways[i-1]+ways[i-2];\n            }\n            return ways[n];\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\nclass solution {\n    public int climbstairs(int n) {\n        if (n<=2){\n                return n;\n            }\n            int[] ways=new int[n+1];\n            ways[1]=1;\n            ways[2]=2;\n            for (int i = 3; i <=n ; i++) {\n                ways[i]=ways[i-1]+ways[i-2];\n            }\n            return ways[n];\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n# 我的笔记\n就是斐波拉契数列 第一层：1 第二层：2 第三层，可以从第一层跨2步，可以从第二层跨一步 故第三层：f(3)=f(1)+f(2)，由于最后一步的不同，方法肯定不同 故第n层：f(n)=f(n-1)+f(n-2)\n\n# 高赞题解\n# 📺 视频题解\n\n\n# 方法一：动态规划\n思路和算法\n\n我们用 f(x)f(x)f(x) 表示爬到第 xxx 级台阶的方案数，考虑最后一步可能跨了一级台阶，也可能跨了两级台阶，所以我们可以列出如下式子：\n\nf(x)=f(x−1)+f(x−2)f(x) = f(x - 1) + f(x - 2)f(x)=f(x−1)+f(x−2)\n\n它意味着爬到第 xxx 级台阶的方案数是爬到第 x−1x - 1x−1 级台阶的方案数和爬到第 x−2x - 2x−2 级台阶的方案数的和。很好理解，因为每次只能爬 111 级或 222 级，所以 f(x)f(x)f(x) 只能从 f(x−1)f(x - 1)f(x−1) 和 f(x−2)f(x - 2)f(x−2) 转移过来，而这里要统计方案总数，我们就需要对这两项的贡献求和。\n\n以上是动态规划的转移方程，下面我们来讨论边界条件。我们是从第 000 级开始爬的，所以从第 000 级爬到第 000 级我们可以看作只有一种方案，即 f(0)=1f(0) = 1f(0)=1；从第 000 级到第 111 级也只有一种方案，即爬一级，f(1)=1f(1) = 1f(1)=1。这两个作为边界条件就可以继续向后推导出第 nnn 级的正确结果。我们不妨写几项来验证一下，根据转移方程得到 f(2)=2f(2) = 2f(2)=2，f(3)=3f(3) = 3f(3)=3，f(4)=5f(4) = 5f(4)=5，……，我们把这些情况都枚举出来，发现计算的结果是正确的。\n\n我们不难通过转移方程和边界条件给出一个时间复杂度和空间复杂度都是 o(n)o(n)o(n) 的实现，但是由于这里的 f(x)f(x)f(x) 只和 f(x−1)f(x - 1)f(x−1) 与 f(x−2)f(x - 2)f(x−2) 有关，所以我们可以用「滚动数组思想」把空间复杂度优化成 o(1)o(1)o(1)。下面的代码中给出的就是这种实现。\n\n\n\n代码\n\nclass solution {\npublic:\n    int climbstairs(int n) {\n        int p = 0, q = 0, r = 1;\n        for (int i = 1; i <= n; ++i) {\n            p = q; \n            q = r; \n            r = p + q;\n        }\n        return r;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\nclass solution {\n    public int climbstairs(int n) {\n        int p = 0, q = 0, r = 1;\n        for (int i = 1; i <= n; ++i) {\n            p = q; \n            q = r; \n            r = p + q;\n        }\n        return r;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\nfunction climbstairs(n: number): number {\n    let p: number = 0, q: number = 0, r: number = 1;\n    for (let i = 1; i <= n; ++i) {\n        p = q; \n        q = r; \n        r = p + q;\n    }\n    return r;\n};\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\nfunc climbstairs(n int) int {\n    p, q, r := 0, 0, 1\n    for i := 1; i <= n; i++ {\n        p = q\n        q = r\n        r = p + q\n    }\n    return r\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\nvar climbstairs = function(n) {\n    let p = 0, q = 0, r = 1;\n    for (let i = 1; i <= n; ++i) {\n        p = q;\n        q = r;\n        r = p + q;\n    }\n    return r;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\nint climbstairs(int n) {\n    int p = 0, q = 0, r = 1;\n    for (int i = 1; i <= n; ++i) {\n        p = q;\n        q = r;\n        r = p + q;\n    }\n    return r;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n复杂度分析\n\n * 时间复杂度：循环执行 nnn 次，每次花费常数的时间代价，故渐进时间复杂度为 o(n)o(n)o(n)。\n * 空间复杂度：这里只用了常数个变量作为辅助空间，故渐进空间复杂度为 o(1)o(1)o(1)。\n\n# 方法二：矩阵快速幂\n思路\n\n以上的方法适用于 nnn 比较小的情况，在 nnn 变大之后，o(n)o(n)o(n) 的时间复杂度会让这个算法看起来有些捉襟见肘。我们可以用「矩阵快速幂」的方法来优化这个过程。\n\n首先我们可以构建这样一个递推关系：\n\n[1110][f(n)f(n−1)]=[f(n)+f(n−1)f(n)]=[f(n+1)f(n)]\\left[ \\begin{matrix} 1 & 1 \\\\ 1 & 0 \\end{matrix} \\right] \\left[ \\begin{matrix} f(n)\\\\ f(n - 1) \\end{matrix} \\right] = \\left[ \\begin{matrix} f(n) + f(n - 1)\\\\ f(n) \\end{matrix} \\right] = \\left[ \\begin{matrix} f(n + 1)\\\\ f(n) \\end{matrix} \\right][11​10​][f(n)f(n−1)​]=[f(n)+f(n−1)f(n)​]=[f(n+1)f(n)​]\n\n因此：\n\n[f(n+1)f(n)]=[1110]n[f(1)f(0)]\\left[ \\begin{matrix} f(n + 1)\\\\ f(n) \\end{matrix} \\right] = \\left[ \\begin{matrix} 1 & 1 \\\\ 1 & 0 \\end{matrix} \\right] ^n \\left[ \\begin{matrix} f(1)\\\\ f(0) \\end{matrix} \\right][f(n+1)f(n)​]=[11​10​]n[f(1)f(0)​]\n\n令：\n\nm=[1110]m = \\left[ \\begin{matrix} 1 & 1 \\\\ 1 & 0 \\end{matrix} \\right]m=[11​10​]\n\n因此我们只要能快速计算矩阵 mmm 的 nnn 次幂，就可以得到 f(n)f(n)f(n) 的值。如果直接求取 mnm^nmn，时间复杂度是 o(n)o(n)o(n) 的，我们可以定义矩阵乘法，然后用快速幂算法来加速这里 mnm^nmn 的求取。\n\n如何想到使用矩阵快速幂？\n\n * 如果一个问题可与转化为求解一个矩阵的 nnn 次方的形式，那么可以用快速幂来加速计算\n * 如果一个递归式形如 f(n)=∑i=1maif(n−i)f(n) = \\sum_{i = 1}^{m} a_i f(n - i)f(n)=∑i=1m​ai​f(n−i)，即齐次线性递推式，我们就可以把数列的递推关系转化为矩阵的递推关系，即构造出一个矩阵的 nnn 次方乘以一个列向量得到一个列向量，这个列向量中包含我们要求的 f(n)f(n)f(n)。一般情况下，形如 f(n)=∑i=1maif(n−i)f(n) = \\sum_{i = 1}^{m} a_i f(n - i)f(n)=∑i=1m​ai​f(n−i) 可以构造出这样的 m×mm \\times mm×m 的矩阵：\n\n[a1a2a3⋯am100⋯0010⋯0001⋯0⋮⋮⋮⋱⋮000⋯1]\\left[ \\begin{matrix} a_1 & a_2 & a_3 & \\cdots & a_m \\\\ 1 & 0 & 0 & \\cdots & 0 \\\\ 0 & 1 & 0 & \\cdots & 0 \\\\ 0 & 0 & 1 & \\cdots & 0 \\\\ \\vdots & \\vdots & \\vdots & \\ddots & \\vdots \\\\ 0 & 0 & 0 & \\cdots & 1 \\\\ \\end{matrix} \\right]⎣⎢⎢⎢⎢⎢⎢⎢⎡​a1​100⋮0​a2​010⋮0​a3​001⋮0​⋯⋯⋯⋯⋱⋯​am​000⋮1​⎦⎥⎥⎥⎥⎥⎥⎥⎤​\n\n * 那么遇到非齐次线性递推我们是不是就束手无策了呢？其实未必。有些时候我们可以把非齐次线性递推转化为其次线性递推，比如这样一个递推：\n\nf(x)=(2x−6)c+f(x−1)+f(x−2)+f(x−3)f(x) = (2x-6)c + f(x - 1) + f(x - 2) + f(x - 3)f(x)=(2x−6)c+f(x−1)+f(x−2)+f(x−3)\n\n我们可以做这样的变换：\n\nf(x)+xc=[f(x−1)+(x−1)c]+[f(x−2)+(x−2)c]+[f(x−3)+(x−3)c]f(x) + xc = [f(x - 1) + (x - 1)c] + [f(x - 2) + (x - 2)c] + [f(x - 3) + (x - 3)c]f(x)+xc=[f(x−1)+(x−1)c]+[f(x−2)+(x−2)c]+[f(x−3)+(x−3)c]\n\n令 g(x)=f(x)+xcg(x) = f(x) + xcg(x)=f(x)+xc，那么我们又得到了一个齐次线性递：\n\ng(x)=g(x−1)+g(x−2)+g(x−3)g(x) = g(x - 1) + g(x - 2) + g(x - 3)g(x)=g(x−1)+g(x−2)+g(x−3)\n\n于是就可以使用矩阵快速幂求解了。当然并不是所有非齐次线性都可以化成齐次线性，我们还是要具体问题具体分析。\n\n> 留两个思考题：\n\n * 你能把 f(x)=2f(x−1)+3f(x−2)+4cf(x) = 2f(x - 1) + 3f(x - 2) + 4cf(x)=2f(x−1)+3f(x−2)+4c 化成齐次线性递推吗？欢迎大家在评论区留言。\n * 如果一个非齐次线性递推可以转化成齐次线性递推，那么一般方法是什么？这个问题也欢迎大家在评论区总结。\n\n\n代码\n\npublic class solution {\n    public int climbstairs(int n) {\n        int[][] q = {{1, 1}, {1, 0}};\n        int[][] res = pow(q, n);\n        return res[0][0];\n    }\n\n    public int[][] pow(int[][] a, int n) {\n        int[][] ret = {{1, 0}, {0, 1}};\n        while (n > 0) {\n            if ((n & 1) == 1) {\n                ret = multiply(ret, a);\n            }\n            n >>= 1;\n            a = multiply(a, a);\n        }\n        return ret;\n    }\n\n    public int[][] multiply(int[][] a, int[][] b) {\n        int[][] c = new int[2][2];\n        for (int i = 0; i < 2; i++) {\n            for (int j = 0; j < 2; j++) {\n                c[i][j] = a[i][0] * b[0][j] + a[i][1] * b[1][j];\n            }\n        }\n        return c;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\nclass solution {\npublic:\n    vector<vector<long long>> multiply(vector<vector<long long>> &a, vector<vector<long long>> &b) {\n        vector<vector<long long>> c(2, vector<long long>(2));\n        for (int i = 0; i < 2; i++) {\n            for (int j = 0; j < 2; j++) {\n                c[i][j] = a[i][0] * b[0][j] + a[i][1] * b[1][j];\n            }\n        }\n        return c;\n    }\n\n    vector<vector<long long>> matrixpow(vector<vector<long long>> a, int n) {\n        vector<vector<long long>> ret = {{1, 0}, {0, 1}};\n        while (n > 0) {\n            if ((n & 1) == 1) {\n                ret = multiply(ret, a);\n            }\n            n >>= 1;\n            a = multiply(a, a);\n        }\n        return ret;\n    }\n\n    int climbstairs(int n) {\n        vector<vector<long long>> ret = {{1, 1}, {1, 0}};\n        vector<vector<long long>> res = matrixpow(ret, n);\n        return res[0][0];\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\nvar climbstairs = function(n) {\n    const q = [[1, 1], [1, 0]];\n    const res = pow(q, n);\n    return res[0][0];\n};\n\nconst pow = (a, n) => {\n    let ret = [[1, 0], [0, 1]];\n    while (n > 0) {\n        if ((n & 1) === 1) {\n            ret = multiply(ret, a);\n        }\n        n >>= 1;\n        a = multiply(a, a);\n    }\n    return ret;\n}\n\nconst multiply = (a, b) => {\n    const c = new array(2).fill(0).map(() => new array(2).fill(0));\n    for (let i = 0; i < 2; i++) {\n        for (let j = 0; j < 2; j++) {\n            c[i][j] = a[i][0] * b[0][j] + a[i][1] * b[1][j];\n        }\n    }\n    return c;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\ntype matrix [2][2]int\n\nfunc mul(a, b matrix) (c matrix) {\n    for i := 0; i < 2; i++ {\n        for j := 0; j < 2; j++ {\n            c[i][j] = a[i][0]*b[0][j] + a[i][1]*b[1][j]\n        }\n    }\n    return c\n}\n\nfunc pow(a matrix, n int) matrix {\n    res := matrix{{1, 0}, {0, 1}}\n    for ; n > 0; n >>= 1 {\n        if n&1 == 1 {\n            res = mul(res, a)\n        }\n        a = mul(a, a)\n    }\n    return res\n}\n\nfunc climbstairs(n int) int {\n    res := pow(matrix{{1, 1}, {1, 0}}, n)\n    return res[0][0]\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\nstruct matrix {\n    long long mat[2][2];\n};\n\nstruct matrix multiply(struct matrix a, struct matrix b) {\n    struct matrix c;\n    for (int i = 0; i < 2; i++) {\n        for (int j = 0; j < 2; j++) {\n            c.mat[i][j] = a.mat[i][0] * b.mat[0][j] + a.mat[i][1] * b.mat[1][j];\n        }\n    }\n    return c;\n}\n\nstruct matrix matrixpow(struct matrix a, int n) {\n    struct matrix ret;\n    ret.mat[0][0] = ret.mat[1][1] = 1;\n    ret.mat[0][1] = ret.mat[1][0] = 0;\n    while (n > 0) {\n        if ((n & 1) == 1) {\n            ret = multiply(ret, a);\n        }\n        n >>= 1;\n        a = multiply(a, a);\n    }\n    return ret;\n}\n\nint climbstairs(int n) {\n    struct matrix ret;\n    ret.mat[1][1] = 0;\n    ret.mat[0][0] = ret.mat[0][1] = ret.mat[1][0] = 1;\n    struct matrix res = matrixpow(ret, n);\n    return res.mat[0][0];\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n复杂度分析\n\n * 时间复杂度：同快速幂，o(log⁡n)o(\\log n)o(logn)。\n * 空间复杂度：o(1)o(1)o(1)。\n\n# 方法三：通项公式\n思路\n\n之前的方法我们已经讨论了 f(n)f(n)f(n) 是齐次线性递推，根据递推方程 f(n)=f(n−1)+f(n−2)f(n) = f(n - 1) + f(n - 2)f(n)=f(n−1)+f(n−2)，我们可以写出这样的特征方程：\n\nx2=x+1x^2 = x + 1x2=x+1\n\n求得 x1=1+52x_1 = \\frac{1+\\sqrt{5}}{2}x1​=21+5​​，x2=1−52x_2 = \\frac{1-\\sqrt{5}}{2}x2​=21−5​​，设通解为 f(n)=c1x1n+c2x2nf(n) = c_1 x_1 ^n + c_2 x_2 ^ nf(n)=c1​x1n​+c2​x2n​，代入初始条件 f(1)=1f(1) = 1f(1)=1，f(2)=1f(2) = 1f(2)=1，得 c1=15c_1 = \\frac{1}{\\sqrt{5}}c1​=5​1​，c2=−15c_2 = -\\frac{1}{\\sqrt{5}}c2​=−5​1​，我们得到了这个递推数列的通项公式：\n\nf(n)=15[(1+52)n−(1−52)n]f(n) = \\frac{1}{\\sqrt{5}}\\left[ \\left(\\frac{1+\\sqrt{5}}{2}\\right)^{n} - \\left(\\frac{1-\\sqrt{5}}{2}\\right)^{n} \\right]f(n)=5​1​[(21+5​​)n−(21−5​​)n]\n\n接着我们就可以通过这个公式直接求第 nnn 项了。\n\n代码\n\npublic class solution {\n    public int climbstairs(int n) {\n        double sqrt5 = math.sqrt(5);\n        double fibn = math.pow((1 + sqrt5) / 2, n + 1) - math.pow((1 - sqrt5) / 2, n + 1);\n        return (int) math.round(fibn / sqrt5);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\nclass solution {\npublic:\n    int climbstairs(int n) {\n        double sqrt5 = sqrt(5);\n        double fibn = pow((1 + sqrt5) / 2, n + 1) - pow((1 - sqrt5) / 2, n + 1);\n        return (int)round(fibn / sqrt5);\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\nvar climbstairs = function(n) {\n    const sqrt5 = math.sqrt(5);\n    const fibn = math.pow((1 + sqrt5) / 2, n + 1) - math.pow((1 - sqrt5) / 2, n + 1);\n    return math.round(fibn / sqrt5);\n};\n\n\n1\n2\n3\n4\n5\nfunc climbstairs(n int) int {\n    sqrt5 := math.sqrt(5)\n    pow1 := math.pow((1+sqrt5)/2, float64(n+1))\n    pow2 := math.pow((1-sqrt5)/2, float64(n+1))\n    return int(math.round((pow1 - pow2) / sqrt5))\n}\n\n\n1\n2\n3\n4\n5\n6\nint climbstairs(int n) {\n    double sqrt5 = sqrt(5);\n    double fibn = pow((1 + sqrt5) / 2, n + 1) - pow((1 - sqrt5) / 2, n + 1);\n    return (int) round(fibn / sqrt5);\n}\n\n\n1\n2\n3\n4\n5\n复杂度分析\n\n代码中使用的 pow\\texttt{pow}pow 函数的时空复杂度与 cpu 支持的指令集相关，这里不深入分析。\n\n# 总结\n这里形成的数列正好是斐波那契数列，答案要求的 f(n)f(n)f(n) 即是斐波那契数列的第 nnn 项（下标从 000 开始）。我们来总结一下斐波那契数列第 nnn 项的求解方法：\n\n * nnn 比较小的时候，可以直接使用过递归法求解，不做任何记忆化操作，时间复杂度是 o(2n)o(2^n)o(2n)，存在很多冗余计算。\n * 一般情况下，我们使用「记忆化搜索」或者「迭代」的方法，实现这个转移方程，时间复杂度和空间复杂度都可以做到 o(n)o(n)o(n)。\n * 为了优化空间复杂度，我们可以不用保存 f(x−2)f(x - 2)f(x−2) 之前的项，我们只用三个变量来维护 f(x)f(x)f(x)、f(x−1)f(x - 1)f(x−1) 和 f(x−2)f(x - 2)f(x−2)，你可以理解成是把「滚动数组思想」应用在了动态规划中，也可以理解成是一种递推，这样把空间复杂度优化到了 o(1)o(1)o(1)。\n * 随着 nnn 的不断增大 o(n)o(n)o(n) 可能已经不能满足我们的需要了，我们可以用「矩阵快速幂」的方法把算法加速到 o(log⁡n)o(\\log n)o(logn)。\n * 我们也可以把 nnn 代入斐波那契数列的通项公式计算结果，但是如果我们用浮点数计算来实现，可能会产生精度误差。\n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2021-04-14 21:58:32accepted [https://leetcode-cn.com//submissions/detail/167942214/]0 ms100.0%35.3 mbjava2021-04-14 21:54:49accepted [https://leetcode-cn.com//submissions/detail/167940424/]0 ms100.0%35.4 mbjava2021-04-14 21:53:55runtime error [https://leetcode-cn.com//submissions/detail/167939980/]n/an/an/ajava2018-09-14 14:43:36compile error [https://leetcode-cn.com//submissions/detail/7085945/]n/an/an/ajava2018-09-14 14:43:03accepted [https://leetcode-cn.com//submissions/detail/7085908/]4 ms100.0%n/ajava2018-09-14 14:42:52compile error [https://leetcode-cn.com//submissions/detail/7085901/]n/an/an/ajava2018-07-23 21:16:17accepted [https://leetcode-cn.com//submissions/detail/4554229/]3 ms100.0%n/ajava2018-07-23 21:14:37wrong answer [https://leetcode-cn.com//submissions/detail/4554126/]n/an/an/ajava2018-07-23 21:13:50runtime error [https://leetcode-cn.com//submissions/detail/4554072/]n/an/an/ajava2018-07-23 21:13:06accepted [https://leetcode-cn.com//submissions/detail/4554020/]3 ms100.0%n/ajava2018-05-06 23:04:51accepted [https://leetcode-cn.com//submissions/detail/2027427/]3 ms100.0%n/ajava2018-05-06 23:00:52time limit exceeded [https://leetcode-cn.com//submissions/detail/2027291/]n/an/an/ajava# 统计信息\n通过次数提交次数ac比率41835080779451.8%# 相似题目\n题目难度使用最小花费爬楼梯 [https://leetcode-cn.com/problems/min-cost-climbing-stairs/]简单斐波那契数 [https://leetcode-cn.com/problems/fibonacci-number/]简单第 n 个泰波那契数 [https://leetcode-cn.com/problems/n-th-tribonacci-number/]简单"},{title:"100-相同的树(Same Tree)",frontmatter:{title:"100-相同的树(Same Tree)",date:"2018-09-06T00:00:00.000Z",categories:["简单"],tags:["树<Tree>","深度优先搜索<Depth-first Search>"]},regularPath:"/views/%E7%AE%80%E5%8D%95/0100-%E7%9B%B8%E5%90%8C%E7%9A%84%E6%A0%91.html",relativePath:"views/简单/0100-相同的树.md",key:"v-0e59c80c",path:"/views/%E7%AE%80%E5%8D%95/0100-%E7%9B%B8%E5%90%8C%E7%9A%84%E6%A0%91.html",headers:[{level:2,title:"中文题目",slug:"中文题目",charIndex:2},{level:2,title:"通过代码",slug:"通过代码",charIndex:428},{level:2,title:"官方题解",slug:"官方题解",charIndex:1059},{level:2,title:"提交历史",slug:"提交历史",charIndex:4872},{level:2,title:"统计信息",slug:"统计信息",charIndex:4999}],lastUpdated:"4/11/2021, 1:15:21 PM",headersStr:"中文题目 通过代码 官方题解 提交历史 统计信息",content:'# 中文题目\n给定两个二叉树，编写一个函数来检验它们是否相同。\n\n如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。\n\n示例 1:\n\n输入:       1         1\n          / \\       / \\\n         2   3     2   3\n\n        [1,2,3],   [1,2,3]\n\n输出: true\n\n示例 2:\n\n输入:      1          1\n          /           \\\n         2             2\n\n        [1,2],     [1,null,2]\n\n输出: false\n\n\n示例 3:\n\n输入:       1         1\n          / \\       / \\\n         2   1     1   2\n\n        [1,2,1],   [1,1,2]\n\n输出: false\n\n\n# 通过代码\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n         if (p==null && q==null){\n                return true;\n            }\n            if (p==null || q==null){\n                return false;\n            }\n            if (p.val==q.val){\n                return isSameTree(p.left,q.left) && isSameTree(p.right,q.right);\n            }\n            return false;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n# 官方题解\n# 方法一：递归\n直觉\n\n最简单的策略是使用递归。首先判断 p 和 q 是不是 None，然后判断它们的值是否相等。 若以上判断通过，则递归对子结点做同样操作。\n\n实现\n\n<,,, , ,>\n\nclass Solution:\n    def isSameTree(self, p, q):\n        """\n        :type p: TreeNode\n        :type q: TreeNode\n        :rtype: bool\n        """    \n        # p and q are both None\n        if not p and not q:\n            return True\n        # one of p and q is None\n        if not q or not p:\n            return False\n        if p.val != q.val:\n            return False\n        return self.isSameTree(p.right, q.right) and \\\n               self.isSameTree(p.left, q.left)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n  public boolean isSameTree(TreeNode p, TreeNode q) {\n    // p and q are both null\n    if (p == null && q == null) return true;\n    // one of p and q is null\n    if (q == null || p == null) return false;\n    if (p.val != q.val) return false;\n    return isSameTree(p.right, q.right) &&\n            isSameTree(p.left, q.left);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n复杂度分析\n\n * 时间复杂度 : O(N)O(N)O(N)，其中 N 是树的结点数，因为每个结点都访问一次。\n   \n   \n * 空间复杂度 : 最优情况（完全平衡二叉树）时为 O(log⁡(N))O(\\log(N))O(log(N))，最坏情况下（完全不平衡二叉树）时为 O(N){O}(N)O(N)，用于维护递归栈。\n   \n   \n   \n   \n\n\n\n\n# 方法二：迭代\n直觉\n\n从根开始，每次迭代将当前结点从双向队列中弹出。然后，进行方法一中的判断：\n\n * p 和 q 不是 None,\n   \n   \n * p.val 等于 q.val,\n   \n   \n\n若以上均满足，则压入子结点。\n\n实现\n\nfrom collections import deque\nclass Solution:\n    def isSameTree(self, p, q):\n        """\n        :type p: TreeNode\n        :type q: TreeNode\n        :rtype: bool\n        """    \n        def check(p, q):\n            # if both are None\n            if not p and not q:\n                return True\n            # one of p and q is None\n            if not q or not p:\n                return False\n            if p.val != q.val:\n                return False\n            return True\n        \n        deq = deque([(p, q),])\n        while deq:\n            p, q = deq.popleft()\n            if not check(p, q):\n                return False\n            \n            if p:\n                deq.append((p.left, q.left))\n                deq.append((p.right, q.right))\n                    \n        return True\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\nclass Solution {\n  public boolean check(TreeNode p, TreeNode q) {\n    // p and q are null\n    if (p == null && q == null) return true;\n    // one of p and q is null\n    if (q == null || p == null) return false;\n    if (p.val != q.val) return false;\n    return true;\n  }\n\n  public boolean isSameTree(TreeNode p, TreeNode q) {\n    if (p == null && q == null) return true;\n    if (!check(p, q)) return false;\n\n    // init deques\n    ArrayDeque<TreeNode> deqP = new ArrayDeque<TreeNode>();\n    ArrayDeque<TreeNode> deqQ = new ArrayDeque<TreeNode>();\n    deqP.addLast(p);\n    deqQ.addLast(q);\n\n    while (!deqP.isEmpty()) {\n      p = deqP.removeFirst();\n      q = deqQ.removeFirst();\n\n      if (!check(p, q)) return false;\n      if (p != null) {\n        // in Java nulls are not allowed in Deque\n        if (!check(p.left, q.left)) return false;\n        if (p.left != null) {\n          deqP.addLast(p.left);\n          deqQ.addLast(q.left);\n        }\n        if (!check(p.right, q.right)) return false;\n        if (p.right != null) {\n          deqP.addLast(p.right);\n          deqQ.addLast(q.right);\n        }\n      }\n    }\n    return true;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n复杂度分析\n\n * 时间复杂度 : O(N)O(N)O(N)，其中 N 是树的结点数，因为每个结点都访问一次。\n   \n   \n * 空间复杂度 : 最优情况（完全平衡二叉树）时为 O(log⁡(N))O(\\log(N))O(log(N))，最坏情况下（完全不平衡二叉树）时为 O(N){O}(N)O(N)，用于维护双向队列。\n   \n   \n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-09-06 14:41:47Accepted [https://leetcode-cn.com//submissions/detail/6637175/]5 ms7.92%N/Ajava# 统计信息\n通过次数提交次数AC比率5643610085756.0%',contentLowercase:'# 中文题目\n给定两个二叉树，编写一个函数来检验它们是否相同。\n\n如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。\n\n示例 1:\n\n输入:       1         1\n          / \\       / \\\n         2   3     2   3\n\n        [1,2,3],   [1,2,3]\n\n输出: true\n\n示例 2:\n\n输入:      1          1\n          /           \\\n         2             2\n\n        [1,2],     [1,null,2]\n\n输出: false\n\n\n示例 3:\n\n输入:       1         1\n          / \\       / \\\n         2   1     1   2\n\n        [1,2,1],   [1,1,2]\n\n输出: false\n\n\n# 通过代码\n/**\n * definition for a binary tree node.\n * public class treenode {\n *     int val;\n *     treenode left;\n *     treenode right;\n *     treenode(int x) { val = x; }\n * }\n */\nclass solution {\n    public boolean issametree(treenode p, treenode q) {\n         if (p==null && q==null){\n                return true;\n            }\n            if (p==null || q==null){\n                return false;\n            }\n            if (p.val==q.val){\n                return issametree(p.left,q.left) && issametree(p.right,q.right);\n            }\n            return false;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n# 官方题解\n# 方法一：递归\n直觉\n\n最简单的策略是使用递归。首先判断 p 和 q 是不是 none，然后判断它们的值是否相等。 若以上判断通过，则递归对子结点做同样操作。\n\n实现\n\n<,,, , ,>\n\nclass solution:\n    def issametree(self, p, q):\n        """\n        :type p: treenode\n        :type q: treenode\n        :rtype: bool\n        """    \n        # p and q are both none\n        if not p and not q:\n            return true\n        # one of p and q is none\n        if not q or not p:\n            return false\n        if p.val != q.val:\n            return false\n        return self.issametree(p.right, q.right) and \\\n               self.issametree(p.left, q.left)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n/**\n * definition for a binary tree node.\n * public class treenode {\n *     int val;\n *     treenode left;\n *     treenode right;\n *     treenode(int x) { val = x; }\n * }\n */\nclass solution {\n  public boolean issametree(treenode p, treenode q) {\n    // p and q are both null\n    if (p == null && q == null) return true;\n    // one of p and q is null\n    if (q == null || p == null) return false;\n    if (p.val != q.val) return false;\n    return issametree(p.right, q.right) &&\n            issametree(p.left, q.left);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n复杂度分析\n\n * 时间复杂度 : o(n)o(n)o(n)，其中 n 是树的结点数，因为每个结点都访问一次。\n   \n   \n * 空间复杂度 : 最优情况（完全平衡二叉树）时为 o(log⁡(n))o(\\log(n))o(log(n))，最坏情况下（完全不平衡二叉树）时为 o(n){o}(n)o(n)，用于维护递归栈。\n   \n   \n   \n   \n\n\n\n\n# 方法二：迭代\n直觉\n\n从根开始，每次迭代将当前结点从双向队列中弹出。然后，进行方法一中的判断：\n\n * p 和 q 不是 none,\n   \n   \n * p.val 等于 q.val,\n   \n   \n\n若以上均满足，则压入子结点。\n\n实现\n\nfrom collections import deque\nclass solution:\n    def issametree(self, p, q):\n        """\n        :type p: treenode\n        :type q: treenode\n        :rtype: bool\n        """    \n        def check(p, q):\n            # if both are none\n            if not p and not q:\n                return true\n            # one of p and q is none\n            if not q or not p:\n                return false\n            if p.val != q.val:\n                return false\n            return true\n        \n        deq = deque([(p, q),])\n        while deq:\n            p, q = deq.popleft()\n            if not check(p, q):\n                return false\n            \n            if p:\n                deq.append((p.left, q.left))\n                deq.append((p.right, q.right))\n                    \n        return true\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\nclass solution {\n  public boolean check(treenode p, treenode q) {\n    // p and q are null\n    if (p == null && q == null) return true;\n    // one of p and q is null\n    if (q == null || p == null) return false;\n    if (p.val != q.val) return false;\n    return true;\n  }\n\n  public boolean issametree(treenode p, treenode q) {\n    if (p == null && q == null) return true;\n    if (!check(p, q)) return false;\n\n    // init deques\n    arraydeque<treenode> deqp = new arraydeque<treenode>();\n    arraydeque<treenode> deqq = new arraydeque<treenode>();\n    deqp.addlast(p);\n    deqq.addlast(q);\n\n    while (!deqp.isempty()) {\n      p = deqp.removefirst();\n      q = deqq.removefirst();\n\n      if (!check(p, q)) return false;\n      if (p != null) {\n        // in java nulls are not allowed in deque\n        if (!check(p.left, q.left)) return false;\n        if (p.left != null) {\n          deqp.addlast(p.left);\n          deqq.addlast(q.left);\n        }\n        if (!check(p.right, q.right)) return false;\n        if (p.right != null) {\n          deqp.addlast(p.right);\n          deqq.addlast(q.right);\n        }\n      }\n    }\n    return true;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n复杂度分析\n\n * 时间复杂度 : o(n)o(n)o(n)，其中 n 是树的结点数，因为每个结点都访问一次。\n   \n   \n * 空间复杂度 : 最优情况（完全平衡二叉树）时为 o(log⁡(n))o(\\log(n))o(log(n))，最坏情况下（完全不平衡二叉树）时为 o(n){o}(n)o(n)，用于维护双向队列。\n   \n   \n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-09-06 14:41:47accepted [https://leetcode-cn.com//submissions/detail/6637175/]5 ms7.92%n/ajava# 统计信息\n通过次数提交次数ac比率5643610085756.0%'},{title:"88-合并两个有序数组(Merge Sorted Array)",frontmatter:{title:"88-合并两个有序数组(Merge Sorted Array)",date:"2018-05-14T00:00:00.000Z",categories:["简单"],tags:["数组<Array>","双指针<Two Pointers>"]},regularPath:"/views/%E7%AE%80%E5%8D%95/0088-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84.html",relativePath:"views/简单/0088-合并两个有序数组.md",key:"v-ccf835da",path:"/views/%E7%AE%80%E5%8D%95/0088-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84.html",headers:[{level:2,title:"中文题目",slug:"中文题目",charIndex:2},{level:2,title:"通过代码",slug:"通过代码",charIndex:248},{level:2,title:"官方题解",slug:"官方题解",charIndex:3023},{level:2,title:"提交历史",slug:"提交历史",charIndex:7699},{level:2,title:"统计信息",slug:"统计信息",charIndex:8120},{level:2,title:"相似题目",slug:"相似题目",charIndex:8155}],lastUpdated:"4/11/2021, 1:15:21 PM",headersStr:"中文题目 通过代码 官方题解 提交历史 统计信息 相似题目",content:'# 中文题目\n给定两个有序整数数组nums1 和 nums2，将 nums2 合并到nums1中，使得num1 成为一个有序数组。\n\n说明:\n\n * 初始化nums1 和 nums2 的元素数量分别为m 和 n。\n * 你可以假设nums1有足够的空间（空间大小大于或等于m + n）来保存 nums2 中的元素。\n\n示例:\n\n输入:\nnums1 = [1,2,3,0,0,0], m = 3\nnums2 = [2,5,6],       n = 3\n\n输出: [1,2,2,3,5,6]\n\n# 通过代码\nclass Solution {\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\n         int k=n+m-1;\n            int i=m-1;\n            int j=n-1;\n            while (i>-1||j>-1){\n                if (i==-1){\n                    nums1[k--]=nums2[j--];\n                    continue;\n                }\n                if (j==-1){\n                    nums1[k--]=nums1[i--];\n                    continue;\n                }\n                if (nums1[i]>nums2[j]){\n                    nums1[k--]=nums1[i--];\n                }else {\n                    nums1[k--]=nums2[j--];\n                }\n            }\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\nclass Solution {\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\n         int k=n+m-1;\n            int i=m-1;\n            int j=n-1;\n            while (i>-1||j>-1){\n                if (i==-1){\n                    nums1[k--]=nums2[j--];\n                    continue;\n                }\n                if (j==-1){\n                    nums1[k--]=nums1[i--];\n                    continue;\n                }\n                if (nums1[i]>nums2[j]){\n                    nums1[k--]=nums1[i--];\n                }else {\n                    nums1[k--]=nums2[j--];\n                }\n            }\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\nclass Solution {\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\n         int k=n+m-1;\n            int i=m-1;\n            int j=n-1;\n            while (i>-1||j>-1){\n                if (i==-1){\n                    nums1[k--]=nums2[j--];\n                    continue;\n                }\n                if (j==-1){\n                    nums1[k--]=nums1[i--];\n                    continue;\n                }\n                if (nums1[i]>nums2[j]){\n                    nums1[k--]=nums1[i--];\n                }else {\n                    nums1[k--]=nums2[j--];\n                }\n            }\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\nclass Solution {\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\n          int[] arr=new int[m+n];\n            int k=0;\n            int i=0;\n            int j=0;\n           while (i<m||j<n){\n               if (i==m){\n                   arr[k++]=nums2[j++];\n                   continue;\n               }\n               if (j==n){\n                   arr[k++]=nums1[i++];\n                   continue;\n               }\n               if (nums1[i]<nums2[j]){\n                   arr[k++]=nums1[i++];\n               }else {\n                   arr[k++]=nums2[j++];\n               }\n           }\n            for (int l = 0; l < arr.length; l++) {\n                nums1[l]=arr[l];\n            }\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n# 官方题解\n# 方法一 : 合并后排序\n直觉\n\n最朴素的解法就是将两个数组合并之后再排序。该算法只需要一行(Java是2行)，时间复杂度较差，为O((n+m)log⁡(n+m))O((n + m)\\log(n + m))O((n+m)log(n+m))。这是由于这种方法没有利用两个数组本身已经有序这一点。\n\n实现\n\nclass Solution {\n  public void merge(int[] nums1, int m, int[] nums2, int n) {\n    System.arraycopy(nums2, 0, nums1, m, n);\n    Arrays.sort(nums1);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\nclass Solution(object):\n    def merge(self, nums1, m, nums2, n):\n        """\n        :type nums1: List[int]\n        :type m: int\n        :type nums2: List[int]\n        :type n: int\n        :rtype: void Do not return anything, modify nums1 in-place instead.\n        """\n        nums1[:] = sorted(nums1[:m] + nums2)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n复杂度分析\n\n * 时间复杂度 : O((n+m)log⁡(n+m))O((n + m)\\log(n + m))O((n+m)log(n+m))。\n * 空间复杂度 : O(1)O(1)O(1)。\n   \n   \n\n\n\n\n# 方法二 : 双指针 / 从前往后\n直觉\n\n一般而言，对于有序数组可以通过 双指针法 达到O(n+m)O(n + m)O(n+m)的时间复杂度。\n\n最直接的算法实现是将指针p1 置为 nums1的开头， p2为 nums2的开头，在每一步将最小值放入输出数组中。\n\n由于 nums1 是用于输出的数组，需要将nums1中的前m个元素放在其他地方，也就需要 O(m)O(m)O(m) 的空间复杂度。\n\n{:align="center"}\n\n实现\n\nclass Solution {\n  public void merge(int[] nums1, int m, int[] nums2, int n) {\n    // Make a copy of nums1.\n    int [] nums1_copy = new int[m];\n    System.arraycopy(nums1, 0, nums1_copy, 0, m);\n\n    // Two get pointers for nums1_copy and nums2.\n    int p1 = 0;\n    int p2 = 0;\n\n    // Set pointer for nums1\n    int p = 0;\n\n    // Compare elements from nums1_copy and nums2\n    // and add the smallest one into nums1.\n    while ((p1 < m) && (p2 < n))\n      nums1[p++] = (nums1_copy[p1] < nums2[p2]) ? nums1_copy[p1++] : nums2[p2++];\n\n    // if there are still elements to add\n    if (p1 < m)\n      System.arraycopy(nums1_copy, p1, nums1, p1 + p2, m + n - p1 - p2);\n    if (p2 < n)\n      System.arraycopy(nums2, p2, nums1, p1 + p2, m + n - p1 - p2);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\nclass Solution(object):\n    def merge(self, nums1, m, nums2, n):\n        """\n        :type nums1: List[int]\n        :type m: int\n        :type nums2: List[int]\n        :type n: int\n        :rtype: void Do not return anything, modify nums1 in-place instead.\n        """\n        # Make a copy of nums1.\n        nums1_copy = nums1[:m] \n        nums1[:] = []\n\n        # Two get pointers for nums1_copy and nums2.\n        p1 = 0 \n        p2 = 0\n        \n        # Compare elements from nums1_copy and nums2\n        # and add the smallest one into nums1.\n        while p1 < m and p2 < n: \n            if nums1_copy[p1] < nums2[p2]: \n                nums1.append(nums1_copy[p1])\n                p1 += 1\n            else:\n                nums1.append(nums2[p2])\n                p2 += 1\n\n        # if there are still elements to add\n        if p1 < m: \n            nums1[p1 + p2:] = nums1_copy[p1:]\n        if p2 < n:\n            nums1[p1 + p2:] = nums2[p2:]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n复杂度分析\n\n * 时间复杂度 : O(n+m)O(n + m)O(n+m)。\n * 空间复杂度 : O(m)O(m)O(m)。\n   \n   \n\n\n\n\n# 方法三 : 双指针 / 从后往前\n直觉\n\n方法二已经取得了最优的时间复杂度O(n+m)O(n + m)O(n+m)，但需要使用额外空间。这是由于在从头改变nums1的值时，需要把nums1中的元素存放在其他位置。\n\n> 如果我们从结尾开始改写 nums1 的值又会如何呢？这里没有信息，因此不需要额外空间。\n\n\n这里的指针 p 用于追踪添加元素的位置。\n\n\n\n<,,,,,>\n\n实现\n\nclass Solution {\n  public void merge(int[] nums1, int m, int[] nums2, int n) {\n    // two get pointers for nums1 and nums2\n    int p1 = m - 1;\n    int p2 = n - 1;\n    // set pointer for nums1\n    int p = m + n - 1;\n\n    // while there are still elements to compare\n    while ((p1 >= 0) && (p2 >= 0))\n      // compare two elements from nums1 and nums2 \n      // and add the largest one in nums1 \n      nums1[p--] = (nums1[p1] < nums2[p2]) ? nums2[p2--] : nums1[p1--];\n\n    // add missing elements from nums2\n    System.arraycopy(nums2, 0, nums1, 0, p2 + 1);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\nclass Solution(object):\n    def merge(self, nums1, m, nums2, n):\n        """\n        :type nums1: List[int]\n        :type m: int\n        :type nums2: List[int]\n        :type n: int\n        :rtype: void Do not return anything, modify nums1 in-place instead.\n        """\n        # two get pointers for nums1 and nums2\n        p1 = m - 1\n        p2 = n - 1\n        # set pointer for nums1\n        p = m + n - 1\n        \n        # while there are still elements to compare\n        while p1 >= 0 and p2 >= 0:\n            if nums1[p1] < nums2[p2]:\n                nums1[p] = nums2[p2]\n                p2 -= 1\n            else:\n                nums1[p] =  nums1[p1]\n                p1 -= 1\n            p -= 1\n        \n        # add missing elements from nums2\n        nums1[:p2 + 1] = nums2[:p2 + 1]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n复杂度分析\n\n * 时间复杂度 : O(n+m)O(n + m)O(n+m)。\n * 空间复杂度 : O(1)O(1)O(1)。\n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-05-14 23:13:25Accepted [https://leetcode-cn.com//submissions/detail/2275773/]4 ms6.08%N/Ajava2018-05-14 23:13:03Accepted [https://leetcode-cn.com//submissions/detail/2275758/]5 ms6.08%N/Ajava2018-05-14 23:12:46Accepted [https://leetcode-cn.com//submissions/detail/2275742/]5 ms6.08%N/Ajava2018-05-14 23:00:33Accepted [https://leetcode-cn.com//submissions/detail/2275202/]4 ms6.08%N/Ajava# 统计信息\n通过次数提交次数AC比率9987721608446.2%# 相似题目\n题目难度合并两个有序链表 [https://leetcode-cn.com/problems/merge-two-sorted-lists/]简单有序数组的平方 [https://leetcode-cn.com/problems/squares-of-a-sorted-array/]简单区间列表的交集 [https://leetcode-cn.com/problems/interval-list-intersections/]中等',contentLowercase:'# 中文题目\n给定两个有序整数数组nums1 和 nums2，将 nums2 合并到nums1中，使得num1 成为一个有序数组。\n\n说明:\n\n * 初始化nums1 和 nums2 的元素数量分别为m 和 n。\n * 你可以假设nums1有足够的空间（空间大小大于或等于m + n）来保存 nums2 中的元素。\n\n示例:\n\n输入:\nnums1 = [1,2,3,0,0,0], m = 3\nnums2 = [2,5,6],       n = 3\n\n输出: [1,2,2,3,5,6]\n\n# 通过代码\nclass solution {\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\n         int k=n+m-1;\n            int i=m-1;\n            int j=n-1;\n            while (i>-1||j>-1){\n                if (i==-1){\n                    nums1[k--]=nums2[j--];\n                    continue;\n                }\n                if (j==-1){\n                    nums1[k--]=nums1[i--];\n                    continue;\n                }\n                if (nums1[i]>nums2[j]){\n                    nums1[k--]=nums1[i--];\n                }else {\n                    nums1[k--]=nums2[j--];\n                }\n            }\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\nclass solution {\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\n         int k=n+m-1;\n            int i=m-1;\n            int j=n-1;\n            while (i>-1||j>-1){\n                if (i==-1){\n                    nums1[k--]=nums2[j--];\n                    continue;\n                }\n                if (j==-1){\n                    nums1[k--]=nums1[i--];\n                    continue;\n                }\n                if (nums1[i]>nums2[j]){\n                    nums1[k--]=nums1[i--];\n                }else {\n                    nums1[k--]=nums2[j--];\n                }\n            }\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\nclass solution {\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\n         int k=n+m-1;\n            int i=m-1;\n            int j=n-1;\n            while (i>-1||j>-1){\n                if (i==-1){\n                    nums1[k--]=nums2[j--];\n                    continue;\n                }\n                if (j==-1){\n                    nums1[k--]=nums1[i--];\n                    continue;\n                }\n                if (nums1[i]>nums2[j]){\n                    nums1[k--]=nums1[i--];\n                }else {\n                    nums1[k--]=nums2[j--];\n                }\n            }\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\nclass solution {\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\n          int[] arr=new int[m+n];\n            int k=0;\n            int i=0;\n            int j=0;\n           while (i<m||j<n){\n               if (i==m){\n                   arr[k++]=nums2[j++];\n                   continue;\n               }\n               if (j==n){\n                   arr[k++]=nums1[i++];\n                   continue;\n               }\n               if (nums1[i]<nums2[j]){\n                   arr[k++]=nums1[i++];\n               }else {\n                   arr[k++]=nums2[j++];\n               }\n           }\n            for (int l = 0; l < arr.length; l++) {\n                nums1[l]=arr[l];\n            }\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n# 官方题解\n# 方法一 : 合并后排序\n直觉\n\n最朴素的解法就是将两个数组合并之后再排序。该算法只需要一行(java是2行)，时间复杂度较差，为o((n+m)log⁡(n+m))o((n + m)\\log(n + m))o((n+m)log(n+m))。这是由于这种方法没有利用两个数组本身已经有序这一点。\n\n实现\n\nclass solution {\n  public void merge(int[] nums1, int m, int[] nums2, int n) {\n    system.arraycopy(nums2, 0, nums1, m, n);\n    arrays.sort(nums1);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\nclass solution(object):\n    def merge(self, nums1, m, nums2, n):\n        """\n        :type nums1: list[int]\n        :type m: int\n        :type nums2: list[int]\n        :type n: int\n        :rtype: void do not return anything, modify nums1 in-place instead.\n        """\n        nums1[:] = sorted(nums1[:m] + nums2)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n复杂度分析\n\n * 时间复杂度 : o((n+m)log⁡(n+m))o((n + m)\\log(n + m))o((n+m)log(n+m))。\n * 空间复杂度 : o(1)o(1)o(1)。\n   \n   \n\n\n\n\n# 方法二 : 双指针 / 从前往后\n直觉\n\n一般而言，对于有序数组可以通过 双指针法 达到o(n+m)o(n + m)o(n+m)的时间复杂度。\n\n最直接的算法实现是将指针p1 置为 nums1的开头， p2为 nums2的开头，在每一步将最小值放入输出数组中。\n\n由于 nums1 是用于输出的数组，需要将nums1中的前m个元素放在其他地方，也就需要 o(m)o(m)o(m) 的空间复杂度。\n\n{:align="center"}\n\n实现\n\nclass solution {\n  public void merge(int[] nums1, int m, int[] nums2, int n) {\n    // make a copy of nums1.\n    int [] nums1_copy = new int[m];\n    system.arraycopy(nums1, 0, nums1_copy, 0, m);\n\n    // two get pointers for nums1_copy and nums2.\n    int p1 = 0;\n    int p2 = 0;\n\n    // set pointer for nums1\n    int p = 0;\n\n    // compare elements from nums1_copy and nums2\n    // and add the smallest one into nums1.\n    while ((p1 < m) && (p2 < n))\n      nums1[p++] = (nums1_copy[p1] < nums2[p2]) ? nums1_copy[p1++] : nums2[p2++];\n\n    // if there are still elements to add\n    if (p1 < m)\n      system.arraycopy(nums1_copy, p1, nums1, p1 + p2, m + n - p1 - p2);\n    if (p2 < n)\n      system.arraycopy(nums2, p2, nums1, p1 + p2, m + n - p1 - p2);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\nclass solution(object):\n    def merge(self, nums1, m, nums2, n):\n        """\n        :type nums1: list[int]\n        :type m: int\n        :type nums2: list[int]\n        :type n: int\n        :rtype: void do not return anything, modify nums1 in-place instead.\n        """\n        # make a copy of nums1.\n        nums1_copy = nums1[:m] \n        nums1[:] = []\n\n        # two get pointers for nums1_copy and nums2.\n        p1 = 0 \n        p2 = 0\n        \n        # compare elements from nums1_copy and nums2\n        # and add the smallest one into nums1.\n        while p1 < m and p2 < n: \n            if nums1_copy[p1] < nums2[p2]: \n                nums1.append(nums1_copy[p1])\n                p1 += 1\n            else:\n                nums1.append(nums2[p2])\n                p2 += 1\n\n        # if there are still elements to add\n        if p1 < m: \n            nums1[p1 + p2:] = nums1_copy[p1:]\n        if p2 < n:\n            nums1[p1 + p2:] = nums2[p2:]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n复杂度分析\n\n * 时间复杂度 : o(n+m)o(n + m)o(n+m)。\n * 空间复杂度 : o(m)o(m)o(m)。\n   \n   \n\n\n\n\n# 方法三 : 双指针 / 从后往前\n直觉\n\n方法二已经取得了最优的时间复杂度o(n+m)o(n + m)o(n+m)，但需要使用额外空间。这是由于在从头改变nums1的值时，需要把nums1中的元素存放在其他位置。\n\n> 如果我们从结尾开始改写 nums1 的值又会如何呢？这里没有信息，因此不需要额外空间。\n\n\n这里的指针 p 用于追踪添加元素的位置。\n\n\n\n<,,,,,>\n\n实现\n\nclass solution {\n  public void merge(int[] nums1, int m, int[] nums2, int n) {\n    // two get pointers for nums1 and nums2\n    int p1 = m - 1;\n    int p2 = n - 1;\n    // set pointer for nums1\n    int p = m + n - 1;\n\n    // while there are still elements to compare\n    while ((p1 >= 0) && (p2 >= 0))\n      // compare two elements from nums1 and nums2 \n      // and add the largest one in nums1 \n      nums1[p--] = (nums1[p1] < nums2[p2]) ? nums2[p2--] : nums1[p1--];\n\n    // add missing elements from nums2\n    system.arraycopy(nums2, 0, nums1, 0, p2 + 1);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\nclass solution(object):\n    def merge(self, nums1, m, nums2, n):\n        """\n        :type nums1: list[int]\n        :type m: int\n        :type nums2: list[int]\n        :type n: int\n        :rtype: void do not return anything, modify nums1 in-place instead.\n        """\n        # two get pointers for nums1 and nums2\n        p1 = m - 1\n        p2 = n - 1\n        # set pointer for nums1\n        p = m + n - 1\n        \n        # while there are still elements to compare\n        while p1 >= 0 and p2 >= 0:\n            if nums1[p1] < nums2[p2]:\n                nums1[p] = nums2[p2]\n                p2 -= 1\n            else:\n                nums1[p] =  nums1[p1]\n                p1 -= 1\n            p -= 1\n        \n        # add missing elements from nums2\n        nums1[:p2 + 1] = nums2[:p2 + 1]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n复杂度分析\n\n * 时间复杂度 : o(n+m)o(n + m)o(n+m)。\n * 空间复杂度 : o(1)o(1)o(1)。\n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-05-14 23:13:25accepted [https://leetcode-cn.com//submissions/detail/2275773/]4 ms6.08%n/ajava2018-05-14 23:13:03accepted [https://leetcode-cn.com//submissions/detail/2275758/]5 ms6.08%n/ajava2018-05-14 23:12:46accepted [https://leetcode-cn.com//submissions/detail/2275742/]5 ms6.08%n/ajava2018-05-14 23:00:33accepted [https://leetcode-cn.com//submissions/detail/2275202/]4 ms6.08%n/ajava# 统计信息\n通过次数提交次数ac比率9987721608446.2%# 相似题目\n题目难度合并两个有序链表 [https://leetcode-cn.com/problems/merge-two-sorted-lists/]简单有序数组的平方 [https://leetcode-cn.com/problems/squares-of-a-sorted-array/]简单区间列表的交集 [https://leetcode-cn.com/problems/interval-list-intersections/]中等'},{title:"101-对称二叉树(Symmetric Tree)",frontmatter:{title:"101-对称二叉树(Symmetric Tree)",date:"2018-09-07T00:00:00.000Z",categories:["简单"],tags:["树<Tree>","深度优先搜索<Depth-first Search>","广度优先搜索<Breadth-first Search>"]},regularPath:"/views/%E7%AE%80%E5%8D%95/0101-%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91.html",relativePath:"views/简单/0101-对称二叉树.md",key:"v-cb8dcbd0",path:"/views/%E7%AE%80%E5%8D%95/0101-%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91.html",headers:[{level:2,title:"中文题目",slug:"中文题目",charIndex:2},{level:2,title:"通过代码",slug:"通过代码",charIndex:218},{level:2,title:"官方题解",slug:"官方题解",charIndex:975},{level:2,title:"提交历史",slug:"提交历史",charIndex:2715},{level:2,title:"统计信息",slug:"统计信息",charIndex:2844}],lastUpdated:"4/11/2021, 1:15:21 PM",headersStr:"中文题目 通过代码 官方题解 提交历史 统计信息",content:'# 中文题目\n给定一个二叉树，检查它是否是镜像对称的。\n\n例如，二叉树[1,2,2,3,4,4,3] 是对称的。\n\n    1\n   / \\\n  2   2\n / \\ / \\\n3  4 4  3\n\n\n但是下面这个[1,2,2,null,3,null,3] 则不是镜像对称的:\n\n    1\n   / \\\n  2   2\n   \\   \\\n   3    3\n\n\n说明:\n\n如果你可以运用递归和迭代两种方法解决这个问题，会很加分。\n\n# 通过代码\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n        public boolean isSymmetric(TreeNode root) {\n            return root==null || isSymmetricHelp(root.left,root.right);\n        }\n\n        private boolean isSymmetricHelp(TreeNode left, TreeNode right) {\n            if (left==null || right==null){\n                return left==right;\n            }\n            if (left.val!=right.val){\n                return false;\n            }\n            return isSymmetricHelp(left.left,right.right) && isSymmetricHelp(left.right,right.left);\n        }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n# 官方题解\n# 方法：递归\n如果一个树的左子树与右子树镜像对称，那么这个树是对称的。\n\n{:width="200px"} {:align="center"}\n\n因此，该问题可以转化为：两个树在什么情况下互为镜像？\n\n如果同时满足下面的条件，两个树互为镜像：\n\n 1. 它们的两个根结点具有相同的值。\n 2. 每个树的右子树都与另一个树的左子树镜像对称。\n\n{:width="400px"} {:align="center"}\n\n就像人站在镜子前审视自己那样。镜中的反射与现实中的人具有相同的头部，但反射的右臂对应于人的左臂，反之亦然。\n\n上面的解释可以很自然地转换为一个递归函数，如下所示：\n\npublic boolean isSymmetric(TreeNode root) {\n    return isMirror(root, root);\n}\n\npublic boolean isMirror(TreeNode t1, TreeNode t2) {\n    if (t1 == null && t2 == null) return true;\n    if (t1 == null || t2 == null) return false;\n    return (t1.val == t2.val)\n        && isMirror(t1.right, t2.left)\n        && isMirror(t1.left, t2.right);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n复杂度分析\n\n * 时间复杂度：O(n)O(n)O(n)，因为我们遍历整个输入树一次，所以总的运行时间为 O(n)O(n)O(n)，其中 nnn 是树中结点的总数。\n * 空间复杂度：递归调用的次数受树的高度限制。在最糟糕情况下，树是线性的，其高度为 O(n)O(n)O(n)。因此，在最糟糕的情况下，由栈上的递归调用造成的空间复杂度为 O(n)O(n)O(n)。\n\n\n\n\n# 方法二：迭代\n除了递归的方法外，我们也可以利用队列进行迭代。队列中每两个连续的结点应该是相等的，而且它们的子树互为镜像。最初，队列中包含的是 root 以及 root。该算法的工作原理类似于 BFS，但存在一些关键差异。每次提取两个结点并比较它们的值。然后，将两个结点的左右子结点按相反的顺序插入队列中。当队列为空时，或者我们检测到树不对称（即从队列中取出两个不相等的连续结点）时，该算法结束。\n\npublic boolean isSymmetric(TreeNode root) {\n    Queue<TreeNode> q = new LinkedList<>();\n    q.add(root);\n    q.add(root);\n    while (!q.isEmpty()) {\n        TreeNode t1 = q.poll();\n        TreeNode t2 = q.poll();\n        if (t1 == null && t2 == null) continue;\n        if (t1 == null || t2 == null) return false;\n        if (t1.val != t2.val) return false;\n        q.add(t1.left);\n        q.add(t2.right);\n        q.add(t1.right);\n        q.add(t2.left);\n    }\n    return true;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n复杂度分析\n\n * 时间复杂度：O(n)O(n)O(n)，因为我们遍历整个输入树一次，所以总的运行时间为 O(n)O(n)O(n)，其中 nnn 是树中结点的总数。\n * 空间复杂度：搜索队列需要额外的空间。在最糟糕情况下，我们不得不向队列中插入 O(n)O(n)O(n) 个结点。因此，空间复杂度为 O(n)O(n)O(n)。\n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-09-07 15:12:44Accepted [https://leetcode-cn.com//submissions/detail/6697930/]14 ms12.69%N/Ajava# 统计信息\n通过次数提交次数AC比率8521517203449.5%',contentLowercase:'# 中文题目\n给定一个二叉树，检查它是否是镜像对称的。\n\n例如，二叉树[1,2,2,3,4,4,3] 是对称的。\n\n    1\n   / \\\n  2   2\n / \\ / \\\n3  4 4  3\n\n\n但是下面这个[1,2,2,null,3,null,3] 则不是镜像对称的:\n\n    1\n   / \\\n  2   2\n   \\   \\\n   3    3\n\n\n说明:\n\n如果你可以运用递归和迭代两种方法解决这个问题，会很加分。\n\n# 通过代码\n/**\n * definition for a binary tree node.\n * public class treenode {\n *     int val;\n *     treenode left;\n *     treenode right;\n *     treenode(int x) { val = x; }\n * }\n */\nclass solution {\n        public boolean issymmetric(treenode root) {\n            return root==null || issymmetrichelp(root.left,root.right);\n        }\n\n        private boolean issymmetrichelp(treenode left, treenode right) {\n            if (left==null || right==null){\n                return left==right;\n            }\n            if (left.val!=right.val){\n                return false;\n            }\n            return issymmetrichelp(left.left,right.right) && issymmetrichelp(left.right,right.left);\n        }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n# 官方题解\n# 方法：递归\n如果一个树的左子树与右子树镜像对称，那么这个树是对称的。\n\n{:width="200px"} {:align="center"}\n\n因此，该问题可以转化为：两个树在什么情况下互为镜像？\n\n如果同时满足下面的条件，两个树互为镜像：\n\n 1. 它们的两个根结点具有相同的值。\n 2. 每个树的右子树都与另一个树的左子树镜像对称。\n\n{:width="400px"} {:align="center"}\n\n就像人站在镜子前审视自己那样。镜中的反射与现实中的人具有相同的头部，但反射的右臂对应于人的左臂，反之亦然。\n\n上面的解释可以很自然地转换为一个递归函数，如下所示：\n\npublic boolean issymmetric(treenode root) {\n    return ismirror(root, root);\n}\n\npublic boolean ismirror(treenode t1, treenode t2) {\n    if (t1 == null && t2 == null) return true;\n    if (t1 == null || t2 == null) return false;\n    return (t1.val == t2.val)\n        && ismirror(t1.right, t2.left)\n        && ismirror(t1.left, t2.right);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n复杂度分析\n\n * 时间复杂度：o(n)o(n)o(n)，因为我们遍历整个输入树一次，所以总的运行时间为 o(n)o(n)o(n)，其中 nnn 是树中结点的总数。\n * 空间复杂度：递归调用的次数受树的高度限制。在最糟糕情况下，树是线性的，其高度为 o(n)o(n)o(n)。因此，在最糟糕的情况下，由栈上的递归调用造成的空间复杂度为 o(n)o(n)o(n)。\n\n\n\n\n# 方法二：迭代\n除了递归的方法外，我们也可以利用队列进行迭代。队列中每两个连续的结点应该是相等的，而且它们的子树互为镜像。最初，队列中包含的是 root 以及 root。该算法的工作原理类似于 bfs，但存在一些关键差异。每次提取两个结点并比较它们的值。然后，将两个结点的左右子结点按相反的顺序插入队列中。当队列为空时，或者我们检测到树不对称（即从队列中取出两个不相等的连续结点）时，该算法结束。\n\npublic boolean issymmetric(treenode root) {\n    queue<treenode> q = new linkedlist<>();\n    q.add(root);\n    q.add(root);\n    while (!q.isempty()) {\n        treenode t1 = q.poll();\n        treenode t2 = q.poll();\n        if (t1 == null && t2 == null) continue;\n        if (t1 == null || t2 == null) return false;\n        if (t1.val != t2.val) return false;\n        q.add(t1.left);\n        q.add(t2.right);\n        q.add(t1.right);\n        q.add(t2.left);\n    }\n    return true;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n复杂度分析\n\n * 时间复杂度：o(n)o(n)o(n)，因为我们遍历整个输入树一次，所以总的运行时间为 o(n)o(n)o(n)，其中 nnn 是树中结点的总数。\n * 空间复杂度：搜索队列需要额外的空间。在最糟糕情况下，我们不得不向队列中插入 o(n)o(n)o(n) 个结点。因此，空间复杂度为 o(n)o(n)o(n)。\n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-09-07 15:12:44accepted [https://leetcode-cn.com//submissions/detail/6697930/]14 ms12.69%n/ajava# 统计信息\n通过次数提交次数ac比率8521517203449.5%'},{title:"107-二叉树的层次遍历 II(Binary Tree Level Order Traversal II)",frontmatter:{title:"107-二叉树的层次遍历 II(Binary Tree Level Order Traversal II)",date:"2018-09-05T00:00:00.000Z",categories:["简单"],tags:["树<Tree>","广度优先搜索<Breadth-first Search>"]},regularPath:"/views/%E7%AE%80%E5%8D%95/0107-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86%20II.html",relativePath:"views/简单/0107-二叉树的层次遍历 II.md",key:"v-1f930831",path:"/views/%E7%AE%80%E5%8D%95/0107-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86%20II.html",headers:[{level:2,title:"中文题目",slug:"中文题目",charIndex:2},{level:2,title:"通过代码",slug:"通过代码",charIndex:191},{level:2,title:"高赞题解",slug:"高赞题解",charIndex:1578},{level:2,title:"提交历史",slug:"提交历史",charIndex:2775},{level:2,title:"统计信息",slug:"统计信息",charIndex:2902},{level:2,title:"相似题目",slug:"相似题目",charIndex:2936}],lastUpdated:"4/11/2021, 1:15:21 PM",headersStr:"中文题目 通过代码 高赞题解 提交历史 统计信息 相似题目",content:"# 中文题目\n给定一个二叉树，返回其节点值自底向上的层次遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）\n\n例如：\n给定二叉树 [3,9,20,null,null,15,7],\n\n    3\n   / \\\n  9  20\n    /  \\\n   15   7\n\n\n返回其自底向上的层次遍历为：\n\n[\n  [15,7],\n  [9,20],\n  [3]\n]\n\n\n# 通过代码\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public List<List<Integer>> levelOrderBottom(TreeNode root) {\n        List<List<Integer>> lists=new LinkedList<List<Integer>>();\n            if (root==null){\n                return lists;\n            }\n            LinkedList<TreeNode> queue=new LinkedList<TreeNode>();\n            queue.offer(root);\n            Stack<List<Integer>> stack=new Stack<List<Integer>>();\n            while (!queue.isEmpty()){\n                int size=queue.size();\n                LinkedList<Integer> linkedList=new LinkedList<Integer>();\n                while (size--\x3e0){\n                    TreeNode node=queue.pollFirst();\n                    linkedList.addLast(node.val);\n                    if (node.left!=null){\n                        queue.offer(node.left);\n                    }\n                    if (node.right!=null){\n                        queue.offer(node.right);\n                    }\n                }\n                stack.push(linkedList);\n            }\n            while (!stack.isEmpty()){\n                lists.add(stack.pop());\n            }\n            return lists;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n# 高赞题解\nclass Solution:\n    def levelOrderBottom(self, root):\n        queue = []                                                  # 结果列表\n        cur = [root]                                                # 接下来要循环的当前层节点，存的是节点\n        while cur:                                                  # 当前层存在结点时\n            cur_layer_val = []                                      # 初始化当前层结果列表为空，存的是val\n            next_layer_node = []                                    # 初始化下一层结点列表为空\n            for node in cur:                                        # 遍历当前层的每一个结点\n                if node:                                            # 如果该结点不为空，则进行记录\n                    cur_layer_val.append(node.val)                  # 将该结点的值加入当前层结果列表的末尾\n                    next_layer_node.extend([node.left, node.right]) # 将该结点的左右孩子结点加入到下一层结点列表\n            if cur_layer_val:                                       # 只要当前层结果列表不为空\n                queue.insert(0, cur_layer_val)                      # 则把当前层结果列表插入到队列首端\n            cur = next_layer_node                                   # 下一层的结点变成当前层，接着循环\n        return queue                                                # 返回结果队列\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-09-05 19:37:13Accepted [https://leetcode-cn.com//submissions/detail/6598915/]4 ms7.16%N/Ajava# 统计信息\n通过次数提交次数AC比率374245875863.7%# 相似题目\n题目难度二叉树的层次遍历 [https://leetcode-cn.com/problems/binary-tree-level-order-traversal/]中等二叉树的层平均值 [https://leetcode-cn.com/problems/average-of-levels-in-binary-tree/]简单",contentLowercase:"# 中文题目\n给定一个二叉树，返回其节点值自底向上的层次遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）\n\n例如：\n给定二叉树 [3,9,20,null,null,15,7],\n\n    3\n   / \\\n  9  20\n    /  \\\n   15   7\n\n\n返回其自底向上的层次遍历为：\n\n[\n  [15,7],\n  [9,20],\n  [3]\n]\n\n\n# 通过代码\n/**\n * definition for a binary tree node.\n * public class treenode {\n *     int val;\n *     treenode left;\n *     treenode right;\n *     treenode(int x) { val = x; }\n * }\n */\nclass solution {\n    public list<list<integer>> levelorderbottom(treenode root) {\n        list<list<integer>> lists=new linkedlist<list<integer>>();\n            if (root==null){\n                return lists;\n            }\n            linkedlist<treenode> queue=new linkedlist<treenode>();\n            queue.offer(root);\n            stack<list<integer>> stack=new stack<list<integer>>();\n            while (!queue.isempty()){\n                int size=queue.size();\n                linkedlist<integer> linkedlist=new linkedlist<integer>();\n                while (size--\x3e0){\n                    treenode node=queue.pollfirst();\n                    linkedlist.addlast(node.val);\n                    if (node.left!=null){\n                        queue.offer(node.left);\n                    }\n                    if (node.right!=null){\n                        queue.offer(node.right);\n                    }\n                }\n                stack.push(linkedlist);\n            }\n            while (!stack.isempty()){\n                lists.add(stack.pop());\n            }\n            return lists;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n# 高赞题解\nclass solution:\n    def levelorderbottom(self, root):\n        queue = []                                                  # 结果列表\n        cur = [root]                                                # 接下来要循环的当前层节点，存的是节点\n        while cur:                                                  # 当前层存在结点时\n            cur_layer_val = []                                      # 初始化当前层结果列表为空，存的是val\n            next_layer_node = []                                    # 初始化下一层结点列表为空\n            for node in cur:                                        # 遍历当前层的每一个结点\n                if node:                                            # 如果该结点不为空，则进行记录\n                    cur_layer_val.append(node.val)                  # 将该结点的值加入当前层结果列表的末尾\n                    next_layer_node.extend([node.left, node.right]) # 将该结点的左右孩子结点加入到下一层结点列表\n            if cur_layer_val:                                       # 只要当前层结果列表不为空\n                queue.insert(0, cur_layer_val)                      # 则把当前层结果列表插入到队列首端\n            cur = next_layer_node                                   # 下一层的结点变成当前层，接着循环\n        return queue                                                # 返回结果队列\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-09-05 19:37:13accepted [https://leetcode-cn.com//submissions/detail/6598915/]4 ms7.16%n/ajava# 统计信息\n通过次数提交次数ac比率374245875863.7%# 相似题目\n题目难度二叉树的层次遍历 [https://leetcode-cn.com/problems/binary-tree-level-order-traversal/]中等二叉树的层平均值 [https://leetcode-cn.com/problems/average-of-levels-in-binary-tree/]简单"},{title:"110-平衡二叉树(Balanced Binary Tree)",frontmatter:{title:"110-平衡二叉树(Balanced Binary Tree)",date:"2018-09-07T00:00:00.000Z",categories:["简单"],tags:["树<Tree>","深度优先搜索<Depth-first Search>"]},regularPath:"/views/%E7%AE%80%E5%8D%95/0110-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91.html",relativePath:"views/简单/0110-平衡二叉树.md",key:"v-8f131bfc",path:"/views/%E7%AE%80%E5%8D%95/0110-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91.html",headers:[{level:2,title:"中文题目",slug:"中文题目",charIndex:2},{level:2,title:"通过代码",slug:"通过代码",charIndex:290},{level:2,title:"高赞题解",slug:"高赞题解",charIndex:1064},{level:2,title:"提交历史",slug:"提交历史",charIndex:3298},{level:2,title:"统计信息",slug:"统计信息",charIndex:3425},{level:2,title:"相似题目",slug:"相似题目",charIndex:3459}],lastUpdated:"4/11/2021, 1:15:21 PM",headersStr:"中文题目 通过代码 高赞题解 提交历史 统计信息 相似题目",content:"# 中文题目\n给定一个二叉树，判断它是否是高度平衡的二叉树。\n\n本题中，一棵高度平衡二叉树定义为：\n\n> 一个二叉树每个节点的左右两个子树的高度差的绝对值不超过1。\n\n\n示例 1:\n\n给定二叉树 [3,9,20,null,null,15,7]\n\n    3\n   / \\\n  9  20\n    /  \\\n   15   7\n\n返回 true 。\n\n示例 2:\n\n给定二叉树 [1,2,2,3,3,null,null,4,4]\n\n       1\n      / \\\n     2   2\n    / \\\n   3   3\n  / \\\n 4   4\n\n\n返回false 。\n\n# 通过代码\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n           public boolean isBalanced(TreeNode root) {\n            if (root==null){\n                return true;\n            }\n            if (Math.abs(depth(root.left)-depth(root.right))>1){\n                return false;\n            }\n            return isBalanced(root.left) && isBalanced(root.right);\n        }\n\n        private int depth(TreeNode node) {\n            if (node==null){\n                return 0;\n            }\n            return Math.max(depth(node.left),depth(node.right))+1;\n        }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n# 高赞题解\n# 从底至顶（提前阻断法）\n * 对二叉树做深度优先遍历DFS，递归过程中： * 终止条件：当DFS越过叶子节点时，返回高度0；\n    * 返回值： * 从底至顶，返回以每个节点root为根节点的子树最大高度(左右子树中最大的高度值加1max(left,right) + 1)；\n       * 当我们发现有一例 左/右子树高度差 ＞ 1 的情况时，代表此树不是平衡树，返回-1；\n      \n      \n    * 当发现不是平衡树时，后面的高度计算都没有意义了，因此一路返回-1，避免后续多余计算。\n   \n   \n * 最差情况是对树做一遍完整DFS，时间复杂度为 O(N)。\n\nclass Solution:\n    def isBalanced(self, root: TreeNode) -> bool:\n        return self.depth(root) != -1\n\n    def depth(self, root):\n        if not root: return 0\n        left = self.depth(root.left)\n        if left == -1: return -1\n        right = self.depth(root.right)\n        if right == -1: return -1\n        return max(left, right) + 1 if abs(left - right) < 2 else -1\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\nclass Solution {\n    public boolean isBalanced(TreeNode root) {\n        return depth(root) != -1;\n    }\n\n    private int depth(TreeNode root) {\n        if (root == null) return 0;\n        int left = depth(root.left);\n        if(left == -1) return -1;\n        int right = depth(root.right);\n        if(right == -1) return -1;\n        return Math.abs(left - right) < 2 ? Math.max(left, right) + 1 : -1;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n# 从顶至底（暴力法）\n * 构造一个获取当前节点最大深度的方法 depth() ，通过比较左右子树最大高度差abs(self.depth(root.left) - self.depth(root.right))，来判断以此节点为根节点下是否是二叉平衡树；\n * 从顶至底DFS，以每个节点为根节点，递归判断是否是平衡二叉树： * 若所有根节点都满足平衡二叉树性质，则返回 True ；\n    * 若其中任何一个节点作为根节点时，不满足平衡二叉树性质，则返回False。\n   \n   \n * 本方法产生大量重复的节点访问和计算，最差情况下时间复杂度 O(N^2)。\n\nclass Solution:\n    def isBalanced(self, root: TreeNode) -> bool:\n        if not root: return True\n        return abs(self.depth(root.left) - self.depth(root.right)) <= 1 and \\\n            self.isBalanced(root.left) and self.isBalanced(root.right)\n\n    def depth(self, root):\n        if not root: return 0\n        return max(self.depth(root.left), self.depth(root.right)) + 1\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\nclass Solution {\n    public boolean isBalanced(TreeNode root) {\n        if (root == null) return true;\n        return Math.abs(depth(root.left) - depth(root.right)) <= 1 && isBalanced(root.left) && isBalanced(root.right);\n    }\n\n    private int depth(TreeNode root) {\n        if (root == null) return 0;\n        return Math.max(depth(root.left), depth(root.right)) + 1;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-09-07 15:58:55Accepted [https://leetcode-cn.com//submissions/detail/6702261/]3 ms5.91%N/Ajava# 统计信息\n通过次数提交次数AC比率445988995749.6%# 相似题目\n题目难度二叉树的最大深度 [https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/]简单",contentLowercase:"# 中文题目\n给定一个二叉树，判断它是否是高度平衡的二叉树。\n\n本题中，一棵高度平衡二叉树定义为：\n\n> 一个二叉树每个节点的左右两个子树的高度差的绝对值不超过1。\n\n\n示例 1:\n\n给定二叉树 [3,9,20,null,null,15,7]\n\n    3\n   / \\\n  9  20\n    /  \\\n   15   7\n\n返回 true 。\n\n示例 2:\n\n给定二叉树 [1,2,2,3,3,null,null,4,4]\n\n       1\n      / \\\n     2   2\n    / \\\n   3   3\n  / \\\n 4   4\n\n\n返回false 。\n\n# 通过代码\n/**\n * definition for a binary tree node.\n * public class treenode {\n *     int val;\n *     treenode left;\n *     treenode right;\n *     treenode(int x) { val = x; }\n * }\n */\nclass solution {\n           public boolean isbalanced(treenode root) {\n            if (root==null){\n                return true;\n            }\n            if (math.abs(depth(root.left)-depth(root.right))>1){\n                return false;\n            }\n            return isbalanced(root.left) && isbalanced(root.right);\n        }\n\n        private int depth(treenode node) {\n            if (node==null){\n                return 0;\n            }\n            return math.max(depth(node.left),depth(node.right))+1;\n        }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n# 高赞题解\n# 从底至顶（提前阻断法）\n * 对二叉树做深度优先遍历dfs，递归过程中： * 终止条件：当dfs越过叶子节点时，返回高度0；\n    * 返回值： * 从底至顶，返回以每个节点root为根节点的子树最大高度(左右子树中最大的高度值加1max(left,right) + 1)；\n       * 当我们发现有一例 左/右子树高度差 ＞ 1 的情况时，代表此树不是平衡树，返回-1；\n      \n      \n    * 当发现不是平衡树时，后面的高度计算都没有意义了，因此一路返回-1，避免后续多余计算。\n   \n   \n * 最差情况是对树做一遍完整dfs，时间复杂度为 o(n)。\n\nclass solution:\n    def isbalanced(self, root: treenode) -> bool:\n        return self.depth(root) != -1\n\n    def depth(self, root):\n        if not root: return 0\n        left = self.depth(root.left)\n        if left == -1: return -1\n        right = self.depth(root.right)\n        if right == -1: return -1\n        return max(left, right) + 1 if abs(left - right) < 2 else -1\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\nclass solution {\n    public boolean isbalanced(treenode root) {\n        return depth(root) != -1;\n    }\n\n    private int depth(treenode root) {\n        if (root == null) return 0;\n        int left = depth(root.left);\n        if(left == -1) return -1;\n        int right = depth(root.right);\n        if(right == -1) return -1;\n        return math.abs(left - right) < 2 ? math.max(left, right) + 1 : -1;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n# 从顶至底（暴力法）\n * 构造一个获取当前节点最大深度的方法 depth() ，通过比较左右子树最大高度差abs(self.depth(root.left) - self.depth(root.right))，来判断以此节点为根节点下是否是二叉平衡树；\n * 从顶至底dfs，以每个节点为根节点，递归判断是否是平衡二叉树： * 若所有根节点都满足平衡二叉树性质，则返回 true ；\n    * 若其中任何一个节点作为根节点时，不满足平衡二叉树性质，则返回false。\n   \n   \n * 本方法产生大量重复的节点访问和计算，最差情况下时间复杂度 o(n^2)。\n\nclass solution:\n    def isbalanced(self, root: treenode) -> bool:\n        if not root: return true\n        return abs(self.depth(root.left) - self.depth(root.right)) <= 1 and \\\n            self.isbalanced(root.left) and self.isbalanced(root.right)\n\n    def depth(self, root):\n        if not root: return 0\n        return max(self.depth(root.left), self.depth(root.right)) + 1\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\nclass solution {\n    public boolean isbalanced(treenode root) {\n        if (root == null) return true;\n        return math.abs(depth(root.left) - depth(root.right)) <= 1 && isbalanced(root.left) && isbalanced(root.right);\n    }\n\n    private int depth(treenode root) {\n        if (root == null) return 0;\n        return math.max(depth(root.left), depth(root.right)) + 1;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-09-07 15:58:55accepted [https://leetcode-cn.com//submissions/detail/6702261/]3 ms5.91%n/ajava# 统计信息\n通过次数提交次数ac比率445988995749.6%# 相似题目\n题目难度二叉树的最大深度 [https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/]简单"},{title:"104-二叉树的最大深度(Maximum Depth of Binary Tree)",frontmatter:{title:"104-二叉树的最大深度(Maximum Depth of Binary Tree)",date:"2018-05-09T00:00:00.000Z",categories:["简单"],tags:["树<Tree>","深度优先搜索<Depth-first Search>"]},regularPath:"/views/%E7%AE%80%E5%8D%95/0104-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6.html",relativePath:"views/简单/0104-二叉树的最大深度.md",key:"v-9e31a4c2",path:"/views/%E7%AE%80%E5%8D%95/0104-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6.html",headers:[{level:2,title:"中文题目",slug:"中文题目",charIndex:2},{level:2,title:"通过代码",slug:"通过代码",charIndex:168},{level:2,title:"官方题解",slug:"官方题解",charIndex:1582},{level:2,title:"提交历史",slug:"提交历史",charIndex:4496},{level:2,title:"统计信息",slug:"统计信息",charIndex:4722},{level:2,title:"相似题目",slug:"相似题目",charIndex:4758}],lastUpdated:"4/11/2021, 1:15:21 PM",headersStr:"中文题目 通过代码 官方题解 提交历史 统计信息 相似题目",content:'# 中文题目\n给定一个二叉树，找出其最大深度。\n\n二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。\n\n说明:叶子节点是指没有子节点的节点。\n\n示例：\n给定二叉树 [3,9,20,null,null,15,7]，\n\n    3\n   / \\\n  9  20\n    /  \\\n   15   7\n\n返回它的最大深度 3 。\n\n# 通过代码\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public int maxDepth(TreeNode root) {\n       if (root==null){\n                return 0;\n            }\n            LinkedList<TreeNode> queue=new LinkedList<>();\n            queue.addLast(root);\n            int depth=0;\n            while (!queue.isEmpty()){\n                depth++;\n                int size=queue.size();\n                while (size--\x3e0){\n                    TreeNode temp=queue.removeFirst();\n                    if (temp.left!=null){\n                        queue.addLast(temp.left);\n                    }\n                    if (temp.right!=null){\n                        queue.addLast(temp.right);\n                    }\n                }\n            }\n            return depth;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public int maxDepth(TreeNode root) {\n        if (root==null){\n                return 0;\n            }\n           return 1+Math.max(maxDepth(root.left),maxDepth(root.right));\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n# 官方题解\n树的定义\n\n首先，给出我们将要使用的树的结点 TreeNode 的定义。\n\n  /* Definition for a binary tree node. */\n  public class TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n\n    TreeNode(int x) {\n      val = x;\n    }\n  }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\nclass TreeNode(object):\n    """ Definition of a binary tree node."""\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 方法一：递归\n算法\n\n<,,,,,,,,,>\n\n直观的方法是通过递归来解决问题。在这里，我们演示了 DFS（深度优先搜索）策略的示例。\n\nclass Solution {\n  public int maxDepth(TreeNode root) {\n    if (root == null) {\n      return 0;\n    } else {\n      int left_height = maxDepth(root.left);\n      int right_height = maxDepth(root.right);\n      return java.lang.Math.max(left_height, right_height) + 1;\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\nclass Solution:\n    def maxDepth(self, root):\n        """\n        :type root: TreeNode\n        :rtype: int\n        """ \n        if root is None: \n            return 0 \n        else: \n            left_height = self.maxDepth(root.left) \n            right_height = self.maxDepth(root.right) \n            return max(left_height, right_height) + 1 \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n复杂度分析\n\n * 时间复杂度：我们每个结点只访问一次，因此时间复杂度为 O(N)O(N)O(N)， 其中 NNN 是结点的数量。\n * 空间复杂度：在最糟糕的情况下，树是完全不平衡的，例如每个结点只剩下左子结点，递归将会被调用 NNN 次（树的高度），因此保持调用栈的存储将是 O(N)O(N)O(N)。但在最好的情况下（树是完全平衡的），树的高度将是 log⁡(N)\\log(N)log(N)。因此，在这种情况下的空间复杂度将是 O(log⁡(N))O(\\log(N))O(log(N))。\n\n\n\n\n# 方法二：迭代\n我们还可以在栈的帮助下将上面的递归转换为迭代。\n\n> 我们的想法是使用 DFS 策略访问每个结点，同时在每次访问时更新最大深度。\n\n\n所以我们从包含根结点且相应深度为 1 的栈开始。然后我们继续迭代：将当前结点弹出栈并推入子结点。每一步都会更新深度。\n\nimport javafx.util.Pair;\nimport java.lang.Math;\n\nclass Solution {\n  public int maxDepth(TreeNode root) {\n    Queue<Pair<TreeNode, Integer>> stack = new LinkedList<>();\n    if (root != null) {\n      stack.add(new Pair(root, 1));\n    }\n\n    int depth = 0;\n    while (!stack.isEmpty()) {\n      Pair<TreeNode, Integer> current = stack.poll();\n      root = current.getKey();\n      int current_depth = current.getValue();\n      if (root != null) {\n        depth = Math.max(depth, current_depth);\n        stack.add(new Pair(root.left, current_depth + 1));\n        stack.add(new Pair(root.right, current_depth + 1));\n      }\n    }\n    return depth;\n  }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\nclass Solution:\n    def maxDepth(self, root):\n        """\n        :type root: TreeNode\n        :rtype: int\n        """ \n        stack = []\n        if root is not None:\n            stack.append((1, root))\n        \n        depth = 0\n        while stack != []:\n            current_depth, root = stack.pop()\n            if root is not None:\n                depth = max(depth, current_depth)\n                stack.append((current_depth + 1, root.left))\n                stack.append((current_depth + 1, root.right))\n        \n        return depth\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n复杂度分析\n\n * 时间复杂度：O(N)O(N)O(N)。\n * 空间复杂度：O(N)O(N)O(N)。\n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-05-09 23:10:16Accepted [https://leetcode-cn.com//submissions/detail/2121011/]2 ms9.76%N/Ajava2018-05-09 23:01:13Accepted [https://leetcode-cn.com//submissions/detail/2120572/]0 ms100.0%N/Ajava# 统计信息\n通过次数提交次数AC比率11339715774471.9%# 相似题目\n题目难度平衡二叉树 [https://leetcode-cn.com/problems/balanced-binary-tree/]简单二叉树的最小深度 [https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/]简单N叉树的最大深度 [https://leetcode-cn.com/problems/maximum-depth-of-n-ary-tree/]简单',contentLowercase:'# 中文题目\n给定一个二叉树，找出其最大深度。\n\n二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。\n\n说明:叶子节点是指没有子节点的节点。\n\n示例：\n给定二叉树 [3,9,20,null,null,15,7]，\n\n    3\n   / \\\n  9  20\n    /  \\\n   15   7\n\n返回它的最大深度 3 。\n\n# 通过代码\n/**\n * definition for a binary tree node.\n * public class treenode {\n *     int val;\n *     treenode left;\n *     treenode right;\n *     treenode(int x) { val = x; }\n * }\n */\nclass solution {\n    public int maxdepth(treenode root) {\n       if (root==null){\n                return 0;\n            }\n            linkedlist<treenode> queue=new linkedlist<>();\n            queue.addlast(root);\n            int depth=0;\n            while (!queue.isempty()){\n                depth++;\n                int size=queue.size();\n                while (size--\x3e0){\n                    treenode temp=queue.removefirst();\n                    if (temp.left!=null){\n                        queue.addlast(temp.left);\n                    }\n                    if (temp.right!=null){\n                        queue.addlast(temp.right);\n                    }\n                }\n            }\n            return depth;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n/**\n * definition for a binary tree node.\n * public class treenode {\n *     int val;\n *     treenode left;\n *     treenode right;\n *     treenode(int x) { val = x; }\n * }\n */\nclass solution {\n    public int maxdepth(treenode root) {\n        if (root==null){\n                return 0;\n            }\n           return 1+math.max(maxdepth(root.left),maxdepth(root.right));\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n# 官方题解\n树的定义\n\n首先，给出我们将要使用的树的结点 treenode 的定义。\n\n  /* definition for a binary tree node. */\n  public class treenode {\n    int val;\n    treenode left;\n    treenode right;\n\n    treenode(int x) {\n      val = x;\n    }\n  }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\nclass treenode(object):\n    """ definition of a binary tree node."""\n    def __init__(self, x):\n        self.val = x\n        self.left = none\n        self.right = none\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 方法一：递归\n算法\n\n<,,,,,,,,,>\n\n直观的方法是通过递归来解决问题。在这里，我们演示了 dfs（深度优先搜索）策略的示例。\n\nclass solution {\n  public int maxdepth(treenode root) {\n    if (root == null) {\n      return 0;\n    } else {\n      int left_height = maxdepth(root.left);\n      int right_height = maxdepth(root.right);\n      return java.lang.math.max(left_height, right_height) + 1;\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\nclass solution:\n    def maxdepth(self, root):\n        """\n        :type root: treenode\n        :rtype: int\n        """ \n        if root is none: \n            return 0 \n        else: \n            left_height = self.maxdepth(root.left) \n            right_height = self.maxdepth(root.right) \n            return max(left_height, right_height) + 1 \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n复杂度分析\n\n * 时间复杂度：我们每个结点只访问一次，因此时间复杂度为 o(n)o(n)o(n)， 其中 nnn 是结点的数量。\n * 空间复杂度：在最糟糕的情况下，树是完全不平衡的，例如每个结点只剩下左子结点，递归将会被调用 nnn 次（树的高度），因此保持调用栈的存储将是 o(n)o(n)o(n)。但在最好的情况下（树是完全平衡的），树的高度将是 log⁡(n)\\log(n)log(n)。因此，在这种情况下的空间复杂度将是 o(log⁡(n))o(\\log(n))o(log(n))。\n\n\n\n\n# 方法二：迭代\n我们还可以在栈的帮助下将上面的递归转换为迭代。\n\n> 我们的想法是使用 dfs 策略访问每个结点，同时在每次访问时更新最大深度。\n\n\n所以我们从包含根结点且相应深度为 1 的栈开始。然后我们继续迭代：将当前结点弹出栈并推入子结点。每一步都会更新深度。\n\nimport javafx.util.pair;\nimport java.lang.math;\n\nclass solution {\n  public int maxdepth(treenode root) {\n    queue<pair<treenode, integer>> stack = new linkedlist<>();\n    if (root != null) {\n      stack.add(new pair(root, 1));\n    }\n\n    int depth = 0;\n    while (!stack.isempty()) {\n      pair<treenode, integer> current = stack.poll();\n      root = current.getkey();\n      int current_depth = current.getvalue();\n      if (root != null) {\n        depth = math.max(depth, current_depth);\n        stack.add(new pair(root.left, current_depth + 1));\n        stack.add(new pair(root.right, current_depth + 1));\n      }\n    }\n    return depth;\n  }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\nclass solution:\n    def maxdepth(self, root):\n        """\n        :type root: treenode\n        :rtype: int\n        """ \n        stack = []\n        if root is not none:\n            stack.append((1, root))\n        \n        depth = 0\n        while stack != []:\n            current_depth, root = stack.pop()\n            if root is not none:\n                depth = max(depth, current_depth)\n                stack.append((current_depth + 1, root.left))\n                stack.append((current_depth + 1, root.right))\n        \n        return depth\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n复杂度分析\n\n * 时间复杂度：o(n)o(n)o(n)。\n * 空间复杂度：o(n)o(n)o(n)。\n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-05-09 23:10:16accepted [https://leetcode-cn.com//submissions/detail/2121011/]2 ms9.76%n/ajava2018-05-09 23:01:13accepted [https://leetcode-cn.com//submissions/detail/2120572/]0 ms100.0%n/ajava# 统计信息\n通过次数提交次数ac比率11339715774471.9%# 相似题目\n题目难度平衡二叉树 [https://leetcode-cn.com/problems/balanced-binary-tree/]简单二叉树的最小深度 [https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/]简单n叉树的最大深度 [https://leetcode-cn.com/problems/maximum-depth-of-n-ary-tree/]简单'},{title:"108-将有序数组转换为二叉搜索树(Convert Sorted Array to Binary Search Tree)",frontmatter:{title:"108-将有序数组转换为二叉搜索树(Convert Sorted Array to Binary Search Tree)",date:"2018-05-11T00:00:00.000Z",categories:["简单"],tags:["树<Tree>","深度优先搜索<Depth-first Search>"]},regularPath:"/views/%E7%AE%80%E5%8D%95/0108-%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.html",relativePath:"views/简单/0108-将有序数组转换为二叉搜索树.md",key:"v-41f9c21d",path:"/views/%E7%AE%80%E5%8D%95/0108-%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.html",headers:[{level:2,title:"中文题目",slug:"中文题目",charIndex:2},{level:2,title:"通过代码",slug:"通过代码",charIndex:214},{level:2,title:"高赞题解",slug:"高赞题解",charIndex:1064},{level:3,title:"解法一 递归",slug:"解法一-递归",charIndex:1071},{level:3,title:"解法二 栈 DFS",slug:"解法二-栈-dfs",charIndex:2182},{level:3,title:"解法三 队列 BFS",slug:"解法三-队列-bfs",charIndex:5807},{level:3,title:"扩展 求中点",slug:"扩展-求中点",charIndex:7172},{level:3,title:"总",slug:"总",charIndex:8029},{level:2,title:"提交历史",slug:"提交历史",charIndex:8207},{level:2,title:"统计信息",slug:"统计信息",charIndex:8334},{level:2,title:"相似题目",slug:"相似题目",charIndex:8368}],lastUpdated:"4/11/2021, 1:15:21 PM",headersStr:"中文题目 通过代码 高赞题解 解法一 递归 解法二 栈 DFS 解法三 队列 BFS 扩展 求中点 总 提交历史 统计信息 相似题目",content:"# 中文题目\n将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。\n\n本题中，一个高度平衡二叉树是指一个二叉树每个节点的左右两个子树的高度差的绝对值不超过 1。\n\n示例:\n\n给定有序数组: [-10,-3,0,5,9],\n\n一个可能的答案是：[0,-3,9,-10,null,5]，它可以表示下面这个高度平衡二叉搜索树：\n\n      0\n     / \\\n   -3   9\n   /   /\n -10  5\n\n\n# 通过代码\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public TreeNode sortedArrayToBST(int[] nums) {\n            if (nums.length==0){\n                return null;\n            }\n            TreeNode head=helper(nums,0,nums.length-1);\n            return head;\n        }\n\n        private TreeNode helper(int[] nums, int low, int high) {\n            if (low >high){\n                return null;\n            }\n            int mid=low+(high-low)/2;\n            TreeNode node=new TreeNode(nums[mid]);\n            node.left=helper(nums,low,mid-1);\n            node.right=helper(nums,mid+1,high);\n            return node;\n        }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n# 高赞题解\n# 解法一 递归\n如果做了 98 题 [https://leetcode.wang/leetCode-98-Validate-Binary-Search-Tree.html] 和 99 题 [https://leetcode.wang/leetcode-99-Recover-Binary-Search-Tree.html]，那么又看到这里的升序数组，然后应该会想到一个点，二叉搜索树的中序遍历刚好可以输出一个升序数组。\n\n所以题目给出的升序数组就是二叉搜索树的中序遍历。\n\n根据中序遍历还原一颗树，又想到了 105 题 [https://leetcode.wang/leetcode-105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal.html] 和 106 题 [https://leetcode.wang/leetcode-106-Construct-Binary-Tree-from-Inorder-and-Postorder-Traversal.html]，通过中序遍历加前序遍历或者中序遍历加后序遍历来还原一棵树。前序（后序）遍历的作用呢？提供根节点！然后根据根节点，就可以递归的生成左右子树。\n\n这里的话怎么知道根节点呢？平衡二叉树，既然要做到平衡，我们只要把根节点选为数组的中点即可。\n\n综上，和之前一样，找到了根节点，然后把数组一分为二，进入递归即可。注意这里的边界情况，包括左边界，不包括右边界。\n\npublic TreeNode sortedArrayToBST(int[] nums) {\n    return sortedArrayToBST(nums, 0, nums.length);\n}\n\nprivate TreeNode sortedArrayToBST(int[] nums, int start, int end) {\n    if (start == end) {\n        return null;\n    }\n    int mid = (start + end) >>> 1;\n    TreeNode root = new TreeNode(nums[mid]);\n    root.left = sortedArrayToBST(nums, start, mid);\n    root.right = sortedArrayToBST(nums, mid + 1, end);\n\n    return root;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n# 解法二 栈 DFS\n递归都可以转为迭代的形式。\n\n一部分递归算法，可以转成动态规划，实现空间换时间，例如 5题 [https://leetcode.windliang.cc/leetCode-5-Longest-Palindromic-Substring.html]，10题 [https://leetcode.windliang.cc/leetCode-10-Regular-Expression-Matching.html]，53题 [https://leetcode.windliang.cc/leetCode-53-Maximum-Subarray.html?h=%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92]，72题 [https://leetcode.wang/leetCode-72-Edit-Distance.html]，从自顶向下再向顶改为了自底向上。\n\n一部分递归算法，只是可以用栈去模仿递归的过程，对于时间或空间的复杂度没有任何好处，比如这道题，唯一好处可能就是能让我们更清楚的了解递归的过程吧。\n\n自己之前对于这种完全模仿递归思路写成迭代，一直也没写过，今天也就试试吧。\n\n思路的话，我们本质上就是在模拟递归，递归其实就是压栈出栈的过程，我们需要用一个栈去把递归的参数存起来。这里的话，就是函数的参数 start，end，以及内部定义的 root。为了方便，我们就定义一个类。\n\nclass MyTreeNode {\n    TreeNode root;\n    int start;\n    int end \n    MyTreeNode(TreeNode r, int s, int e) {\n        this.root = r;\n        this.start = s;\n        this.end = e;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n第一步，我们把根节点存起来。\n\nStack<MyTreeNode> rootStack = new Stack<>();\nint start = 0;\nint end = nums.length;\nint mid = (start + end) >>> 1;\nTreeNode root = new TreeNode(nums[mid]);\nTreeNode curRoot = root;\nrootStack.push(new MyTreeNode(root, start, end));\n\n\n1\n2\n3\n4\n5\n6\n7\n然后开始递归的过程，就是不停的生成左子树。因为要生成左子树，end - start 表示当前树的可用数字的个数，因为根节点已经用去 1 个了，所以为了生成左子树，个数肯定需要大于 1。\n\nwhile (end - start > 1) {\n    mid = (start + end) >>> 1; //当前根节点\n    end = mid;//左子树的结尾\n    mid = (start + end) >>> 1;//左子树的中点\n    curRoot.left = new TreeNode(nums[mid]);\n    curRoot = curRoot.left;\n    rootStack.push(new MyTreeNode(curRoot, start, end));\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n在递归中，返回 null 以后，开始生成右子树。这里的话，当 end - start <= 1 ，也就是无法生成左子树了，我们就可以出栈，来生成右子树。\n\nMyTreeNode myNode = rootStack.pop();\n//当前作为根节点的 start end 以及 mid\nstart = myNode.start;\nend = myNode.end;\nmid = (start + end) >>> 1;\nstart = mid + 1; //右子树的 start\ncurRoot = myNode.root; //当前根节点\nif (start < end) { //判断当前范围内是否有数\n    mid = (start + end) >>> 1; //右子树的 mid\n    curRoot.right = new TreeNode(nums[mid]);\n    curRoot = curRoot.right;\n    rootStack.push(new MyTreeNode(curRoot, start, end));\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n然后把上边几块内容组合起来就可以了。\n\nclass MyTreeNode {\n    TreeNode root;\n    int start;\n    int end;\n\n    MyTreeNode(TreeNode r, int s, int e) {\n        this.root = r;\n        this.start = s;\n        this.end = e;\n    }\n}\npublic TreeNode sortedArrayToBST(int[] nums) {\n    if (nums.length == 0) {\n        return null;\n    }\n    Stack<MyTreeNode> rootStack = new Stack<>();\n    int start = 0;\n    int end = nums.length;\n    int mid = (start + end) >>> 1;\n    TreeNode root = new TreeNode(nums[mid]);\n    TreeNode curRoot = root;\n    rootStack.push(new MyTreeNode(root, start, end));\n    while (end - start > 1 || !rootStack.isEmpty()) {\n        //考虑左子树\n        while (end - start > 1) {\n            mid = (start + end) >>> 1; //当前根节点\n            end = mid;//左子树的结尾\n            mid = (start + end) >>> 1;//左子树的中点\n            curRoot.left = new TreeNode(nums[mid]);\n            curRoot = curRoot.left;\n            rootStack.push(new MyTreeNode(curRoot, start, end));\n        }\n        //出栈考虑右子树\n        MyTreeNode myNode = rootStack.pop();\n        //当前作为根节点的 start end 以及 mid\n        start = myNode.start;\n        end = myNode.end;\n        mid = (start + end) >>> 1;\n        start = mid + 1; //右子树的 start\n        curRoot = myNode.root; //当前根节点\n        if (start < end) { //判断当前范围内是否有数\n            mid = (start + end) >>> 1; //右子树的 mid\n            curRoot.right = new TreeNode(nums[mid]);\n            curRoot = curRoot.right;\n            rootStack.push(new MyTreeNode(curRoot, start, end));\n        }\n\n    }\n\n    return root;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n# 解法三 队列 BFS\n参考 这里 [https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/discuss/35218/Java-Iterative-Solution]。 和递归的思路基本一样，不停的划分范围。\n\nclass MyTreeNode {\n    TreeNode root;\n    int start;\n    int end;\n\n    MyTreeNode(TreeNode r, int s, int e) {\n        this.root = r;\n        this.start = s;\n        this.end = e;\n    }\n}\npublic TreeNode sortedArrayToBST3(int[] nums) {\n    if (nums.length == 0) {\n        return null;\n    }\n    Queue<MyTreeNode> rootQueue = new LinkedList<>();\n    TreeNode root = new TreeNode(0);\n    rootQueue.offer(new MyTreeNode(root, 0, nums.length));\n    while (!rootQueue.isEmpty()) {\n        MyTreeNode myRoot = rootQueue.poll();\n        int start = myRoot.start;\n        int end = myRoot.end;\n        int mid = (start + end) >>> 1;\n        TreeNode curRoot = myRoot.root;\n        curRoot.val = nums[mid];\n        if (start < mid) {\n            curRoot.left = new TreeNode(0);\n            rootQueue.offer(new MyTreeNode(curRoot.left, start, mid));\n        }\n        if (mid + 1 < end) {\n            curRoot.right = new TreeNode(0);\n            rootQueue.offer(new MyTreeNode(curRoot.right, mid + 1, end));\n        }\n    }\n\n    return root;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n最巧妙的地方是它先生成 left 和 right 但不进行赋值，只是把范围传过去，然后出队的时候再进行赋值。这样最开始的根节点也无需单独考虑了。\n\n# 扩展 求中点\n前几天和同学发现个有趣的事情，分享一下。\n\n首先假设我们的变量都是 int 值。\n\n二分查找中我们需要根据 start 和 end 求中点，正常情况下加起来除以 2 即可。\n\nint mid = (start + end) / 2\n\n\n1\n但这样有一个缺点，我们知道int的最大值是 Integer.MAX_VALUE ，也就是2147483647。那么有一个问题，如果 start = 2147483645，end = = 2147483645，虽然 start 和 end都没有超出最大值，但是如果利用上边的公式，加起来的话就会造成溢出，从而导致mid计算错误。\n\n解决的一个方案就是利用数学上的技巧，我们可以加一个 start 再减一个 start 将公式变形。\n\n(start + end) / 2 = (start + end + start - start) / 2 = start + (end - start) / 2\n\n\n1\n这样的话，就解决了上边的问题。\n\n然后当时和同学看到jdk源码中，求mid的方法如下\n\nint mid = (start + end) >>> 1\n\n\n1\n它通过移位实现了除以 2，但。。。这样难道不会导致溢出吗？\n\n首先大家可以补一下 补码 [https://leetcode-cn.com/circle/article/bnmsCV/] 的知识。\n\n其实问题的关键就是这里了>>> ，我们知道还有一种右移是>>。区别在于>>为有符号右移，右移以后最高位保持原来的最高位。而>>>这个右移的话最高位补 0。\n\n所以这里其实利用到了整数的补码形式，最高位其实是符号位，所以当 start + end 溢出的时候，其实本质上只是符号位收到了进位，而>>>这个右移不仅可以把符号位右移，同时最高位只是补零，不会对数字的大小造成影响。\n\n但>>有符号右移就会出现问题了，事实上 JDK6 之前都用的>>，这个 BUG 在 java 里竟然隐藏了十年之久。\n\n# 总\n经过这么多的分析，大家估计体会到了递归的魅力了吧，简洁而优雅。另外的两种迭代的实现，可以让我们更清楚的了解递归到底发生了什么。关于求中点，大家以后就用>>>吧，比start + (end - start) / 2简洁不少，还能给别人科普一下补码的知识。\n\n之前自己在博客总结的，更多题解可以在原地址 https://leetcode.wang。\n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-05-11 23:26:15Accepted [https://leetcode-cn.com//submissions/detail/2189029/]1 ms42.7%N/Ajava# 统计信息\n通过次数提交次数AC比率442536456168.5%# 相似题目\n题目难度有序链表转换二叉搜索树 [https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/]中等",contentLowercase:"# 中文题目\n将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。\n\n本题中，一个高度平衡二叉树是指一个二叉树每个节点的左右两个子树的高度差的绝对值不超过 1。\n\n示例:\n\n给定有序数组: [-10,-3,0,5,9],\n\n一个可能的答案是：[0,-3,9,-10,null,5]，它可以表示下面这个高度平衡二叉搜索树：\n\n      0\n     / \\\n   -3   9\n   /   /\n -10  5\n\n\n# 通过代码\n/**\n * definition for a binary tree node.\n * public class treenode {\n *     int val;\n *     treenode left;\n *     treenode right;\n *     treenode(int x) { val = x; }\n * }\n */\nclass solution {\n    public treenode sortedarraytobst(int[] nums) {\n            if (nums.length==0){\n                return null;\n            }\n            treenode head=helper(nums,0,nums.length-1);\n            return head;\n        }\n\n        private treenode helper(int[] nums, int low, int high) {\n            if (low >high){\n                return null;\n            }\n            int mid=low+(high-low)/2;\n            treenode node=new treenode(nums[mid]);\n            node.left=helper(nums,low,mid-1);\n            node.right=helper(nums,mid+1,high);\n            return node;\n        }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n# 高赞题解\n# 解法一 递归\n如果做了 98 题 [https://leetcode.wang/leetcode-98-validate-binary-search-tree.html] 和 99 题 [https://leetcode.wang/leetcode-99-recover-binary-search-tree.html]，那么又看到这里的升序数组，然后应该会想到一个点，二叉搜索树的中序遍历刚好可以输出一个升序数组。\n\n所以题目给出的升序数组就是二叉搜索树的中序遍历。\n\n根据中序遍历还原一颗树，又想到了 105 题 [https://leetcode.wang/leetcode-105-construct-binary-tree-from-preorder-and-inorder-traversal.html] 和 106 题 [https://leetcode.wang/leetcode-106-construct-binary-tree-from-inorder-and-postorder-traversal.html]，通过中序遍历加前序遍历或者中序遍历加后序遍历来还原一棵树。前序（后序）遍历的作用呢？提供根节点！然后根据根节点，就可以递归的生成左右子树。\n\n这里的话怎么知道根节点呢？平衡二叉树，既然要做到平衡，我们只要把根节点选为数组的中点即可。\n\n综上，和之前一样，找到了根节点，然后把数组一分为二，进入递归即可。注意这里的边界情况，包括左边界，不包括右边界。\n\npublic treenode sortedarraytobst(int[] nums) {\n    return sortedarraytobst(nums, 0, nums.length);\n}\n\nprivate treenode sortedarraytobst(int[] nums, int start, int end) {\n    if (start == end) {\n        return null;\n    }\n    int mid = (start + end) >>> 1;\n    treenode root = new treenode(nums[mid]);\n    root.left = sortedarraytobst(nums, start, mid);\n    root.right = sortedarraytobst(nums, mid + 1, end);\n\n    return root;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n# 解法二 栈 dfs\n递归都可以转为迭代的形式。\n\n一部分递归算法，可以转成动态规划，实现空间换时间，例如 5题 [https://leetcode.windliang.cc/leetcode-5-longest-palindromic-substring.html]，10题 [https://leetcode.windliang.cc/leetcode-10-regular-expression-matching.html]，53题 [https://leetcode.windliang.cc/leetcode-53-maximum-subarray.html?h=%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92]，72题 [https://leetcode.wang/leetcode-72-edit-distance.html]，从自顶向下再向顶改为了自底向上。\n\n一部分递归算法，只是可以用栈去模仿递归的过程，对于时间或空间的复杂度没有任何好处，比如这道题，唯一好处可能就是能让我们更清楚的了解递归的过程吧。\n\n自己之前对于这种完全模仿递归思路写成迭代，一直也没写过，今天也就试试吧。\n\n思路的话，我们本质上就是在模拟递归，递归其实就是压栈出栈的过程，我们需要用一个栈去把递归的参数存起来。这里的话，就是函数的参数 start，end，以及内部定义的 root。为了方便，我们就定义一个类。\n\nclass mytreenode {\n    treenode root;\n    int start;\n    int end \n    mytreenode(treenode r, int s, int e) {\n        this.root = r;\n        this.start = s;\n        this.end = e;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n第一步，我们把根节点存起来。\n\nstack<mytreenode> rootstack = new stack<>();\nint start = 0;\nint end = nums.length;\nint mid = (start + end) >>> 1;\ntreenode root = new treenode(nums[mid]);\ntreenode curroot = root;\nrootstack.push(new mytreenode(root, start, end));\n\n\n1\n2\n3\n4\n5\n6\n7\n然后开始递归的过程，就是不停的生成左子树。因为要生成左子树，end - start 表示当前树的可用数字的个数，因为根节点已经用去 1 个了，所以为了生成左子树，个数肯定需要大于 1。\n\nwhile (end - start > 1) {\n    mid = (start + end) >>> 1; //当前根节点\n    end = mid;//左子树的结尾\n    mid = (start + end) >>> 1;//左子树的中点\n    curroot.left = new treenode(nums[mid]);\n    curroot = curroot.left;\n    rootstack.push(new mytreenode(curroot, start, end));\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n在递归中，返回 null 以后，开始生成右子树。这里的话，当 end - start <= 1 ，也就是无法生成左子树了，我们就可以出栈，来生成右子树。\n\nmytreenode mynode = rootstack.pop();\n//当前作为根节点的 start end 以及 mid\nstart = mynode.start;\nend = mynode.end;\nmid = (start + end) >>> 1;\nstart = mid + 1; //右子树的 start\ncurroot = mynode.root; //当前根节点\nif (start < end) { //判断当前范围内是否有数\n    mid = (start + end) >>> 1; //右子树的 mid\n    curroot.right = new treenode(nums[mid]);\n    curroot = curroot.right;\n    rootstack.push(new mytreenode(curroot, start, end));\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n然后把上边几块内容组合起来就可以了。\n\nclass mytreenode {\n    treenode root;\n    int start;\n    int end;\n\n    mytreenode(treenode r, int s, int e) {\n        this.root = r;\n        this.start = s;\n        this.end = e;\n    }\n}\npublic treenode sortedarraytobst(int[] nums) {\n    if (nums.length == 0) {\n        return null;\n    }\n    stack<mytreenode> rootstack = new stack<>();\n    int start = 0;\n    int end = nums.length;\n    int mid = (start + end) >>> 1;\n    treenode root = new treenode(nums[mid]);\n    treenode curroot = root;\n    rootstack.push(new mytreenode(root, start, end));\n    while (end - start > 1 || !rootstack.isempty()) {\n        //考虑左子树\n        while (end - start > 1) {\n            mid = (start + end) >>> 1; //当前根节点\n            end = mid;//左子树的结尾\n            mid = (start + end) >>> 1;//左子树的中点\n            curroot.left = new treenode(nums[mid]);\n            curroot = curroot.left;\n            rootstack.push(new mytreenode(curroot, start, end));\n        }\n        //出栈考虑右子树\n        mytreenode mynode = rootstack.pop();\n        //当前作为根节点的 start end 以及 mid\n        start = mynode.start;\n        end = mynode.end;\n        mid = (start + end) >>> 1;\n        start = mid + 1; //右子树的 start\n        curroot = mynode.root; //当前根节点\n        if (start < end) { //判断当前范围内是否有数\n            mid = (start + end) >>> 1; //右子树的 mid\n            curroot.right = new treenode(nums[mid]);\n            curroot = curroot.right;\n            rootstack.push(new mytreenode(curroot, start, end));\n        }\n\n    }\n\n    return root;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n# 解法三 队列 bfs\n参考 这里 [https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/discuss/35218/java-iterative-solution]。 和递归的思路基本一样，不停的划分范围。\n\nclass mytreenode {\n    treenode root;\n    int start;\n    int end;\n\n    mytreenode(treenode r, int s, int e) {\n        this.root = r;\n        this.start = s;\n        this.end = e;\n    }\n}\npublic treenode sortedarraytobst3(int[] nums) {\n    if (nums.length == 0) {\n        return null;\n    }\n    queue<mytreenode> rootqueue = new linkedlist<>();\n    treenode root = new treenode(0);\n    rootqueue.offer(new mytreenode(root, 0, nums.length));\n    while (!rootqueue.isempty()) {\n        mytreenode myroot = rootqueue.poll();\n        int start = myroot.start;\n        int end = myroot.end;\n        int mid = (start + end) >>> 1;\n        treenode curroot = myroot.root;\n        curroot.val = nums[mid];\n        if (start < mid) {\n            curroot.left = new treenode(0);\n            rootqueue.offer(new mytreenode(curroot.left, start, mid));\n        }\n        if (mid + 1 < end) {\n            curroot.right = new treenode(0);\n            rootqueue.offer(new mytreenode(curroot.right, mid + 1, end));\n        }\n    }\n\n    return root;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n最巧妙的地方是它先生成 left 和 right 但不进行赋值，只是把范围传过去，然后出队的时候再进行赋值。这样最开始的根节点也无需单独考虑了。\n\n# 扩展 求中点\n前几天和同学发现个有趣的事情，分享一下。\n\n首先假设我们的变量都是 int 值。\n\n二分查找中我们需要根据 start 和 end 求中点，正常情况下加起来除以 2 即可。\n\nint mid = (start + end) / 2\n\n\n1\n但这样有一个缺点，我们知道int的最大值是 integer.max_value ，也就是2147483647。那么有一个问题，如果 start = 2147483645，end = = 2147483645，虽然 start 和 end都没有超出最大值，但是如果利用上边的公式，加起来的话就会造成溢出，从而导致mid计算错误。\n\n解决的一个方案就是利用数学上的技巧，我们可以加一个 start 再减一个 start 将公式变形。\n\n(start + end) / 2 = (start + end + start - start) / 2 = start + (end - start) / 2\n\n\n1\n这样的话，就解决了上边的问题。\n\n然后当时和同学看到jdk源码中，求mid的方法如下\n\nint mid = (start + end) >>> 1\n\n\n1\n它通过移位实现了除以 2，但。。。这样难道不会导致溢出吗？\n\n首先大家可以补一下 补码 [https://leetcode-cn.com/circle/article/bnmscv/] 的知识。\n\n其实问题的关键就是这里了>>> ，我们知道还有一种右移是>>。区别在于>>为有符号右移，右移以后最高位保持原来的最高位。而>>>这个右移的话最高位补 0。\n\n所以这里其实利用到了整数的补码形式，最高位其实是符号位，所以当 start + end 溢出的时候，其实本质上只是符号位收到了进位，而>>>这个右移不仅可以把符号位右移，同时最高位只是补零，不会对数字的大小造成影响。\n\n但>>有符号右移就会出现问题了，事实上 jdk6 之前都用的>>，这个 bug 在 java 里竟然隐藏了十年之久。\n\n# 总\n经过这么多的分析，大家估计体会到了递归的魅力了吧，简洁而优雅。另外的两种迭代的实现，可以让我们更清楚的了解递归到底发生了什么。关于求中点，大家以后就用>>>吧，比start + (end - start) / 2简洁不少，还能给别人科普一下补码的知识。\n\n之前自己在博客总结的，更多题解可以在原地址 https://leetcode.wang。\n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-05-11 23:26:15accepted [https://leetcode-cn.com//submissions/detail/2189029/]1 ms42.7%n/ajava# 统计信息\n通过次数提交次数ac比率442536456168.5%# 相似题目\n题目难度有序链表转换二叉搜索树 [https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/]中等"},{title:"112-路径总和(Path Sum)",frontmatter:{title:"112-路径总和(Path Sum)",date:"2018-07-01T00:00:00.000Z",categories:["简单"],tags:["树<Tree>","深度优先搜索<Depth-first Search>"]},regularPath:"/views/%E7%AE%80%E5%8D%95/0112-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C.html",relativePath:"views/简单/0112-路径总和.md",key:"v-7727e773",path:"/views/%E7%AE%80%E5%8D%95/0112-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C.html",headers:[{level:2,title:"中文题目",slug:"中文题目",charIndex:2},{level:2,title:"通过代码",slug:"通过代码",charIndex:296},{level:2,title:"官方题解",slug:"官方题解",charIndex:984},{level:2,title:"提交历史",slug:"提交历史",charIndex:4435},{level:2,title:"统计信息",slug:"统计信息",charIndex:4563},{level:2,title:"相似题目",slug:"相似题目",charIndex:4597}],lastUpdated:"4/11/2021, 1:15:21 PM",headersStr:"中文题目 通过代码 官方题解 提交历史 统计信息 相似题目",content:'# 中文题目\n给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。\n\n说明:叶子节点是指没有子节点的节点。\n\n示例:\n给定如下二叉树，以及目标和 sum = 22，\n\n              5\n             / \\\n            4   8\n           /   / \\\n          11  13  4\n         /  \\      \\\n        7    2      1\n\n\n返回 true, 因为存在目标和为 22 的根节点到叶子节点的路径 5->4->11->2。\n\n# 通过代码\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public boolean hasPathSum(TreeNode root, int sum) {\n        if (root==null)\n                return false;\n            if (root.left==null && root.right==null)\n                return root.val==sum;\n            if (hasPathSum(root.left,sum-root.val)){\n                return true;\n            }\n            if (hasPathSum(root.right,sum-root.val)){\n                return true;\n            }\n            return false;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n# 官方题解\n# 二叉树定义\n首先，定义一下二叉树的结构 TreeNode。\n\n/* Definition for a binary tree node. */\npublic class TreeNode {\n  int val;\n  TreeNode left;\n  TreeNode right;\n\n  TreeNode(int x) {\n    val = x;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\nclass TreeNode(object):\n    """ Definition of a binary tree node."""\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\n\n1\n2\n3\n4\n5\n6\n# 方法 1：递归\n最直接的方法就是利用递归，遍历整棵树：如果当前节点不是叶子，对它的所有孩子节点，递归调用 hasPathSum 函数，其中 sum 值减去当前节点的权值；如果当前节点是叶子，检查 sum 值是否为 0，也就是是否找到了给定的目标和。\n\nclass Solution {\n  public boolean hasPathSum(TreeNode root, int sum) {\n    if (root == null)\n      return false;\n\n    sum -= root.val;\n    if ((root.left == null) && (root.right == null))\n      return (sum == 0);\n    return hasPathSum(root.left, sum) || hasPathSum(root.right, sum);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\nclass Solution:\n    def hasPathSum(self, root, sum):\n        """\n        :type root: TreeNode\n        :type sum: int\n        :rtype: bool\n        """\n        if not root:\n            return False\n\n        sum -= root.val\n        if not root.left and not root.right:  # if reach a leaf\n            return sum == 0\n        return self.hasPathSum(root.left, sum) or self.hasPathSum(root.right, sum)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n复杂度分析\n\n * 时间复杂度：我们访问每个节点一次，时间复杂度为 O(N)O(N)O(N) ，其中 NNN 是节点个数。\n * 空间复杂度：最坏情况下，整棵树是非平衡的，例如每个节点都只有一个孩子，递归会调用 NNN 次（树的高度），因此栈的空间开销是 O(N)O(N)O(N) 。但在最好情况下，树是完全平衡的，高度只有 log⁡(N)\\log(N)log(N)，因此在这种情况下空间复杂度只有 O(log⁡(N))O(\\log(N))O(log(N)) 。\n\n# 方法 2：迭代\n算法\n\n我们可以用栈将递归转成迭代的形式。深度优先搜索在除了最坏情况下都比广度优先搜索更快。最坏情况是指满足目标和的 root->leaf 路径是最后被考虑的，这种情况下深度优先搜索和广度优先搜索代价是相通的。\n\n> 利用深度优先策略访问每个节点，同时更新剩余的目标和。\n\n\n所以我们从包含根节点的栈开始模拟，剩余目标和为 sum - root.val。\n\n然后开始迭代：弹出当前元素，如果当前剩余目标和为 0 并且在叶子节点上返回 True；如果剩余和不为零并且还处在非叶子节点上，将当前节点的所有孩子以及对应的剩余和压入栈中。\n\n<,,,,,,,>\n\nclass Solution {\n  public boolean hasPathSum(TreeNode root, int sum) {\n    if (root == null)\n      return false;\n\n    LinkedList<TreeNode> node_stack = new LinkedList();\n    LinkedList<Integer> sum_stack = new LinkedList();\n    node_stack.add(root);\n    sum_stack.add(sum - root.val);\n\n    TreeNode node;\n    int curr_sum;\n    while ( !node_stack.isEmpty() ) {\n      node = node_stack.pollLast();\n      curr_sum = sum_stack.pollLast();\n      if ((node.right == null) && (node.left == null) && (curr_sum == 0))\n        return true;\n\n      if (node.right != null) {\n        node_stack.add(node.right);\n        sum_stack.add(curr_sum - node.right.val);\n      }\n      if (node.left != null) {\n        node_stack.add(node.left);\n        sum_stack.add(curr_sum - node.left.val);\n      }\n    }\n    return false;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\nclass Solution:\n    def hasPathSum(self, root, sum):\n        """\n        :type root: TreeNode\n        :type sum: int\n        :rtype: bool\n        """\n        if not root:\n            return False\n\n        de = [(root, sum - root.val), ]\n        while de:\n            node, curr_sum = de.pop()\n            if not node.left and not node.right and curr_sum == 0:  \n                return True\n            if node.right:\n                de.append((node.right, curr_sum - node.right.val))\n            if node.left:\n                de.append((node.left, curr_sum - node.left.val))\n        return False\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n复杂度分析\n\n * 时间复杂度：和递归方法相同是 O(N)O(N)O(N)。\n * 空间复杂度：当树不平衡的最坏情况下是 O(N)O(N)O(N) 。在最好情况（树是平衡的）下是 O(log⁡N)O(\\log N)O(logN)。\n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-07-01 18:06:34Accepted [https://leetcode-cn.com//submissions/detail/3659564/]2 ms11.04%N/Ajava# 统计信息\n通过次数提交次数AC比率460039453848.7%# 相似题目\n题目难度路径总和 II [https://leetcode-cn.com/problems/path-sum-ii/]中等二叉树中的最大路径和 [https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/]困难求根到叶子节点数字之和 [https://leetcode-cn.com/problems/sum-root-to-leaf-numbers/]中等路径总和 III [https://leetcode-cn.com/problems/path-sum-iii/]简单路径和 IV [https://leetcode-cn.com/problems/path-sum-iv/]中等',contentLowercase:'# 中文题目\n给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。\n\n说明:叶子节点是指没有子节点的节点。\n\n示例:\n给定如下二叉树，以及目标和 sum = 22，\n\n              5\n             / \\\n            4   8\n           /   / \\\n          11  13  4\n         /  \\      \\\n        7    2      1\n\n\n返回 true, 因为存在目标和为 22 的根节点到叶子节点的路径 5->4->11->2。\n\n# 通过代码\n/**\n * definition for a binary tree node.\n * public class treenode {\n *     int val;\n *     treenode left;\n *     treenode right;\n *     treenode(int x) { val = x; }\n * }\n */\nclass solution {\n    public boolean haspathsum(treenode root, int sum) {\n        if (root==null)\n                return false;\n            if (root.left==null && root.right==null)\n                return root.val==sum;\n            if (haspathsum(root.left,sum-root.val)){\n                return true;\n            }\n            if (haspathsum(root.right,sum-root.val)){\n                return true;\n            }\n            return false;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n# 官方题解\n# 二叉树定义\n首先，定义一下二叉树的结构 treenode。\n\n/* definition for a binary tree node. */\npublic class treenode {\n  int val;\n  treenode left;\n  treenode right;\n\n  treenode(int x) {\n    val = x;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\nclass treenode(object):\n    """ definition of a binary tree node."""\n    def __init__(self, x):\n        self.val = x\n        self.left = none\n        self.right = none\n\n\n1\n2\n3\n4\n5\n6\n# 方法 1：递归\n最直接的方法就是利用递归，遍历整棵树：如果当前节点不是叶子，对它的所有孩子节点，递归调用 haspathsum 函数，其中 sum 值减去当前节点的权值；如果当前节点是叶子，检查 sum 值是否为 0，也就是是否找到了给定的目标和。\n\nclass solution {\n  public boolean haspathsum(treenode root, int sum) {\n    if (root == null)\n      return false;\n\n    sum -= root.val;\n    if ((root.left == null) && (root.right == null))\n      return (sum == 0);\n    return haspathsum(root.left, sum) || haspathsum(root.right, sum);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\nclass solution:\n    def haspathsum(self, root, sum):\n        """\n        :type root: treenode\n        :type sum: int\n        :rtype: bool\n        """\n        if not root:\n            return false\n\n        sum -= root.val\n        if not root.left and not root.right:  # if reach a leaf\n            return sum == 0\n        return self.haspathsum(root.left, sum) or self.haspathsum(root.right, sum)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n复杂度分析\n\n * 时间复杂度：我们访问每个节点一次，时间复杂度为 o(n)o(n)o(n) ，其中 nnn 是节点个数。\n * 空间复杂度：最坏情况下，整棵树是非平衡的，例如每个节点都只有一个孩子，递归会调用 nnn 次（树的高度），因此栈的空间开销是 o(n)o(n)o(n) 。但在最好情况下，树是完全平衡的，高度只有 log⁡(n)\\log(n)log(n)，因此在这种情况下空间复杂度只有 o(log⁡(n))o(\\log(n))o(log(n)) 。\n\n# 方法 2：迭代\n算法\n\n我们可以用栈将递归转成迭代的形式。深度优先搜索在除了最坏情况下都比广度优先搜索更快。最坏情况是指满足目标和的 root->leaf 路径是最后被考虑的，这种情况下深度优先搜索和广度优先搜索代价是相通的。\n\n> 利用深度优先策略访问每个节点，同时更新剩余的目标和。\n\n\n所以我们从包含根节点的栈开始模拟，剩余目标和为 sum - root.val。\n\n然后开始迭代：弹出当前元素，如果当前剩余目标和为 0 并且在叶子节点上返回 true；如果剩余和不为零并且还处在非叶子节点上，将当前节点的所有孩子以及对应的剩余和压入栈中。\n\n<,,,,,,,>\n\nclass solution {\n  public boolean haspathsum(treenode root, int sum) {\n    if (root == null)\n      return false;\n\n    linkedlist<treenode> node_stack = new linkedlist();\n    linkedlist<integer> sum_stack = new linkedlist();\n    node_stack.add(root);\n    sum_stack.add(sum - root.val);\n\n    treenode node;\n    int curr_sum;\n    while ( !node_stack.isempty() ) {\n      node = node_stack.polllast();\n      curr_sum = sum_stack.polllast();\n      if ((node.right == null) && (node.left == null) && (curr_sum == 0))\n        return true;\n\n      if (node.right != null) {\n        node_stack.add(node.right);\n        sum_stack.add(curr_sum - node.right.val);\n      }\n      if (node.left != null) {\n        node_stack.add(node.left);\n        sum_stack.add(curr_sum - node.left.val);\n      }\n    }\n    return false;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\nclass solution:\n    def haspathsum(self, root, sum):\n        """\n        :type root: treenode\n        :type sum: int\n        :rtype: bool\n        """\n        if not root:\n            return false\n\n        de = [(root, sum - root.val), ]\n        while de:\n            node, curr_sum = de.pop()\n            if not node.left and not node.right and curr_sum == 0:  \n                return true\n            if node.right:\n                de.append((node.right, curr_sum - node.right.val))\n            if node.left:\n                de.append((node.left, curr_sum - node.left.val))\n        return false\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n复杂度分析\n\n * 时间复杂度：和递归方法相同是 o(n)o(n)o(n)。\n * 空间复杂度：当树不平衡的最坏情况下是 o(n)o(n)o(n) 。在最好情况（树是平衡的）下是 o(log⁡n)o(\\log n)o(logn)。\n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-07-01 18:06:34accepted [https://leetcode-cn.com//submissions/detail/3659564/]2 ms11.04%n/ajava# 统计信息\n通过次数提交次数ac比率460039453848.7%# 相似题目\n题目难度路径总和 ii [https://leetcode-cn.com/problems/path-sum-ii/]中等二叉树中的最大路径和 [https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/]困难求根到叶子节点数字之和 [https://leetcode-cn.com/problems/sum-root-to-leaf-numbers/]中等路径总和 iii [https://leetcode-cn.com/problems/path-sum-iii/]简单路径和 iv [https://leetcode-cn.com/problems/path-sum-iv/]中等'},{title:"118-杨辉三角(Pascal's Triangle)",frontmatter:{title:"118-杨辉三角(Pascal's Triangle)",date:"2019-12-30T00:00:00.000Z",categories:["简单"],tags:["数组<Array>"]},regularPath:"/views/%E7%AE%80%E5%8D%95/0118-%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92.html",relativePath:"views/简单/0118-杨辉三角.md",key:"v-9c035a4c",path:"/views/%E7%AE%80%E5%8D%95/0118-%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92.html",headers:[{level:2,title:"中文题目",slug:"中文题目",charIndex:2},{level:2,title:"通过代码",slug:"通过代码",charIndex:151},{level:2,title:"官方题解",slug:"官方题解",charIndex:1833},{level:2,title:"提交历史",slug:"提交历史",charIndex:4738},{level:2,title:"统计信息",slug:"统计信息",charIndex:4871},{level:2,title:"相似题目",slug:"相似题目",charIndex:4905}],lastUpdated:"4/11/2021, 1:15:21 PM",headersStr:"中文题目 通过代码 官方题解 提交历史 统计信息 相似题目",content:'# 中文题目\n给定一个非负整数numRows，生成杨辉三角的前numRows行。\n\n\n\n在杨辉三角中，每个数是它左上方和右上方的数的和。\n\n示例:\n\n输入: 5\n输出:\n[\n     [1],\n    [1,1],\n   [1,2,1],\n  [1,3,3,1],\n [1,4,6,4,1]\n]\n\n# 通过代码\nclass Solution {\n    public List<List<Integer>> generate(int numRows) {\n        int[][] arr=new int[numRows][numRows];\n            if (numRows == 1){\n                return Arrays.asList(Arrays.asList(1));\n            }\n            if (numRows == 2){\n                return Arrays.asList(Arrays.asList(1),Arrays.asList(1,1));\n            }\n            for (int i = 0; i < numRows; i++) {\n                for (int j = 0; j < numRows; j++) {\n                    if (j == 0 ){\n                        arr[i][j]=1;\n                    }else if (i == j){\n                        arr[i][j]=1;\n                    }else {\n                        arr [i] [j] = 0;\n                    }\n                }\n            }\n\n            for (int i = 2; i < numRows; i++) {\n                for (int j = 1; j < i; j++) {\n                    if (arr [i] [j] ==0){\n                        arr [i] [j] = arr [i-1][j-1]+arr [i-1][j];\n                    }\n                }\n            }\n\n//            for (int i = 0; i < numRows; i++) {\n//                for (int j = 0; j < numRows; j++) {\n//                    System.out.print(arr[i][j]+"\\t");\n//                }\n//                System.out.println();\n//            }\n            List < List<Integer>> res=new ArrayList<>();\n            for (int i = 0; i < numRows; i++) {\n                List<Integer> temp=new LinkedList<>();\n                for (int j = 0; j <= i; j++) {\n                    temp.add(arr[i][j]);\n                }\n                res.add(temp);\n            }\n            return res;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n# 官方题解\n# 方法：动态规划\n思路\n\n如果能够知道一行杨辉三角，我们就可以根据每对相邻的值轻松地计算出它的下一行。\n\n算法\n\n虽然这一算法非常简单，但用于构造杨辉三角的迭代方法可以归类为动态规划，因为我们需要基于前一行来构造每一行。\n\n首先，我们会生成整个 triangle 列表，三角形的每一行都以子列表的形式存储。然后，我们会检查行数为 000 的特殊情况，否则我们会返回 [1][1][1]。如果 numRows>0numRows > 0numRows>0，那么我们用 [1][1][1] 作为第一行来初始化 triangle with [1][1][1]，并按如下方式继续填充：\n\n<,,,,,,,,,,,>\n\nclass Solution {\n    public List<List<Integer>> generate(int numRows) {\n        List<List<Integer>> triangle = new ArrayList<List<Integer>>();\n\n        // First base case; if user requests zero rows, they get zero rows.\n        if (numRows == 0) {\n            return triangle;\n        }\n\n        // Second base case; first row is always [1].\n        triangle.add(new ArrayList<>());\n        triangle.get(0).add(1);\n\n        for (int rowNum = 1; rowNum < numRows; rowNum++) {\n            List<Integer> row = new ArrayList<>();\n            List<Integer> prevRow = triangle.get(rowNum-1);\n\n            // The first row element is always 1.\n            row.add(1);\n\n            // Each triangle element (other than the first and last of each row)\n            // is equal to the sum of the elements above-and-to-the-left and\n            // above-and-to-the-right.\n            for (int j = 1; j < rowNum; j++) {\n                row.add(prevRow.get(j-1) + prevRow.get(j));\n            }\n\n            // The last row element is always 1.\n            row.add(1);\n\n            triangle.add(row);\n        }\n\n        return triangle;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\nclass Solution:\n    def generate(self, num_rows):\n        triangle = []\n\n        for row_num in range(num_rows):\n            # The first and last row elements are always 1.\n            row = [None for _ in range(row_num+1)]\n            row[0], row[-1] = 1, 1\n\n            # Each triangle element is equal to the sum of the elements\n            # above-and-to-the-left and above-and-to-the-right.\n            for j in range(1, len(row)-1):\n                row[j] = triangle[row_num-1][j-1] + triangle[row_num-1][j]\n\n            triangle.append(row)\n\n        return triangle\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n复杂度分析\n\n * 时间复杂度：O(numRows2)O(numRows^2)O(numRows2)\n   \n   虽然更新 triangle 中的每个值都是在常量时间内发生的， 但它会被执行 O(numRows2)O(numRows^2)O(numRows2) 次。想要了解原因，就需要考虑总共有多少 次循环迭代。很明显外层循环需要运行numRowsnumRowsnumRows 次，但在外层循环的每次迭代中，内层 循环要运行 rowNumrowNumrowNum 次。因此，triangle 发生的更新总数为1+2+3+…+numRows1 + 2 + 3 + \\ldots + numRows1+2+3+…+numRows，根据高斯公式 有\n   \n   numRows(numRows+1)2=numRows2+numRows2=numRows22+numRows2=O(numRows2)\\begin{aligned} \\frac{numRows(numRows+1)}{2} &= \\frac{numRows^2 + numRows}{2} \\\\ &= \\frac{numRows^2}{2} + \\frac{numRows}{2} \\\\ &= O(numRows^2) \\end{aligned}2numRows(numRows+1)​​=2numRows2+numRows​=2numRows2​+2numRows​=O(numRows2)​\n   \n   \n * 空间复杂度：O(numRows2)O(numRows^2)O(numRows2)\n   \n   因为我们需要存储我们在 triangle 中更新的每个数字， 所以空间需求与时间复杂度相同。\n   \n   \n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2019-12-30 23:07:34Accepted [https://leetcode-cn.com//submissions/detail/41786759/]1 ms98.66%33.8 MBjava# 统计信息\n通过次数提交次数AC比率544008330665.3%# 相似题目\n题目难度杨辉三角 II [https://leetcode-cn.com/problems/pascals-triangle-ii/]简单',contentLowercase:'# 中文题目\n给定一个非负整数numrows，生成杨辉三角的前numrows行。\n\n\n\n在杨辉三角中，每个数是它左上方和右上方的数的和。\n\n示例:\n\n输入: 5\n输出:\n[\n     [1],\n    [1,1],\n   [1,2,1],\n  [1,3,3,1],\n [1,4,6,4,1]\n]\n\n# 通过代码\nclass solution {\n    public list<list<integer>> generate(int numrows) {\n        int[][] arr=new int[numrows][numrows];\n            if (numrows == 1){\n                return arrays.aslist(arrays.aslist(1));\n            }\n            if (numrows == 2){\n                return arrays.aslist(arrays.aslist(1),arrays.aslist(1,1));\n            }\n            for (int i = 0; i < numrows; i++) {\n                for (int j = 0; j < numrows; j++) {\n                    if (j == 0 ){\n                        arr[i][j]=1;\n                    }else if (i == j){\n                        arr[i][j]=1;\n                    }else {\n                        arr [i] [j] = 0;\n                    }\n                }\n            }\n\n            for (int i = 2; i < numrows; i++) {\n                for (int j = 1; j < i; j++) {\n                    if (arr [i] [j] ==0){\n                        arr [i] [j] = arr [i-1][j-1]+arr [i-1][j];\n                    }\n                }\n            }\n\n//            for (int i = 0; i < numrows; i++) {\n//                for (int j = 0; j < numrows; j++) {\n//                    system.out.print(arr[i][j]+"\\t");\n//                }\n//                system.out.println();\n//            }\n            list < list<integer>> res=new arraylist<>();\n            for (int i = 0; i < numrows; i++) {\n                list<integer> temp=new linkedlist<>();\n                for (int j = 0; j <= i; j++) {\n                    temp.add(arr[i][j]);\n                }\n                res.add(temp);\n            }\n            return res;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n# 官方题解\n# 方法：动态规划\n思路\n\n如果能够知道一行杨辉三角，我们就可以根据每对相邻的值轻松地计算出它的下一行。\n\n算法\n\n虽然这一算法非常简单，但用于构造杨辉三角的迭代方法可以归类为动态规划，因为我们需要基于前一行来构造每一行。\n\n首先，我们会生成整个 triangle 列表，三角形的每一行都以子列表的形式存储。然后，我们会检查行数为 000 的特殊情况，否则我们会返回 [1][1][1]。如果 numrows>0numrows > 0numrows>0，那么我们用 [1][1][1] 作为第一行来初始化 triangle with [1][1][1]，并按如下方式继续填充：\n\n<,,,,,,,,,,,>\n\nclass solution {\n    public list<list<integer>> generate(int numrows) {\n        list<list<integer>> triangle = new arraylist<list<integer>>();\n\n        // first base case; if user requests zero rows, they get zero rows.\n        if (numrows == 0) {\n            return triangle;\n        }\n\n        // second base case; first row is always [1].\n        triangle.add(new arraylist<>());\n        triangle.get(0).add(1);\n\n        for (int rownum = 1; rownum < numrows; rownum++) {\n            list<integer> row = new arraylist<>();\n            list<integer> prevrow = triangle.get(rownum-1);\n\n            // the first row element is always 1.\n            row.add(1);\n\n            // each triangle element (other than the first and last of each row)\n            // is equal to the sum of the elements above-and-to-the-left and\n            // above-and-to-the-right.\n            for (int j = 1; j < rownum; j++) {\n                row.add(prevrow.get(j-1) + prevrow.get(j));\n            }\n\n            // the last row element is always 1.\n            row.add(1);\n\n            triangle.add(row);\n        }\n\n        return triangle;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\nclass solution:\n    def generate(self, num_rows):\n        triangle = []\n\n        for row_num in range(num_rows):\n            # the first and last row elements are always 1.\n            row = [none for _ in range(row_num+1)]\n            row[0], row[-1] = 1, 1\n\n            # each triangle element is equal to the sum of the elements\n            # above-and-to-the-left and above-and-to-the-right.\n            for j in range(1, len(row)-1):\n                row[j] = triangle[row_num-1][j-1] + triangle[row_num-1][j]\n\n            triangle.append(row)\n\n        return triangle\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n复杂度分析\n\n * 时间复杂度：o(numrows2)o(numrows^2)o(numrows2)\n   \n   虽然更新 triangle 中的每个值都是在常量时间内发生的， 但它会被执行 o(numrows2)o(numrows^2)o(numrows2) 次。想要了解原因，就需要考虑总共有多少 次循环迭代。很明显外层循环需要运行numrowsnumrowsnumrows 次，但在外层循环的每次迭代中，内层 循环要运行 rownumrownumrownum 次。因此，triangle 发生的更新总数为1+2+3+…+numrows1 + 2 + 3 + \\ldots + numrows1+2+3+…+numrows，根据高斯公式 有\n   \n   numrows(numrows+1)2=numrows2+numrows2=numrows22+numrows2=o(numrows2)\\begin{aligned} \\frac{numrows(numrows+1)}{2} &= \\frac{numrows^2 + numrows}{2} \\\\ &= \\frac{numrows^2}{2} + \\frac{numrows}{2} \\\\ &= o(numrows^2) \\end{aligned}2numrows(numrows+1)​​=2numrows2+numrows​=2numrows2​+2numrows​=o(numrows2)​\n   \n   \n * 空间复杂度：o(numrows2)o(numrows^2)o(numrows2)\n   \n   因为我们需要存储我们在 triangle 中更新的每个数字， 所以空间需求与时间复杂度相同。\n   \n   \n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2019-12-30 23:07:34accepted [https://leetcode-cn.com//submissions/detail/41786759/]1 ms98.66%33.8 mbjava# 统计信息\n通过次数提交次数ac比率544008330665.3%# 相似题目\n题目难度杨辉三角 ii [https://leetcode-cn.com/problems/pascals-triangle-ii/]简单'},{title:"111-二叉树的最小深度(Minimum Depth of Binary Tree)",frontmatter:{title:"111-二叉树的最小深度(Minimum Depth of Binary Tree)",date:"2018-09-06T00:00:00.000Z",categories:["简单"],tags:["树<Tree>","深度优先搜索<Depth-first Search>","广度优先搜索<Breadth-first Search>"]},regularPath:"/views/%E7%AE%80%E5%8D%95/0111-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6.html",relativePath:"views/简单/0111-二叉树的最小深度.md",key:"v-c37cfd5c",path:"/views/%E7%AE%80%E5%8D%95/0111-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6.html",headers:[{level:2,title:"中文题目",slug:"中文题目",charIndex:2},{level:2,title:"通过代码",slug:"通过代码",charIndex:167},{level:2,title:"官方题解",slug:"官方题解",charIndex:1041},{level:2,title:"提交历史",slug:"提交历史",charIndex:6194},{level:2,title:"统计信息",slug:"统计信息",charIndex:6620},{level:2,title:"相似题目",slug:"相似题目",charIndex:6655}],lastUpdated:"4/11/2021, 1:15:21 PM",headersStr:"中文题目 通过代码 官方题解 提交历史 统计信息 相似题目",content:'# 中文题目\n给定一个二叉树，找出其最小深度。\n\n最小深度是从根节点到最近叶子节点的最短路径上的节点数量。\n\n说明:叶子节点是指没有子节点的节点。\n\n示例:\n\n给定二叉树[3,9,20,null,null,15,7],\n\n    3\n   / \\\n  9  20\n    /  \\\n   15   7\n\n返回它的最小深度 2.\n\n# 通过代码\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n        /**\n         * 要对下面这种情况单独考虑：\n         *     A\n         *    /\n         *   B\n         *   或者\n         *     A\n         *      \\\n         *       B\n         *  è¿ä¸ªæ¶åçæå¤§æ·±åº¦è¦ä¸ºå·¦å­©å­ç或者å³å­©å­ç\n         * @param root\n         * @return\n         */\n        public int minDepth(TreeNode root) {\n            if(root == null) {\n                return 0;\n            }\n            int left = minDepth(root.left);\n            int right = minDepth(root.right);\n            return (left == 0 || right == 0) ? left + right + 1: Math.min(left,right) + 1;\n        }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n# 官方题解\n树的定义\n\n首先，定义树节点结构 TreeNode。\n\n// Definition for a binary tree node.\npublic class TreeNode {\n  int val;\n  TreeNode left;\n  TreeNode right;\n\n  TreeNode(int x) {\n    val = x;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\n\n1\n2\n3\n4\n5\n6\n# 方法 1：递归\n算法\n\n最直接的思路就是递归。\n\n我们用深度优先搜索来解决这个问题。\n\nclass Solution {\n  public int minDepth(TreeNode root) {\n    if (root == null) {\n      return 0;\n    }\n\n    if ((root.left == null) && (root.right == null)) {\n      return 1;\n    }\n\n    int min_depth = Integer.MAX_VALUE;\n    if (root.left != null) {\n      min_depth = Math.min(minDepth(root.left), min_depth);\n    }\n    if (root.right != null) {\n      min_depth = Math.min(minDepth(root.right), min_depth);\n    }\n\n    return min_depth + 1;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\nclass Solution:\n    def minDepth(self, root):\n        """\n        :type root: TreeNode\n        :rtype: int\n        """\n        if not root: \n            return 0 \n        \n        children = [root.left, root.right]\n        # if we\'re at leaf node\n        if not any(children):\n            return 1\n        \n        min_depth = float(\'inf\')\n        for c in children:\n            if c:\n                min_depth = min(self.minDepth(c), min_depth)\n        return min_depth + 1 \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n复杂度分析\n\n * 时间复杂度：我们访问每个节点一次，时间复杂度为 O(N)O(N)O(N) ，其中 NNN 是节点个数。\n * 空间复杂度：最坏情况下，整棵树是非平衡的，例如每个节点都只有一个孩子，递归会调用 NNN （树的高度）次，因此栈的空间开销是 O(N)O(N)O(N) 。但在最好情况下，树是完全平衡的，高度只有 log⁡(N)\\log(N)log(N)，因此在这种情况下空间复杂度只有 O(log⁡(N))O(\\log(N))O(log(N)) 。\n\n# 方法 2：深度优先搜索迭代\n我们可以利用栈将上述解法中的递归变成迭代。\n\n> 想法是对于每个节点，按照深度优先搜索的策略访问，同时在访问到叶子节点时更新最小深度。\n\n\n我们从一个包含根节点的栈开始，当前深度为 1 。\n\n然后开始迭代：弹出当前栈顶元素，将它的孩子节点压入栈中。当遇到叶子节点时更新最小深度。\n\nimport javafx.util.Pair;\nclass Solution {\n  public int minDepth(TreeNode root) {\n    LinkedList<Pair<TreeNode, Integer>> stack = new LinkedList<>();\n    if (root == null) {\n      return 0;\n    }\n    else {\n      stack.add(new Pair(root, 1));\n    }\n\n    int min_depth = Integer.MAX_VALUE;\n    while (!stack.isEmpty()) {\n      Pair<TreeNode, Integer> current = stack.pollLast();\n      root = current.getKey();\n      int current_depth = current.getValue();\n      if ((root.left == null) && (root.right == null)) {\n        min_depth = Math.min(min_depth, current_depth);\n      }\n      if (root.left != null) {\n        stack.add(new Pair(root.left, current_depth + 1));\n      }\n      if (root.right != null) {\n        stack.add(new Pair(root.right, current_depth + 1));\n      }\n    }\n    return min_depth;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\nclass Solution:\n    def minDepth(self, root):\n        """\n        :type root: TreeNode\n        :rtype: int\n        """\n        if not root:\n            return 0\n        else:\n            stack, min_depth = [(1, root),], float(\'inf\')\n        \n        while stack:\n            depth, root = stack.pop()\n            children = [root.left, root.right]\n            if not any(children):\n                min_depth = min(depth, min_depth)\n            for c in children:\n                if c:\n                    stack.append((depth + 1, c))\n        \n        return min_depth \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n复杂度分析\n\n * 时间复杂度：每个节点恰好被访问一遍，复杂度为 O(N)O(N)O(N)。\n * 空间复杂度：最坏情况下我们会在栈中保存整棵树，此时空间复杂度为 O(N)O(N)O(N)。\n\n# 方法 3：宽度优先搜索迭代\n深度优先搜索方法的缺陷是所有节点都必须访问到，以保证能够找到最小深度。因此复杂度是 O(N)O(N)O(N)。\n\n一个优化的方法是利用宽度优先搜索，我们按照树的层次去迭代，第一个访问到的叶子就是最小深度的节点，这样就不要遍历所有的节点了。\n\nimport javafx.util.Pair;\nclass Solution {\n  public int minDepth(TreeNode root) {\n    LinkedList<Pair<TreeNode, Integer>> stack = new LinkedList<>();\n    if (root == null) {\n      return 0;\n    }\n    else {\n      stack.add(new Pair(root, 1));\n    }\n\n    int current_depth = 0;\n    while (!stack.isEmpty()) {\n      Pair<TreeNode, Integer> current = stack.poll();\n      root = current.getKey();\n      current_depth = current.getValue();\n      if ((root.left == null) && (root.right == null)) {\n        break;\n      }\n      if (root.left != null) {\n        stack.add(new Pair(root.left, current_depth + 1));\n      }\n      if (root.right != null) {\n        stack.add(new Pair(root.right, current_depth + 1));\n      }\n    }\n    return current_depth;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\nfrom collections import deque\nclass Solution:\n    def minDepth(self, root):\n        """\n        :type root: TreeNode\n        :rtype: int\n        """\n        if not root:\n            return 0\n        else:\n            node_deque = deque([(1, root),])\n        \n        while node_deque:\n            depth, root = node_deque.popleft()\n            children = [root.left, root.right]\n            if not any(children):\n                return depth\n            for c in children:\n                if c:\n                    node_deque.append((depth + 1, c))\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n复杂度分析\n\n * 时间复杂度：最坏情况下，这是一棵平衡树，我们需要按照树的层次一层一层的访问完所有节点，除去最后一层的节点。这样访问了 N/2N/2N/2 个节点，因此复杂度是 O(N)O(N)O(N)。\n * 空间复杂度：和时间复杂度相同，也是 O(N)O(N)O(N)。\n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-09-06 11:24:17Accepted [https://leetcode-cn.com//submissions/detail/6626875/]1 ms48.52%N/Ajava2018-09-06 11:14:16Wrong Answer [https://leetcode-cn.com//submissions/detail/6626137/]N/AN/AN/Ajava2018-09-06 11:13:37Wrong Answer [https://leetcode-cn.com//submissions/detail/6626098/]N/AN/AN/Ajava2018-09-06 11:12:44Runtime Error [https://leetcode-cn.com//submissions/detail/6626041/]N/AN/AN/Ajava# 统计信息\n通过次数提交次数AC比率4585011181941.0%# 相似题目\n题目难度二叉树的层次遍历 [https://leetcode-cn.com/problems/binary-tree-level-order-traversal/]中等二叉树的最大深度 [https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/]简单',contentLowercase:'# 中文题目\n给定一个二叉树，找出其最小深度。\n\n最小深度是从根节点到最近叶子节点的最短路径上的节点数量。\n\n说明:叶子节点是指没有子节点的节点。\n\n示例:\n\n给定二叉树[3,9,20,null,null,15,7],\n\n    3\n   / \\\n  9  20\n    /  \\\n   15   7\n\n返回它的最小深度 2.\n\n# 通过代码\n/**\n * definition for a binary tree node.\n * public class treenode {\n *     int val;\n *     treenode left;\n *     treenode right;\n *     treenode(int x) { val = x; }\n * }\n */\nclass solution {\n        /**\n         * 要对下面这种情况单独考虑：\n         *     a\n         *    /\n         *   b\n         *   或者\n         *     a\n         *      \\\n         *       b\n         *  è¿ä¸ªæ¶åçæå¤§æ·±åº¦è¦ä¸ºå·¦å­©å­ç或者å³å­©å­ç\n         * @param root\n         * @return\n         */\n        public int mindepth(treenode root) {\n            if(root == null) {\n                return 0;\n            }\n            int left = mindepth(root.left);\n            int right = mindepth(root.right);\n            return (left == 0 || right == 0) ? left + right + 1: math.min(left,right) + 1;\n        }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n# 官方题解\n树的定义\n\n首先，定义树节点结构 treenode。\n\n// definition for a binary tree node.\npublic class treenode {\n  int val;\n  treenode left;\n  treenode right;\n\n  treenode(int x) {\n    val = x;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n# definition for a binary tree node.\nclass treenode:\n    def __init__(self, x):\n        self.val = x\n        self.left = none\n        self.right = none\n\n\n1\n2\n3\n4\n5\n6\n# 方法 1：递归\n算法\n\n最直接的思路就是递归。\n\n我们用深度优先搜索来解决这个问题。\n\nclass solution {\n  public int mindepth(treenode root) {\n    if (root == null) {\n      return 0;\n    }\n\n    if ((root.left == null) && (root.right == null)) {\n      return 1;\n    }\n\n    int min_depth = integer.max_value;\n    if (root.left != null) {\n      min_depth = math.min(mindepth(root.left), min_depth);\n    }\n    if (root.right != null) {\n      min_depth = math.min(mindepth(root.right), min_depth);\n    }\n\n    return min_depth + 1;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\nclass solution:\n    def mindepth(self, root):\n        """\n        :type root: treenode\n        :rtype: int\n        """\n        if not root: \n            return 0 \n        \n        children = [root.left, root.right]\n        # if we\'re at leaf node\n        if not any(children):\n            return 1\n        \n        min_depth = float(\'inf\')\n        for c in children:\n            if c:\n                min_depth = min(self.mindepth(c), min_depth)\n        return min_depth + 1 \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n复杂度分析\n\n * 时间复杂度：我们访问每个节点一次，时间复杂度为 o(n)o(n)o(n) ，其中 nnn 是节点个数。\n * 空间复杂度：最坏情况下，整棵树是非平衡的，例如每个节点都只有一个孩子，递归会调用 nnn （树的高度）次，因此栈的空间开销是 o(n)o(n)o(n) 。但在最好情况下，树是完全平衡的，高度只有 log⁡(n)\\log(n)log(n)，因此在这种情况下空间复杂度只有 o(log⁡(n))o(\\log(n))o(log(n)) 。\n\n# 方法 2：深度优先搜索迭代\n我们可以利用栈将上述解法中的递归变成迭代。\n\n> 想法是对于每个节点，按照深度优先搜索的策略访问，同时在访问到叶子节点时更新最小深度。\n\n\n我们从一个包含根节点的栈开始，当前深度为 1 。\n\n然后开始迭代：弹出当前栈顶元素，将它的孩子节点压入栈中。当遇到叶子节点时更新最小深度。\n\nimport javafx.util.pair;\nclass solution {\n  public int mindepth(treenode root) {\n    linkedlist<pair<treenode, integer>> stack = new linkedlist<>();\n    if (root == null) {\n      return 0;\n    }\n    else {\n      stack.add(new pair(root, 1));\n    }\n\n    int min_depth = integer.max_value;\n    while (!stack.isempty()) {\n      pair<treenode, integer> current = stack.polllast();\n      root = current.getkey();\n      int current_depth = current.getvalue();\n      if ((root.left == null) && (root.right == null)) {\n        min_depth = math.min(min_depth, current_depth);\n      }\n      if (root.left != null) {\n        stack.add(new pair(root.left, current_depth + 1));\n      }\n      if (root.right != null) {\n        stack.add(new pair(root.right, current_depth + 1));\n      }\n    }\n    return min_depth;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\nclass solution:\n    def mindepth(self, root):\n        """\n        :type root: treenode\n        :rtype: int\n        """\n        if not root:\n            return 0\n        else:\n            stack, min_depth = [(1, root),], float(\'inf\')\n        \n        while stack:\n            depth, root = stack.pop()\n            children = [root.left, root.right]\n            if not any(children):\n                min_depth = min(depth, min_depth)\n            for c in children:\n                if c:\n                    stack.append((depth + 1, c))\n        \n        return min_depth \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n复杂度分析\n\n * 时间复杂度：每个节点恰好被访问一遍，复杂度为 o(n)o(n)o(n)。\n * 空间复杂度：最坏情况下我们会在栈中保存整棵树，此时空间复杂度为 o(n)o(n)o(n)。\n\n# 方法 3：宽度优先搜索迭代\n深度优先搜索方法的缺陷是所有节点都必须访问到，以保证能够找到最小深度。因此复杂度是 o(n)o(n)o(n)。\n\n一个优化的方法是利用宽度优先搜索，我们按照树的层次去迭代，第一个访问到的叶子就是最小深度的节点，这样就不要遍历所有的节点了。\n\nimport javafx.util.pair;\nclass solution {\n  public int mindepth(treenode root) {\n    linkedlist<pair<treenode, integer>> stack = new linkedlist<>();\n    if (root == null) {\n      return 0;\n    }\n    else {\n      stack.add(new pair(root, 1));\n    }\n\n    int current_depth = 0;\n    while (!stack.isempty()) {\n      pair<treenode, integer> current = stack.poll();\n      root = current.getkey();\n      current_depth = current.getvalue();\n      if ((root.left == null) && (root.right == null)) {\n        break;\n      }\n      if (root.left != null) {\n        stack.add(new pair(root.left, current_depth + 1));\n      }\n      if (root.right != null) {\n        stack.add(new pair(root.right, current_depth + 1));\n      }\n    }\n    return current_depth;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\nfrom collections import deque\nclass solution:\n    def mindepth(self, root):\n        """\n        :type root: treenode\n        :rtype: int\n        """\n        if not root:\n            return 0\n        else:\n            node_deque = deque([(1, root),])\n        \n        while node_deque:\n            depth, root = node_deque.popleft()\n            children = [root.left, root.right]\n            if not any(children):\n                return depth\n            for c in children:\n                if c:\n                    node_deque.append((depth + 1, c))\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n复杂度分析\n\n * 时间复杂度：最坏情况下，这是一棵平衡树，我们需要按照树的层次一层一层的访问完所有节点，除去最后一层的节点。这样访问了 n/2n/2n/2 个节点，因此复杂度是 o(n)o(n)o(n)。\n * 空间复杂度：和时间复杂度相同，也是 o(n)o(n)o(n)。\n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-09-06 11:24:17accepted [https://leetcode-cn.com//submissions/detail/6626875/]1 ms48.52%n/ajava2018-09-06 11:14:16wrong answer [https://leetcode-cn.com//submissions/detail/6626137/]n/an/an/ajava2018-09-06 11:13:37wrong answer [https://leetcode-cn.com//submissions/detail/6626098/]n/an/an/ajava2018-09-06 11:12:44runtime error [https://leetcode-cn.com//submissions/detail/6626041/]n/an/an/ajava# 统计信息\n通过次数提交次数ac比率4585011181941.0%# 相似题目\n题目难度二叉树的层次遍历 [https://leetcode-cn.com/problems/binary-tree-level-order-traversal/]中等二叉树的最大深度 [https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/]简单'},{title:"121-买卖股票的最佳时机(Best Time to Buy and Sell Stock)",frontmatter:{title:"121-买卖股票的最佳时机(Best Time to Buy and Sell Stock)",date:"2018-09-18T00:00:00.000Z",categories:["简单"],tags:["数组<Array>","动态规划<Dynamic Programming>"]},regularPath:"/views/%E7%AE%80%E5%8D%95/0121-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA.html",relativePath:"views/简单/0121-买卖股票的最佳时机.md",key:"v-3d43ded6",path:"/views/%E7%AE%80%E5%8D%95/0121-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA.html",headers:[{level:2,title:"中文题目",slug:"中文题目",charIndex:2},{level:2,title:"通过代码",slug:"通过代码",charIndex:307},{level:2,title:"官方题解",slug:"官方题解",charIndex:2168},{level:2,title:"解决方案",slug:"解决方案",charIndex:2175},{level:2,title:"提交历史",slug:"提交历史",charIndex:3712},{level:2,title:"统计信息",slug:"统计信息",charIndex:4038},{level:2,title:"相似题目",slug:"相似题目",charIndex:4074}],lastUpdated:"4/11/2021, 1:15:21 PM",headersStr:"中文题目 通过代码 官方题解 解决方案 提交历史 统计信息 相似题目",content:'# 中文题目\n给定一个数组，它的第i 个元素是一支给定股票第 i 天的价格。\n\n如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。\n\n注意你不能在买入股票前卖出股票。\n\n示例 1:\n\n输入: [7,1,5,3,6,4]\n输出: 5\n解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。\n     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。\n\n\n示例 2:\n\n输入: [7,6,4,3,1]\n输出: 0\n解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。\n\n\n# 通过代码\nclass Solution {\n    public int maxProfit(int[] prices) {\n       if (null==prices ||prices.length==0){\n                return 0;\n            }\n            int max=0;\n            int sofarMin=prices[0];\n            for (int i = 1; i <prices.length ; i++) {\n//                如果当前的价格减去前面最小的价格比max大，更新\n                if (prices[i]-sofarMin>max){\n                    max=prices[i]-sofarMin;\n                }\n//                如果当前的价格比之前的小，更新ç®åæå°çä»·æ ¼\n                if (prices[i]<sofarMin){\n                    sofarMin=prices[i];\n                }\n            }\n            return max;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\nclass Solution {\n    public int maxProfit(int[] prices) {\n       if (null==prices ||prices.length==0){\n                return 0;\n            }\n            int max=0;\n            int sofarMin=prices[0];\n            for (int i = 1; i <prices.length ; i++) {\n//                如果当前的价格减去前面最小的价格比max小，更新\n                if (prices[i]-sofarMin>max){\n                    max=prices[i]-sofarMin;\n                }\n//                å¦æå½åçä»·æ ¼æ¯ä¹åç小，更新ç®åæ小çä»·æ ¼\n                if (prices[i]<sofarMin){\n                    sofarMin=prices[i];\n                }\n            }\n            return max;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\nclass Solution {\n    public int maxProfit(int[] prices) {\n        if (null==prices ||prices.length==0){\n                return 0;\n            }\n            int max=0;\n            int sofarMin=prices[0];\n            for (int i = 1; i <prices.length ; i++) {\n                if (prices[i]>sofarMin){\n                    max=Math.max(prices[i]-sofarMin,max);\n                }else {\n                    sofarMin=prices[i];\n                }\n            }\n            return max;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n# 官方题解\n# 解决方案\n我们需要找出给定数组中两个数字之间的最大差值（即，最大利润）。此外，第二个数字（卖出价格）必须大于第一个数字（买入价格）。\n\n形式上，对于每组 iii 和 jjj（其中 j>ij > ij>i）我们需要找出 max⁡(prices[j]−prices[i])\\max(prices[j] - prices[i])max(prices[j]−prices[i])。\n\n# 方法一：暴力法\npublic class Solution {\n    public int maxProfit(int prices[]) {\n        int maxprofit = 0;\n        for (int i = 0; i < prices.length - 1; i++) {\n            for (int j = i + 1; j < prices.length; j++) {\n                int profit = prices[j] - prices[i];\n                if (profit > maxprofit)\n                    maxprofit = profit;\n            }\n        }\n        return maxprofit;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n复杂度分析\n\n * 时间复杂度：O(n2)O(n^2)O(n2)。循环运行 n(n−1)2\\dfrac{n (n-1)}{2}2n(n−1)​ 次。\n * 空间复杂度：O(1)O(1)O(1)。只使用了两个变量 —— maxprofit\\text{maxprofit}maxprofit 和 profit\\text{profit}profit。\n\n# 方法二：一次遍历\n算法\n\n假设给定的数组为：\n\n[7, 1, 5, 3, 6, 4]\n\n如果我们在图表上绘制给定数组中的数字，我们将会得到：\n\n{:width="400px"} {:align="center"}\n\n使我们感兴趣的点是上图中的峰和谷。我们需要找到最小的谷之后的最大的峰。 我们可以维持两个变量——minprice 和 maxprofit，它们分别对应迄今为止所得到的最小的谷值和最大的利润（卖出价格与最低价格之间的最大差值）。\n\npublic class Solution {\n    public int maxProfit(int prices[]) {\n        int minprice = Integer.MAX_VALUE;\n        int maxprofit = 0;\n        for (int i = 0; i < prices.length; i++) {\n            if (prices[i] < minprice)\n                minprice = prices[i];\n            else if (prices[i] - minprice > maxprofit)\n                maxprofit = prices[i] - minprice;\n        }\n        return maxprofit;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n复杂度分析\n\n * 时间复杂度：O(n)O(n)O(n)，只需要遍历一次。\n * 空间复杂度：O(1)O(1)O(1)，只使用了两个变量。\n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-09-18 16:46:15Accepted [https://leetcode-cn.com//submissions/detail/7259792/]2 ms61.56%N/Ajava2018-05-07 22:42:28Accepted [https://leetcode-cn.com//submissions/detail/2057938/]1 ms99.99%N/Ajava2018-05-07 22:37:22Accepted [https://leetcode-cn.com//submissions/detail/2057799/]3 ms35.98%N/Ajava# 统计信息\n通过次数提交次数AC比率11541022208052.0%# 相似题目\n题目难度最大子序和 [https://leetcode-cn.com/problems/maximum-subarray/]简单买卖股票的最佳时机 II [https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/]简单买卖股票的最佳时机 III [https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/]困难买卖股票的最佳时机 IV [https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/]困难最佳买卖股票时机含冷冻期 [https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/]中等',contentLowercase:'# 中文题目\n给定一个数组，它的第i 个元素是一支给定股票第 i 天的价格。\n\n如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。\n\n注意你不能在买入股票前卖出股票。\n\n示例 1:\n\n输入: [7,1,5,3,6,4]\n输出: 5\n解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。\n     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。\n\n\n示例 2:\n\n输入: [7,6,4,3,1]\n输出: 0\n解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。\n\n\n# 通过代码\nclass solution {\n    public int maxprofit(int[] prices) {\n       if (null==prices ||prices.length==0){\n                return 0;\n            }\n            int max=0;\n            int sofarmin=prices[0];\n            for (int i = 1; i <prices.length ; i++) {\n//                如果当前的价格减去前面最小的价格比max大，更新\n                if (prices[i]-sofarmin>max){\n                    max=prices[i]-sofarmin;\n                }\n//                如果当前的价格比之前的小，更新ç®åæå°çä»·æ ¼\n                if (prices[i]<sofarmin){\n                    sofarmin=prices[i];\n                }\n            }\n            return max;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\nclass solution {\n    public int maxprofit(int[] prices) {\n       if (null==prices ||prices.length==0){\n                return 0;\n            }\n            int max=0;\n            int sofarmin=prices[0];\n            for (int i = 1; i <prices.length ; i++) {\n//                如果当前的价格减去前面最小的价格比max小，更新\n                if (prices[i]-sofarmin>max){\n                    max=prices[i]-sofarmin;\n                }\n//                å¦æå½åçä»·æ ¼æ¯ä¹åç小，更新ç®åæ小çä»·æ ¼\n                if (prices[i]<sofarmin){\n                    sofarmin=prices[i];\n                }\n            }\n            return max;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\nclass solution {\n    public int maxprofit(int[] prices) {\n        if (null==prices ||prices.length==0){\n                return 0;\n            }\n            int max=0;\n            int sofarmin=prices[0];\n            for (int i = 1; i <prices.length ; i++) {\n                if (prices[i]>sofarmin){\n                    max=math.max(prices[i]-sofarmin,max);\n                }else {\n                    sofarmin=prices[i];\n                }\n            }\n            return max;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n# 官方题解\n# 解决方案\n我们需要找出给定数组中两个数字之间的最大差值（即，最大利润）。此外，第二个数字（卖出价格）必须大于第一个数字（买入价格）。\n\n形式上，对于每组 iii 和 jjj（其中 j>ij > ij>i）我们需要找出 max⁡(prices[j]−prices[i])\\max(prices[j] - prices[i])max(prices[j]−prices[i])。\n\n# 方法一：暴力法\npublic class solution {\n    public int maxprofit(int prices[]) {\n        int maxprofit = 0;\n        for (int i = 0; i < prices.length - 1; i++) {\n            for (int j = i + 1; j < prices.length; j++) {\n                int profit = prices[j] - prices[i];\n                if (profit > maxprofit)\n                    maxprofit = profit;\n            }\n        }\n        return maxprofit;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n复杂度分析\n\n * 时间复杂度：o(n2)o(n^2)o(n2)。循环运行 n(n−1)2\\dfrac{n (n-1)}{2}2n(n−1)​ 次。\n * 空间复杂度：o(1)o(1)o(1)。只使用了两个变量 —— maxprofit\\text{maxprofit}maxprofit 和 profit\\text{profit}profit。\n\n# 方法二：一次遍历\n算法\n\n假设给定的数组为：\n\n[7, 1, 5, 3, 6, 4]\n\n如果我们在图表上绘制给定数组中的数字，我们将会得到：\n\n{:width="400px"} {:align="center"}\n\n使我们感兴趣的点是上图中的峰和谷。我们需要找到最小的谷之后的最大的峰。 我们可以维持两个变量——minprice 和 maxprofit，它们分别对应迄今为止所得到的最小的谷值和最大的利润（卖出价格与最低价格之间的最大差值）。\n\npublic class solution {\n    public int maxprofit(int prices[]) {\n        int minprice = integer.max_value;\n        int maxprofit = 0;\n        for (int i = 0; i < prices.length; i++) {\n            if (prices[i] < minprice)\n                minprice = prices[i];\n            else if (prices[i] - minprice > maxprofit)\n                maxprofit = prices[i] - minprice;\n        }\n        return maxprofit;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n复杂度分析\n\n * 时间复杂度：o(n)o(n)o(n)，只需要遍历一次。\n * 空间复杂度：o(1)o(1)o(1)，只使用了两个变量。\n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-09-18 16:46:15accepted [https://leetcode-cn.com//submissions/detail/7259792/]2 ms61.56%n/ajava2018-05-07 22:42:28accepted [https://leetcode-cn.com//submissions/detail/2057938/]1 ms99.99%n/ajava2018-05-07 22:37:22accepted [https://leetcode-cn.com//submissions/detail/2057799/]3 ms35.98%n/ajava# 统计信息\n通过次数提交次数ac比率11541022208052.0%# 相似题目\n题目难度最大子序和 [https://leetcode-cn.com/problems/maximum-subarray/]简单买卖股票的最佳时机 ii [https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/]简单买卖股票的最佳时机 iii [https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/]困难买卖股票的最佳时机 iv [https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/]困难最佳买卖股票时机含冷冻期 [https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/]中等'},{title:"125-验证回文串(Valid Palindrome)",frontmatter:{title:"125-验证回文串(Valid Palindrome)",date:"2018-05-16T00:00:00.000Z",categories:["简单"],tags:["双指针<Two Pointers>","字符串<String>"]},regularPath:"/views/%E7%AE%80%E5%8D%95/0125-%E9%AA%8C%E8%AF%81%E5%9B%9E%E6%96%87%E4%B8%B2.html",relativePath:"views/简单/0125-验证回文串.md",key:"v-a3978ed0",path:"/views/%E7%AE%80%E5%8D%95/0125-%E9%AA%8C%E8%AF%81%E5%9B%9E%E6%96%87%E4%B8%B2.html",headers:[{level:2,title:"中文题目",slug:"中文题目",charIndex:2},{level:2,title:"通过代码",slug:"通过代码",charIndex:168},{level:2,title:"高赞题解",slug:"高赞题解",charIndex:858},{level:2,title:"解法1：",slug:"解法1：",charIndex:1043},{level:2,title:"解法2：双指针法：",slug:"解法2：双指针法：",charIndex:1850},{level:2,title:"提交历史",slug:"提交历史",charIndex:2446},{level:2,title:"统计信息",slug:"统计信息",charIndex:2674},{level:2,title:"相似题目",slug:"相似题目",charIndex:2709}],lastUpdated:"4/11/2021, 1:15:21 PM",headersStr:"中文题目 通过代码 高赞题解 解法1： 解法2：双指针法： 提交历史 统计信息 相似题目",content:"# 中文题目\n给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。\n\n说明：本题中，我们将空字符串定义为有效的回文串。\n\n示例 1:\n\n输入: \"A man, a plan, a canal: Panama\"\n输出: true\n\n\n示例 2:\n\n输入: \"race a car\"\n输出: false\n\n\n# 通过代码\nclass Solution {\n    public boolean isPalindrome(String s) {\n      s=s.toLowerCase();\n            int lo=0;\n            int hi=s.length()-1;\n            while (lo<hi){\n                Character c1=s.charAt(lo);\n                Character c2=s.charAt(hi);\n                if (!Character.isLetterOrDigit(c1)){\n                    lo++;\n                }else if (!Character.isLetterOrDigit(c2)){\n                    hi--;\n                }else if (c1!=c2){\n                    return false;\n                }else {\n                    lo++;\n                    hi--;\n                }\n            }\n            return true;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n# 高赞题解\n# 验证回文串\n给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。\n\n说明：本题中，我们将空字符串定义为有效的回文串。\n\n示例 1:\n\n输入: \"A man, a plan, a canal: Panama\"\n输出: true\n\n\n1\n2\n示例 2:\n\n输入: \"race a car\"\n输出: false\n\n\n1\n2\n\n\n\n# 解法1：\nclass Solution {\npublic:\n\tbool isPalindrome(string s) {\n\t\tstring s1;\n\t\tfor (int i = 0; i < s.length(); i++)\n\t\t{\n\t\t\tif (s[i] == ' ')\n\t\t\t{\n\t\t\t\ti = s.find_first_not_of(' ',i);//从第i位置开始找第一个不为空格的位置\n                if(i==-1) \n                    break;\n\t\t\t}\n\t\t\tif ((s[i] >= 'A'&&s[i] <= 'Z') || (s[i] >= 'a'&&s[i] <= 'z') || (s[i] >= '0'&&s[i] <= '9'))//是数字或者字母\n\t\t\t{\n\t\t\t\tif (s[i] >= 'A'&&s[i] <= 'Z')//大写转小写\n\t\t\t\t{\n\t\t\t\t\ts[i] = (s[i] + 32);\n\t\t\t\t\ts1 = s1 + s[i];\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\ts1 = s1 + s[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\telse continue;\n\t\t}\n\t\tstring ress1 = s1;\n\t\tstd::reverse(ress1.begin(), ress1.end());//回转字符串\n\t\tif (ress1 == s1)若相等\n\t\t\treturn true;\n\t\telse return false;\n\t}\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n该方法在字符串过大时，反转过程消耗过大的内存，故该方法在最后一个测试用例过不去。\n\n# 解法2：双指针法：\nclass Solution {\npublic:\n    bool isPalindrome(string s) {\n        // 双指针\n        if(s.size() <= 1) return true;\n        int i = 0, j = s.size() - 1;\n        while(i < j){\n            while(i < j && !isalnum(s[i])) // 排除所有非字母或数字的字符\n                i++;\n            while(i < j && !isalnum(s[j]))\n                j--;\n            if(tolower(s[i++]) != tolower(s[j--])) //统一转换成小写字母再比较\n                return false;\n        }\n        return true;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\nisalnum(char c):判断字符变量c是否为字母或数字，若是则返回非零，否则返回零。 tolower(char c):把字母字符转换成小写,非字母字符不做出处理。\n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-05-16 19:38:54Accepted [https://leetcode-cn.com//submissions/detail/2334481/]13 ms24.81%N/Ajava2018-05-16 18:31:42Wrong Answer [https://leetcode-cn.com//submissions/detail/2332055/]N/AN/AN/Ajava# 统计信息\n通过次数提交次数AC比率7224317188442.0%# 相似题目\n题目难度回文链表 [https://leetcode-cn.com/problems/palindrome-linked-list/]简单验证回文字符串 Ⅱ [https://leetcode-cn.com/problems/valid-palindrome-ii/]简单",contentLowercase:"# 中文题目\n给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。\n\n说明：本题中，我们将空字符串定义为有效的回文串。\n\n示例 1:\n\n输入: \"a man, a plan, a canal: panama\"\n输出: true\n\n\n示例 2:\n\n输入: \"race a car\"\n输出: false\n\n\n# 通过代码\nclass solution {\n    public boolean ispalindrome(string s) {\n      s=s.tolowercase();\n            int lo=0;\n            int hi=s.length()-1;\n            while (lo<hi){\n                character c1=s.charat(lo);\n                character c2=s.charat(hi);\n                if (!character.isletterordigit(c1)){\n                    lo++;\n                }else if (!character.isletterordigit(c2)){\n                    hi--;\n                }else if (c1!=c2){\n                    return false;\n                }else {\n                    lo++;\n                    hi--;\n                }\n            }\n            return true;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n# 高赞题解\n# 验证回文串\n给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。\n\n说明：本题中，我们将空字符串定义为有效的回文串。\n\n示例 1:\n\n输入: \"a man, a plan, a canal: panama\"\n输出: true\n\n\n1\n2\n示例 2:\n\n输入: \"race a car\"\n输出: false\n\n\n1\n2\n\n\n\n# 解法1：\nclass solution {\npublic:\n\tbool ispalindrome(string s) {\n\t\tstring s1;\n\t\tfor (int i = 0; i < s.length(); i++)\n\t\t{\n\t\t\tif (s[i] == ' ')\n\t\t\t{\n\t\t\t\ti = s.find_first_not_of(' ',i);//从第i位置开始找第一个不为空格的位置\n                if(i==-1) \n                    break;\n\t\t\t}\n\t\t\tif ((s[i] >= 'a'&&s[i] <= 'z') || (s[i] >= 'a'&&s[i] <= 'z') || (s[i] >= '0'&&s[i] <= '9'))//是数字或者字母\n\t\t\t{\n\t\t\t\tif (s[i] >= 'a'&&s[i] <= 'z')//大写转小写\n\t\t\t\t{\n\t\t\t\t\ts[i] = (s[i] + 32);\n\t\t\t\t\ts1 = s1 + s[i];\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\ts1 = s1 + s[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\telse continue;\n\t\t}\n\t\tstring ress1 = s1;\n\t\tstd::reverse(ress1.begin(), ress1.end());//回转字符串\n\t\tif (ress1 == s1)若相等\n\t\t\treturn true;\n\t\telse return false;\n\t}\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n该方法在字符串过大时，反转过程消耗过大的内存，故该方法在最后一个测试用例过不去。\n\n# 解法2：双指针法：\nclass solution {\npublic:\n    bool ispalindrome(string s) {\n        // 双指针\n        if(s.size() <= 1) return true;\n        int i = 0, j = s.size() - 1;\n        while(i < j){\n            while(i < j && !isalnum(s[i])) // 排除所有非字母或数字的字符\n                i++;\n            while(i < j && !isalnum(s[j]))\n                j--;\n            if(tolower(s[i++]) != tolower(s[j--])) //统一转换成小写字母再比较\n                return false;\n        }\n        return true;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\nisalnum(char c):判断字符变量c是否为字母或数字，若是则返回非零，否则返回零。 tolower(char c):把字母字符转换成小写,非字母字符不做出处理。\n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-05-16 19:38:54accepted [https://leetcode-cn.com//submissions/detail/2334481/]13 ms24.81%n/ajava2018-05-16 18:31:42wrong answer [https://leetcode-cn.com//submissions/detail/2332055/]n/an/an/ajava# 统计信息\n通过次数提交次数ac比率7224317188442.0%# 相似题目\n题目难度回文链表 [https://leetcode-cn.com/problems/palindrome-linked-list/]简单验证回文字符串 ⅱ [https://leetcode-cn.com/problems/valid-palindrome-ii/]简单"},{title:"119-杨辉三角 II(Pascal's Triangle II)",frontmatter:{title:"119-杨辉三角 II(Pascal's Triangle II)",date:"2019-12-30T00:00:00.000Z",categories:["简单"],tags:["数组<Array>"]},regularPath:"/views/%E7%AE%80%E5%8D%95/0119-%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92%20II.html",relativePath:"views/简单/0119-杨辉三角 II.md",key:"v-0bb21a4d",path:"/views/%E7%AE%80%E5%8D%95/0119-%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92%20II.html",headers:[{level:2,title:"中文题目",slug:"中文题目",charIndex:2},{level:2,title:"通过代码",slug:"通过代码",charIndex:128},{level:2,title:"高赞题解",slug:"高赞题解",charIndex:863},{level:2,title:"提交历史",slug:"提交历史",charIndex:1283},{level:2,title:"统计信息",slug:"统计信息",charIndex:1520},{level:2,title:"相似题目",slug:"相似题目",charIndex:1554}],lastUpdated:"4/11/2021, 1:15:21 PM",headersStr:"中文题目 通过代码 高赞题解 提交历史 统计信息 相似题目",content:"# 中文题目\n给定一个非负索引k，其中 k≤ 33，返回杨辉三角的第 k 行。\n\n\n\n在杨辉三角中，每个数是它左上方和右上方的数的和。\n\n示例:\n\n输入: 3\n输出: [1,3,3,1]\n\n\n进阶：\n\n你可以优化你的算法到 O(k) 空间复杂度吗？\n\n# 通过代码\nclass Solution {\n    public List<Integer> getRow(int rowIndex) {\n        List<Integer> res = new ArrayList<Integer>(rowIndex+1);\n        long nk = 1;\n        for(int i = 0; i <= rowIndex; i++){\n            res.add((int)nk);\n            nk = nk * (rowIndex - i) / (i + 1);\n        }\n        return res;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\nclass Solution {\n    public List<Integer> getRow(int rowIndex) {\n        ArrayList<Integer> row = new ArrayList<Integer>();\n            for (int i=0; i<rowIndex+1; i++){\n                row.add(0,1);\n                for(int j=1; j<row.size()-1;j++){\n                    row.set(j, row.get(j)+row.get(j+1));\n                }\n            }\n            return row;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n# 高赞题解\ndef getRow(rowIndex):\n    # j行的数据, 应该由j - 1行的数据计算出来.\n    # 假设j - 1行为[1,3,3,1], 那么我们前面插入一个0(j行的数据会比j-1行多一个),\n    # 然后执行相加[0+1,1+3,3+3,3+1,1] = [1,4,6,4,1], 最后一个1保留即可.\n    r = [1]\n    for i in range(1, rowIndex + 1):\n        r.insert(0, 0)\n        # 因为i行的数据长度为i+1, 所以j+1不会越界, 并且最后一个1不会被修改.\n        for j in range(i):\n            r[j] = r[j] + r[j + 1]\n    return r\n\nprint(getRow(5))\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2019-12-30 23:51:03Accepted [https://leetcode-cn.com//submissions/detail/41790479/]0 ms100.0%33.8 MBjava2019-12-30 23:36:44Accepted [https://leetcode-cn.com//submissions/detail/41789421/]2 ms66.02%33.6 MBjava# 统计信息\n通过次数提交次数AC比率355625974559.5%# 相似题目\n题目难度杨辉三角 [https://leetcode-cn.com/problems/pascals-triangle/]简单",contentLowercase:"# 中文题目\n给定一个非负索引k，其中 k≤ 33，返回杨辉三角的第 k 行。\n\n\n\n在杨辉三角中，每个数是它左上方和右上方的数的和。\n\n示例:\n\n输入: 3\n输出: [1,3,3,1]\n\n\n进阶：\n\n你可以优化你的算法到 o(k) 空间复杂度吗？\n\n# 通过代码\nclass solution {\n    public list<integer> getrow(int rowindex) {\n        list<integer> res = new arraylist<integer>(rowindex+1);\n        long nk = 1;\n        for(int i = 0; i <= rowindex; i++){\n            res.add((int)nk);\n            nk = nk * (rowindex - i) / (i + 1);\n        }\n        return res;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\nclass solution {\n    public list<integer> getrow(int rowindex) {\n        arraylist<integer> row = new arraylist<integer>();\n            for (int i=0; i<rowindex+1; i++){\n                row.add(0,1);\n                for(int j=1; j<row.size()-1;j++){\n                    row.set(j, row.get(j)+row.get(j+1));\n                }\n            }\n            return row;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n# 高赞题解\ndef getrow(rowindex):\n    # j行的数据, 应该由j - 1行的数据计算出来.\n    # 假设j - 1行为[1,3,3,1], 那么我们前面插入一个0(j行的数据会比j-1行多一个),\n    # 然后执行相加[0+1,1+3,3+3,3+1,1] = [1,4,6,4,1], 最后一个1保留即可.\n    r = [1]\n    for i in range(1, rowindex + 1):\n        r.insert(0, 0)\n        # 因为i行的数据长度为i+1, 所以j+1不会越界, 并且最后一个1不会被修改.\n        for j in range(i):\n            r[j] = r[j] + r[j + 1]\n    return r\n\nprint(getrow(5))\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2019-12-30 23:51:03accepted [https://leetcode-cn.com//submissions/detail/41790479/]0 ms100.0%33.8 mbjava2019-12-30 23:36:44accepted [https://leetcode-cn.com//submissions/detail/41789421/]2 ms66.02%33.6 mbjava# 统计信息\n通过次数提交次数ac比率355625974559.5%# 相似题目\n题目难度杨辉三角 [https://leetcode-cn.com/problems/pascals-triangle/]简单"},{title:"136-只出现一次的数字(Single Number)",frontmatter:{title:"136-只出现一次的数字(Single Number)",date:"2020-01-05T00:00:00.000Z",categories:["简单"],tags:["位运算<Bit Manipulation>","哈希表<Hash Table>"]},regularPath:"/views/%E7%AE%80%E5%8D%95/0136-%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97.html",relativePath:"views/简单/0136-只出现一次的数字.md",key:"v-0cf96847",path:"/views/%E7%AE%80%E5%8D%95/0136-%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97.html",headers:[{level:2,title:"中文题目",slug:"中文题目",charIndex:2},{level:2,title:"通过代码",slug:"通过代码",charIndex:158},{level:2,title:"官方题解",slug:"官方题解",charIndex:1270},{level:2,title:"提交历史",slug:"提交历史",charIndex:4108},{level:2,title:"统计信息",slug:"统计信息",charIndex:4346},{level:2,title:"相似题目",slug:"相似题目",charIndex:4382}],lastUpdated:"4/11/2021, 1:15:21 PM",headersStr:"中文题目 通过代码 官方题解 提交历史 统计信息 相似题目",content:'# 中文题目\n给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。\n\n说明：\n\n你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？\n\n示例 1:\n\n输入: [2,2,1]\n输出: 1\n\n\n示例 2:\n\n输入: [4,1,2,1,2]\n输出: 4\n\n# 通过代码\nclass Solution {\n    public int singleNumber(int[] nums) {\n//        如果我们对 0 和二进制位做 XOR 运算，得到的仍然是这个二进制位\n//        aâ0=a\n//        如果我们对ç¸åçäºè¿å¶ä½å XOR 运算，返回的结果是 0\n//        aâa=0\n//        XOR 满足交换律和结合律\n//        aâbâa=(aâa)âb=0âb=b\n//        所以我们只需要将所有的数进行 XOR 操作，得到那个唯一的数字。\n\n        int res = nums[0];\n        for(int t = 1 ;t < nums.length;t++)\n        {\n            res = res^nums[t];\n        }\n        return res;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\nclass Solution {\n    public int singleNumber(int[] nums) {\n        HashMap<Integer,Integer> map=new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            if (map.containsKey(nums[i])){\n                int res=map.get(nums[i]);\n                map.put(nums[i],++res);\n            }else {\n                map.put(nums[i],1);\n            }\n        }\n\n        for (Map.Entry<Integer,Integer> temp:map.entrySet()) {\n            if (temp.getValue()==1){\n                return temp.getKey();\n            }\n        }\n        return 0;\n    }\n\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n# 官方题解\n# 方法 1：列表操作\n算法\n\n 1. 遍历 nums\\text{nums}nums 中的每一个元素\n 2. 如果某个 nums\\text{nums}nums 中的数字是新出现的，则将它添加到列表中\n 3. 如果某个数字已经在列表中，删除它\n\nclass Solution(object):\n    def singleNumber(self, nums):\n        """\n        :type nums: List[int]\n        :rtype: int\n        """\n        no_duplicate_list = []\n        for i in nums:\n            if i not in no_duplicate_list:\n                no_duplicate_list.append(i)\n            else:\n                no_duplicate_list.remove(i)\n        return no_duplicate_list.pop()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n复杂度分析\n\n * 时间复杂度：O(n2)O(n^2)O(n2) 。我们遍历 nums\\text{nums}nums 花费 O(n)O(n)O(n) 的时间。我们还要在列表中遍历判断是否存在这个数字，花费 O(n)O(n)O(n) 的时间，所以总循环时间为 O(n2)O(n^2)O(n2) 。\n * 空间复杂度：O(n)O(n)O(n) 。我们需要一个大小为 nnn 的列表保存所有的 nums\\text{nums}nums 中元素。\n\n# 方法 2：哈希表\n算法\n\n我们用哈希表避免每次查找元素是否存在需要的 O(n)O(n)O(n) 时间。\n\n 1. 遍历 nums\\text{nums}nums 中的每一个元素\n 2. 查找 hash_tablehash\\_tablehash_table 中是否有当前元素的键\n 3. 如果没有，将当前元素作为键插入 hash_tablehash\\_tablehash_table\n 4. 最后， hash_tablehash\\_tablehash_table 中仅有一个元素，用 popitem 获得它\n\nclass Solution(object):\n    def singleNumber(self, nums):\n        """\n        :type nums: List[int]\n        :rtype: int\n        """\n        hash_table = {}\n        for i in nums:\n            try:\n                hash_table.pop(i)\n            except:\n                hash_table[i] = 1\n        return hash_table.popitem()[0]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n复杂度分析\n\n * 时间复杂度： O(n⋅1)=O(n)O(n \\cdot 1) = O(n)O(n⋅1)=O(n) 。for 循环的时间复杂度是 O(n)O(n)O(n) 的。Python 中哈希表的 pop 操作时间复杂度为O(1)O(1)O(1) 。\n * 空间复杂度： O(n)O(n)O(n) 。hash_tablehash\\_tablehash_table 需要的空间与 nums\\text{nums}nums 中元素个数相等。\n\n# 方法 3：数学\n概念\n\n2∗(a+b+c)−(a+a+b+b+c)=c2 * (a + b + c) - (a + a + b + b + c) = c2∗(a+b+c)−(a+a+b+b+c)=c\n\nclass Solution(object):\n    def singleNumber(self, nums):\n        """\n        :type nums: List[int]\n        :rtype: int\n        """\n        return 2 * sum(set(nums)) - sum(nums)\n\n\n1\n2\n3\n4\n5\n6\n7\n复杂度分析\n\n * 时间复杂度：O(n+n)=O(n)O(n + n) = O(n)O(n+n)=O(n) 。sum 会调用 next 将 nums\\text{nums}nums 中的元素遍历一遍。我们可以把上述代码看成 sum(list(i, for i in nums)) ，这意味着时间复杂度为 O(n)O(n)O(n) ，因为 nums\\text{nums}nums 中的元素个数是 nnn 个。\n * 空间复杂度： O(n+n)=O(n)O(n + n) = O(n)O(n+n)=O(n) 。 set 需要的空间跟 nums 中元素个数相等。\n\n# 方法 4：位操作\n概念\n\n * 如果我们对 0 和二进制位做 XOR 运算，得到的仍然是这个二进制位 * a⊕0=aa \\oplus 0 = aa⊕0=a\n   \n   \n * 如果我们对相同的二进制位做 XOR 运算，返回的结果是 0 * a⊕a=0a \\oplus a = 0a⊕a=0\n   \n   \n * XOR 满足交换律和结合律 * a⊕b⊕a=(a⊕a)⊕b=0⊕b=ba \\oplus b \\oplus a = (a \\oplus a) \\oplus b = 0 \\oplus b = ba⊕b⊕a=(a⊕a)⊕b=0⊕b=b\n   \n   \n\n所以我们只需要将所有的数进行 XOR 操作，得到那个唯一的数字。\n\nclass Solution(object):\n    def singleNumber(self, nums):\n        """\n        :type nums: List[int]\n        :rtype: int\n        """\n        a = 0\n        for i in nums:\n            a ^= i\n        return a\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n复杂度分析\n\n * 时间复杂度： O(n)O(n)O(n) 。我们只需要将 nums\\text{nums}nums 中的元素遍历一遍，所以时间复杂度就是 nums\\text{nums}nums 中的元素个数。\n * 空间复杂度：O(1)O(1)O(1) 。\n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2020-01-05 15:33:39Accepted [https://leetcode-cn.com//submissions/detail/42344768/]1 ms99.55%39.1 MBjava2020-01-05 15:16:54Accepted [https://leetcode-cn.com//submissions/detail/42342890/]14 ms20.18%39.9 MBjava# 统计信息\n通过次数提交次数AC比率13880221409964.8%# 相似题目\n题目难度只出现一次的数字 II [https://leetcode-cn.com/problems/single-number-ii/]中等只出现一次的数字 III [https://leetcode-cn.com/problems/single-number-iii/]中等缺失数字 [https://leetcode-cn.com/problems/missing-number/]简单寻找重复数 [https://leetcode-cn.com/problems/find-the-duplicate-number/]中等找不同 [https://leetcode-cn.com/problems/find-the-difference/]简单',contentLowercase:'# 中文题目\n给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。\n\n说明：\n\n你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？\n\n示例 1:\n\n输入: [2,2,1]\n输出: 1\n\n\n示例 2:\n\n输入: [4,1,2,1,2]\n输出: 4\n\n# 通过代码\nclass solution {\n    public int singlenumber(int[] nums) {\n//        如果我们对 0 和二进制位做 xor 运算，得到的仍然是这个二进制位\n//        aâ0=a\n//        如果我们对ç¸åçäºè¿å¶ä½å xor 运算，返回的结果是 0\n//        aâa=0\n//        xor 满足交换律和结合律\n//        aâbâa=(aâa)âb=0âb=b\n//        所以我们只需要将所有的数进行 xor 操作，得到那个唯一的数字。\n\n        int res = nums[0];\n        for(int t = 1 ;t < nums.length;t++)\n        {\n            res = res^nums[t];\n        }\n        return res;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\nclass solution {\n    public int singlenumber(int[] nums) {\n        hashmap<integer,integer> map=new hashmap<>();\n        for (int i = 0; i < nums.length; i++) {\n            if (map.containskey(nums[i])){\n                int res=map.get(nums[i]);\n                map.put(nums[i],++res);\n            }else {\n                map.put(nums[i],1);\n            }\n        }\n\n        for (map.entry<integer,integer> temp:map.entryset()) {\n            if (temp.getvalue()==1){\n                return temp.getkey();\n            }\n        }\n        return 0;\n    }\n\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n# 官方题解\n# 方法 1：列表操作\n算法\n\n 1. 遍历 nums\\text{nums}nums 中的每一个元素\n 2. 如果某个 nums\\text{nums}nums 中的数字是新出现的，则将它添加到列表中\n 3. 如果某个数字已经在列表中，删除它\n\nclass solution(object):\n    def singlenumber(self, nums):\n        """\n        :type nums: list[int]\n        :rtype: int\n        """\n        no_duplicate_list = []\n        for i in nums:\n            if i not in no_duplicate_list:\n                no_duplicate_list.append(i)\n            else:\n                no_duplicate_list.remove(i)\n        return no_duplicate_list.pop()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n复杂度分析\n\n * 时间复杂度：o(n2)o(n^2)o(n2) 。我们遍历 nums\\text{nums}nums 花费 o(n)o(n)o(n) 的时间。我们还要在列表中遍历判断是否存在这个数字，花费 o(n)o(n)o(n) 的时间，所以总循环时间为 o(n2)o(n^2)o(n2) 。\n * 空间复杂度：o(n)o(n)o(n) 。我们需要一个大小为 nnn 的列表保存所有的 nums\\text{nums}nums 中元素。\n\n# 方法 2：哈希表\n算法\n\n我们用哈希表避免每次查找元素是否存在需要的 o(n)o(n)o(n) 时间。\n\n 1. 遍历 nums\\text{nums}nums 中的每一个元素\n 2. 查找 hash_tablehash\\_tablehash_table 中是否有当前元素的键\n 3. 如果没有，将当前元素作为键插入 hash_tablehash\\_tablehash_table\n 4. 最后， hash_tablehash\\_tablehash_table 中仅有一个元素，用 popitem 获得它\n\nclass solution(object):\n    def singlenumber(self, nums):\n        """\n        :type nums: list[int]\n        :rtype: int\n        """\n        hash_table = {}\n        for i in nums:\n            try:\n                hash_table.pop(i)\n            except:\n                hash_table[i] = 1\n        return hash_table.popitem()[0]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n复杂度分析\n\n * 时间复杂度： o(n⋅1)=o(n)o(n \\cdot 1) = o(n)o(n⋅1)=o(n) 。for 循环的时间复杂度是 o(n)o(n)o(n) 的。python 中哈希表的 pop 操作时间复杂度为o(1)o(1)o(1) 。\n * 空间复杂度： o(n)o(n)o(n) 。hash_tablehash\\_tablehash_table 需要的空间与 nums\\text{nums}nums 中元素个数相等。\n\n# 方法 3：数学\n概念\n\n2∗(a+b+c)−(a+a+b+b+c)=c2 * (a + b + c) - (a + a + b + b + c) = c2∗(a+b+c)−(a+a+b+b+c)=c\n\nclass solution(object):\n    def singlenumber(self, nums):\n        """\n        :type nums: list[int]\n        :rtype: int\n        """\n        return 2 * sum(set(nums)) - sum(nums)\n\n\n1\n2\n3\n4\n5\n6\n7\n复杂度分析\n\n * 时间复杂度：o(n+n)=o(n)o(n + n) = o(n)o(n+n)=o(n) 。sum 会调用 next 将 nums\\text{nums}nums 中的元素遍历一遍。我们可以把上述代码看成 sum(list(i, for i in nums)) ，这意味着时间复杂度为 o(n)o(n)o(n) ，因为 nums\\text{nums}nums 中的元素个数是 nnn 个。\n * 空间复杂度： o(n+n)=o(n)o(n + n) = o(n)o(n+n)=o(n) 。 set 需要的空间跟 nums 中元素个数相等。\n\n# 方法 4：位操作\n概念\n\n * 如果我们对 0 和二进制位做 xor 运算，得到的仍然是这个二进制位 * a⊕0=aa \\oplus 0 = aa⊕0=a\n   \n   \n * 如果我们对相同的二进制位做 xor 运算，返回的结果是 0 * a⊕a=0a \\oplus a = 0a⊕a=0\n   \n   \n * xor 满足交换律和结合律 * a⊕b⊕a=(a⊕a)⊕b=0⊕b=ba \\oplus b \\oplus a = (a \\oplus a) \\oplus b = 0 \\oplus b = ba⊕b⊕a=(a⊕a)⊕b=0⊕b=b\n   \n   \n\n所以我们只需要将所有的数进行 xor 操作，得到那个唯一的数字。\n\nclass solution(object):\n    def singlenumber(self, nums):\n        """\n        :type nums: list[int]\n        :rtype: int\n        """\n        a = 0\n        for i in nums:\n            a ^= i\n        return a\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n复杂度分析\n\n * 时间复杂度： o(n)o(n)o(n) 。我们只需要将 nums\\text{nums}nums 中的元素遍历一遍，所以时间复杂度就是 nums\\text{nums}nums 中的元素个数。\n * 空间复杂度：o(1)o(1)o(1) 。\n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2020-01-05 15:33:39accepted [https://leetcode-cn.com//submissions/detail/42344768/]1 ms99.55%39.1 mbjava2020-01-05 15:16:54accepted [https://leetcode-cn.com//submissions/detail/42342890/]14 ms20.18%39.9 mbjava# 统计信息\n通过次数提交次数ac比率13880221409964.8%# 相似题目\n题目难度只出现一次的数字 ii [https://leetcode-cn.com/problems/single-number-ii/]中等只出现一次的数字 iii [https://leetcode-cn.com/problems/single-number-iii/]中等缺失数字 [https://leetcode-cn.com/problems/missing-number/]简单寻找重复数 [https://leetcode-cn.com/problems/find-the-duplicate-number/]中等找不同 [https://leetcode-cn.com/problems/find-the-difference/]简单'},{title:"167-两数之和 II - 输入有序数组(Two Sum II - Input array is sorted)",frontmatter:{title:"167-两数之和 II - 输入有序数组(Two Sum II - Input array is sorted)",date:"2018-05-16T00:00:00.000Z",categories:["简单"],tags:["数组<Array>","双指针<Two Pointers>","二分查找<Binary Search>"]},regularPath:"/views/%E7%AE%80%E5%8D%95/0167-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C%20II%20-%20%E8%BE%93%E5%85%A5%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84.html",relativePath:"views/简单/0167-两数之和 II - 输入有序数组.md",key:"v-1676ace0",path:"/views/%E7%AE%80%E5%8D%95/0167-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C%20II%20-%20%E8%BE%93%E5%85%A5%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84.html",headers:[{level:2,title:"中文题目",slug:"中文题目",charIndex:2},{level:2,title:"通过代码",slug:"通过代码",charIndex:285},{level:2,title:"官方题解",slug:"官方题解",charIndex:1488},{level:2,title:"提交历史",slug:"提交历史",charIndex:2790},{level:2,title:"统计信息",slug:"统计信息",charIndex:3017},{level:2,title:"相似题目",slug:"相似题目",charIndex:3052}],lastUpdated:"4/11/2021, 1:15:21 PM",headersStr:"中文题目 通过代码 官方题解 提交历史 统计信息 相似题目",content:"# 中文题目\n给定一个已按照升序排列的有序数组，找到两个数使得它们相加之和等于目标数。\n\n函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2。\n\n说明:\n\n * 返回的下标值（index1 和 index2）不是从零开始的。\n * 你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。\n\n示例:\n\n输入: numbers = [2, 7, 11, 15], target = 9\n输出: [1,2]\n解释: 2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。\n\n# 通过代码\nclass Solution {\n    public int[] twoSum(int[] numbers, int target) {\n          if (null==numbers || numbers.length==0){\n                return null;\n            }\n            int lo=0;\n            int hi=numbers.length-1;\n            while (lo<hi){\n                if (numbers[lo]+numbers[hi]<target){\n                    lo++;\n                }else if (numbers[lo]+numbers[hi]>target){\n                    hi--;\n                }else {\n                    return new int[]{lo+1,hi+1};\n                }\n            }\n            return null;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\nclass Solution {\n    public int[] twoSum(int[] numbers, int target) {\n          if (null==numbers || numbers.length==0){\n                return null;\n            }\n            int lo=0;\n            int hi=numbers.length-1;\n            while (lo<hi){\n                if (numbers[lo]+numbers[hi]<target){\n                    lo++;\n                }else if (numbers[lo]+numbers[hi]>target){\n                    hi--;\n                }else {\n                    return new int[]{lo+1,hi+1};\n                }\n            }\n            return null;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n# 官方题解\n# 方法 1：双指针\n算法\n\n我们可以使用 两数之和 [https://leetcode-cn.com/problems/two-sum/solution/liang-shu-zhi-he-by-leetcode-2/] 的解法在 O(n2)O(n^2)O(n2) 时间 O(1)O(1)O(1) 空间暴力解决，也可以用哈希表在 O(n)O(n)O(n) 时间和 O(n)O(n)O(n) 空间内解决。然而，这两种方法都没有用到输入数组已经排序的性质，我们可以做得更好。\n\n我们使用两个指针，初始分别位于第一个元素和最后一个元素位置，比较这两个元素之和与目标值的大小。如果和等于目标值，我们发现了这个唯一解。如果比目标值小，我们将较小元素指针增加一。如果比目标值大，我们将较大指针减小一。移动指针后重复上述比较知道找到答案。\n\n假设 [...,a,b,c,...,d,e,f,…][... , a, b, c, ... , d, e, f, …][...,a,b,c,...,d,e,f,…] 是已经升序排列的输入数组，并且元素 b,eb, eb,e 是唯一解。因为我们从左到右移动较小指针，从右到左移动较大指针，总有某个时刻存在一个指针移动到 bbb 或 eee 的位置。不妨假设小指针县移动到了元素 bbb ，这是两个元素的和一定比目标值大，根据我们的算法，我们会向左移动较大指针直至获得结果。\n\nclass Solution {\npublic:\n    vector<int> twoSum(vector<int>& numbers, int target) {\n        int low = 0, high = numbers.size() - 1;\n        while (low < high) {\n            int sum = numbers[low] + numbers[high];\n            if (sum == target)\n                return {low + 1, high + 1};\n            else if (sum < target)\n                ++low;\n            else\n                --high;\n        }\n        return {-1, -1};\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n是否需要考虑 numbers[low]+numbers[high]numbers[low] + numbers[high]numbers[low]+numbers[high] 溢出呢？答案是不需要。因为即使两个元素之和溢出了，因为只存在唯一解，所以一定会先访问到答案。\n\n复杂度分析\n\n * 时间复杂度：O(n)O(n)O(n)。每个元素最多被访问一次，共有 nnn 个元素。\n * 空间复杂度：O(1)O(1)O(1)。只是用了两个指针。\n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-05-16 18:23:14Accepted [https://leetcode-cn.com//submissions/detail/2331800/]4 ms27.04%N/Ajava2018-05-16 18:21:28Accepted [https://leetcode-cn.com//submissions/detail/2331772/]3 ms35.88%N/Ajava# 统计信息\n通过次数提交次数AC比率6048111658351.9%# 相似题目\n题目难度两数之和 [https://leetcode-cn.com/problems/two-sum/]简单两数之和 IV - 输入 BST [https://leetcode-cn.com/problems/two-sum-iv-input-is-a-bst/]简单小于 K 的两数之和 [https://leetcode-cn.com/problems/two-sum-less-than-k/]简单",contentLowercase:"# 中文题目\n给定一个已按照升序排列的有序数组，找到两个数使得它们相加之和等于目标数。\n\n函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2。\n\n说明:\n\n * 返回的下标值（index1 和 index2）不是从零开始的。\n * 你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。\n\n示例:\n\n输入: numbers = [2, 7, 11, 15], target = 9\n输出: [1,2]\n解释: 2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。\n\n# 通过代码\nclass solution {\n    public int[] twosum(int[] numbers, int target) {\n          if (null==numbers || numbers.length==0){\n                return null;\n            }\n            int lo=0;\n            int hi=numbers.length-1;\n            while (lo<hi){\n                if (numbers[lo]+numbers[hi]<target){\n                    lo++;\n                }else if (numbers[lo]+numbers[hi]>target){\n                    hi--;\n                }else {\n                    return new int[]{lo+1,hi+1};\n                }\n            }\n            return null;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\nclass solution {\n    public int[] twosum(int[] numbers, int target) {\n          if (null==numbers || numbers.length==0){\n                return null;\n            }\n            int lo=0;\n            int hi=numbers.length-1;\n            while (lo<hi){\n                if (numbers[lo]+numbers[hi]<target){\n                    lo++;\n                }else if (numbers[lo]+numbers[hi]>target){\n                    hi--;\n                }else {\n                    return new int[]{lo+1,hi+1};\n                }\n            }\n            return null;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n# 官方题解\n# 方法 1：双指针\n算法\n\n我们可以使用 两数之和 [https://leetcode-cn.com/problems/two-sum/solution/liang-shu-zhi-he-by-leetcode-2/] 的解法在 o(n2)o(n^2)o(n2) 时间 o(1)o(1)o(1) 空间暴力解决，也可以用哈希表在 o(n)o(n)o(n) 时间和 o(n)o(n)o(n) 空间内解决。然而，这两种方法都没有用到输入数组已经排序的性质，我们可以做得更好。\n\n我们使用两个指针，初始分别位于第一个元素和最后一个元素位置，比较这两个元素之和与目标值的大小。如果和等于目标值，我们发现了这个唯一解。如果比目标值小，我们将较小元素指针增加一。如果比目标值大，我们将较大指针减小一。移动指针后重复上述比较知道找到答案。\n\n假设 [...,a,b,c,...,d,e,f,…][... , a, b, c, ... , d, e, f, …][...,a,b,c,...,d,e,f,…] 是已经升序排列的输入数组，并且元素 b,eb, eb,e 是唯一解。因为我们从左到右移动较小指针，从右到左移动较大指针，总有某个时刻存在一个指针移动到 bbb 或 eee 的位置。不妨假设小指针县移动到了元素 bbb ，这是两个元素的和一定比目标值大，根据我们的算法，我们会向左移动较大指针直至获得结果。\n\nclass solution {\npublic:\n    vector<int> twosum(vector<int>& numbers, int target) {\n        int low = 0, high = numbers.size() - 1;\n        while (low < high) {\n            int sum = numbers[low] + numbers[high];\n            if (sum == target)\n                return {low + 1, high + 1};\n            else if (sum < target)\n                ++low;\n            else\n                --high;\n        }\n        return {-1, -1};\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n是否需要考虑 numbers[low]+numbers[high]numbers[low] + numbers[high]numbers[low]+numbers[high] 溢出呢？答案是不需要。因为即使两个元素之和溢出了，因为只存在唯一解，所以一定会先访问到答案。\n\n复杂度分析\n\n * 时间复杂度：o(n)o(n)o(n)。每个元素最多被访问一次，共有 nnn 个元素。\n * 空间复杂度：o(1)o(1)o(1)。只是用了两个指针。\n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-05-16 18:23:14accepted [https://leetcode-cn.com//submissions/detail/2331800/]4 ms27.04%n/ajava2018-05-16 18:21:28accepted [https://leetcode-cn.com//submissions/detail/2331772/]3 ms35.88%n/ajava# 统计信息\n通过次数提交次数ac比率6048111658351.9%# 相似题目\n题目难度两数之和 [https://leetcode-cn.com/problems/two-sum/]简单两数之和 iv - 输入 bst [https://leetcode-cn.com/problems/two-sum-iv-input-is-a-bst/]简单小于 k 的两数之和 [https://leetcode-cn.com/problems/two-sum-less-than-k/]简单"},{title:"168-Excel表列名称(Excel Sheet Column Title)",frontmatter:{title:"168-Excel表列名称(Excel Sheet Column Title)",date:"2020-01-02T00:00:00.000Z",categories:["简单"],tags:["数学<Math>"]},regularPath:"/views/%E7%AE%80%E5%8D%95/0168-Excel%E8%A1%A8%E5%88%97%E5%90%8D%E7%A7%B0.html",relativePath:"views/简单/0168-Excel表列名称.md",key:"v-fa980d7a",path:"/views/%E7%AE%80%E5%8D%95/0168-Excel%E8%A1%A8%E5%88%97%E5%90%8D%E7%A7%B0.html",headers:[{level:2,title:"中文题目",slug:"中文题目",charIndex:2},{level:2,title:"通过代码",slug:"通过代码",charIndex:209},{level:2,title:"高赞题解",slug:"高赞题解",charIndex:785},{level:2,title:"思路",slug:"思路",charIndex:792},{level:2,title:"提交历史",slug:"提交历史",charIndex:1850},{level:2,title:"统计信息",slug:"统计信息",charIndex:1983},{level:2,title:"相似题目",slug:"相似题目",charIndex:2017}],lastUpdated:"4/11/2021, 1:15:21 PM",headersStr:"中文题目 通过代码 高赞题解 思路 提交历史 统计信息 相似题目",content:'# 中文题目\n给定一个正整数，返回它在 Excel 表中相对应的列名称。\n\n例如，\n\n    1 -> A\n    2 -> B\n    3 -> C\n    ...\n    26 -> Z\n    27 -> AA\n    28 -> AB \n    ...\n\n\n示例 1:\n\n输入: 1\n输出: "A"\n\n\n示例 2:\n\n输入: 28\n输出: "AB"\n\n\n示例 3:\n\n输入: 701\n输出: "ZY"\n\n\n# 通过代码\nclass Solution {\n    public String convertToTitle(int n) {\n        StringBuilder str = new StringBuilder();\n        while (n > 0) {\n            int c = n % 26;\n            if (c == 0) {\n                //由于如果能整除的话，按照26进制的话，应该是A0，为了映射成AZ，相当于进制转换后的数少了1，\n                //所以插入Z之后要原来的数要减一\n                str.insert(0, (char) (25 + \'A\'));\n                --n;\n            } else {\n                str.insert(0, (char) (c - 1 + \'A\'));\n\n            }\n            n /= 26;\n        }\n        return str.toString();       \n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n# 高赞题解\n# 思路\n做这道题要先了解一下, 十进制转二进制, 比如 6 转 成二进制多少?\n\n 2 |_ 6 _                       ^\n    2|_ 3 _  ······ 0    |\n     2|_ 1 _ ·······1    |\n       |_ 0_ ·······1    |\n \t\n\n\n1\n2\n3\n4\n5\n所以， 我们能得到二进制为 110, 这道题换句话说是十进制转26进制的\n\n但是有个难点: 如果 26 转成 字母是多少?\n\n 26|_ 26 _\n        1   ··· 0\n\n\n1\n2\n这里出现了0, 但是我们26 字母 没有任何一个字母是表示0, 所以我们可以从 商 借一个给余数\n\n  26| _ 26 _\n  \t0 ··· 26\n\n\n1\n2\n这样就可以表示出来了,所以代码如下\n\nclass Solution:\n    def convertToTitle(self, n: int) -> str:\n        res = ""\n        while n:\n            n, y = divmod(n, 26) \n            if y == 0:\n                n -= 1\n                y = 26\n            res = chr(y + 64) + res\n        return res\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n看了其他做法, 他们先让n 减一\n\nclass Solution:\n    def convertToTitle(self, n: int) -> str:\n        res = ""\n        while n:\n            n -= 1\n            n, y = divmod(n, 26) \n            res = chr(y + 65) + res\n        return res\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n还有一种递归写法:\n\nclass Solution:\n    def convertToTitle(self, n: int) -> str:\n        return "" if n == 0 else self.convertToTitle((n - 1) // 26) + chr((n - 1) % 26 + 65)\n\n\n1\n2\n3\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2020-01-02 22:57:06Accepted [https://leetcode-cn.com//submissions/detail/42081074/]0 ms100.0%34.1 MBjava# 统计信息\n通过次数提交次数AC比率178644935836.2%# 相似题目\n题目难度Excel表列序号 [https://leetcode-cn.com/problems/excel-sheet-column-number/]简单',contentLowercase:'# 中文题目\n给定一个正整数，返回它在 excel 表中相对应的列名称。\n\n例如，\n\n    1 -> a\n    2 -> b\n    3 -> c\n    ...\n    26 -> z\n    27 -> aa\n    28 -> ab \n    ...\n\n\n示例 1:\n\n输入: 1\n输出: "a"\n\n\n示例 2:\n\n输入: 28\n输出: "ab"\n\n\n示例 3:\n\n输入: 701\n输出: "zy"\n\n\n# 通过代码\nclass solution {\n    public string converttotitle(int n) {\n        stringbuilder str = new stringbuilder();\n        while (n > 0) {\n            int c = n % 26;\n            if (c == 0) {\n                //由于如果能整除的话，按照26进制的话，应该是a0，为了映射成az，相当于进制转换后的数少了1，\n                //所以插入z之后要原来的数要减一\n                str.insert(0, (char) (25 + \'a\'));\n                --n;\n            } else {\n                str.insert(0, (char) (c - 1 + \'a\'));\n\n            }\n            n /= 26;\n        }\n        return str.tostring();       \n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n# 高赞题解\n# 思路\n做这道题要先了解一下, 十进制转二进制, 比如 6 转 成二进制多少?\n\n 2 |_ 6 _                       ^\n    2|_ 3 _  ······ 0    |\n     2|_ 1 _ ·······1    |\n       |_ 0_ ·······1    |\n \t\n\n\n1\n2\n3\n4\n5\n所以， 我们能得到二进制为 110, 这道题换句话说是十进制转26进制的\n\n但是有个难点: 如果 26 转成 字母是多少?\n\n 26|_ 26 _\n        1   ··· 0\n\n\n1\n2\n这里出现了0, 但是我们26 字母 没有任何一个字母是表示0, 所以我们可以从 商 借一个给余数\n\n  26| _ 26 _\n  \t0 ··· 26\n\n\n1\n2\n这样就可以表示出来了,所以代码如下\n\nclass solution:\n    def converttotitle(self, n: int) -> str:\n        res = ""\n        while n:\n            n, y = divmod(n, 26) \n            if y == 0:\n                n -= 1\n                y = 26\n            res = chr(y + 64) + res\n        return res\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n看了其他做法, 他们先让n 减一\n\nclass solution:\n    def converttotitle(self, n: int) -> str:\n        res = ""\n        while n:\n            n -= 1\n            n, y = divmod(n, 26) \n            res = chr(y + 65) + res\n        return res\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n还有一种递归写法:\n\nclass solution:\n    def converttotitle(self, n: int) -> str:\n        return "" if n == 0 else self.converttotitle((n - 1) // 26) + chr((n - 1) % 26 + 65)\n\n\n1\n2\n3\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2020-01-02 22:57:06accepted [https://leetcode-cn.com//submissions/detail/42081074/]0 ms100.0%34.1 mbjava# 统计信息\n通过次数提交次数ac比率178644935836.2%# 相似题目\n题目难度excel表列序号 [https://leetcode-cn.com/problems/excel-sheet-column-number/]简单'},{title:"155-最小栈(Min Stack)",frontmatter:{title:"155-最小栈(Min Stack)",date:"2021-04-18T00:00:00.000Z",categories:["简单"],tags:["栈<Stack>","设计<Design>"]},regularPath:"/views/%E7%AE%80%E5%8D%95/0155-%E6%9C%80%E5%B0%8F%E6%A0%88.html",relativePath:"views/简单/0155-最小栈.md",key:"v-35262026",path:"/views/%E7%AE%80%E5%8D%95/0155-%E6%9C%80%E5%B0%8F%E6%A0%88.html",headers:[{level:2,title:"中文题目",slug:"中文题目",charIndex:2},{level:2,title:"通过代码",slug:"通过代码",charIndex:545},{level:2,title:"我的笔记",slug:"我的笔记",charIndex:3895},{level:2,title:"高赞题解",slug:"高赞题解",charIndex:3953},{level:2,title:"提交历史",slug:"提交历史",charIndex:11175},{level:2,title:"统计信息",slug:"统计信息",charIndex:11822},{level:2,title:"相似题目",slug:"相似题目",charIndex:11858}],headersStr:"中文题目 通过代码 我的笔记 高赞题解 提交历史 统计信息 相似题目",content:'# 中文题目\n设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。\n\n * push(x) —— 将元素 x 推入栈中。\n * pop()—— 删除栈顶的元素。\n * top()—— 获取栈顶元素。\n * getMin() —— 检索栈中的最小元素。\n\n\n\n示例:\n\n输入：\n["MinStack","push","push","push","getMin","pop","top","getMin"]\n[[],[-2],[0],[-3],[],[],[],[]]\n\n输出：\n[null,null,null,null,-3,null,0,-2]\n\n解释：\nMinStack minStack = new MinStack();\nminStack.push(-2);\nminStack.push(0);\nminStack.push(-3);\nminStack.getMin();   --\x3e 返回 -3.\nminStack.pop();\nminStack.top();      --\x3e 返回 0.\nminStack.getMin();   --\x3e 返回 -2.\n\n\n\n\n提示：\n\n * pop、top 和 getMin 操作总是在 非空栈 上调用。\n\n# 通过代码\n  class MinStack {\n      // 通过自定义链表的方式实现\n      private Node node;\n\n      public MinStack() {\n\n      }\n\n      public void push(int x) {\n          if (node == null){\n              node = new Node(x, x);\n          }else {\n              // node = new Node(x, Math.min(x, node.min), node);\n              Node next = new Node(x, Math.min(x, node.min));\n              next.prev = node;\n              node = next;\n          }\n      }\n\n      public void pop() {\n          node = node.prev;\n      }\n\n      public int top() {\n          return node.val;\n      }\n\n      public int getMin() {\n          return node.min;\n      }\n\n      private class Node {\n          int val;\n          int min;\n          Node prev;\n\n          private Node(int val, int min){\n              this.val = val;\n              this.min = min;\n          }\n\n          private Node(int val, int min, Node prev){\n              this.val = val;\n              this.min = min;\n              this.prev = prev;\n          }\n      }\n  }\n\n/**\n * Your MinStack object will be instantiated and called as such:\n * MinStack obj = new MinStack();\n * obj.push(val);\n * obj.pop();\n * int param_3 = obj.top();\n * int param_4 = obj.getMin();\n */\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\nclass MinStack {\n    // 可以通过在栈中存放数组的方式实现,数组中放两个元素，[当前值，最小值]\n      private Stack<int[]> stack=new Stack<>();\n\n    /** initialize your data structure here. */\n    public MinStack() {\n\n    }\n    \n    public void push(int val) {\n        if (stack.isEmpty()){\n            stack.push(new int[]{val,val});\n        }else{\n            stack.push(new int[]{val,Math.min(val,stack.peek()[1])});\n        }\n    }\n    \n    public void pop() {\n        stack.pop();\n    }\n    \n    public int top() {\n        return stack.peek()[0];\n    }\n    \n    public int getMin() {\n        return stack.peek()[1];\n    }\n}\n\n/**\n * Your MinStack object will be instantiated and called as such:\n * MinStack obj = new MinStack();\n * obj.push(val);\n * obj.pop();\n * int param_3 = obj.top();\n * int param_4 = obj.getMin();\n */\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\nclass MinStack {\n        Stack<Integer> stack;\n        Stack<Integer> minStack;\n        Integer min;\n\n        /**\n         * initialize your data structure here.\n         */\n        public MinStack() {\n            stack=new Stack<>();\n            minStack=new Stack<>();\n            min=Integer.MAX_VALUE;\n        }\n\n        public void push(int val) {\n            stack.push(val);\n            min=Math.min(min,val);\n            minStack.push(min);\n        }\n\n        public void pop() {\n            stack.pop();\n            minStack.pop();\n            // 当栈空了的时候，需要重置最小值为整数最大值\n            if (minStack.isEmpty()){\n                min=Integer.MAX_VALUE;\n                return;\n            }\n            // 最小值被弹出了，需重设最小的值为最小栈中的最小值\n            if (!min.equals(getMin())){\n                min=getMin();\n            }\n        }\n\n        public int top() {\n            return stack.peek();\n        }\n\n        public int getMin() {\n            return minStack.peek();\n        }\n    }\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n# 我的笔记\n主要需要对当前的最小值进行判断，特别时下面两种情况\n\n 1. 最小值被弹出了\n 2. 最小栈为空了\n\n# 高赞题解\n# 题目描述（简单难度）\n\n\n设计数据结构的题，设计一个栈，除了栈特有的功能，入栈、出栈、查看栈顶元素，还需要增加一个功能，得到当前栈里边最小的元素。\n\n# 解法一\n要实现一个 stack，那么我们还能用 java 自带的 stack 吗？也不用纠结，这道题的关键其实是实现「得到最小值这个功能」，所以为了代码简洁些，我们就直接使用系统自带的 stack 了。\n\n这道题最直接的解法就是我们可以用两个栈，一个栈去保存正常的入栈出栈的值，另一个栈去存最小值，也就是用栈顶保存当前所有元素的最小值。存最小值的栈的具体操作流程如下：\n\n将第一个元素入栈。\n\n新加入的元素如果大于栈顶元素，那么新加入的元素就不处理。\n\n新加入的元素如果小于等于栈顶元素，那么就将新元素入栈。\n\n出栈元素不等于栈顶元素，不操作。\n\n出栈元素等于栈顶元素，那么就将栈顶元素出栈。\n\n举个例子。\n\n入栈 3 \n|   |    |   |\n|   |    |   |\n|_3_|    |_3_|\nstack  minStack\n\n入栈 5 ， 5 大于 minStack 栈顶，不处理\n|   |    |   |\n| 5 |    |   |\n|_3_|    |_3_|\nstack  minStack\n\n入栈 2 ，此时右边的 minStack 栈顶就保存了当前最小值 2 \n| 2 |    |   |\n| 5 |    | 2 |\n|_3_|    |_3_|\nstack  minStack\n\n出栈 2，此时右边的 minStack 栈顶就保存了当前最小值 3\n|   |    |   |\n| 5 |    |   |\n|_3_|    |_3_|\nstack  minStack\n\n出栈 5，右边 minStack 不处理\n|   |    |   |\n|   |    |   |\n|_3_|    |_3_|\nstack  minStack\n\n出栈 3\n|   |    |   |\n|   |    |   |\n|_ _|    |_ _|\nstack  minStack\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n代码的话就很好写了。\n\nclass MinStack {\n    /** initialize your data structure here. */\n    private Stack<Integer> stack;\n    private Stack<Integer> minStack;\n\n    public MinStack() {\n        stack = new Stack<>();\n        minStack = new Stack<>();\n    }\n\n    public void push(int x) {\n        stack.push(x);\n        if (!minStack.isEmpty()) {\n            int top = minStack.peek();\n            //小于的时候才入栈\n            if (x <= top) {\n                minStack.push(x);\n            }\n        }else{\n            minStack.push(x);\n        }\n    }\n\n    public void pop() {\n        int pop = stack.pop();\n\n        int top = minStack.peek();\n        //等于的时候再出栈\n        if (pop == top) {\n            minStack.pop();\n        }\n\n    }\n\n    public int top() {\n        return stack.peek();\n    }\n\n    public int getMin() {\n        return minStack.peek();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n# 解法二\n解法一中用了两个栈去实现，那么我们能不能用一个栈去实现呢？\n\n参考了 这里 [https://leetcode.com/problems/min-stack/discuss/49014/Java-accepted-solution-using-one-stack]。\n\n解法一中单独用了一个栈去保存所有最小值，那么我们能不能只用一个变量去保存最小值呢？\n\n再看一下上边的例子。\n\n入栈 3 \n|   |   min = 3\n|   |     \n|_3_|    \nstack   \n\n入栈 5 \n|   |   min = 3\n| 5 |     \n|_3_|    \nstack  \n\n入栈 2 \n| 2 |   min = 2?\n| 5 |     \n|_3_|    \nstack  \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n如果只用一个变量就会遇到一个问题，如果把 min 更新为 2，那么之前的最小值 3 就丢失了。\n\n怎么把 3 保存起来呢？把它在 2 之前压入栈中即可。\n\n入栈 2 ，同时将之前的 min 值 3 入栈，再把 2 入栈，同时更新 min = 2\n| 2 |   min = 2\n| 3 |  \n| 5 |     \n|_3_|    \nstack  \n\n入栈 6 \n| 6 |  min = 2\n| 2 |   \n| 3 |  \n| 5 |     \n|_3_|    \nstack  \n\n出栈 6     \n| 2 |   min = 2\n| 3 |  \n| 5 |     \n|_3_|    \nstack  \n\n出栈 2     \n| 2 |   min = 2\n| 3 |  \n| 5 |     \n|_3_|    \nstack  \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n上边的最后一个状态，当出栈元素是最小元素我们该如何处理呢？\n\n我们只需要把 2 出栈，然后再出栈一次，把 3 赋值给 min 即可。\n\n出栈 2     \n|   |  min = 3   \n| 5 |   \n|_3_|    \nstack  \n\n\n1\n2\n3\n4\n5\n通过上边的方式，我们就只需要一个栈了。当有更小的值来的时候，我们只需要把之前的最小值入栈，当前更小的值再入栈即可。当这个最小值要出栈的时候，下一个值便是之前的最小值了。\n\nclass MinStack {\n    int min = Integer.MAX_VALUE;\n    Stack<Integer> stack = new Stack<Integer>();\n    public void push(int x) {\n        //当前值更小\n        if(x <= min){   \n            //将之前的最小值保存\n            stack.push(min);\n            //更新最小值\n            min=x;\n        }\n        stack.push(x);\n    }\n\n    public void pop() {\n        //如果弹出的值是最小值，那么将下一个元素更新为最小值\n        if(stack.pop() == min) {\n            min=stack.pop();\n        }\n    }\n\n    public int top() {\n        return stack.peek();\n    }\n\n    public int getMin() {\n        return min;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n# 解法三\n参考 这里 [https://leetcode.com/problems/min-stack/discuss/49031/Share-my-Java-solution-with-ONLY-ONE-stack]，再分享利用一个栈的另一种思路。\n\n通过解法二的分析，我们关键要解决的问题就是当有新的更小值的时候，之前的最小值该怎么办？\n\n解法二中通过把之前的最小值入栈解决问题。\n\n这里的话，用了另一种思路。同样是用一个 min 变量保存最小值。只不过栈里边我们不去保存原来的值，而是去存储入栈的值和最小值的差值。然后得到之前的最小值的话，我们就可以通过 min 值和栈顶元素得到，举个例子。\n\n入栈 3，存入 3 - 3 = 0\n|   |   min = 3\n|   |     \n|_0_|    \nstack   \n\n入栈 5，存入 5 - 3 = 2\n|   |   min = 3\n| 2 |     \n|_0_|    \nstack  \n\n入栈 2，因为出现了更小的数，所以我们会存入一个负数，这里很关键\n也就是存入  2 - 3 = -1, 并且更新 min = 2 \n对于之前的 min 值 3, 我们只需要用更新后的 min - 栈顶元素 -1 就可以得到    \n| -1|   min = 2\n| 5 |     \n|_3_|    \nstack  \n\n入栈 6，存入  6 - 2 = 4\n| 4 |   min = 2\n| -1| \n| 5 |     \n|_3_|    \nstack  \n\n出栈，返回的值就是栈顶元素 4 加上 min，就是 6\n|   |   min = 2\n| -1| \n| 5 |     \n|_3_|    \nstack  \n\n出栈，此时栈顶元素是负数，说明之前对 min 值进行了更新。\n入栈元素 - min = 栈顶元素，入栈元素其实就是当前的 min 值 2\n所以更新前的 min 就等于入栈元素 2 - 栈顶元素(-1) = 3\n|   | min = 3\n| 5 |     \n|_3_|    \nstack     \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n再理一下上边的思路，我们每次存入的是 原来值 - 当前最小值。\n\n当原来值大于等于当前最小值的时候，我们存入的肯定就是非负数，所以出栈的时候就是 栈中的值 + 当前最小值 。\n\n当原来值小于当前最小值的时候，我们存入的肯定就是负值，此时的值我们不入栈，用 min 保存起来，同时将差值入栈。\n\n当后续如果出栈元素是负数的时候，那么要出栈的元素其实就是 min。此外之前的 min 值，我们可以通过栈顶的值和当前 min 值进行还原，就是用 min 减去栈顶元素即可。\n\npublic class MinStack {\n    long min;\n\tStack<Long> stack;\n\n\tpublic MinStack(){\n        stack=new Stack<>();\n    }\n\n\tpublic void push(int x) {\n\t\tif (stack.isEmpty()) {\n\t\t\tmin = x;\n\t\t\tstack.push(x - min);\n\t\t} else {\n\t\t\tstack.push(x - min);\n\t\t\tif (x < min){\n\t\t\t\tmin = x; // 更新最小值\n\t\t\t}\n\t\t\t\t\n\t\t}\n\t}\n\n\tpublic void pop() {\n\t\tif (stack.isEmpty())\n\t\t\treturn;\n\n\t\tlong pop = stack.pop();\n\t\t\n\t\t//弹出的是负值，要更新 min\n\t\tif (pop < 0) {\n\t\t\tmin = min - pop;\n\t\t}\n\n\t}\n\n\tpublic int top() {\n\t\tlong top = stack.peek();\n\t\t//负数的话，出栈的值保存在 min 中\n\t\tif (top < 0) {\n\t\t\treturn (int) (min);\n        //出栈元素加上最小值即可\n\t\t} else {\n\t\t\treturn (int) (top + min);\n\t\t}\n\t}\n\n\tpublic int getMin() {\n\t\treturn (int) min;\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n上边的解法的一个缺点就是由于我们保存的是差值，所以可能造成溢出，所以我们用了数据范围更大的 long 类型。\n\n此外相对于解法二，最小值需要更新的时候，我们并没有将之前的最小值存起来，我们每次都是通过当前最小值和栈顶元素推出了之前的最小值，所以会省一些空间。\n\n# 解法四\n再分享一个有趣的解法，参考 这里 [https://leetcode.com/problems/min-stack/discuss/49217/6ms-Java-Solution-using-Linked-List.-Clean-self-explanatory-and-efficient.] 。\n\n回到最初的疑虑，我们要不要用 java 提供的 stack 。如果不用的话，可以怎么做的？\n\n直接用一个链表即可实现栈的基本功能，那么最小值该怎么得到呢？我们可以在 Node 节点中增加一个 min 字段，这样的话每次加入一个节点的时候，我们同时只要确定它的 min 值即可。\n\n代码很简洁，我直接把代码贴过来吧。\n\nclass MinStack {\n    class Node{\n        int value;\n        int min;\n        Node next;\n\n        Node(int x, int min){\n            this.value=x;\n            this.min=min;\n            next = null;\n        }\n    }\n    Node head;\n    //每次加入的节点放到头部\n    public void push(int x) {\n        if(null==head){\n            head = new Node(x,x);\n        }else{\n            //当前值和之前头结点的最小值较小的做为当前的 min\n            Node n = new Node(x, Math.min(x,head.min));\n            n.next=head;\n            head=n;\n        }\n    }\n\n    public void pop() {\n        if(head!=null)\n            head =head.next;\n    }\n\n    public int top() {\n        if(head!=null)\n            return head.value;\n        return -1;\n    }\n\n    public int getMin() {\n        if(null!=head)\n            return head.min;\n        return -1;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n# 总\n虽然题目比较简单，但解法二和解法三真的让人耳目一新，一个通过存储，一个通过差值解决了「保存之前值」的问题，思路很值得借鉴。解法四更像降维打击一样，回到改底层数据结构，从而更加简洁的解决了问题。\n\n之前自己在博客总结的，更多题解可以在原地址 https://leetcode.wang。\n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2021-04-18 21:46:49Accepted [https://leetcode-cn.com//submissions/detail/169373143/]7 ms100.0%40.4 MBjava2021-04-18 21:45:56Accepted [https://leetcode-cn.com//submissions/detail/169372811/]8 ms100.0%40.2 MBjava2021-04-18 21:36:14Accepted [https://leetcode-cn.com//submissions/detail/169369257/]7 ms100.0%40.4 MBjava2021-04-18 21:31:34Wrong Answer [https://leetcode-cn.com//submissions/detail/169367628/]N/AN/AN/Ajava2021-04-18 21:08:26Wrong Answer [https://leetcode-cn.com//submissions/detail/169358113/]N/AN/AN/Ajava2021-04-18 20:58:39Wrong Answer [https://leetcode-cn.com//submissions/detail/169354894/]N/AN/AN/Ajava# 统计信息\n通过次数提交次数AC比率22760040228056.6%# 相似题目\n题目难度滑动窗口最大值 [https://leetcode-cn.com/problems/sliding-window-maximum/]困难最大栈 [https://leetcode-cn.com/problems/max-stack/]简单',contentLowercase:'# 中文题目\n设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。\n\n * push(x) —— 将元素 x 推入栈中。\n * pop()—— 删除栈顶的元素。\n * top()—— 获取栈顶元素。\n * getmin() —— 检索栈中的最小元素。\n\n\n\n示例:\n\n输入：\n["minstack","push","push","push","getmin","pop","top","getmin"]\n[[],[-2],[0],[-3],[],[],[],[]]\n\n输出：\n[null,null,null,null,-3,null,0,-2]\n\n解释：\nminstack minstack = new minstack();\nminstack.push(-2);\nminstack.push(0);\nminstack.push(-3);\nminstack.getmin();   --\x3e 返回 -3.\nminstack.pop();\nminstack.top();      --\x3e 返回 0.\nminstack.getmin();   --\x3e 返回 -2.\n\n\n\n\n提示：\n\n * pop、top 和 getmin 操作总是在 非空栈 上调用。\n\n# 通过代码\n  class minstack {\n      // 通过自定义链表的方式实现\n      private node node;\n\n      public minstack() {\n\n      }\n\n      public void push(int x) {\n          if (node == null){\n              node = new node(x, x);\n          }else {\n              // node = new node(x, math.min(x, node.min), node);\n              node next = new node(x, math.min(x, node.min));\n              next.prev = node;\n              node = next;\n          }\n      }\n\n      public void pop() {\n          node = node.prev;\n      }\n\n      public int top() {\n          return node.val;\n      }\n\n      public int getmin() {\n          return node.min;\n      }\n\n      private class node {\n          int val;\n          int min;\n          node prev;\n\n          private node(int val, int min){\n              this.val = val;\n              this.min = min;\n          }\n\n          private node(int val, int min, node prev){\n              this.val = val;\n              this.min = min;\n              this.prev = prev;\n          }\n      }\n  }\n\n/**\n * your minstack object will be instantiated and called as such:\n * minstack obj = new minstack();\n * obj.push(val);\n * obj.pop();\n * int param_3 = obj.top();\n * int param_4 = obj.getmin();\n */\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\nclass minstack {\n    // 可以通过在栈中存放数组的方式实现,数组中放两个元素，[当前值，最小值]\n      private stack<int[]> stack=new stack<>();\n\n    /** initialize your data structure here. */\n    public minstack() {\n\n    }\n    \n    public void push(int val) {\n        if (stack.isempty()){\n            stack.push(new int[]{val,val});\n        }else{\n            stack.push(new int[]{val,math.min(val,stack.peek()[1])});\n        }\n    }\n    \n    public void pop() {\n        stack.pop();\n    }\n    \n    public int top() {\n        return stack.peek()[0];\n    }\n    \n    public int getmin() {\n        return stack.peek()[1];\n    }\n}\n\n/**\n * your minstack object will be instantiated and called as such:\n * minstack obj = new minstack();\n * obj.push(val);\n * obj.pop();\n * int param_3 = obj.top();\n * int param_4 = obj.getmin();\n */\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\nclass minstack {\n        stack<integer> stack;\n        stack<integer> minstack;\n        integer min;\n\n        /**\n         * initialize your data structure here.\n         */\n        public minstack() {\n            stack=new stack<>();\n            minstack=new stack<>();\n            min=integer.max_value;\n        }\n\n        public void push(int val) {\n            stack.push(val);\n            min=math.min(min,val);\n            minstack.push(min);\n        }\n\n        public void pop() {\n            stack.pop();\n            minstack.pop();\n            // 当栈空了的时候，需要重置最小值为整数最大值\n            if (minstack.isempty()){\n                min=integer.max_value;\n                return;\n            }\n            // 最小值被弹出了，需重设最小的值为最小栈中的最小值\n            if (!min.equals(getmin())){\n                min=getmin();\n            }\n        }\n\n        public int top() {\n            return stack.peek();\n        }\n\n        public int getmin() {\n            return minstack.peek();\n        }\n    }\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n# 我的笔记\n主要需要对当前的最小值进行判断，特别时下面两种情况\n\n 1. 最小值被弹出了\n 2. 最小栈为空了\n\n# 高赞题解\n# 题目描述（简单难度）\n\n\n设计数据结构的题，设计一个栈，除了栈特有的功能，入栈、出栈、查看栈顶元素，还需要增加一个功能，得到当前栈里边最小的元素。\n\n# 解法一\n要实现一个 stack，那么我们还能用 java 自带的 stack 吗？也不用纠结，这道题的关键其实是实现「得到最小值这个功能」，所以为了代码简洁些，我们就直接使用系统自带的 stack 了。\n\n这道题最直接的解法就是我们可以用两个栈，一个栈去保存正常的入栈出栈的值，另一个栈去存最小值，也就是用栈顶保存当前所有元素的最小值。存最小值的栈的具体操作流程如下：\n\n将第一个元素入栈。\n\n新加入的元素如果大于栈顶元素，那么新加入的元素就不处理。\n\n新加入的元素如果小于等于栈顶元素，那么就将新元素入栈。\n\n出栈元素不等于栈顶元素，不操作。\n\n出栈元素等于栈顶元素，那么就将栈顶元素出栈。\n\n举个例子。\n\n入栈 3 \n|   |    |   |\n|   |    |   |\n|_3_|    |_3_|\nstack  minstack\n\n入栈 5 ， 5 大于 minstack 栈顶，不处理\n|   |    |   |\n| 5 |    |   |\n|_3_|    |_3_|\nstack  minstack\n\n入栈 2 ，此时右边的 minstack 栈顶就保存了当前最小值 2 \n| 2 |    |   |\n| 5 |    | 2 |\n|_3_|    |_3_|\nstack  minstack\n\n出栈 2，此时右边的 minstack 栈顶就保存了当前最小值 3\n|   |    |   |\n| 5 |    |   |\n|_3_|    |_3_|\nstack  minstack\n\n出栈 5，右边 minstack 不处理\n|   |    |   |\n|   |    |   |\n|_3_|    |_3_|\nstack  minstack\n\n出栈 3\n|   |    |   |\n|   |    |   |\n|_ _|    |_ _|\nstack  minstack\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n代码的话就很好写了。\n\nclass minstack {\n    /** initialize your data structure here. */\n    private stack<integer> stack;\n    private stack<integer> minstack;\n\n    public minstack() {\n        stack = new stack<>();\n        minstack = new stack<>();\n    }\n\n    public void push(int x) {\n        stack.push(x);\n        if (!minstack.isempty()) {\n            int top = minstack.peek();\n            //小于的时候才入栈\n            if (x <= top) {\n                minstack.push(x);\n            }\n        }else{\n            minstack.push(x);\n        }\n    }\n\n    public void pop() {\n        int pop = stack.pop();\n\n        int top = minstack.peek();\n        //等于的时候再出栈\n        if (pop == top) {\n            minstack.pop();\n        }\n\n    }\n\n    public int top() {\n        return stack.peek();\n    }\n\n    public int getmin() {\n        return minstack.peek();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n# 解法二\n解法一中用了两个栈去实现，那么我们能不能用一个栈去实现呢？\n\n参考了 这里 [https://leetcode.com/problems/min-stack/discuss/49014/java-accepted-solution-using-one-stack]。\n\n解法一中单独用了一个栈去保存所有最小值，那么我们能不能只用一个变量去保存最小值呢？\n\n再看一下上边的例子。\n\n入栈 3 \n|   |   min = 3\n|   |     \n|_3_|    \nstack   \n\n入栈 5 \n|   |   min = 3\n| 5 |     \n|_3_|    \nstack  \n\n入栈 2 \n| 2 |   min = 2?\n| 5 |     \n|_3_|    \nstack  \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n如果只用一个变量就会遇到一个问题，如果把 min 更新为 2，那么之前的最小值 3 就丢失了。\n\n怎么把 3 保存起来呢？把它在 2 之前压入栈中即可。\n\n入栈 2 ，同时将之前的 min 值 3 入栈，再把 2 入栈，同时更新 min = 2\n| 2 |   min = 2\n| 3 |  \n| 5 |     \n|_3_|    \nstack  \n\n入栈 6 \n| 6 |  min = 2\n| 2 |   \n| 3 |  \n| 5 |     \n|_3_|    \nstack  \n\n出栈 6     \n| 2 |   min = 2\n| 3 |  \n| 5 |     \n|_3_|    \nstack  \n\n出栈 2     \n| 2 |   min = 2\n| 3 |  \n| 5 |     \n|_3_|    \nstack  \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n上边的最后一个状态，当出栈元素是最小元素我们该如何处理呢？\n\n我们只需要把 2 出栈，然后再出栈一次，把 3 赋值给 min 即可。\n\n出栈 2     \n|   |  min = 3   \n| 5 |   \n|_3_|    \nstack  \n\n\n1\n2\n3\n4\n5\n通过上边的方式，我们就只需要一个栈了。当有更小的值来的时候，我们只需要把之前的最小值入栈，当前更小的值再入栈即可。当这个最小值要出栈的时候，下一个值便是之前的最小值了。\n\nclass minstack {\n    int min = integer.max_value;\n    stack<integer> stack = new stack<integer>();\n    public void push(int x) {\n        //当前值更小\n        if(x <= min){   \n            //将之前的最小值保存\n            stack.push(min);\n            //更新最小值\n            min=x;\n        }\n        stack.push(x);\n    }\n\n    public void pop() {\n        //如果弹出的值是最小值，那么将下一个元素更新为最小值\n        if(stack.pop() == min) {\n            min=stack.pop();\n        }\n    }\n\n    public int top() {\n        return stack.peek();\n    }\n\n    public int getmin() {\n        return min;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n# 解法三\n参考 这里 [https://leetcode.com/problems/min-stack/discuss/49031/share-my-java-solution-with-only-one-stack]，再分享利用一个栈的另一种思路。\n\n通过解法二的分析，我们关键要解决的问题就是当有新的更小值的时候，之前的最小值该怎么办？\n\n解法二中通过把之前的最小值入栈解决问题。\n\n这里的话，用了另一种思路。同样是用一个 min 变量保存最小值。只不过栈里边我们不去保存原来的值，而是去存储入栈的值和最小值的差值。然后得到之前的最小值的话，我们就可以通过 min 值和栈顶元素得到，举个例子。\n\n入栈 3，存入 3 - 3 = 0\n|   |   min = 3\n|   |     \n|_0_|    \nstack   \n\n入栈 5，存入 5 - 3 = 2\n|   |   min = 3\n| 2 |     \n|_0_|    \nstack  \n\n入栈 2，因为出现了更小的数，所以我们会存入一个负数，这里很关键\n也就是存入  2 - 3 = -1, 并且更新 min = 2 \n对于之前的 min 值 3, 我们只需要用更新后的 min - 栈顶元素 -1 就可以得到    \n| -1|   min = 2\n| 5 |     \n|_3_|    \nstack  \n\n入栈 6，存入  6 - 2 = 4\n| 4 |   min = 2\n| -1| \n| 5 |     \n|_3_|    \nstack  \n\n出栈，返回的值就是栈顶元素 4 加上 min，就是 6\n|   |   min = 2\n| -1| \n| 5 |     \n|_3_|    \nstack  \n\n出栈，此时栈顶元素是负数，说明之前对 min 值进行了更新。\n入栈元素 - min = 栈顶元素，入栈元素其实就是当前的 min 值 2\n所以更新前的 min 就等于入栈元素 2 - 栈顶元素(-1) = 3\n|   | min = 3\n| 5 |     \n|_3_|    \nstack     \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n再理一下上边的思路，我们每次存入的是 原来值 - 当前最小值。\n\n当原来值大于等于当前最小值的时候，我们存入的肯定就是非负数，所以出栈的时候就是 栈中的值 + 当前最小值 。\n\n当原来值小于当前最小值的时候，我们存入的肯定就是负值，此时的值我们不入栈，用 min 保存起来，同时将差值入栈。\n\n当后续如果出栈元素是负数的时候，那么要出栈的元素其实就是 min。此外之前的 min 值，我们可以通过栈顶的值和当前 min 值进行还原，就是用 min 减去栈顶元素即可。\n\npublic class minstack {\n    long min;\n\tstack<long> stack;\n\n\tpublic minstack(){\n        stack=new stack<>();\n    }\n\n\tpublic void push(int x) {\n\t\tif (stack.isempty()) {\n\t\t\tmin = x;\n\t\t\tstack.push(x - min);\n\t\t} else {\n\t\t\tstack.push(x - min);\n\t\t\tif (x < min){\n\t\t\t\tmin = x; // 更新最小值\n\t\t\t}\n\t\t\t\t\n\t\t}\n\t}\n\n\tpublic void pop() {\n\t\tif (stack.isempty())\n\t\t\treturn;\n\n\t\tlong pop = stack.pop();\n\t\t\n\t\t//弹出的是负值，要更新 min\n\t\tif (pop < 0) {\n\t\t\tmin = min - pop;\n\t\t}\n\n\t}\n\n\tpublic int top() {\n\t\tlong top = stack.peek();\n\t\t//负数的话，出栈的值保存在 min 中\n\t\tif (top < 0) {\n\t\t\treturn (int) (min);\n        //出栈元素加上最小值即可\n\t\t} else {\n\t\t\treturn (int) (top + min);\n\t\t}\n\t}\n\n\tpublic int getmin() {\n\t\treturn (int) min;\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n上边的解法的一个缺点就是由于我们保存的是差值，所以可能造成溢出，所以我们用了数据范围更大的 long 类型。\n\n此外相对于解法二，最小值需要更新的时候，我们并没有将之前的最小值存起来，我们每次都是通过当前最小值和栈顶元素推出了之前的最小值，所以会省一些空间。\n\n# 解法四\n再分享一个有趣的解法，参考 这里 [https://leetcode.com/problems/min-stack/discuss/49217/6ms-java-solution-using-linked-list.-clean-self-explanatory-and-efficient.] 。\n\n回到最初的疑虑，我们要不要用 java 提供的 stack 。如果不用的话，可以怎么做的？\n\n直接用一个链表即可实现栈的基本功能，那么最小值该怎么得到呢？我们可以在 node 节点中增加一个 min 字段，这样的话每次加入一个节点的时候，我们同时只要确定它的 min 值即可。\n\n代码很简洁，我直接把代码贴过来吧。\n\nclass minstack {\n    class node{\n        int value;\n        int min;\n        node next;\n\n        node(int x, int min){\n            this.value=x;\n            this.min=min;\n            next = null;\n        }\n    }\n    node head;\n    //每次加入的节点放到头部\n    public void push(int x) {\n        if(null==head){\n            head = new node(x,x);\n        }else{\n            //当前值和之前头结点的最小值较小的做为当前的 min\n            node n = new node(x, math.min(x,head.min));\n            n.next=head;\n            head=n;\n        }\n    }\n\n    public void pop() {\n        if(head!=null)\n            head =head.next;\n    }\n\n    public int top() {\n        if(head!=null)\n            return head.value;\n        return -1;\n    }\n\n    public int getmin() {\n        if(null!=head)\n            return head.min;\n        return -1;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n# 总\n虽然题目比较简单，但解法二和解法三真的让人耳目一新，一个通过存储，一个通过差值解决了「保存之前值」的问题，思路很值得借鉴。解法四更像降维打击一样，回到改底层数据结构，从而更加简洁的解决了问题。\n\n之前自己在博客总结的，更多题解可以在原地址 https://leetcode.wang。\n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2021-04-18 21:46:49accepted [https://leetcode-cn.com//submissions/detail/169373143/]7 ms100.0%40.4 mbjava2021-04-18 21:45:56accepted [https://leetcode-cn.com//submissions/detail/169372811/]8 ms100.0%40.2 mbjava2021-04-18 21:36:14accepted [https://leetcode-cn.com//submissions/detail/169369257/]7 ms100.0%40.4 mbjava2021-04-18 21:31:34wrong answer [https://leetcode-cn.com//submissions/detail/169367628/]n/an/an/ajava2021-04-18 21:08:26wrong answer [https://leetcode-cn.com//submissions/detail/169358113/]n/an/an/ajava2021-04-18 20:58:39wrong answer [https://leetcode-cn.com//submissions/detail/169354894/]n/an/an/ajava# 统计信息\n通过次数提交次数ac比率22760040228056.6%# 相似题目\n题目难度滑动窗口最大值 [https://leetcode-cn.com/problems/sliding-window-maximum/]困难最大栈 [https://leetcode-cn.com/problems/max-stack/]简单'},{title:"160-相交链表(Intersection of Two Linked Lists)",frontmatter:{title:"160-相交链表(Intersection of Two Linked Lists)",date:"2021-05-08T00:00:00.000Z",categories:["简单"],tags:["链表<Linked List>"]},regularPath:"/views/%E7%AE%80%E5%8D%95/0160-%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8.html",relativePath:"views/简单/0160-相交链表.md",key:"v-17a4fc23",path:"/views/%E7%AE%80%E5%8D%95/0160-%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8.html",headers:[{level:2,title:"中文题目",slug:"中文题目",charIndex:2},{level:2,title:"通过代码",slug:"通过代码",charIndex:1192},{level:2,title:"官方题解",slug:"官方题解",charIndex:2048},{level:2,title:"提交历史",slug:"提交历史",charIndex:4285},{level:2,title:"统计信息",slug:"统计信息",charIndex:4537},{level:2,title:"相似题目",slug:"相似题目",charIndex:4573}],headersStr:"中文题目 通过代码 官方题解 提交历史 统计信息 相似题目",content:"# 中文题目\n编写一个程序，找到两个单链表相交的起始节点。\n\n如下面的两个链表：\n\n [https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png]\n\n在节点 c1 开始相交。\n\n\n\n示例 1：\n\n [https://assets.leetcode.com/uploads/2018/12/13/160_example_1.png]\n\n输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3\n输出：Reference of the node with value = 8\n输入解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。\n\n\n\n\n示例 2：\n\n [https://assets.leetcode.com/uploads/2018/12/13/160_example_2.png]\n\n输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1\n输出：Reference of the node with value = 2\n输入解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。\n\n\n\n\n示例 3：\n\n [https://assets.leetcode.com/uploads/2018/12/13/160_example_3.png]\n\n输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2\n输出：null\n输入解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。\n解释：这两个链表不相交，因此返回 null。\n\n\n\n\n注意：\n\n * 如果两个链表没有交点，返回 null.\n * 在返回结果后，两个链表仍须保持原有的结构。\n * 可假定整个链表结构中没有循环。\n * 程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。\n\n# 通过代码\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        /**\n         定义两个指针, 第一轮让两个到达末尾的节点指向另一个链表的头部, 最后如果相遇则为交点(在第一轮移动中恰好抹除了长度差)\n         两个指针等于移动了相同的距离, 有交点就返回, 无交点就是各走了两条指针的长度\n         **/\n        if(headA == null || headB == null) return null;\n        ListNode pA = headA, pB = headB;\n        // 在这里第一轮体现在pA和pB第一次到达尾部会移向另一链表的表头, 而第二轮体现在如果pA或pB相交就返回交点, 不相交最后就是null==null\n        while(pA != pB) {\n            pA = pA == null ? headB : pA.next;\n            pB = pB == null ? headA : pB.next;\n        }\n        return pA;\n    }\n\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n# 官方题解\n# 方法一: 暴力法\n对链表A中的每一个结点 aia_iai​，遍历整个链表 B 并检查链表 B 中是否存在结点和 aia_iai​ 相同。\n\n代码省略。\n\n复杂度分析\n\n * 时间复杂度 : (mn)(mn)(mn)。\n * 空间复杂度 : O(1)O(1)O(1)。\n   \n   \n\n\n\n\n# 方法二: 哈希表法\n遍历链表 A 并将每个结点的地址/引用存储在哈希表中。然后检查链表 B 中的每一个结点 bib_ibi​ 是否在哈希表中。若在，则 bib_ibi​ 为相交结点。\n\nimport java.util.HashSet;\nimport java.util.Set;\n\npublic class Solution {\n\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        Set<ListNode> hashSet = new HashSet<>();\n\n        ListNode curNode = headA;\n        while (curNode != null) {\n            hashSet.add(curNode);\n            curNode = curNode.next;\n        }\n\n        curNode = headB;\n        while (curNode != null) {\n            if(hashSet.contains(curNode)){\n                return curNode;\n            }\n            curNode = curNode.next;\n        }\n        return null;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n复杂度分析\n\n * 时间复杂度 : O(m+n)O(m+n)O(m+n)。\n * 空间复杂度 : O(m)O(m)O(m) 或 O(n)O(n)O(n)。\n   \n   \n\n\n\n\n# 方法三：双指针法\n * 创建两个指针 pApApA 和 pBpBpB，分别初始化为链表 A 和 B 的头结点。然后让它们向后逐结点遍历。\n * 当 pApApA 到达链表的尾部时，将它重定位到链表 B 的头结点 (你没看错，就是链表 B); 类似的，当 pBpBpB 到达链表的尾部时，将它重定位到链表 A 的头结点。\n * 若在某一时刻 pApApA 和 pBpBpB 相遇，则 pApApA/pBpBpB 为相交结点。\n * 想弄清楚为什么这样可行, 可以考虑以下两个链表: A={1,3,5,7,9,11} 和 B={2,4,9,11}，相交于结点 9。 由于 B.length (=4) < A.length (=6)，pBpBpB 比 pApApA 少经过 222 个结点，会先到达尾部。将 pBpBpB 重定向到 A 的头结点，pApApA 重定向到 B 的头结点后，pBpBpB 要比 pApApA 多走 2 个结点。因此，它们会同时到达交点。\n * 如果两个链表存在相交，它们末尾的结点必然相同。因此当 pApApA/pBpBpB 到达链表结尾时，记录下链表 A/B 对应的元素。若最后元素不相同，则两个链表不相交。\n\npublic class Solution {\n\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        // 特判\n        if (headA == null || headB == null) {\n            return null;\n        }\n\n        ListNode head1 = headA;\n        ListNode head2 = headB;\n\n        while (head1 != head2) {\n            if (head1 != null) {\n                head1 = head1.next;\n            } else {\n                head1 = headB;\n            }\n\n            if (head2 != null) {\n                head2 = head2.next;\n            } else {\n                head2 = headA;\n            }\n        }\n        return head1;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n复杂度分析\n\n * 时间复杂度 : O(m+n)O(m+n)O(m+n)。\n * 空间复杂度 : O(1)O(1)O(1)。\n\n# 提交历史\n提交时间提交结果标记状态我的注释执行时间战胜比例内存消耗语言2021-05-08 21:44:35Accepted [https://leetcode-cn.com/submissions/detail/175588785/]BLUE定义两个指针1 ms100.0%41.2 MBjava2021-05-08 21:43:55Compile Error [https://leetcode-cn.com/submissions/detail/175588614/]N/AN/AN/Ajava# 统计信息\n通过次数提交次数AC比率23324939818958.6%# 相似题目\n题目难度两个列表的最小索引总和 [https://leetcode-cn.com/problems/minimum-index-sum-of-two-lists/]简单",contentLowercase:"# 中文题目\n编写一个程序，找到两个单链表相交的起始节点。\n\n如下面的两个链表：\n\n [https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png]\n\n在节点 c1 开始相交。\n\n\n\n示例 1：\n\n [https://assets.leetcode.com/uploads/2018/12/13/160_example_1.png]\n\n输入：intersectval = 8, lista = [4,1,8,4,5], listb = [5,0,1,8,4,5], skipa = 2, skipb = 3\n输出：reference of the node with value = 8\n输入解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 a 为 [4,1,8,4,5]，链表 b 为 [5,0,1,8,4,5]。在 a 中，相交节点前有 2 个节点；在 b 中，相交节点前有 3 个节点。\n\n\n\n\n示例 2：\n\n [https://assets.leetcode.com/uploads/2018/12/13/160_example_2.png]\n\n输入：intersectval = 2, lista = [0,9,1,2,4], listb = [3,2,4], skipa = 3, skipb = 1\n输出：reference of the node with value = 2\n输入解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 a 为 [0,9,1,2,4]，链表 b 为 [3,2,4]。在 a 中，相交节点前有 3 个节点；在 b 中，相交节点前有 1 个节点。\n\n\n\n\n示例 3：\n\n [https://assets.leetcode.com/uploads/2018/12/13/160_example_3.png]\n\n输入：intersectval = 0, lista = [2,6,4], listb = [1,5], skipa = 3, skipb = 2\n输出：null\n输入解释：从各自的表头开始算起，链表 a 为 [2,6,4]，链表 b 为 [1,5]。由于这两个链表不相交，所以 intersectval 必须为 0，而 skipa 和 skipb 可以是任意值。\n解释：这两个链表不相交，因此返回 null。\n\n\n\n\n注意：\n\n * 如果两个链表没有交点，返回 null.\n * 在返回结果后，两个链表仍须保持原有的结构。\n * 可假定整个链表结构中没有循环。\n * 程序尽量满足 o(n) 时间复杂度，且仅用 o(1) 内存。\n\n# 通过代码\n/**\n * definition for singly-linked list.\n * public class listnode {\n *     int val;\n *     listnode next;\n *     listnode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\npublic class solution {\n    public listnode getintersectionnode(listnode heada, listnode headb) {\n        /**\n         定义两个指针, 第一轮让两个到达末尾的节点指向另一个链表的头部, 最后如果相遇则为交点(在第一轮移动中恰好抹除了长度差)\n         两个指针等于移动了相同的距离, 有交点就返回, 无交点就是各走了两条指针的长度\n         **/\n        if(heada == null || headb == null) return null;\n        listnode pa = heada, pb = headb;\n        // 在这里第一轮体现在pa和pb第一次到达尾部会移向另一链表的表头, 而第二轮体现在如果pa或pb相交就返回交点, 不相交最后就是null==null\n        while(pa != pb) {\n            pa = pa == null ? headb : pa.next;\n            pb = pb == null ? heada : pb.next;\n        }\n        return pa;\n    }\n\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n# 官方题解\n# 方法一: 暴力法\n对链表a中的每一个结点 aia_iai​，遍历整个链表 b 并检查链表 b 中是否存在结点和 aia_iai​ 相同。\n\n代码省略。\n\n复杂度分析\n\n * 时间复杂度 : (mn)(mn)(mn)。\n * 空间复杂度 : o(1)o(1)o(1)。\n   \n   \n\n\n\n\n# 方法二: 哈希表法\n遍历链表 a 并将每个结点的地址/引用存储在哈希表中。然后检查链表 b 中的每一个结点 bib_ibi​ 是否在哈希表中。若在，则 bib_ibi​ 为相交结点。\n\nimport java.util.hashset;\nimport java.util.set;\n\npublic class solution {\n\n    public listnode getintersectionnode(listnode heada, listnode headb) {\n        set<listnode> hashset = new hashset<>();\n\n        listnode curnode = heada;\n        while (curnode != null) {\n            hashset.add(curnode);\n            curnode = curnode.next;\n        }\n\n        curnode = headb;\n        while (curnode != null) {\n            if(hashset.contains(curnode)){\n                return curnode;\n            }\n            curnode = curnode.next;\n        }\n        return null;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n复杂度分析\n\n * 时间复杂度 : o(m+n)o(m+n)o(m+n)。\n * 空间复杂度 : o(m)o(m)o(m) 或 o(n)o(n)o(n)。\n   \n   \n\n\n\n\n# 方法三：双指针法\n * 创建两个指针 papapa 和 pbpbpb，分别初始化为链表 a 和 b 的头结点。然后让它们向后逐结点遍历。\n * 当 papapa 到达链表的尾部时，将它重定位到链表 b 的头结点 (你没看错，就是链表 b); 类似的，当 pbpbpb 到达链表的尾部时，将它重定位到链表 a 的头结点。\n * 若在某一时刻 papapa 和 pbpbpb 相遇，则 papapa/pbpbpb 为相交结点。\n * 想弄清楚为什么这样可行, 可以考虑以下两个链表: a={1,3,5,7,9,11} 和 b={2,4,9,11}，相交于结点 9。 由于 b.length (=4) < a.length (=6)，pbpbpb 比 papapa 少经过 222 个结点，会先到达尾部。将 pbpbpb 重定向到 a 的头结点，papapa 重定向到 b 的头结点后，pbpbpb 要比 papapa 多走 2 个结点。因此，它们会同时到达交点。\n * 如果两个链表存在相交，它们末尾的结点必然相同。因此当 papapa/pbpbpb 到达链表结尾时，记录下链表 a/b 对应的元素。若最后元素不相同，则两个链表不相交。\n\npublic class solution {\n\n    public listnode getintersectionnode(listnode heada, listnode headb) {\n        // 特判\n        if (heada == null || headb == null) {\n            return null;\n        }\n\n        listnode head1 = heada;\n        listnode head2 = headb;\n\n        while (head1 != head2) {\n            if (head1 != null) {\n                head1 = head1.next;\n            } else {\n                head1 = headb;\n            }\n\n            if (head2 != null) {\n                head2 = head2.next;\n            } else {\n                head2 = heada;\n            }\n        }\n        return head1;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n复杂度分析\n\n * 时间复杂度 : o(m+n)o(m+n)o(m+n)。\n * 空间复杂度 : o(1)o(1)o(1)。\n\n# 提交历史\n提交时间提交结果标记状态我的注释执行时间战胜比例内存消耗语言2021-05-08 21:44:35accepted [https://leetcode-cn.com/submissions/detail/175588785/]blue定义两个指针1 ms100.0%41.2 mbjava2021-05-08 21:43:55compile error [https://leetcode-cn.com/submissions/detail/175588614/]n/an/an/ajava# 统计信息\n通过次数提交次数ac比率23324939818958.6%# 相似题目\n题目难度两个列表的最小索引总和 [https://leetcode-cn.com/problems/minimum-index-sum-of-two-lists/]简单"},{title:"169-多数元素(Majority Element)",frontmatter:{title:"169-多数元素(Majority Element)",date:"2020-01-05T00:00:00.000Z",categories:["简单"],tags:["位运算<Bit Manipulation>","数组<Array>","分治算法<Divide and Conquer>"]},regularPath:"/views/%E7%AE%80%E5%8D%95/0169-%E5%A4%9A%E6%95%B0%E5%85%83%E7%B4%A0.html",relativePath:"views/简单/0169-多数元素.md",key:"v-6f1770fa",path:"/views/%E7%AE%80%E5%8D%95/0169-%E5%A4%9A%E6%95%B0%E5%85%83%E7%B4%A0.html",headers:[{level:2,title:"中文题目",slug:"中文题目",charIndex:2},{level:2,title:"通过代码",slug:"通过代码",charIndex:153},{level:2,title:"官方题解",slug:"官方题解",charIndex:308},{level:2,title:"提交历史",slug:"提交历史",charIndex:10820},{level:2,title:"统计信息",slug:"统计信息",charIndex:10951},{level:2,title:"相似题目",slug:"相似题目",charIndex:10987}],lastUpdated:"4/11/2021, 1:15:21 PM",headersStr:"中文题目 通过代码 官方题解 提交历史 统计信息 相似题目",content:'# 中文题目\n给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数大于⌊ n/2 ⌋的元素。\n\n你可以假设数组是非空的，并且给定的数组总是存在多数元素。\n\n示例 1:\n\n输入: [3,2,3]\n输出: 3\n\n示例 2:\n\n输入: [2,2,1,1,1,2,2]\n输出: 2\n\n\n# 通过代码\nclass Solution {\n    public int majorityElement(int[] nums) {\n        Arrays.sort(nums);\n        return nums[(nums.length-1)/2];\n    }\n}\n\n1\n2\n3\n4\n5\n# 官方题解\n# 方法 1：暴力\n想法\n\n我们可以在平方级的时间里穷举所有情况，来检测每个数是不是众数。\n\n算法\n\n暴力算法遍历整个数组，然后用另一重循环统计每个数字出现的次数。将出现次数比其他数字加起来出现次数还多的元素返回。\n\nclass Solution {\n    public int majorityElement(int[] nums) {\n        int majorityCount = nums.length/2;\n\n        for (int num : nums) {\n            int count = 0;\n            for (int elem : nums) {\n                if (elem == num) {\n                    count += 1;\n                }\n            }\n\n            if (count > majorityCount) {\n                return num;\n            }\n\n        }\n\n        return -1;    \n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\nclass Solution:\n    def majorityElement(self, nums):\n        majority_count = len(nums)//2\n        for num in nums:\n            count = sum(1 for elem in nums if elem == num)\n            if count > majority_count:\n                return num\n\n\n1\n2\n3\n4\n5\n6\n7\n复杂度分析\n\n * 时间复杂度：O(n2)O(n^2)O(n2)\n   \n   暴力算法包含两重嵌套的 for 循环，每一层 nnn 次迭代，所以总的是平方级的时间复杂度。\n   \n   \n * 空间复杂度：O(1)O(1)O(1)\n   \n   暴力方法没有分配任何与输入规模成比例的额外的空间\n   \n   \n\n\n#### 方法 2：哈希表想法\n\n我们知道出现次数最多的元素大于 ⌊n2⌋\\lfloor \\dfrac{n}{2} \\rfloor⌊2n​⌋ 次，所以可以用哈希表来快速统计每个元素出现的次数。\n\n算法\n\n我们使用哈希表来存储每个元素，然后用一个循环在线性时间内遍历 nums ，然后我们只需要返回有最大值的键。\n\nclass Solution {\n    private Map<Integer, Integer> countNums(int[] nums) {\n        Map<Integer, Integer> counts = new HashMap<Integer, Integer>();\n        for (int num : nums) {\n            if (!counts.containsKey(num)) {\n                counts.put(num, 1);\n            }\n            else {\n                counts.put(num, counts.get(num)+1);\n            }\n        }\n        return counts;\n    }\n\n    public int majorityElement(int[] nums) {\n        Map<Integer, Integer> counts = countNums(nums);\n\n        Map.E***y<Integer, Integer> majorityE***y = null;\n        for (Map.E***y<Integer, Integer> e***y : counts.e***ySet()) {\n            if (majorityE***y == null || e***y.getValue() > majorityE***y.getValue()) {\n                majorityE***y = e***y;\n            }\n        }\n\n        return majorityE***y.getKey();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\nclass Solution:\n    def majorityElement(self, nums):\n        counts = collections.Counter(nums)\n        return max(counts.keys(), key=counts.get)\n\n\n1\n2\n3\n4\n复杂度分析\n\n * 时间复杂度：O(n)O(n)O(n)\n   \n   我们将 nums 迭代一次，哈希表的插入是常数时间的。所以总时间复杂度为 O(n)O(n)O(n) 时间的。\n   \n   \n * 空间复杂度：O(n)O(n)O(n)\n   \n   哈希表最多包含 n−⌊n2⌋n - \\lfloor \\dfrac{n}{2} \\rfloorn−⌊2n​⌋ 个关系，所以占用的空间为 O(n)O(n)O(n) 。这是因为任意一个长度为 nnn 的数组最多只能包含 nnn 个不同的值，但题中保证 nums 一定有一个众数，会占用（最少） ⌊n2⌋+1\\lfloor \\dfrac{n}{2} \\rfloor + 1⌊2n​⌋+1 个数字。因此最多有 n−(⌊n2⌋+1)n - (\\lfloor \\dfrac{n}{2} \\rfloor + 1)n−(⌊2n​⌋+1) 个不同的其他数字，所以最多有 n−⌊n2⌋n - \\lfloor \\dfrac{n}{2} \\rfloorn−⌊2n​⌋ 个不同的元素。\n   \n   \n\n\n#### 方法 3：排序想法\n\n如果所有数字被单调递增或者单调递减的顺序排了序，那么众数的下标为 ⌊n2⌋\\lfloor \\dfrac{n}{2} \\rfloor⌊2n​⌋ （当 nnn 是偶数时，下标为 ⌊n2⌋+1\\lfloor \\dfrac{n}{2} \\rfloor + 1⌊2n​⌋+1 ）\n\n算法\n\n对于这种算法，我们先将 nums 数组排序，然后返回上面所说的数字。下面解释了为什么这种策略是有效的。考虑下图（上面的例子是一个可能的奇数的情况，下面的例子是一个可能的偶数的情况）：\n\n{:width="200px"} {:align="center"}\n\n对于每种情况，数组下面的线表示如果众数是数组中最小值的情况下覆盖的下标。数组上面的线是数组中最大值的情况。其他情况，这条线会在这两种极端情况的中间。但我们看到即使是这两种极端情况，它们也会在下标为 ⌊n2⌋\\lfloor \\dfrac{n}{2} \\rfloor⌊2n​⌋ 的地方有重叠。因此，无论众数是多少，返回 ⌊n2⌋\\lfloor \\dfrac{n}{2} \\rfloor⌊2n​⌋ 下标对应的值都是正确的。\n\nclass Solution {\n    public int majorityElement(int[] nums) {\n        Arrays.sort(nums);\n        return nums[nums.length/2];\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\nclass Solution:\n    def majorityElement(self, nums):\n        nums.sort()\n        return nums[len(nums)//2]\n\n\n1\n2\n3\n4\n复杂度分析\n\n * 时间复杂度：O(nlgn)O(nlgn)O(nlgn)\n   \n   用 Python 和 Java 将数组排序开销都为 O(nlgn)O(nlgn)O(nlgn) ，它占据了运行的主要时间。\n   \n   \n * 空间复杂度：O(1)O(1)O(1) 或者 O(n)O(n)O(n)\n   \n   我们将 nums 就地排序，如果不能就低排序，我们必须使用线性空间将 nums 数组拷贝，然后再排序。\n   \n   \n\n\n#### 方法 4：随机化想法\n\n因为超过 ⌊n2⌋\\lfloor \\dfrac{n}{2} \\rfloor⌊2n​⌋ 的数组下标被众数占据了，一个随机的下标很有可能存有众数。\n\n算法\n\n由于一个给定的下标对应的数字很有可能是众数，我们随机挑选一个下标，检查它的值是否是众数，如果是就返回，否则继续随机挑选。\n\nclass Solution {\n    private int randRange(Random rand, int min, int max) {\n        return rand.nextInt(max - min) + min;\n    }\n\n    private int countOccurences(int[] nums, int num) {\n        int count = 0;\n        for (int i = 0; i < nums.length; i++) {\n            if (nums[i] == num) {\n                count++;\n            }\n        }\n        return count;\n    }\n\n    public int majorityElement(int[] nums) {\n        Random rand = new Random();\n\n        int majorityCount = nums.length/2;\n\n        while (true) {\n            int candidate = nums[randRange(rand, 0, nums.length)];\n            if (countOccurences(nums, candidate) > majorityCount) {\n                return candidate;\n            }\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\nimport random\n\nclass Solution:\n    def majorityElement(self, nums):\n        majority_count = len(nums)//2\n        while True:\n            candidate = random.choice(nums)\n            if sum(1 for elem in nums if elem == candidate) > majority_count:\n                return candidate\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n复杂度分析\n\n * 时间复杂度：O(∞)O(\\infty)O(∞)\n   \n   理论上这个算法有可能跑无穷次（如果我们一直无法随机到众数），所以最坏时间复杂度是没有上限的。然而，运行的期望时间远小于无限次的 - 线性时间即可。为了更简单地分析，先说服你自己：由于众数占据 超过 数组一半的位置，期望的迭代次数会小于众数占据数组恰好一半的情况。因此，我们可以计算迭代的期望次数（下标为 prob 为原问题， mod 为众数恰好占据数组一半数目的问题）：\n   \n   EV(itersprob)≤EV(itersmod)=lim⁡n→∞∑i=1ni⋅12i=2\\begin{aligned} EV(iters_{prob}) &\\leq EV(iters_{mod}) \\\\ &= \\lim_{n\\to\\infty} \\sum_{i=1}^{n} i \\cdot \\frac{1}{2^i} \\\\ &= 2 \\end{aligned}EV(itersprob​)​≤EV(itersmod​)=n→∞lim​i=1∑n​i⋅2i1​=2​\n   \n   因为级数会收敛，修改后问题的迭代期望次数是个常数。所以修改后问题的运行时间为线性的。因此，原问题期望运行时间也是线性的。\n   \n   \n * 空间复杂度：O(1)O(1)O(1)\n   \n   就像暴力解，随机方法只需要常数级别的额外空间。\n   \n   \n\n\n#### 方法 5：分治想法\n\n如果我们知道数组左边一半和右边一半的众数，我们就可以用线性时间知道全局的众数是哪个。\n\n算法\n\n这里我们使用经典的分治算法递归求解，直到所有的子问题都是长度为 1 的数组。由于传输子数组需要额外的时间和空间，所以我们实际上只传输子区间的左右指针 lo 和 hi 表示相应区间的左右下标。长度为 1 的子数组中唯一的数显然是众数，直接返回即可。如果回溯后某区间的长度大于 1 ，我们必须将左右子区间的值合并。如果它们的众数相同，那么显然这一段区间的众数是它们相同的值。否则，我们需要比较两个众数在整个区间内出现的次数来决定该区间的众数。原问题的答案就是下标为 000 和 nnn 之间的众数这一子问题。\n\nclass Solution {\n    private int countInRange(int[] nums, int num, int lo, int hi) {\n        int count = 0;\n        for (int i = lo; i <= hi; i++) {\n            if (nums[i] == num) {\n                count++;\n            }\n        }\n        return count;\n    }\n\n    private int majorityEleme***ec(int[] nums, int lo, int hi) {\n        // base case; the only element in an array of size 1 is the majority\n        // element.\n        if (lo == hi) {\n            return nums[lo];\n        }\n\n        // recurse on left and right halves of this slice.\n        int mid = (hi-lo)/2 + lo;\n        int left = majorityEleme***ec(nums, lo, mid);\n        int right = majorityEleme***ec(nums, mid+1, hi);\n\n        // if the two halves agree on the majority element, return it.\n        if (left == right) {\n            return left;\n        }\n\n        // otherwise, count each element and return the "winner".\n        int leftCount = countInRange(nums, left, lo, hi);\n        int rightCount = countInRange(nums, right, lo, hi);\n\n        return leftCount > rightCount ? left : right;\n    }\n\n    public int majorityElement(int[] nums) {\n        return majorityEleme***ec(nums, 0, nums.length-1);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\nclass Solution:\n    def majorityElement(self, nums, lo=0, hi=None):\n        def majority_element_rec(lo, hi):\n            # base case; the only element in an array of size 1 is the majority\n            # element.\n            if lo == hi:\n                return nums[lo]\n\n            # recurse on left and right halves of this slice.\n            mid = (hi-lo)//2 + lo\n            left = majority_element_rec(lo, mid)\n            right = majority_element_rec(mid+1, hi)\n\n            # if the two halves agree on the majority element, return it.\n            if left == right:\n                return left\n\n            # otherwise, count each element and return the "winner".\n            left_count = sum(1 for i in range(lo, hi+1) if nums[i] == left)\n            right_count = sum(1 for i in range(lo, hi+1) if nums[i] == right)\n\n            return left if left_count > right_count else right\n\n        return majority_element_rec(0, len(nums)-1)\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n复杂度分析\n\n * 时间复杂度：O(nlgn)O(nlgn)O(nlgn)\n   \n   函数 majority_element_rec 会求解 2 个长度为 n2\\dfrac{n}{2}2n​ 的子问题，并做两遍长度为 nnn 的线性扫描。因此，分治算法的时间复杂度可以表示为：\n   \n   T(n)=2T(n2)+2n T(n) = 2T(\\frac{n}{2}) + 2nT(n)=2T(2n​)+2n\n   \n   根据 主定理 [https://baike.baidu.com/item/%E4%B8%BB%E5%AE%9A%E7%90%86/3463232?fr=aladdin]，本题满足第二种情况，所以时间复杂度可以表示为：\n   \n   T(n)=Θ(nlogbalog⁡n)=Θ(nlog22log⁡n)=Θ(nlog⁡n)\\begin{aligned} T(n) &= \\Theta(n^{log_{b}a}\\log n) \\\\ &= \\Theta(n^{log_{2}2}\\log n) \\\\ &= \\Theta(n \\log n) \\\\ \\end{aligned}T(n)​=Θ(nlogb​alogn)=Θ(nlog2​2logn)=Θ(nlogn)​\n   \n   \n * 空间复杂度：O(lgn)O(lgn)O(lgn)\n   \n   尽管分治算法没有直接分配额外的数组空间，但因为递归的过程，在栈中使用了一些非常数的额外空间。因为算法每次将数组从每一层的中间断开，所以数组长度变为 1 之前只有 O(lgn)O(lgn)O(lgn) 次切断。由于递归树是平衡的，所以从根到每个叶子节点的长度都是 O(lgn)O(lgn)O(lgn) 。由于递归树是深度优先的，空间复杂度等于最长的一条路径，也就是 O(lgn)O(lgn)O(lgn) 。\n   \n   \n\n\n#### 方法 6：Boyer-Moore 投票算法想法\n\n如果我们把众数记为 +1+1+1 ，把其他数记为 −1-1−1 ，将它们全部加起来，显然和大于 0 ，从结果本身我们可以看出众数比其他数多。\n\n算法\n\n本质上， Boyer-Moore 算法就是找 nums 的一个后缀 sufsufsuf ，其中 suf[0]suf[0]suf[0] 就是后缀中的众数。我们维护一个计数器，如果遇到一个我们目前的候选众数，就将计数器加一，否则减一。只要计数器等于 0 ，我们就将 nums 中之前访问的数字全部 忘记 ，并把下一个数字当做候选的众数。直观上这个算法不是特别明显为何是对的，我们先看下面这个例子（竖线用来划分每次计数器归零的情况）\n\n[7, 7, 5, 7, 5, 1 | 5, 7 | 5, 5, 7, 7 | 7, 7, 7, 7]\n\n首先，下标为 0 的 7 被当做众数的第一个候选。在下标为 5 处，计数器会变回0 。所以下标为 6 的 5 是下一个众数的候选者。由于这个例子中 7 是真正的众数，所以通过忽略掉前面的数字，我们忽略掉了同样多数目的众数和非众数。因此， 7 仍然是剩下数字中的众数。\n\n[7, 7, 5, 7, 5, 1 | 5, 7 | 5, 5, 7, 7 | 5, 5, 5, 5]\n\n现在，众数是 5 （在计数器归零的时候我们把候选从 7 变成了 5）。此时，我们的候选者并不是真正的众数，但是我们在 遗忘 前面的数字的时候，要去掉相同数目的众数和非众数（如果遗忘更多的非众数，会导致计数器变成负数）。\n\n因此，上面的过程说明了我们可以放心地遗忘前面的数字，并继续求解剩下数字中的众数。最后，总有一个后缀满足计数器是大于 0 的，此时这个后缀的众数就是整个数组的众数。\n\nclass Solution {\n    public int majorityElement(int[] nums) {\n        int count = 0;\n        Integer candidate = null;\n\n        for (int num : nums) {\n            if (count == 0) {\n                candidate = num;\n            }\n            count += (num == candidate) ? 1 : -1;\n        }\n\n        return candidate;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\nclass Solution:\n    def majorityElement(self, nums):\n        count = 0\n        candidate = None\n\n        for num in nums:\n            if count == 0:\n                candidate = num\n            count += (1 if num == candidate else -1)\n\n        return candidate\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n复杂度分析\n\n * 时间复杂度：O(n)O(n)O(n)\n   \n   Boyer-Moore 算法严格执行了 nnn 次循环，所以时间复杂度是线性时间的。\n   \n   \n * 空间复杂度：O(1)O(1)O(1)\n   \n   Boyer-Moore 只需要常数级别的额外空间。\n   \n   \n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2020-01-05 22:35:36Accepted [https://leetcode-cn.com//submissions/detail/42388768/]1 ms100.0%43 MBjava# 统计信息\n通过次数提交次数AC比率10037216425061.1%# 相似题目\n题目难度求众数 II [https://leetcode-cn.com/problems/majority-element-ii/]中等检查一个数是否在数组中占绝大多数 [https://leetcode-cn.com/problems/check-if-a-number-is-majority-element-in-a-sorted-array/]简单',contentLowercase:'# 中文题目\n给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数大于⌊ n/2 ⌋的元素。\n\n你可以假设数组是非空的，并且给定的数组总是存在多数元素。\n\n示例 1:\n\n输入: [3,2,3]\n输出: 3\n\n示例 2:\n\n输入: [2,2,1,1,1,2,2]\n输出: 2\n\n\n# 通过代码\nclass solution {\n    public int majorityelement(int[] nums) {\n        arrays.sort(nums);\n        return nums[(nums.length-1)/2];\n    }\n}\n\n1\n2\n3\n4\n5\n# 官方题解\n# 方法 1：暴力\n想法\n\n我们可以在平方级的时间里穷举所有情况，来检测每个数是不是众数。\n\n算法\n\n暴力算法遍历整个数组，然后用另一重循环统计每个数字出现的次数。将出现次数比其他数字加起来出现次数还多的元素返回。\n\nclass solution {\n    public int majorityelement(int[] nums) {\n        int majoritycount = nums.length/2;\n\n        for (int num : nums) {\n            int count = 0;\n            for (int elem : nums) {\n                if (elem == num) {\n                    count += 1;\n                }\n            }\n\n            if (count > majoritycount) {\n                return num;\n            }\n\n        }\n\n        return -1;    \n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\nclass solution:\n    def majorityelement(self, nums):\n        majority_count = len(nums)//2\n        for num in nums:\n            count = sum(1 for elem in nums if elem == num)\n            if count > majority_count:\n                return num\n\n\n1\n2\n3\n4\n5\n6\n7\n复杂度分析\n\n * 时间复杂度：o(n2)o(n^2)o(n2)\n   \n   暴力算法包含两重嵌套的 for 循环，每一层 nnn 次迭代，所以总的是平方级的时间复杂度。\n   \n   \n * 空间复杂度：o(1)o(1)o(1)\n   \n   暴力方法没有分配任何与输入规模成比例的额外的空间\n   \n   \n\n\n#### 方法 2：哈希表想法\n\n我们知道出现次数最多的元素大于 ⌊n2⌋\\lfloor \\dfrac{n}{2} \\rfloor⌊2n​⌋ 次，所以可以用哈希表来快速统计每个元素出现的次数。\n\n算法\n\n我们使用哈希表来存储每个元素，然后用一个循环在线性时间内遍历 nums ，然后我们只需要返回有最大值的键。\n\nclass solution {\n    private map<integer, integer> countnums(int[] nums) {\n        map<integer, integer> counts = new hashmap<integer, integer>();\n        for (int num : nums) {\n            if (!counts.containskey(num)) {\n                counts.put(num, 1);\n            }\n            else {\n                counts.put(num, counts.get(num)+1);\n            }\n        }\n        return counts;\n    }\n\n    public int majorityelement(int[] nums) {\n        map<integer, integer> counts = countnums(nums);\n\n        map.e***y<integer, integer> majoritye***y = null;\n        for (map.e***y<integer, integer> e***y : counts.e***yset()) {\n            if (majoritye***y == null || e***y.getvalue() > majoritye***y.getvalue()) {\n                majoritye***y = e***y;\n            }\n        }\n\n        return majoritye***y.getkey();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\nclass solution:\n    def majorityelement(self, nums):\n        counts = collections.counter(nums)\n        return max(counts.keys(), key=counts.get)\n\n\n1\n2\n3\n4\n复杂度分析\n\n * 时间复杂度：o(n)o(n)o(n)\n   \n   我们将 nums 迭代一次，哈希表的插入是常数时间的。所以总时间复杂度为 o(n)o(n)o(n) 时间的。\n   \n   \n * 空间复杂度：o(n)o(n)o(n)\n   \n   哈希表最多包含 n−⌊n2⌋n - \\lfloor \\dfrac{n}{2} \\rfloorn−⌊2n​⌋ 个关系，所以占用的空间为 o(n)o(n)o(n) 。这是因为任意一个长度为 nnn 的数组最多只能包含 nnn 个不同的值，但题中保证 nums 一定有一个众数，会占用（最少） ⌊n2⌋+1\\lfloor \\dfrac{n}{2} \\rfloor + 1⌊2n​⌋+1 个数字。因此最多有 n−(⌊n2⌋+1)n - (\\lfloor \\dfrac{n}{2} \\rfloor + 1)n−(⌊2n​⌋+1) 个不同的其他数字，所以最多有 n−⌊n2⌋n - \\lfloor \\dfrac{n}{2} \\rfloorn−⌊2n​⌋ 个不同的元素。\n   \n   \n\n\n#### 方法 3：排序想法\n\n如果所有数字被单调递增或者单调递减的顺序排了序，那么众数的下标为 ⌊n2⌋\\lfloor \\dfrac{n}{2} \\rfloor⌊2n​⌋ （当 nnn 是偶数时，下标为 ⌊n2⌋+1\\lfloor \\dfrac{n}{2} \\rfloor + 1⌊2n​⌋+1 ）\n\n算法\n\n对于这种算法，我们先将 nums 数组排序，然后返回上面所说的数字。下面解释了为什么这种策略是有效的。考虑下图（上面的例子是一个可能的奇数的情况，下面的例子是一个可能的偶数的情况）：\n\n{:width="200px"} {:align="center"}\n\n对于每种情况，数组下面的线表示如果众数是数组中最小值的情况下覆盖的下标。数组上面的线是数组中最大值的情况。其他情况，这条线会在这两种极端情况的中间。但我们看到即使是这两种极端情况，它们也会在下标为 ⌊n2⌋\\lfloor \\dfrac{n}{2} \\rfloor⌊2n​⌋ 的地方有重叠。因此，无论众数是多少，返回 ⌊n2⌋\\lfloor \\dfrac{n}{2} \\rfloor⌊2n​⌋ 下标对应的值都是正确的。\n\nclass solution {\n    public int majorityelement(int[] nums) {\n        arrays.sort(nums);\n        return nums[nums.length/2];\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\nclass solution:\n    def majorityelement(self, nums):\n        nums.sort()\n        return nums[len(nums)//2]\n\n\n1\n2\n3\n4\n复杂度分析\n\n * 时间复杂度：o(nlgn)o(nlgn)o(nlgn)\n   \n   用 python 和 java 将数组排序开销都为 o(nlgn)o(nlgn)o(nlgn) ，它占据了运行的主要时间。\n   \n   \n * 空间复杂度：o(1)o(1)o(1) 或者 o(n)o(n)o(n)\n   \n   我们将 nums 就地排序，如果不能就低排序，我们必须使用线性空间将 nums 数组拷贝，然后再排序。\n   \n   \n\n\n#### 方法 4：随机化想法\n\n因为超过 ⌊n2⌋\\lfloor \\dfrac{n}{2} \\rfloor⌊2n​⌋ 的数组下标被众数占据了，一个随机的下标很有可能存有众数。\n\n算法\n\n由于一个给定的下标对应的数字很有可能是众数，我们随机挑选一个下标，检查它的值是否是众数，如果是就返回，否则继续随机挑选。\n\nclass solution {\n    private int randrange(random rand, int min, int max) {\n        return rand.nextint(max - min) + min;\n    }\n\n    private int countoccurences(int[] nums, int num) {\n        int count = 0;\n        for (int i = 0; i < nums.length; i++) {\n            if (nums[i] == num) {\n                count++;\n            }\n        }\n        return count;\n    }\n\n    public int majorityelement(int[] nums) {\n        random rand = new random();\n\n        int majoritycount = nums.length/2;\n\n        while (true) {\n            int candidate = nums[randrange(rand, 0, nums.length)];\n            if (countoccurences(nums, candidate) > majoritycount) {\n                return candidate;\n            }\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\nimport random\n\nclass solution:\n    def majorityelement(self, nums):\n        majority_count = len(nums)//2\n        while true:\n            candidate = random.choice(nums)\n            if sum(1 for elem in nums if elem == candidate) > majority_count:\n                return candidate\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n复杂度分析\n\n * 时间复杂度：o(∞)o(\\infty)o(∞)\n   \n   理论上这个算法有可能跑无穷次（如果我们一直无法随机到众数），所以最坏时间复杂度是没有上限的。然而，运行的期望时间远小于无限次的 - 线性时间即可。为了更简单地分析，先说服你自己：由于众数占据 超过 数组一半的位置，期望的迭代次数会小于众数占据数组恰好一半的情况。因此，我们可以计算迭代的期望次数（下标为 prob 为原问题， mod 为众数恰好占据数组一半数目的问题）：\n   \n   ev(itersprob)≤ev(itersmod)=lim⁡n→∞∑i=1ni⋅12i=2\\begin{aligned} ev(iters_{prob}) &\\leq ev(iters_{mod}) \\\\ &= \\lim_{n\\to\\infty} \\sum_{i=1}^{n} i \\cdot \\frac{1}{2^i} \\\\ &= 2 \\end{aligned}ev(itersprob​)​≤ev(itersmod​)=n→∞lim​i=1∑n​i⋅2i1​=2​\n   \n   因为级数会收敛，修改后问题的迭代期望次数是个常数。所以修改后问题的运行时间为线性的。因此，原问题期望运行时间也是线性的。\n   \n   \n * 空间复杂度：o(1)o(1)o(1)\n   \n   就像暴力解，随机方法只需要常数级别的额外空间。\n   \n   \n\n\n#### 方法 5：分治想法\n\n如果我们知道数组左边一半和右边一半的众数，我们就可以用线性时间知道全局的众数是哪个。\n\n算法\n\n这里我们使用经典的分治算法递归求解，直到所有的子问题都是长度为 1 的数组。由于传输子数组需要额外的时间和空间，所以我们实际上只传输子区间的左右指针 lo 和 hi 表示相应区间的左右下标。长度为 1 的子数组中唯一的数显然是众数，直接返回即可。如果回溯后某区间的长度大于 1 ，我们必须将左右子区间的值合并。如果它们的众数相同，那么显然这一段区间的众数是它们相同的值。否则，我们需要比较两个众数在整个区间内出现的次数来决定该区间的众数。原问题的答案就是下标为 000 和 nnn 之间的众数这一子问题。\n\nclass solution {\n    private int countinrange(int[] nums, int num, int lo, int hi) {\n        int count = 0;\n        for (int i = lo; i <= hi; i++) {\n            if (nums[i] == num) {\n                count++;\n            }\n        }\n        return count;\n    }\n\n    private int majorityeleme***ec(int[] nums, int lo, int hi) {\n        // base case; the only element in an array of size 1 is the majority\n        // element.\n        if (lo == hi) {\n            return nums[lo];\n        }\n\n        // recurse on left and right halves of this slice.\n        int mid = (hi-lo)/2 + lo;\n        int left = majorityeleme***ec(nums, lo, mid);\n        int right = majorityeleme***ec(nums, mid+1, hi);\n\n        // if the two halves agree on the majority element, return it.\n        if (left == right) {\n            return left;\n        }\n\n        // otherwise, count each element and return the "winner".\n        int leftcount = countinrange(nums, left, lo, hi);\n        int rightcount = countinrange(nums, right, lo, hi);\n\n        return leftcount > rightcount ? left : right;\n    }\n\n    public int majorityelement(int[] nums) {\n        return majorityeleme***ec(nums, 0, nums.length-1);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\nclass solution:\n    def majorityelement(self, nums, lo=0, hi=none):\n        def majority_element_rec(lo, hi):\n            # base case; the only element in an array of size 1 is the majority\n            # element.\n            if lo == hi:\n                return nums[lo]\n\n            # recurse on left and right halves of this slice.\n            mid = (hi-lo)//2 + lo\n            left = majority_element_rec(lo, mid)\n            right = majority_element_rec(mid+1, hi)\n\n            # if the two halves agree on the majority element, return it.\n            if left == right:\n                return left\n\n            # otherwise, count each element and return the "winner".\n            left_count = sum(1 for i in range(lo, hi+1) if nums[i] == left)\n            right_count = sum(1 for i in range(lo, hi+1) if nums[i] == right)\n\n            return left if left_count > right_count else right\n\n        return majority_element_rec(0, len(nums)-1)\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n复杂度分析\n\n * 时间复杂度：o(nlgn)o(nlgn)o(nlgn)\n   \n   函数 majority_element_rec 会求解 2 个长度为 n2\\dfrac{n}{2}2n​ 的子问题，并做两遍长度为 nnn 的线性扫描。因此，分治算法的时间复杂度可以表示为：\n   \n   t(n)=2t(n2)+2n t(n) = 2t(\\frac{n}{2}) + 2nt(n)=2t(2n​)+2n\n   \n   根据 主定理 [https://baike.baidu.com/item/%e4%b8%bb%e5%ae%9a%e7%90%86/3463232?fr=aladdin]，本题满足第二种情况，所以时间复杂度可以表示为：\n   \n   t(n)=θ(nlogbalog⁡n)=θ(nlog22log⁡n)=θ(nlog⁡n)\\begin{aligned} t(n) &= \\theta(n^{log_{b}a}\\log n) \\\\ &= \\theta(n^{log_{2}2}\\log n) \\\\ &= \\theta(n \\log n) \\\\ \\end{aligned}t(n)​=θ(nlogb​alogn)=θ(nlog2​2logn)=θ(nlogn)​\n   \n   \n * 空间复杂度：o(lgn)o(lgn)o(lgn)\n   \n   尽管分治算法没有直接分配额外的数组空间，但因为递归的过程，在栈中使用了一些非常数的额外空间。因为算法每次将数组从每一层的中间断开，所以数组长度变为 1 之前只有 o(lgn)o(lgn)o(lgn) 次切断。由于递归树是平衡的，所以从根到每个叶子节点的长度都是 o(lgn)o(lgn)o(lgn) 。由于递归树是深度优先的，空间复杂度等于最长的一条路径，也就是 o(lgn)o(lgn)o(lgn) 。\n   \n   \n\n\n#### 方法 6：boyer-moore 投票算法想法\n\n如果我们把众数记为 +1+1+1 ，把其他数记为 −1-1−1 ，将它们全部加起来，显然和大于 0 ，从结果本身我们可以看出众数比其他数多。\n\n算法\n\n本质上， boyer-moore 算法就是找 nums 的一个后缀 sufsufsuf ，其中 suf[0]suf[0]suf[0] 就是后缀中的众数。我们维护一个计数器，如果遇到一个我们目前的候选众数，就将计数器加一，否则减一。只要计数器等于 0 ，我们就将 nums 中之前访问的数字全部 忘记 ，并把下一个数字当做候选的众数。直观上这个算法不是特别明显为何是对的，我们先看下面这个例子（竖线用来划分每次计数器归零的情况）\n\n[7, 7, 5, 7, 5, 1 | 5, 7 | 5, 5, 7, 7 | 7, 7, 7, 7]\n\n首先，下标为 0 的 7 被当做众数的第一个候选。在下标为 5 处，计数器会变回0 。所以下标为 6 的 5 是下一个众数的候选者。由于这个例子中 7 是真正的众数，所以通过忽略掉前面的数字，我们忽略掉了同样多数目的众数和非众数。因此， 7 仍然是剩下数字中的众数。\n\n[7, 7, 5, 7, 5, 1 | 5, 7 | 5, 5, 7, 7 | 5, 5, 5, 5]\n\n现在，众数是 5 （在计数器归零的时候我们把候选从 7 变成了 5）。此时，我们的候选者并不是真正的众数，但是我们在 遗忘 前面的数字的时候，要去掉相同数目的众数和非众数（如果遗忘更多的非众数，会导致计数器变成负数）。\n\n因此，上面的过程说明了我们可以放心地遗忘前面的数字，并继续求解剩下数字中的众数。最后，总有一个后缀满足计数器是大于 0 的，此时这个后缀的众数就是整个数组的众数。\n\nclass solution {\n    public int majorityelement(int[] nums) {\n        int count = 0;\n        integer candidate = null;\n\n        for (int num : nums) {\n            if (count == 0) {\n                candidate = num;\n            }\n            count += (num == candidate) ? 1 : -1;\n        }\n\n        return candidate;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\nclass solution:\n    def majorityelement(self, nums):\n        count = 0\n        candidate = none\n\n        for num in nums:\n            if count == 0:\n                candidate = num\n            count += (1 if num == candidate else -1)\n\n        return candidate\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n复杂度分析\n\n * 时间复杂度：o(n)o(n)o(n)\n   \n   boyer-moore 算法严格执行了 nnn 次循环，所以时间复杂度是线性时间的。\n   \n   \n * 空间复杂度：o(1)o(1)o(1)\n   \n   boyer-moore 只需要常数级别的额外空间。\n   \n   \n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2020-01-05 22:35:36accepted [https://leetcode-cn.com//submissions/detail/42388768/]1 ms100.0%43 mbjava# 统计信息\n通过次数提交次数ac比率10037216425061.1%# 相似题目\n题目难度求众数 ii [https://leetcode-cn.com/problems/majority-element-ii/]中等检查一个数是否在数组中占绝大多数 [https://leetcode-cn.com/problems/check-if-a-number-is-majority-element-in-a-sorted-array/]简单'},{title:"171-Excel表列序号(Excel Sheet Column Number)",frontmatter:{title:"171-Excel表列序号(Excel Sheet Column Number)",date:"2021-03-30T00:00:00.000Z",categories:["简单"],tags:["数学<Math>"]},regularPath:"/views/%E7%AE%80%E5%8D%95/0171-Excel%E8%A1%A8%E5%88%97%E5%BA%8F%E5%8F%B7.html",relativePath:"views/简单/0171-Excel表列序号.md",key:"v-58dab6f5",path:"/views/%E7%AE%80%E5%8D%95/0171-Excel%E8%A1%A8%E5%88%97%E5%BA%8F%E5%8F%B7.html",headers:[{level:2,title:"中文题目",slug:"中文题目",charIndex:2},{level:2,title:"通过代码",slug:"通过代码",charIndex:272},{level:2,title:"高赞题解",slug:"高赞题解",charIndex:589},{level:3,title:"解题思路",slug:"解题思路",charIndex:596},{level:3,title:"代码",slug:"代码",charIndex:274},{level:3,title:"画解",slug:"画解",charIndex:1115},{level:2,title:"提交历史",slug:"提交历史",charIndex:1240},{level:2,title:"统计信息",slug:"统计信息",charIndex:1374},{level:2,title:"相似题目",slug:"相似题目",charIndex:1408}],lastUpdated:"4/11/2021, 1:15:21 PM",headersStr:"中文题目 通过代码 高赞题解 解题思路 代码 画解 提交历史 统计信息 相似题目",content:'# 中文题目\n给定一个Excel表格中的列名称，返回其相应的列序号。\n\n例如，\n\n    A -> 1\n    B -> 2\n    C -> 3\n    ...\n    Z -> 26\n    AA -> 27\n    AB -> 28 \n    ...\n\n\n示例 1:\n\n输入: "A"\n输出: 1\n\n\n示例 2:\n\n输入: "AB"\n输出: 28\n\n\n示例 3:\n\n输入: "ZY"\n输出: 701\n\n致谢：\n特别感谢@ts [http://leetcode.com/discuss/user/ts]添加此问题并创建所有测试用例。\n\n# 通过代码\nclass Solution {\n    public int titleToNumber(String columnTitle) {\n        int res=0;\n        int tmp;\n        for (int i=columnTitle.length(),k=0;i>0;i--,k++){\n            tmp=columnTitle.charAt(i-1)-\'A\'+1;\n            res+=tmp*Math.pow(26,k);\n        }\n        return res;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n# 高赞题解\n# 解题思路\n * 标签：字符串遍历，进制转换\n * 初始化结果 ans = 0，遍历时将每个字母与 A 做减法，因为 A 表示 1，所以减法后需要每个数加 1，计算其代表的数值 num = 字母 - ‘A’ + 1\n * 因为有 26 个字母，所以相当于 26 进制，每 26 个数则向前进一位\n * 所以每遍历一位则ans = ans * 26 + num\n * 以 ZY 为例，Z 的值为 26，Y 的值为 25，则结果为 26 * 26 + 25=701\n * 时间复杂度：O(n)O(n)O(n)\n\n# 代码\nclass Solution {\n    public int titleToNumber(String s) {\n        int ans = 0;\n        for(int i=0;i<s.length();i++) {\n            int num = s.charAt(i) - \'A\' + 1;\n            ans = ans * 26 + num;\n        }\n        return ans;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n# 画解\n<,,,>\n\n想看大鹏画解更多高频面试题，欢迎阅读大鹏的 LeetBook：《画解剑指 Offer 》 [https://leetcode-cn.com/leetbook/detail/illustrate-lcof/]，O(∩_∩)O\n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2021-03-30 17:48:48Accepted [https://leetcode-cn.com//submissions/detail/161798256/]1 ms100.0%38.3 MBjava# 统计信息\n通过次数提交次数AC比率665769652769.0%# 相似题目\n题目难度Excel表列名称 [https://leetcode-cn.com/problems/excel-sheet-column-title/]简单',contentLowercase:'# 中文题目\n给定一个excel表格中的列名称，返回其相应的列序号。\n\n例如，\n\n    a -> 1\n    b -> 2\n    c -> 3\n    ...\n    z -> 26\n    aa -> 27\n    ab -> 28 \n    ...\n\n\n示例 1:\n\n输入: "a"\n输出: 1\n\n\n示例 2:\n\n输入: "ab"\n输出: 28\n\n\n示例 3:\n\n输入: "zy"\n输出: 701\n\n致谢：\n特别感谢@ts [http://leetcode.com/discuss/user/ts]添加此问题并创建所有测试用例。\n\n# 通过代码\nclass solution {\n    public int titletonumber(string columntitle) {\n        int res=0;\n        int tmp;\n        for (int i=columntitle.length(),k=0;i>0;i--,k++){\n            tmp=columntitle.charat(i-1)-\'a\'+1;\n            res+=tmp*math.pow(26,k);\n        }\n        return res;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n# 高赞题解\n# 解题思路\n * 标签：字符串遍历，进制转换\n * 初始化结果 ans = 0，遍历时将每个字母与 a 做减法，因为 a 表示 1，所以减法后需要每个数加 1，计算其代表的数值 num = 字母 - ‘a’ + 1\n * 因为有 26 个字母，所以相当于 26 进制，每 26 个数则向前进一位\n * 所以每遍历一位则ans = ans * 26 + num\n * 以 zy 为例，z 的值为 26，y 的值为 25，则结果为 26 * 26 + 25=701\n * 时间复杂度：o(n)o(n)o(n)\n\n# 代码\nclass solution {\n    public int titletonumber(string s) {\n        int ans = 0;\n        for(int i=0;i<s.length();i++) {\n            int num = s.charat(i) - \'a\' + 1;\n            ans = ans * 26 + num;\n        }\n        return ans;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n# 画解\n<,,,>\n\n想看大鹏画解更多高频面试题，欢迎阅读大鹏的 leetbook：《画解剑指 offer 》 [https://leetcode-cn.com/leetbook/detail/illustrate-lcof/]，o(∩_∩)o\n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2021-03-30 17:48:48accepted [https://leetcode-cn.com//submissions/detail/161798256/]1 ms100.0%38.3 mbjava# 统计信息\n通过次数提交次数ac比率665769652769.0%# 相似题目\n题目难度excel表列名称 [https://leetcode-cn.com/problems/excel-sheet-column-title/]简单'},{title:"141-环形链表(Linked List Cycle)",frontmatter:{title:"141-环形链表(Linked List Cycle)",date:"2021-04-12T00:00:00.000Z",categories:["简单"],tags:["链表<Linked List>","双指针<Two Pointers>"]},regularPath:"/views/%E7%AE%80%E5%8D%95/0141-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8.html",relativePath:"views/简单/0141-环形链表.md",key:"v-896f1fde",path:"/views/%E7%AE%80%E5%8D%95/0141-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8.html",headers:[{level:2,title:"中文题目",slug:"中文题目",charIndex:2},{level:2,title:"通过代码",slug:"通过代码",charIndex:527},{level:2,title:"我的笔记",slug:"我的笔记",charIndex:2010},{level:2,title:"高赞题解",slug:"高赞题解",charIndex:2044},{level:2,title:"提交历史",slug:"提交历史",charIndex:5860},{level:2,title:"统计信息",slug:"统计信息",charIndex:6709},{level:2,title:"相似题目",slug:"相似题目",charIndex:6745}],headersStr:"中文题目 通过代码 我的笔记 高赞题解 提交历史 统计信息 相似题目",content:'# 中文题目\n给定一个链表，判断链表中是否有环。\n\n如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。\n\n如果链表中存在环，则返回 true 。 否则，返回 false 。\n\n\n\n进阶：\n\n你能用 O(1)（即，常量）内存解决此问题吗？\n\n\n\n示例 1：\n\n\n\n输入：head = [3,2,0,-4], pos = 1\n输出：true\n解释：链表中有一个环，其尾部连接到第二个节点。\n\n\n示例 2：\n\n\n\n输入：head = [1,2], pos = 0\n输出：true\n解释：链表中有一个环，其尾部连接到第一个节点。\n\n\n示例 3：\n\n\n\n输入：head = [1], pos = -1\n输出：false\n解释：链表中没有环。\n\n\n\n\n提示：\n\n * 链表中节点的数目范围是 [0, 104]\n * -105 <= Node.val <= 105\n * pos 为 -1 或者链表中的一个 有效索引 。\n\n# 通过代码\n/**\n * Definition for singly-linked list.\n * class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\npublic class Solution {\n    public boolean hasCycle(ListNode head) {\n        // 快慢指针，快指针每次走两步，慢指针每次走一步\n        if (head == null || head.next == null) {\n            return false;\n        }\n        // 初始化位置\n        ListNode slow = head;\n        ListNode fast = head.next;\n        while (slow != fast) {\n            // 注意这里判断的时fast是否为null和fast的后继是否为null\n            if (fast == null || fast.next == null) {\n                return false;\n            }\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        return true;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n/**\n * Definition for singly-linked list.\n * class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\npublic class Solution {\n    public boolean hasCycle(ListNode head) {\n        // 注意要用ListNode作为元素，因为ListNode有next，只有保证next也相同才时环\n        // 不能使用Integer作为元素\n        Set<ListNode> set=new HashSet<>();\n        while (head!=null){\n            if (set.contains(head)){\n                return true;\n            }\n            set.add(head);\n            head=head.next;\n        }\n        return false;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n# 我的笔记\n环形链表的判断主要采用set缓存或者快慢指针的方法\n\n# 高赞题解\n# 相爱相杀好基友——数组与链表\n作为线性表的两种存储方式 —— 链表和数组，这对相爱相杀的好基友有着各自的优缺点。接下来，我们梳理一下这两种方式。\n\n数组，所有元素都连续的存储于一段内存中，且每个元素占用的内存大小相同。这使得数组具备了通过下标快速访问数据的能力。 但连续存储的缺点也很明显，增加容量，增删元素的成本很高，时间复杂度均为 O(n)。 增加数组容量需要先申请一块新的内存，然后复制原有的元素。如果需要的话，可能还要删除原先的内存。删除元素时需要移动被删除元素之后的所有元素以保证所有元素是连续的。增加元素时需要移动指定位置及之后的所有元素，然后将新增元素插入到指定位置，如果容量不足的话还需要先进行扩容操作。\n\n总结一下数组的优缺点：\n\n * 优点：可以根据偏移实现快速的随机读写。\n * 缺点：扩容，增删元素极慢。\n\n链表，由若干个结点组成，每个结点包含数据域和指针域。结点结构如下图所示：一般来讲，链表中只会有一个结点的指针域为空，该结点为尾结点，其他结点的指针域都会存储一个结点的内存地址。链表中也只会有一个结点的内存地址没有存储在其他结点的指针域，该结点称为头结点。链表的存储方式使得它可以高效的在指定位置插入与删除，时间复杂度均为 O(1)。 在结点 p 之后增加一个结点 q 总共分三步：\n\n 1. 申请一段内存用以存储 q (可以使用内存池避免频繁申请和销毁内存)。\n 2. 将 p 的指针域数据复制到 q 的指针域。\n 3. 更新 p 的指针域为 q 的地址。\n\n删除结点 p 之后的结点 q 总共分两步：\n\n 1. 将 q 的指针域复制到 p 的指针域。\n 2. 释放 q 结点的内存。\n\n# 链表的主要代码\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n//定义一个结点模板\ntemplate<typename T>\nstruct Node {\n\tT data;\n\tNode *next;\n\tNode() : next(nullptr) {}\n\tNode(const T &d) : data(d), next(nullptr) {}\n};\n\n//删除 p 结点后面的元素\ntemplate<typename T>\nvoid Remove(Node<T> *p) {\n\tif (p == nullptr || p->next == nullptr) {\n\t\treturn;\n\t}\n\tauto tmp = p->next->next;\n\tdelete p->next;\n\tp->next = tmp;\n}\n\n//在 p 结点后面插入元素\ntemplate<typename T>\nvoid Insert(Node<T> *p, const T &data) {\n\tauto tmp = new Node<T>(data);\n\ttmp->next = p->next;\n\tp->next = tmp;\n}\n\n//遍历链表\ntemplate<typename T, typename V>\nvoid Walk(Node<T> *p, const V &vistor) {\n\twhile(p != nullptr) {\n\t\tvistor(p);\n\t\tp = p->next;\n\t}\n}\n\nint main() {\n\tauto p = new Node<int>(1);\n\tInsert(p, 2);\n\tint sum = 0;\n\tWalk(p, [&sum](const Node<int> *p) -> void { sum += p->data; });\n\tcout << sum << endl;\n\tRemove(p);\n\tsum = 0;\n\tWalk(p, [&sum](const Node<int> *p) -> void { sum += p->data; });\n\tcout << sum << endl;\n\treturn 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n# 面试问题总结\n无法高效获取长度，无法根据偏移快速访问元素，是链表的两个劣势。然而面试的时候经常碰见诸如获取倒数第k个元素，获取中间位置的元素，判断链表是否存在环，判断环的长度等和长度与位置有关的问题。这些问题都可以通过灵活运用双指针来解决。\n\nTips：双指针并不是固定的公式，而是一种思维方式~\n\n先来看"倒数第k个元素的问题"。设有两个指针 p 和 q，初始时均指向头结点。首先，先让 p 沿着 next 移动 k 次。此时，p 指向第 k+1个结点，q 指向头节点，两个指针的距离为 k 。然后，同时移动 p 和 q，直到 p 指向空，此时 q 即指向倒数第 k 个结点。可以参考下图来理解：\n\nclass Solution {\npublic:\n    ListNode* getKthFromEnd(ListNode* head, int k) {\n        ListNode *p = head, *q = head; //初始化\n        while(k--) {   //将 p指针移动 k 次\n            p = p->next;\n        }\n        while(p != nullptr) {//同时移动，直到 p == nullptr\n            p = p->next;\n            q = q->next;\n        }\n        return q;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n获取中间元素的问题。设有两个指针 fast 和 slow，初始时指向头节点。每次移动时，fast向后走两次，slow向后走一次，直到 fast 无法向后走两次。这使得在每轮移动之后。fast 和 slow 的距离就会增加一。设链表有 n 个元素，那么最多移动 n/2 轮。当 n 为奇数时，slow 恰好指向中间结点，当 n 为 偶数时，slow 恰好指向中间两个结点的靠前一个(可以考虑下如何使其指向后一个结点呢？)。下述代码实现了 n 为偶数时慢指针指向靠后结点。\n\nclass Solution {\npublic:\n    ListNode* middleNode(ListNode* head) {\n        ListNode *p = head, *q = head;\n        while(q != nullptr && q->next != nullptr) {\n            p = p->next;\n            q = q->next->next;\n        }\n        return p;\n    } \n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n是否存在环的问题。如果将尾结点的 next 指针指向其他任意一个结点，那么链表就存在了一个环。上一部分中，总结快慢指针的特性 —— 每轮移动之后两者的距离会加一。下面会继续用该特性解决环的问题。 当一个链表有环时，快慢指针都会陷入环中进行无限次移动，然后变成了追及问题。想象一下在操场跑步的场景，只要一直跑下去，快的总会追上慢的。当两个指针都进入环后，每轮移动使得慢指针到快指针的距离增加一，同时快指针到慢指针的距离也减少一，只要一直移动下去，快指针总会追上慢指针。根据上述表述得出，如果一个链表存在环，那么快慢指针必然会相遇。实现代码如下：\n\nclass Solution {\npublic:\n    bool hasCycle(ListNode *head) {\n        ListNode *slow = head;\n        ListNode *fast = head;\n        while(fast != nullptr) {\n            fast = fast->next;\n            if(fast != nullptr) {\n                fast = fast->next;\n            }\n            if(fast == slow) {\n                return true;\n            }\n            slow = slow->next;\n        }\n        return nullptr;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n最后一个问题，如果存在环，如何判断环的长度呢？方法是，快慢指针相遇后继续移动，直到第二次相遇。两次相遇间的移动次数即为环的长度。\n\n\n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2021-04-12 22:26:06Accepted [https://leetcode-cn.com//submissions/detail/167136349/]0 ms100.0%39.8 MBjava2021-04-12 22:23:16Runtime Error [https://leetcode-cn.com//submissions/detail/167134913/]N/AN/AN/Ajava2021-04-12 22:20:27Runtime Error [https://leetcode-cn.com//submissions/detail/167133484/]N/AN/AN/Ajava2021-04-12 22:18:48Wrong Answer [https://leetcode-cn.com//submissions/detail/167132647/]N/AN/AN/Ajava2021-04-12 22:17:51Runtime Error [https://leetcode-cn.com//submissions/detail/167132174/]N/AN/AN/Ajava2021-04-12 22:13:53Accepted [https://leetcode-cn.com//submissions/detail/167130269/]7 ms100.0%39.1 MBjava2021-04-12 22:02:20Wrong Answer [https://leetcode-cn.com//submissions/detail/167124350/]N/AN/AN/Ajava2021-04-12 22:00:23Runtime Error [https://leetcode-cn.com//submissions/detail/167123354/]N/AN/AN/Ajava# 统计信息\n通过次数提交次数AC比率38640875940650.9%# 相似题目\n题目难度环形链表 II [https://leetcode-cn.com/problems/linked-list-cycle-ii/]中等快乐数 [https://leetcode-cn.com/problems/happy-number/]简单',contentLowercase:'# 中文题目\n给定一个链表，判断链表中是否有环。\n\n如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。\n\n如果链表中存在环，则返回 true 。 否则，返回 false 。\n\n\n\n进阶：\n\n你能用 o(1)（即，常量）内存解决此问题吗？\n\n\n\n示例 1：\n\n\n\n输入：head = [3,2,0,-4], pos = 1\n输出：true\n解释：链表中有一个环，其尾部连接到第二个节点。\n\n\n示例 2：\n\n\n\n输入：head = [1,2], pos = 0\n输出：true\n解释：链表中有一个环，其尾部连接到第一个节点。\n\n\n示例 3：\n\n\n\n输入：head = [1], pos = -1\n输出：false\n解释：链表中没有环。\n\n\n\n\n提示：\n\n * 链表中节点的数目范围是 [0, 104]\n * -105 <= node.val <= 105\n * pos 为 -1 或者链表中的一个 有效索引 。\n\n# 通过代码\n/**\n * definition for singly-linked list.\n * class listnode {\n *     int val;\n *     listnode next;\n *     listnode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\npublic class solution {\n    public boolean hascycle(listnode head) {\n        // 快慢指针，快指针每次走两步，慢指针每次走一步\n        if (head == null || head.next == null) {\n            return false;\n        }\n        // 初始化位置\n        listnode slow = head;\n        listnode fast = head.next;\n        while (slow != fast) {\n            // 注意这里判断的时fast是否为null和fast的后继是否为null\n            if (fast == null || fast.next == null) {\n                return false;\n            }\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        return true;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n/**\n * definition for singly-linked list.\n * class listnode {\n *     int val;\n *     listnode next;\n *     listnode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\npublic class solution {\n    public boolean hascycle(listnode head) {\n        // 注意要用listnode作为元素，因为listnode有next，只有保证next也相同才时环\n        // 不能使用integer作为元素\n        set<listnode> set=new hashset<>();\n        while (head!=null){\n            if (set.contains(head)){\n                return true;\n            }\n            set.add(head);\n            head=head.next;\n        }\n        return false;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n# 我的笔记\n环形链表的判断主要采用set缓存或者快慢指针的方法\n\n# 高赞题解\n# 相爱相杀好基友——数组与链表\n作为线性表的两种存储方式 —— 链表和数组，这对相爱相杀的好基友有着各自的优缺点。接下来，我们梳理一下这两种方式。\n\n数组，所有元素都连续的存储于一段内存中，且每个元素占用的内存大小相同。这使得数组具备了通过下标快速访问数据的能力。 但连续存储的缺点也很明显，增加容量，增删元素的成本很高，时间复杂度均为 o(n)。 增加数组容量需要先申请一块新的内存，然后复制原有的元素。如果需要的话，可能还要删除原先的内存。删除元素时需要移动被删除元素之后的所有元素以保证所有元素是连续的。增加元素时需要移动指定位置及之后的所有元素，然后将新增元素插入到指定位置，如果容量不足的话还需要先进行扩容操作。\n\n总结一下数组的优缺点：\n\n * 优点：可以根据偏移实现快速的随机读写。\n * 缺点：扩容，增删元素极慢。\n\n链表，由若干个结点组成，每个结点包含数据域和指针域。结点结构如下图所示：一般来讲，链表中只会有一个结点的指针域为空，该结点为尾结点，其他结点的指针域都会存储一个结点的内存地址。链表中也只会有一个结点的内存地址没有存储在其他结点的指针域，该结点称为头结点。链表的存储方式使得它可以高效的在指定位置插入与删除，时间复杂度均为 o(1)。 在结点 p 之后增加一个结点 q 总共分三步：\n\n 1. 申请一段内存用以存储 q (可以使用内存池避免频繁申请和销毁内存)。\n 2. 将 p 的指针域数据复制到 q 的指针域。\n 3. 更新 p 的指针域为 q 的地址。\n\n删除结点 p 之后的结点 q 总共分两步：\n\n 1. 将 q 的指针域复制到 p 的指针域。\n 2. 释放 q 结点的内存。\n\n# 链表的主要代码\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n//定义一个结点模板\ntemplate<typename t>\nstruct node {\n\tt data;\n\tnode *next;\n\tnode() : next(nullptr) {}\n\tnode(const t &d) : data(d), next(nullptr) {}\n};\n\n//删除 p 结点后面的元素\ntemplate<typename t>\nvoid remove(node<t> *p) {\n\tif (p == nullptr || p->next == nullptr) {\n\t\treturn;\n\t}\n\tauto tmp = p->next->next;\n\tdelete p->next;\n\tp->next = tmp;\n}\n\n//在 p 结点后面插入元素\ntemplate<typename t>\nvoid insert(node<t> *p, const t &data) {\n\tauto tmp = new node<t>(data);\n\ttmp->next = p->next;\n\tp->next = tmp;\n}\n\n//遍历链表\ntemplate<typename t, typename v>\nvoid walk(node<t> *p, const v &vistor) {\n\twhile(p != nullptr) {\n\t\tvistor(p);\n\t\tp = p->next;\n\t}\n}\n\nint main() {\n\tauto p = new node<int>(1);\n\tinsert(p, 2);\n\tint sum = 0;\n\twalk(p, [&sum](const node<int> *p) -> void { sum += p->data; });\n\tcout << sum << endl;\n\tremove(p);\n\tsum = 0;\n\twalk(p, [&sum](const node<int> *p) -> void { sum += p->data; });\n\tcout << sum << endl;\n\treturn 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n# 面试问题总结\n无法高效获取长度，无法根据偏移快速访问元素，是链表的两个劣势。然而面试的时候经常碰见诸如获取倒数第k个元素，获取中间位置的元素，判断链表是否存在环，判断环的长度等和长度与位置有关的问题。这些问题都可以通过灵活运用双指针来解决。\n\ntips：双指针并不是固定的公式，而是一种思维方式~\n\n先来看"倒数第k个元素的问题"。设有两个指针 p 和 q，初始时均指向头结点。首先，先让 p 沿着 next 移动 k 次。此时，p 指向第 k+1个结点，q 指向头节点，两个指针的距离为 k 。然后，同时移动 p 和 q，直到 p 指向空，此时 q 即指向倒数第 k 个结点。可以参考下图来理解：\n\nclass solution {\npublic:\n    listnode* getkthfromend(listnode* head, int k) {\n        listnode *p = head, *q = head; //初始化\n        while(k--) {   //将 p指针移动 k 次\n            p = p->next;\n        }\n        while(p != nullptr) {//同时移动，直到 p == nullptr\n            p = p->next;\n            q = q->next;\n        }\n        return q;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n获取中间元素的问题。设有两个指针 fast 和 slow，初始时指向头节点。每次移动时，fast向后走两次，slow向后走一次，直到 fast 无法向后走两次。这使得在每轮移动之后。fast 和 slow 的距离就会增加一。设链表有 n 个元素，那么最多移动 n/2 轮。当 n 为奇数时，slow 恰好指向中间结点，当 n 为 偶数时，slow 恰好指向中间两个结点的靠前一个(可以考虑下如何使其指向后一个结点呢？)。下述代码实现了 n 为偶数时慢指针指向靠后结点。\n\nclass solution {\npublic:\n    listnode* middlenode(listnode* head) {\n        listnode *p = head, *q = head;\n        while(q != nullptr && q->next != nullptr) {\n            p = p->next;\n            q = q->next->next;\n        }\n        return p;\n    } \n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n是否存在环的问题。如果将尾结点的 next 指针指向其他任意一个结点，那么链表就存在了一个环。上一部分中，总结快慢指针的特性 —— 每轮移动之后两者的距离会加一。下面会继续用该特性解决环的问题。 当一个链表有环时，快慢指针都会陷入环中进行无限次移动，然后变成了追及问题。想象一下在操场跑步的场景，只要一直跑下去，快的总会追上慢的。当两个指针都进入环后，每轮移动使得慢指针到快指针的距离增加一，同时快指针到慢指针的距离也减少一，只要一直移动下去，快指针总会追上慢指针。根据上述表述得出，如果一个链表存在环，那么快慢指针必然会相遇。实现代码如下：\n\nclass solution {\npublic:\n    bool hascycle(listnode *head) {\n        listnode *slow = head;\n        listnode *fast = head;\n        while(fast != nullptr) {\n            fast = fast->next;\n            if(fast != nullptr) {\n                fast = fast->next;\n            }\n            if(fast == slow) {\n                return true;\n            }\n            slow = slow->next;\n        }\n        return nullptr;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n最后一个问题，如果存在环，如何判断环的长度呢？方法是，快慢指针相遇后继续移动，直到第二次相遇。两次相遇间的移动次数即为环的长度。\n\n\n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2021-04-12 22:26:06accepted [https://leetcode-cn.com//submissions/detail/167136349/]0 ms100.0%39.8 mbjava2021-04-12 22:23:16runtime error [https://leetcode-cn.com//submissions/detail/167134913/]n/an/an/ajava2021-04-12 22:20:27runtime error [https://leetcode-cn.com//submissions/detail/167133484/]n/an/an/ajava2021-04-12 22:18:48wrong answer [https://leetcode-cn.com//submissions/detail/167132647/]n/an/an/ajava2021-04-12 22:17:51runtime error [https://leetcode-cn.com//submissions/detail/167132174/]n/an/an/ajava2021-04-12 22:13:53accepted [https://leetcode-cn.com//submissions/detail/167130269/]7 ms100.0%39.1 mbjava2021-04-12 22:02:20wrong answer [https://leetcode-cn.com//submissions/detail/167124350/]n/an/an/ajava2021-04-12 22:00:23runtime error [https://leetcode-cn.com//submissions/detail/167123354/]n/an/an/ajava# 统计信息\n通过次数提交次数ac比率38640875940650.9%# 相似题目\n题目难度环形链表 ii [https://leetcode-cn.com/problems/linked-list-cycle-ii/]中等快乐数 [https://leetcode-cn.com/problems/happy-number/]简单'},{title:"189-旋转数组(Rotate Array)",frontmatter:{title:"189-旋转数组(Rotate Array)",date:"2020-01-08T00:00:00.000Z",categories:["简单"],tags:["数组<Array>"]},regularPath:"/views/%E7%AE%80%E5%8D%95/0189-%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84.html",relativePath:"views/简单/0189-旋转数组.md",key:"v-683b2412",path:"/views/%E7%AE%80%E5%8D%95/0189-%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84.html",headers:[{level:2,title:"中文题目",slug:"中文题目",charIndex:2},{level:2,title:"通过代码",slug:"通过代码",charIndex:358},{level:2,title:"官方题解",slug:"官方题解",charIndex:982},{level:2,title:"提交历史",slug:"提交历史",charIndex:4453},{level:2,title:"统计信息",slug:"统计信息",charIndex:4586},{level:2,title:"相似题目",slug:"相似题目",charIndex:4621}],lastUpdated:"4/11/2021, 1:15:21 PM",headersStr:"中文题目 通过代码 官方题解 提交历史 统计信息 相似题目",content:"# 中文题目\n给定一个数组，将数组中的元素向右移动k个位置，其中k是非负数。\n\n示例 1:\n\n输入: [1,2,3,4,5,6,7] 和 k = 3\n输出: [5,6,7,1,2,3,4]\n解释:\n向右旋转 1 步: [7,1,2,3,4,5,6]\n向右旋转 2 步: [6,7,1,2,3,4,5]\n向右旋转 3 步: [5,6,7,1,2,3,4]\n\n\n示例 2:\n\n输入: [-1,-100,3,99] 和 k = 2\n输出: [3,99,-1,-100]\n解释: \n向右旋转 1 步: [99,-1,-100,3]\n向右旋转 2 步: [3,99,-1,-100]\n\n说明:\n\n * 尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。\n * 要求使用空间复杂度为 O(1) 的原地算法。\n\n# 通过代码\nclass Solution {\n    public void rotate(int[] nums, int k) {\n        // 三步：\n        // 1. 先整体旋转\n        // 2. 再旋转前k个元素\n        // 3. 再旋转后n-k个元素\n\n        k %= nums.length;\n        rotate(nums, 0, nums.length - 1);\n        rotate(nums, 0, k - 1);\n        rotate(nums, k, nums.length - 1);\n    }\n\n    public void rotate(int[] nums, int start, int end) {\n        int temp;\n        while (start < end) {\n            temp = nums[start];\n            nums[start] = nums[end];\n            nums[end] = temp;\n            start++;\n            end--;\n        }\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n# 官方题解\n# 方法 1：暴力\n最简单的方法是旋转 k 次，每次将数组旋转 1 个元素。\n\npublic class Solution {\n    public void rotate(int[] nums, int k) {\n        int temp, previous;\n        for (int i = 0; i < k; i++) {\n            previous = nums[nums.length - 1];\n            for (int j = 0; j < nums.length; j++) {\n                temp = nums[j];\n                nums[j] = previous;\n                previous = temp;\n            }\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n复杂度分析\n\n * 时间复杂度：O(n∗k)O(n*k)O(n∗k) 。每个元素都被移动 1 步（O(n)O(n)O(n)） k次（O(k)O(k)O(k)） 。\n * 空间复杂度：O(1)O(1)O(1) 。没有额外空间被使用。\n\n# 方法 2：使用额外的数组\n算法\n\n我们可以用一个额外的数组来将每个元素放到正确的位置上，也就是原本数组里下标为 iii 的我们把它放到 (i+k)%数组长度(i+k)\\%数组长度(i+k)%数组长度 的位置。然后把新的数组拷贝到原数组中。\n\npublic class Solution {\n    public void rotate(int[] nums, int k) {\n        int[] a = new int[nums.length];\n        for (int i = 0; i < nums.length; i++) {\n            a[(i + k) % nums.length] = nums[i];\n        }\n        for (int i = 0; i < nums.length; i++) {\n            nums[i] = a[i];\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n复杂度分析\n\n * 时间复杂度： O(n)O(n)O(n) 。将数字放到新的数组中需要一遍遍历，另一边来把新数组的元素拷贝回原数组。\n * 空间复杂度： O(n)O(n)O(n)。另一个数组需要原数组长度的空间。\n\n# 方法 3：使用环状替换\n算法\n\n如果我们直接把每一个数字放到它最后的位置，但这样的后果是遗失原来的元素。因此，我们需要把被替换的数字保存在变量 temptemptemp 里面。然后，我们将被替换数字（temptemptemp）放到它正确的位置，并继续这个过程 nnn 次， nnn 是数组的长度。这是因为我们需要将数组里所有的元素都移动。但是，这种方法可能会有个问题，如果 n%k==0n\\%k==0n%k==0，其中 k=k%nk=k\\%nk=k%n （因为如果 kkk 大于 nnn ，移动 kkk 次实际上相当于移动 k%nk\\%nk%n 次）。这种情况下，我们会发现在没有遍历所有数字的情况下回到出发数字。此时，我们应该从下一个数字开始再重复相同的过程。\n\n现在，我们看看上面方法的证明。假设，数组里我们有 nnn 个元素并且 kkk 是要求移动的次数。更进一步，假设 n%k=0n\\%k=0n%k=0 。第一轮中，所有移动数字的下标 iii 满足 i%k==0i\\%k==0i%k==0 。这是因为我们每跳 kkk 步，我们只会到达相距为 kkk 个位置下标的数。每一轮，我们都会移动 nk\\frac{n}{k}kn​ 个元素。下一轮中，我们会移动满足 i%k==1i\\%k==1i%k==1 的位置的数。这样的轮次会一直持续到我们再次遇到 i%k==0i\\%k==0i%k==0 的地方为止，此时 i=ki=ki=k 。此时在正确位置上的数字共有 k×nk=nk \\times \\frac{n}{k}=nk×kn​=n 个。因此所有数字都在正确位置上。\n\n让我们看一下接下来的例子，以更好地说明这个过程：\n\nnums: [1, 2, 3, 4, 5, 6]\nk: 2\n\n\n1\n2\n\n\npublic class Solution {\n    public void rotate(int[] nums, int k) {\n        k = k % nums.length;\n        int count = 0;\n        for (int start = 0; count < nums.length; start++) {\n            int current = start;\n            int prev = nums[start];\n            do {\n                int next = (current + k) % nums.length;\n                int temp = nums[next];\n                nums[next] = prev;\n                prev = temp;\n                current = next;\n                count++;\n            } while (start != current);\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n复杂度分析\n\n * 时间复杂度：O(n)O(n)O(n) 。只遍历了每个元素一次。\n * 空间复杂度：O(1)O(1)O(1) 。使用了常数个额外空间。\n\n# 方法 4：使用反转\n算法\n\n这个方法基于这个事实：当我们旋转数组 k 次， k%nk\\%nk%n 个尾部元素会被移动到头部，剩下的元素会被向后移动。\n\n在这个方法中，我们首先将所有元素反转。然后反转前 k 个元素，再反转后面 n−kn-kn−k 个元素，就能得到想要的结果。\n\n假设 n=7n=7n=7 且 k=3k=3k=3 。\n\n原始数组                  : 1 2 3 4 5 6 7\n反转所有数字后             : 7 6 5 4 3 2 1\n反转前 k 个数字后          : 5 6 7 4 3 2 1\n反转后 n-k 个数字后        : 5 6 7 1 2 3 4 --\x3e 结果\n\n\n1\n2\n3\n4\npublic class Solution {\n    public void rotate(int[] nums, int k) {\n        k %= nums.length;\n        reverse(nums, 0, nums.length - 1);\n        reverse(nums, 0, k - 1);\n        reverse(nums, k, nums.length - 1);\n    }\n    public void reverse(int[] nums, int start, int end) {\n        while (start < end) {\n            int temp = nums[start];\n            nums[start] = nums[end];\n            nums[end] = temp;\n            start++;\n            end--;\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n复杂度分析\n\n * 时间复杂度：O(n)O(n)O(n) 。 nnn 个元素被反转了总共 3 次。\n * 空间复杂度：O(1)O(1)O(1) 。 没有使用额外的空间。\n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2020-01-08 22:01:02Accepted [https://leetcode-cn.com//submissions/detail/42785269/]0 ms100.0%38.1 MBjava# 统计信息\n通过次数提交次数AC比率9105122709740.1%# 相似题目\n题目难度旋转链表 [https://leetcode-cn.com/problems/rotate-list/]中等翻转字符串里的单词 II [https://leetcode-cn.com/problems/reverse-words-in-a-string-ii/]中等",contentLowercase:"# 中文题目\n给定一个数组，将数组中的元素向右移动k个位置，其中k是非负数。\n\n示例 1:\n\n输入: [1,2,3,4,5,6,7] 和 k = 3\n输出: [5,6,7,1,2,3,4]\n解释:\n向右旋转 1 步: [7,1,2,3,4,5,6]\n向右旋转 2 步: [6,7,1,2,3,4,5]\n向右旋转 3 步: [5,6,7,1,2,3,4]\n\n\n示例 2:\n\n输入: [-1,-100,3,99] 和 k = 2\n输出: [3,99,-1,-100]\n解释: \n向右旋转 1 步: [99,-1,-100,3]\n向右旋转 2 步: [3,99,-1,-100]\n\n说明:\n\n * 尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。\n * 要求使用空间复杂度为 o(1) 的原地算法。\n\n# 通过代码\nclass solution {\n    public void rotate(int[] nums, int k) {\n        // 三步：\n        // 1. 先整体旋转\n        // 2. 再旋转前k个元素\n        // 3. 再旋转后n-k个元素\n\n        k %= nums.length;\n        rotate(nums, 0, nums.length - 1);\n        rotate(nums, 0, k - 1);\n        rotate(nums, k, nums.length - 1);\n    }\n\n    public void rotate(int[] nums, int start, int end) {\n        int temp;\n        while (start < end) {\n            temp = nums[start];\n            nums[start] = nums[end];\n            nums[end] = temp;\n            start++;\n            end--;\n        }\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n# 官方题解\n# 方法 1：暴力\n最简单的方法是旋转 k 次，每次将数组旋转 1 个元素。\n\npublic class solution {\n    public void rotate(int[] nums, int k) {\n        int temp, previous;\n        for (int i = 0; i < k; i++) {\n            previous = nums[nums.length - 1];\n            for (int j = 0; j < nums.length; j++) {\n                temp = nums[j];\n                nums[j] = previous;\n                previous = temp;\n            }\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n复杂度分析\n\n * 时间复杂度：o(n∗k)o(n*k)o(n∗k) 。每个元素都被移动 1 步（o(n)o(n)o(n)） k次（o(k)o(k)o(k)） 。\n * 空间复杂度：o(1)o(1)o(1) 。没有额外空间被使用。\n\n# 方法 2：使用额外的数组\n算法\n\n我们可以用一个额外的数组来将每个元素放到正确的位置上，也就是原本数组里下标为 iii 的我们把它放到 (i+k)%数组长度(i+k)\\%数组长度(i+k)%数组长度 的位置。然后把新的数组拷贝到原数组中。\n\npublic class solution {\n    public void rotate(int[] nums, int k) {\n        int[] a = new int[nums.length];\n        for (int i = 0; i < nums.length; i++) {\n            a[(i + k) % nums.length] = nums[i];\n        }\n        for (int i = 0; i < nums.length; i++) {\n            nums[i] = a[i];\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n复杂度分析\n\n * 时间复杂度： o(n)o(n)o(n) 。将数字放到新的数组中需要一遍遍历，另一边来把新数组的元素拷贝回原数组。\n * 空间复杂度： o(n)o(n)o(n)。另一个数组需要原数组长度的空间。\n\n# 方法 3：使用环状替换\n算法\n\n如果我们直接把每一个数字放到它最后的位置，但这样的后果是遗失原来的元素。因此，我们需要把被替换的数字保存在变量 temptemptemp 里面。然后，我们将被替换数字（temptemptemp）放到它正确的位置，并继续这个过程 nnn 次， nnn 是数组的长度。这是因为我们需要将数组里所有的元素都移动。但是，这种方法可能会有个问题，如果 n%k==0n\\%k==0n%k==0，其中 k=k%nk=k\\%nk=k%n （因为如果 kkk 大于 nnn ，移动 kkk 次实际上相当于移动 k%nk\\%nk%n 次）。这种情况下，我们会发现在没有遍历所有数字的情况下回到出发数字。此时，我们应该从下一个数字开始再重复相同的过程。\n\n现在，我们看看上面方法的证明。假设，数组里我们有 nnn 个元素并且 kkk 是要求移动的次数。更进一步，假设 n%k=0n\\%k=0n%k=0 。第一轮中，所有移动数字的下标 iii 满足 i%k==0i\\%k==0i%k==0 。这是因为我们每跳 kkk 步，我们只会到达相距为 kkk 个位置下标的数。每一轮，我们都会移动 nk\\frac{n}{k}kn​ 个元素。下一轮中，我们会移动满足 i%k==1i\\%k==1i%k==1 的位置的数。这样的轮次会一直持续到我们再次遇到 i%k==0i\\%k==0i%k==0 的地方为止，此时 i=ki=ki=k 。此时在正确位置上的数字共有 k×nk=nk \\times \\frac{n}{k}=nk×kn​=n 个。因此所有数字都在正确位置上。\n\n让我们看一下接下来的例子，以更好地说明这个过程：\n\nnums: [1, 2, 3, 4, 5, 6]\nk: 2\n\n\n1\n2\n\n\npublic class solution {\n    public void rotate(int[] nums, int k) {\n        k = k % nums.length;\n        int count = 0;\n        for (int start = 0; count < nums.length; start++) {\n            int current = start;\n            int prev = nums[start];\n            do {\n                int next = (current + k) % nums.length;\n                int temp = nums[next];\n                nums[next] = prev;\n                prev = temp;\n                current = next;\n                count++;\n            } while (start != current);\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n复杂度分析\n\n * 时间复杂度：o(n)o(n)o(n) 。只遍历了每个元素一次。\n * 空间复杂度：o(1)o(1)o(1) 。使用了常数个额外空间。\n\n# 方法 4：使用反转\n算法\n\n这个方法基于这个事实：当我们旋转数组 k 次， k%nk\\%nk%n 个尾部元素会被移动到头部，剩下的元素会被向后移动。\n\n在这个方法中，我们首先将所有元素反转。然后反转前 k 个元素，再反转后面 n−kn-kn−k 个元素，就能得到想要的结果。\n\n假设 n=7n=7n=7 且 k=3k=3k=3 。\n\n原始数组                  : 1 2 3 4 5 6 7\n反转所有数字后             : 7 6 5 4 3 2 1\n反转前 k 个数字后          : 5 6 7 4 3 2 1\n反转后 n-k 个数字后        : 5 6 7 1 2 3 4 --\x3e 结果\n\n\n1\n2\n3\n4\npublic class solution {\n    public void rotate(int[] nums, int k) {\n        k %= nums.length;\n        reverse(nums, 0, nums.length - 1);\n        reverse(nums, 0, k - 1);\n        reverse(nums, k, nums.length - 1);\n    }\n    public void reverse(int[] nums, int start, int end) {\n        while (start < end) {\n            int temp = nums[start];\n            nums[start] = nums[end];\n            nums[end] = temp;\n            start++;\n            end--;\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n复杂度分析\n\n * 时间复杂度：o(n)o(n)o(n) 。 nnn 个元素被反转了总共 3 次。\n * 空间复杂度：o(1)o(1)o(1) 。 没有使用额外的空间。\n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2020-01-08 22:01:02accepted [https://leetcode-cn.com//submissions/detail/42785269/]0 ms100.0%38.1 mbjava# 统计信息\n通过次数提交次数ac比率9105122709740.1%# 相似题目\n题目难度旋转链表 [https://leetcode-cn.com/problems/rotate-list/]中等翻转字符串里的单词 ii [https://leetcode-cn.com/problems/reverse-words-in-a-string-ii/]中等"},{title:"198-打家劫舍(House Robber)",frontmatter:{title:"198-打家劫舍(House Robber)",date:"2018-07-24T00:00:00.000Z",categories:["简单"],tags:["动态规划<Dynamic Programming>"]},regularPath:"/views/%E7%AE%80%E5%8D%95/0198-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D.html",relativePath:"views/简单/0198-打家劫舍.md",key:"v-0d83ecdc",path:"/views/%E7%AE%80%E5%8D%95/0198-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D.html",headers:[{level:2,title:"中文题目",slug:"中文题目",charIndex:2},{level:2,title:"通过代码",slug:"通过代码",charIndex:381},{level:2,title:"官方题解",slug:"官方题解",charIndex:2992},{level:2,title:"提交历史",slug:"提交历史",charIndex:3754},{level:2,title:"统计信息",slug:"统计信息",charIndex:4078},{level:2,title:"相似题目",slug:"相似题目",charIndex:4113}],lastUpdated:"4/11/2021, 1:15:21 PM",headersStr:"中文题目 通过代码 官方题解 提交历史 统计信息 相似题目",content:"# 中文题目\n你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。\n\n给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。\n\n示例 1:\n\n输入: [1,2,3,1]\n输出: 4\n解释: 偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。\n     偷窃到的最高金额 = 1 + 3 = 4 。\n\n示例 2:\n\n输入: [2,7,9,3,1]\n输出: 12\n解释: 偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。\n     偷窃到的最高金额 = 2 + 9 + 1 = 12 。\n\n\n# 通过代码\nclass Solution {\n    // public int rob(int[] nums) {\n    //     int prevNo=0; //前一步不走\n    //     int prevYes=0; //前一步走\n    //     int temp;\n    //     for (int n : nums) {\n    //         temp=prevNo; //取得不走的临时值\n    //         prevNo=Math.max(prevNo,prevYes); //在前面的走和不走选一个最大值\n    //         prevYes=n+temp; //走当前这个\n    //     }\n    //     return Math.max(prevNo,prevYes);\n    // }\n    \n    //        自顶向下，记忆化搜索\n    private int[] memo;\n        public int rob(int[] nums) {\n            memo=new int[nums.length+1];\n            Arrays.fill(memo,-1);\n            return tryRob(nums,0);\n        }\n\n        private int tryRob(int[] nums, int index) {\n            if (index >= nums.length){\n                return 0;\n            }\n            if (memo[index]!=-1){\n                return memo[index];\n            }\n            int res=0;\n            for (int i = index; i < nums.length; i++) {\n                res=Math.max(res,nums[i]+tryRob(nums,i+2));\n            }\n            memo[index]=res;\n            return res;\n        }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\nclass Solution {\n    // public int rob(int[] nums) {\n    //     int prevNo=0; //前一步不走\n    //     int prevYes=0; //前一步走\n    //     int temp;\n    //     for (int n : nums) {\n    //         temp=prevNo; //取得不走的临时值\n    //         prevNo=Math.max(prevNo,prevYes); //在前面的走和不走选一个最大值\n    //         prevYes=n+temp; //走当前这个\n    //     }\n    //     return Math.max(prevNo,prevYes);\n    // }\n    \n    \n    private int[] memo;\n        public int rob(int[] nums) {\n            memo=new int[nums.length+1];\n            Arrays.fill(memo,-1);\n            return tryRob(nums,0);\n        }\n\n        private int tryRob(int[] nums, int index) {\n            if (index >= nums.length){\n                return 0;\n            }\n            if (memo[index]!=-1){\n                return memo[index];\n            }\n            int res=0;\n            for (int i = index; i < nums.length; i++) {\n                res=Math.max(res,nums[i]+tryRob(nums,i+2));\n            }\n            memo[index]=res;\n            return res;\n        }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\nclass Solution {\n    public int rob(int[] nums) {\n        int prevNo=0; //前一步不走\n        int prevYes=0; //前一步走\n        int temp;\n        for (int n : nums) {\n            temp=prevNo; //取得不走的临时值\n            prevNo=Math.max(prevNo,prevYes); //在前面的走和不走选一个最大值\n            prevYes=n+temp; //走当前这个\n        }\n        return Math.max(prevNo,prevYes);\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n# 官方题解\n# 方法一：动态规划\n算法\n\n考虑所有可能的抢劫方案过于困难。一个自然而然的想法是首先从最简单的情况开始。记：\n\n> f(k) = 从前 k 个房屋中能抢劫到的最大数额，AiA_iAi​ = 第 i 个房屋的钱数。\n\n\n首先看 n = 1 的情况，显然 f(1) = A1A_1A1​。\n\n再看 n = 2，f(2) = max(A1A_1A1​, A2A_2A2​)。\n\n对于 n = 3，有两个选项:\n\n 1. 抢第三个房子，将数额与第一个房子相加。\n    \n    \n 2. 不抢第三个房子，保持现有最大数额。\n    \n    \n\n显然，你想选择数额更大的选项。于是，可以总结出公式：\n\n> f(k) = max(f(k – 2) + AkA_kAk​, f(k – 1))\n\n\n我们选择 f(–1) = f(0) = 0 为初始情况，这将极大地简化代码。\n\n答案为 f(n)。可以用一个数组来存储并计算结果。不过由于每一步你只需要前两个最大值，两个变量就足够用了。\n\npublic int rob(int[] num) {\n    int prevMax = 0;\n    int currMax = 0;\n    for (int x : num) {\n        int temp = currMax;\n        currMax = Math.max(prevMax + x, currMax);\n        prevMax = temp;\n    }\n    return currMax;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n复杂度分析\n\n * 时间复杂度：O(n)O(n)O(n)。其中 nnn 为房子的数量。\n * 空间复杂度：O(1)O(1)O(1)。\n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-07-24 08:45:27Accepted [https://leetcode-cn.com//submissions/detail/4566409/]6 ms9.38%N/Ajava2018-07-24 08:44:50Accepted [https://leetcode-cn.com//submissions/detail/4566400/]6 ms9.38%N/Ajava2018-05-08 23:01:44Accepted [https://leetcode-cn.com//submissions/detail/2090091/]0 ms100.0%N/Ajava# 统计信息\n通过次数提交次数AC比率6722315839442.4%# 相似题目\n题目难度乘积最大子序列 [https://leetcode-cn.com/problems/maximum-product-subarray/]中等打家劫舍 II [https://leetcode-cn.com/problems/house-robber-ii/]中等粉刷房子 [https://leetcode-cn.com/problems/paint-house/]简单栅栏涂色 [https://leetcode-cn.com/problems/paint-fence/]简单打家劫舍 III [https://leetcode-cn.com/problems/house-robber-iii/]中等不含连续1的非负整数 [https://leetcode-cn.com/problems/non-negative-integers-without-consecutive-ones/]困难金币路径 [https://leetcode-cn.com/problems/coin-path/]困难删除与获得点数 [https://leetcode-cn.com/problems/delete-and-earn/]中等",contentLowercase:"# 中文题目\n你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。\n\n给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。\n\n示例 1:\n\n输入: [1,2,3,1]\n输出: 4\n解释: 偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。\n     偷窃到的最高金额 = 1 + 3 = 4 。\n\n示例 2:\n\n输入: [2,7,9,3,1]\n输出: 12\n解释: 偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。\n     偷窃到的最高金额 = 2 + 9 + 1 = 12 。\n\n\n# 通过代码\nclass solution {\n    // public int rob(int[] nums) {\n    //     int prevno=0; //前一步不走\n    //     int prevyes=0; //前一步走\n    //     int temp;\n    //     for (int n : nums) {\n    //         temp=prevno; //取得不走的临时值\n    //         prevno=math.max(prevno,prevyes); //在前面的走和不走选一个最大值\n    //         prevyes=n+temp; //走当前这个\n    //     }\n    //     return math.max(prevno,prevyes);\n    // }\n    \n    //        自顶向下，记忆化搜索\n    private int[] memo;\n        public int rob(int[] nums) {\n            memo=new int[nums.length+1];\n            arrays.fill(memo,-1);\n            return tryrob(nums,0);\n        }\n\n        private int tryrob(int[] nums, int index) {\n            if (index >= nums.length){\n                return 0;\n            }\n            if (memo[index]!=-1){\n                return memo[index];\n            }\n            int res=0;\n            for (int i = index; i < nums.length; i++) {\n                res=math.max(res,nums[i]+tryrob(nums,i+2));\n            }\n            memo[index]=res;\n            return res;\n        }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\nclass solution {\n    // public int rob(int[] nums) {\n    //     int prevno=0; //前一步不走\n    //     int prevyes=0; //前一步走\n    //     int temp;\n    //     for (int n : nums) {\n    //         temp=prevno; //取得不走的临时值\n    //         prevno=math.max(prevno,prevyes); //在前面的走和不走选一个最大值\n    //         prevyes=n+temp; //走当前这个\n    //     }\n    //     return math.max(prevno,prevyes);\n    // }\n    \n    \n    private int[] memo;\n        public int rob(int[] nums) {\n            memo=new int[nums.length+1];\n            arrays.fill(memo,-1);\n            return tryrob(nums,0);\n        }\n\n        private int tryrob(int[] nums, int index) {\n            if (index >= nums.length){\n                return 0;\n            }\n            if (memo[index]!=-1){\n                return memo[index];\n            }\n            int res=0;\n            for (int i = index; i < nums.length; i++) {\n                res=math.max(res,nums[i]+tryrob(nums,i+2));\n            }\n            memo[index]=res;\n            return res;\n        }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\nclass solution {\n    public int rob(int[] nums) {\n        int prevno=0; //前一步不走\n        int prevyes=0; //前一步走\n        int temp;\n        for (int n : nums) {\n            temp=prevno; //取得不走的临时值\n            prevno=math.max(prevno,prevyes); //在前面的走和不走选一个最大值\n            prevyes=n+temp; //走当前这个\n        }\n        return math.max(prevno,prevyes);\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n# 官方题解\n# 方法一：动态规划\n算法\n\n考虑所有可能的抢劫方案过于困难。一个自然而然的想法是首先从最简单的情况开始。记：\n\n> f(k) = 从前 k 个房屋中能抢劫到的最大数额，aia_iai​ = 第 i 个房屋的钱数。\n\n\n首先看 n = 1 的情况，显然 f(1) = a1a_1a1​。\n\n再看 n = 2，f(2) = max(a1a_1a1​, a2a_2a2​)。\n\n对于 n = 3，有两个选项:\n\n 1. 抢第三个房子，将数额与第一个房子相加。\n    \n    \n 2. 不抢第三个房子，保持现有最大数额。\n    \n    \n\n显然，你想选择数额更大的选项。于是，可以总结出公式：\n\n> f(k) = max(f(k – 2) + aka_kak​, f(k – 1))\n\n\n我们选择 f(–1) = f(0) = 0 为初始情况，这将极大地简化代码。\n\n答案为 f(n)。可以用一个数组来存储并计算结果。不过由于每一步你只需要前两个最大值，两个变量就足够用了。\n\npublic int rob(int[] num) {\n    int prevmax = 0;\n    int currmax = 0;\n    for (int x : num) {\n        int temp = currmax;\n        currmax = math.max(prevmax + x, currmax);\n        prevmax = temp;\n    }\n    return currmax;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n复杂度分析\n\n * 时间复杂度：o(n)o(n)o(n)。其中 nnn 为房子的数量。\n * 空间复杂度：o(1)o(1)o(1)。\n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-07-24 08:45:27accepted [https://leetcode-cn.com//submissions/detail/4566409/]6 ms9.38%n/ajava2018-07-24 08:44:50accepted [https://leetcode-cn.com//submissions/detail/4566400/]6 ms9.38%n/ajava2018-05-08 23:01:44accepted [https://leetcode-cn.com//submissions/detail/2090091/]0 ms100.0%n/ajava# 统计信息\n通过次数提交次数ac比率6722315839442.4%# 相似题目\n题目难度乘积最大子序列 [https://leetcode-cn.com/problems/maximum-product-subarray/]中等打家劫舍 ii [https://leetcode-cn.com/problems/house-robber-ii/]中等粉刷房子 [https://leetcode-cn.com/problems/paint-house/]简单栅栏涂色 [https://leetcode-cn.com/problems/paint-fence/]简单打家劫舍 iii [https://leetcode-cn.com/problems/house-robber-iii/]中等不含连续1的非负整数 [https://leetcode-cn.com/problems/non-negative-integers-without-consecutive-ones/]困难金币路径 [https://leetcode-cn.com/problems/coin-path/]困难删除与获得点数 [https://leetcode-cn.com/problems/delete-and-earn/]中等"},{title:"202-快乐数(Happy Number)",frontmatter:{title:"202-快乐数(Happy Number)",date:"2018-05-31T00:00:00.000Z",categories:["简单"],tags:["哈希表<Hash Table>","数学<Math>"]},regularPath:"/views/%E7%AE%80%E5%8D%95/0202-%E5%BF%AB%E4%B9%90%E6%95%B0.html",relativePath:"views/简单/0202-快乐数.md",key:"v-a44527a2",path:"/views/%E7%AE%80%E5%8D%95/0202-%E5%BF%AB%E4%B9%90%E6%95%B0.html",headers:[{level:2,title:"中文题目",slug:"中文题目",charIndex:2},{level:2,title:"通过代码",slug:"通过代码",charIndex:216},{level:2,title:"高赞题解",slug:"高赞题解",charIndex:806},{level:2,title:"提交历史",slug:"提交历史",charIndex:1572},{level:2,title:"统计信息",slug:"统计信息",charIndex:1700},{level:2,title:"相似题目",slug:"相似题目",charIndex:1734}],lastUpdated:"4/11/2021, 1:15:21 PM",headersStr:"中文题目 通过代码 高赞题解 提交历史 统计信息 相似题目",content:"# 中文题目\n编写一个算法来判断一个数是不是“快乐数”。\n\n一个“快乐数”定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是无限循环但始终变不到 1。如果可以变为 1，那么这个数就是快乐数。\n\n示例:\n\n输入: 19\n输出: true\n解释: \n12 + 92 = 82\n82 + 22 = 68\n62 + 82 = 100\n12 + 02 + 02 = 1\n\n\n# 通过代码\nimport java.util.HashSet;\nimport java.util.Set;\nclass Solution {\n    public boolean isHappy(int n) {\n         Set<Integer> set=new HashSet<>();\n            int sum,remain;\n            while (set.add(n)){\n                sum=0;\n                while (n>0){\n                    remain=n%10;\n                    sum+=remain*remain;\n                    n/=10;\n                }\n                if (sum==1)\n                    return true;\n                else\n                    n=sum;\n            }\n            return false;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n# 高赞题解\n方法：使用“快慢指针”思想找出循环：“快指针”每次走两步，“慢指针”每次走一步，当二者相等时，即为一个循环周期。此时，判断是不是因为1引起的循环，是的话就是快乐数，否则不是快乐数。 注意：此题不建议用集合记录每次的计算结果来判断是否进入循环，因为这个集合可能大到无法存储；另外，也不建议使用递归，同理，如果递归层次较深，会直接导致调用栈崩溃。不要因为这个题目给出的整数是int型而投机取巧。\n\nclass Solution {\npublic:\n    int bitSquareSum(int n) {\n        int sum = 0;\n        while(n > 0)\n        {\n            int bit = n % 10;\n            sum += bit * bit;\n            n = n / 10;\n        }\n        return sum;\n    }\n    \n    bool isHappy(int n) {\n        int slow = n, fast = n;\n        do{\n            slow = bitSquareSum(slow);\n            fast = bitSquareSum(fast);\n            fast = bitSquareSum(fast);\n        }while(slow != fast);\n        \n        return slow == 1;\n    }\n};\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-05-31 23:39:52Accepted [https://leetcode-cn.com//submissions/detail/2798183/]3 ms34.18%N/Ajava# 统计信息\n通过次数提交次数AC比率412517283356.6%# 相似题目\n题目难度环形链表 [https://leetcode-cn.com/problems/linked-list-cycle/]简单各位相加 [https://leetcode-cn.com/problems/add-digits/]简单丑数 [https://leetcode-cn.com/problems/ugly-number/]简单",contentLowercase:"# 中文题目\n编写一个算法来判断一个数是不是“快乐数”。\n\n一个“快乐数”定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是无限循环但始终变不到 1。如果可以变为 1，那么这个数就是快乐数。\n\n示例:\n\n输入: 19\n输出: true\n解释: \n12 + 92 = 82\n82 + 22 = 68\n62 + 82 = 100\n12 + 02 + 02 = 1\n\n\n# 通过代码\nimport java.util.hashset;\nimport java.util.set;\nclass solution {\n    public boolean ishappy(int n) {\n         set<integer> set=new hashset<>();\n            int sum,remain;\n            while (set.add(n)){\n                sum=0;\n                while (n>0){\n                    remain=n%10;\n                    sum+=remain*remain;\n                    n/=10;\n                }\n                if (sum==1)\n                    return true;\n                else\n                    n=sum;\n            }\n            return false;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n# 高赞题解\n方法：使用“快慢指针”思想找出循环：“快指针”每次走两步，“慢指针”每次走一步，当二者相等时，即为一个循环周期。此时，判断是不是因为1引起的循环，是的话就是快乐数，否则不是快乐数。 注意：此题不建议用集合记录每次的计算结果来判断是否进入循环，因为这个集合可能大到无法存储；另外，也不建议使用递归，同理，如果递归层次较深，会直接导致调用栈崩溃。不要因为这个题目给出的整数是int型而投机取巧。\n\nclass solution {\npublic:\n    int bitsquaresum(int n) {\n        int sum = 0;\n        while(n > 0)\n        {\n            int bit = n % 10;\n            sum += bit * bit;\n            n = n / 10;\n        }\n        return sum;\n    }\n    \n    bool ishappy(int n) {\n        int slow = n, fast = n;\n        do{\n            slow = bitsquaresum(slow);\n            fast = bitsquaresum(fast);\n            fast = bitsquaresum(fast);\n        }while(slow != fast);\n        \n        return slow == 1;\n    }\n};\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-05-31 23:39:52accepted [https://leetcode-cn.com//submissions/detail/2798183/]3 ms34.18%n/ajava# 统计信息\n通过次数提交次数ac比率412517283356.6%# 相似题目\n题目难度环形链表 [https://leetcode-cn.com/problems/linked-list-cycle/]简单各位相加 [https://leetcode-cn.com/problems/add-digits/]简单丑数 [https://leetcode-cn.com/problems/ugly-number/]简单"},{title:"203-移除链表元素(Remove Linked List Elements)",frontmatter:{title:"203-移除链表元素(Remove Linked List Elements)",date:"2018-07-15T00:00:00.000Z",categories:["简单"],tags:["链表<Linked List>"]},regularPath:"/views/%E7%AE%80%E5%8D%95/0203-%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0.html",relativePath:"views/简单/0203-移除链表元素.md",key:"v-1b66e8d5",path:"/views/%E7%AE%80%E5%8D%95/0203-%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0.html",headers:[{level:2,title:"中文题目",slug:"中文题目",charIndex:2},{level:2,title:"通过代码",slug:"通过代码",charIndex:88},{level:2,title:"官方题解",slug:"官方题解",charIndex:1411},{level:2,title:"提交历史",slug:"提交历史",charIndex:3516},{level:2,title:"统计信息",slug:"统计信息",charIndex:3742},{level:2,title:"相似题目",slug:"相似题目",charIndex:3777}],lastUpdated:"4/11/2021, 1:15:21 PM",headersStr:"中文题目 通过代码 官方题解 提交历史 统计信息 相似题目",content:"# 中文题目\n删除链表中等于给定值val的所有节点。\n\n示例:\n\n输入: 1->2->6->3->4->5->6, val = 6\n输出: 1->2->3->4->5\n\n\n# 通过代码\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public ListNode removeElements(ListNode head, int val) {\n           ListNode dummyHead=new ListNode(0);\n            dummyHead.next=head;\n            ListNode cur=dummyHead;\n            while (cur.next !=null){\n                if (cur.next.val==val){\n                    cur.next=cur.next.next;\n                }else {\n                    cur=cur.next;\n                }\n            }\n            return dummyHead.next;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public ListNode removeElements(ListNode head, int val) {\n           ListNode dummyHead=new ListNode(0);\n            dummyHead.next=head;\n            ListNode cur=dummyHead;\n            while (cur.next !=null){\n                if (cur.next.val==val){\n                    cur.next=cur.next.next;\n                }else {\n                    cur=cur.next;\n                }\n            }\n            return dummyHead.next;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n# 官方题解\n# 方法：哨兵节点\n如果删除的节点是中间的节点，则问题似乎非常简单：\n\n * 选择要删除节点的前一个结点 prev。\n * 将 prev 的 next 设置为要删除结点的 next。\n\n{:width=400}\n\n当要删除的一个或多个节点位于链表的头部时，事情会变得复杂。\n\n{:width=400} {:align=center}\n\n可以通过哨兵节点去解决它，哨兵节点广泛应用于树和链表中，如伪头、伪尾、标记等，它们是纯功能的，通常不保存任何数据，其主要目的是使链表标准化，如使链表永不为空、永不无头、简化插入和删除。\n\n{:width=400}\n\n在这里哨兵节点将被用于伪头。\n\n算法：\n\n * 初始化哨兵节点为 ListNode(0) 且设置 sentinel.next = head。\n * 初始化两个指针 curr 和 prev 指向当前节点和前继节点。\n * 当 curr != nullptr： * 比较当前节点和要删除的节点： * 若当前节点就是要删除的节点：则 prev.next = curr.next。\n       * 否则设 prve = curr。\n      \n      \n    * 遍历下一个元素：curr = curr.next。\n   \n   \n * 返回 sentinel.next。\n\nclass Solution:\n    def removeElements(self, head: ListNode, val: int) -> ListNode:\n        sentinel = ListNode(0)\n        sentinel.next = head\n        \n        prev, curr = sentinel, head\n        while curr:\n            if curr.val == val:\n                prev.next = curr.next\n            else:\n                prev = curr\n            curr = curr.next\n        \n        return sentinel.next\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\nclass Solution {\n  public ListNode removeElements(ListNode head, int val) {\n    ListNode sentinel = new ListNode(0);\n    sentinel.next = head;\n\n    ListNode prev = sentinel, curr = head;\n    while (curr != null) {\n      if (curr.val == val) prev.next = curr.next;\n      else prev = curr;\n      curr = curr.next;\n    }\n    return sentinel.next;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\nclass Solution {\n  public:\n  ListNode* removeElements(ListNode* head, int val) {\n    ListNode* sentinel = new ListNode(0);\n    sentinel->next = head;\n\n    ListNode *prev = sentinel, *curr = head, *toDelete = nullptr;\n    while (curr != nullptr) {\n      if (curr->val == val) {\n        prev->next = curr->next;\n        toDelete = curr;\n      } else prev = curr;\n\n      curr = curr->next;\n\n      if (toDelete != nullptr) {\n        delete toDelete;\n        toDelete = nullptr;\n      }\n    }\n\n    ListNode *ret = sentinel->next;\n    delete sentinel;\n    return ret;\n  }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n复杂度分析\n\n * 时间复杂度：O(N)\\mathcal{O}(N)O(N)，只遍历了一次。\n * 空间复杂度：O(1)\\mathcal{O}(1)O(1)。\n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-07-15 21:52:37Accepted [https://leetcode-cn.com//submissions/detail/4215167/]7 ms6.55%N/Ajava2018-07-15 21:51:41Accepted [https://leetcode-cn.com//submissions/detail/4215140/]19 ms6.55%N/Ajava# 统计信息\n通过次数提交次数AC比率5409912435143.5%# 相似题目\n题目难度移除元素 [https://leetcode-cn.com/problems/remove-element/]简单删除链表中的节点 [https://leetcode-cn.com/problems/delete-node-in-a-linked-list/]简单",contentLowercase:"# 中文题目\n删除链表中等于给定值val的所有节点。\n\n示例:\n\n输入: 1->2->6->3->4->5->6, val = 6\n输出: 1->2->3->4->5\n\n\n# 通过代码\n/**\n * definition for singly-linked list.\n * public class listnode {\n *     int val;\n *     listnode next;\n *     listnode(int x) { val = x; }\n * }\n */\nclass solution {\n    public listnode removeelements(listnode head, int val) {\n           listnode dummyhead=new listnode(0);\n            dummyhead.next=head;\n            listnode cur=dummyhead;\n            while (cur.next !=null){\n                if (cur.next.val==val){\n                    cur.next=cur.next.next;\n                }else {\n                    cur=cur.next;\n                }\n            }\n            return dummyhead.next;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n/**\n * definition for singly-linked list.\n * public class listnode {\n *     int val;\n *     listnode next;\n *     listnode(int x) { val = x; }\n * }\n */\nclass solution {\n    public listnode removeelements(listnode head, int val) {\n           listnode dummyhead=new listnode(0);\n            dummyhead.next=head;\n            listnode cur=dummyhead;\n            while (cur.next !=null){\n                if (cur.next.val==val){\n                    cur.next=cur.next.next;\n                }else {\n                    cur=cur.next;\n                }\n            }\n            return dummyhead.next;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n# 官方题解\n# 方法：哨兵节点\n如果删除的节点是中间的节点，则问题似乎非常简单：\n\n * 选择要删除节点的前一个结点 prev。\n * 将 prev 的 next 设置为要删除结点的 next。\n\n{:width=400}\n\n当要删除的一个或多个节点位于链表的头部时，事情会变得复杂。\n\n{:width=400} {:align=center}\n\n可以通过哨兵节点去解决它，哨兵节点广泛应用于树和链表中，如伪头、伪尾、标记等，它们是纯功能的，通常不保存任何数据，其主要目的是使链表标准化，如使链表永不为空、永不无头、简化插入和删除。\n\n{:width=400}\n\n在这里哨兵节点将被用于伪头。\n\n算法：\n\n * 初始化哨兵节点为 listnode(0) 且设置 sentinel.next = head。\n * 初始化两个指针 curr 和 prev 指向当前节点和前继节点。\n * 当 curr != nullptr： * 比较当前节点和要删除的节点： * 若当前节点就是要删除的节点：则 prev.next = curr.next。\n       * 否则设 prve = curr。\n      \n      \n    * 遍历下一个元素：curr = curr.next。\n   \n   \n * 返回 sentinel.next。\n\nclass solution:\n    def removeelements(self, head: listnode, val: int) -> listnode:\n        sentinel = listnode(0)\n        sentinel.next = head\n        \n        prev, curr = sentinel, head\n        while curr:\n            if curr.val == val:\n                prev.next = curr.next\n            else:\n                prev = curr\n            curr = curr.next\n        \n        return sentinel.next\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\nclass solution {\n  public listnode removeelements(listnode head, int val) {\n    listnode sentinel = new listnode(0);\n    sentinel.next = head;\n\n    listnode prev = sentinel, curr = head;\n    while (curr != null) {\n      if (curr.val == val) prev.next = curr.next;\n      else prev = curr;\n      curr = curr.next;\n    }\n    return sentinel.next;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\nclass solution {\n  public:\n  listnode* removeelements(listnode* head, int val) {\n    listnode* sentinel = new listnode(0);\n    sentinel->next = head;\n\n    listnode *prev = sentinel, *curr = head, *todelete = nullptr;\n    while (curr != nullptr) {\n      if (curr->val == val) {\n        prev->next = curr->next;\n        todelete = curr;\n      } else prev = curr;\n\n      curr = curr->next;\n\n      if (todelete != nullptr) {\n        delete todelete;\n        todelete = nullptr;\n      }\n    }\n\n    listnode *ret = sentinel->next;\n    delete sentinel;\n    return ret;\n  }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n复杂度分析\n\n * 时间复杂度：o(n)\\mathcal{o}(n)o(n)，只遍历了一次。\n * 空间复杂度：o(1)\\mathcal{o}(1)o(1)。\n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-07-15 21:52:37accepted [https://leetcode-cn.com//submissions/detail/4215167/]7 ms6.55%n/ajava2018-07-15 21:51:41accepted [https://leetcode-cn.com//submissions/detail/4215140/]19 ms6.55%n/ajava# 统计信息\n通过次数提交次数ac比率5409912435143.5%# 相似题目\n题目难度移除元素 [https://leetcode-cn.com/problems/remove-element/]简单删除链表中的节点 [https://leetcode-cn.com/problems/delete-node-in-a-linked-list/]简单"},{title:"204-计数质数(Count Primes)",frontmatter:{title:"204-计数质数(Count Primes)",date:"2020-01-04T00:00:00.000Z",categories:["简单"],tags:["哈希表<Hash Table>","数学<Math>"]},regularPath:"/views/%E7%AE%80%E5%8D%95/0204-%E8%AE%A1%E6%95%B0%E8%B4%A8%E6%95%B0.html",relativePath:"views/简单/0204-计数质数.md",key:"v-1b5e2caa",path:"/views/%E7%AE%80%E5%8D%95/0204-%E8%AE%A1%E6%95%B0%E8%B4%A8%E6%95%B0.html",headers:[{level:2,title:"中文题目",slug:"中文题目",charIndex:2},{level:2,title:"通过代码",slug:"通过代码",charIndex:88},{level:2,title:"高赞题解",slug:"高赞题解",charIndex:1332},{level:3,title:"高效实现 countPrimes",slug:"高效实现-countprimes",charIndex:2483},{level:2,title:"提交历史",slug:"提交历史",charIndex:4510},{level:2,title:"统计信息",slug:"统计信息",charIndex:4643},{level:2,title:"相似题目",slug:"相似题目",charIndex:4678}],lastUpdated:"4/11/2021, 1:15:21 PM",headersStr:"中文题目 通过代码 高赞题解 高效实现 countPrimes 提交历史 统计信息 相似题目",content:"# 中文题目\n统计所有小于非负整数n的质数的数量。\n\n示例:\n\n输入: 10\n输出: 4\n解释: 小于 10 的质数一共有 4 个, 它们是 2, 3, 5, 7 。\n\n\n# 通过代码\nclass Solution {\n    public int countPrimes(int n) {\n//        埃拉托斯特尼筛法：\n\n//        列出2以后的所有序列：\n//        2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25\n//        标出序列中的第一个素数，也就是2，序列变成：\n//        2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25\n//        将剩下序列中，划掉2的倍数，序列变成：\n//        2 3 5 7 9 11 13 15 17 19 21 23 25\n//        如果这个序列中最大数小于最后一个标出的素数的平方，那么剩下的序列中所有的数都是素数，否则回到第二步。\n//        本例中，因为25大于2的平方，我们返回第二步：\n//        剩下的序列中第一个素数是3，将主序列中3的倍数划掉，ä¸»序列变成：\n//        2 3 5 7 11 13 17 19 23 25\n//        我们得到的素数有：2，3\n//        25ä»ç¶大于3的平方，所以我们还要返回第二步：\n//        序列中第一个素数是5，同样将序列中5的倍数划掉，主序列成了：\n//        2 3 5 7 11 13 17 19 23\n//        我们得到的素数有：2，3，5 。\n//        因为23小于5的平方，跳出循环.\n//        结论：2到25之间的素数是：2 3 5 7 11 13 17 19 23。\n        \n        int[] arr = new int[n + 1];\n        int total = 0;\n        // 从2开始计算\n        for (int i = 2; i < n; i++) {\n            if (arr[i] != 1) {\n                total++;\n                for (int j = 2 * i; j < n; j += i) {\n                    //只要能被i整除的都不是质数\n                    arr[j] = 1;\n                }\n            }\n        }\n        return total;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n# 高赞题解\n素数的定义很简单，如果一个数如果只能被 1 和它本身整除，那么这个数就是素数。\n\n不要觉得素数的定义简单，恐怕没多少人真的能把素数相关的算法写得高效。比如让你写这样一个函数：\n\n// 返回区间 [2, n) 中有几个素数 \nint countPrimes(int n)\n\n// 比如 countPrimes(10) 返回 4\n// 因为 2,3,5,7 是素数\n\n\n1\n2\n3\n4\n5\n你会如何写这个函数？我想大家应该会这样写：\n\nint countPrimes(int n) {\n    int count = 0;\n    for (int i = 2; i < n; i++)\n        if (isPrim(i)) count++;\n    return count;\n}\n\n// 判断整数 n 是否是素数\nboolean isPrime(int n) {\n    for (int i = 2; i < n; i++)\n        if (n % i == 0)\n            // 有其他整除因子\n            return false;\n    return true;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n这样写的话时间复杂度 O(n^2)，问题很大。首先你用 isPrime 函数来辅助的思路就不够高效；而且就算你要用 isPrime 函数，这样写算法也是存在计算冗余的。\n\n先来简单说下如果你要判断一个数是不是素数，应该如何写算法。只需稍微修改一下上面的 isPrim 代码中的 for 循环条件：\n\nboolean isPrime(int n) {\n    for (int i = 2; i * i <= n; i++)\n        ...\n}\n\n\n1\n2\n3\n4\n换句话说，i 不需要遍历到 n，而只需要到 sqrt(n) 即可。为什么呢，我们举个例子，假设 n = 12。\n\n12 = 2 × 6\n12 = 3 × 4\n12 = sqrt(12) × sqrt(12)\n12 = 4 × 3\n12 = 6 × 2\n\n\n1\n2\n3\n4\n5\n可以看到，后两个乘积就是前面两个反过来，反转临界点就在 sqrt(n)。\n\n换句话说，如果在 [2,sqrt(n)] 这个区间之内没有发现可整除因子，就可以直接断定 n 是素数了，因为在区间 [sqrt(n),n] 也一定不会发现可整除因子。\n\n现在，isPrime 函数的时间复杂度降为 O(sqrt(N))，但是我们实现 countPrimes 函数其实并不需要这个函数，以上只是希望读者明白 sqrt(n) 的含义，因为等会还会用到。\n\n# 高效实现 countPrimes\n高效解决这个问题的核心思路是和上面的常规思路反着来：\n\n首先从 2 开始，我们知道 2 是一个素数，那么 2 × 2 = 4, 3 × 2 = 6, 4 × 2 = 8... 都不可能是素数了。\n\n然后我们发现 3 也是素数，那么 3 × 2 = 6, 3 × 3 = 9, 3 × 4 = 12... 也都不可能是素数了。\n\n看到这里，你是否有点明白这个排除法的逻辑了呢？先看我们的第一版代码：\n\nint countPrimes(int n) {\n    boolean[] isPrim = new boolean[n];\n    // 将数组都初始化为 true\n    Arrays.fill(isPrim, true);\n\n    for (int i = 2; i < n; i++) \n        if (isPrim[i]) \n            // i 的倍数不可能是素数了\n            for (int j = 2 * i; j < n; j += i) \n                    isPrim[j] = false;\n    \n    int count = 0;\n    for (int i = 2; i < n; i++)\n        if (isPrim[i]) count++;\n    \n    return count;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n图片来自 wikimedia\n\n如果上面这段代码你能够理解，那么你已经掌握了整体思路，但是还有两个细微的地方可以优化。\n\n首先，回想刚才判断一个数是否是素数的 isPrime 函数，由于因子的对称性，其中的 for 循环只需要遍历 [2,sqrt(n)] 就够了。这里也是类似的，我们外层的 for 循环也只需要遍历到 sqrt(n)：\n\nfor (int i = 2; i * i < n; i++) \n    if (isPrim[i]) \n        ...\n\n\n1\n2\n3\n除此之外，很难注意到内层的 for 循环也可以优化。我们之前的做法是：\n\nfor (int j = 2 * i; j < n; j += i) \n    isPrim[j] = false;\n\n\n1\n2\n这样可以把 i 的整数倍都标记为 false，但是仍然存在计算冗余。\n\n比如 n = 25，i = 4 时算法会标记 4 × 2 = 8，4 × 3 = 12 等等数字，但是这两个数字已经被 i = 2 和 i = 3 的 2 × 4 和 3 × 4 标记了。\n\n我们可以稍微优化一下，让 j 从 i 的平方开始遍历，而不是从 2 * i 开始：\n\nfor (int j = i * i; j < n; j += i) \n    isPrim[j] = false;\n\n\n1\n2\n这样，素数计数的算法就高效实现了，其实这个算法有一个名字，叫做 Sieve of Eratosthenes。看下完整的最终代码：\n\nint countPrimes(int n) {\n    boolean[] isPrim = new boolean[n];\n    Arrays.fill(isPrim, true);\n    for (int i = 2; i * i < n; i++) \n        if (isPrim[i]) \n            for (int j = i * i; j < n; j += i) \n                isPrim[j] = false;\n    \n    int count = 0;\n    for (int i = 2; i < n; i++)\n        if (isPrim[i]) count++;\n    \n    return count;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n该算法的时间复杂度比较难算，显然时间跟这两个嵌套的 for 循环有关，其操作数应该是：\n\nn/2 + n/3 + n/5 + n/7 + ... = n × (1/2 + 1/3 + 1/5 + 1/7...)\n\n括号中是素数的倒数。其最终结果是 O(N * loglogN)，有兴趣的读者可以查一下该算法的时间复杂度证明。\n\n以上就是素数算法相关的全部内容。怎么样，是不是看似简单的问题却有不少细节可以打磨呀？\n\n点击我的头像还有更多详细题解，如果本文对你有帮助，欢迎关注我的公众号 labuladong，致力于把算法问题讲清楚～ 后台回复关键词【资料】可获得我精选的经典技术书籍～\n\n{:width=400} {:align=center}\n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2020-01-04 23:56:29Accepted [https://leetcode-cn.com//submissions/detail/42301977/]30 ms30.3%40.3 MBjava# 统计信息\n通过次数提交次数AC比率3872212241031.6%# 相似题目\n题目难度丑数 [https://leetcode-cn.com/problems/ugly-number/]简单丑数 II [https://leetcode-cn.com/problems/ugly-number-ii/]中等完全平方数 [https://leetcode-cn.com/problems/perfect-squares/]中等",contentLowercase:"# 中文题目\n统计所有小于非负整数n的质数的数量。\n\n示例:\n\n输入: 10\n输出: 4\n解释: 小于 10 的质数一共有 4 个, 它们是 2, 3, 5, 7 。\n\n\n# 通过代码\nclass solution {\n    public int countprimes(int n) {\n//        埃拉托斯特尼筛法：\n\n//        列出2以后的所有序列：\n//        2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25\n//        标出序列中的第一个素数，也就是2，序列变成：\n//        2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25\n//        将剩下序列中，划掉2的倍数，序列变成：\n//        2 3 5 7 9 11 13 15 17 19 21 23 25\n//        如果这个序列中最大数小于最后一个标出的素数的平方，那么剩下的序列中所有的数都是素数，否则回到第二步。\n//        本例中，因为25大于2的平方，我们返回第二步：\n//        剩下的序列中第一个素数是3，将主序列中3的倍数划掉，ä¸»序列变成：\n//        2 3 5 7 11 13 17 19 23 25\n//        我们得到的素数有：2，3\n//        25ä»ç¶大于3的平方，所以我们还要返回第二步：\n//        序列中第一个素数是5，同样将序列中5的倍数划掉，主序列成了：\n//        2 3 5 7 11 13 17 19 23\n//        我们得到的素数有：2，3，5 。\n//        因为23小于5的平方，跳出循环.\n//        结论：2到25之间的素数是：2 3 5 7 11 13 17 19 23。\n        \n        int[] arr = new int[n + 1];\n        int total = 0;\n        // 从2开始计算\n        for (int i = 2; i < n; i++) {\n            if (arr[i] != 1) {\n                total++;\n                for (int j = 2 * i; j < n; j += i) {\n                    //只要能被i整除的都不是质数\n                    arr[j] = 1;\n                }\n            }\n        }\n        return total;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n# 高赞题解\n素数的定义很简单，如果一个数如果只能被 1 和它本身整除，那么这个数就是素数。\n\n不要觉得素数的定义简单，恐怕没多少人真的能把素数相关的算法写得高效。比如让你写这样一个函数：\n\n// 返回区间 [2, n) 中有几个素数 \nint countprimes(int n)\n\n// 比如 countprimes(10) 返回 4\n// 因为 2,3,5,7 是素数\n\n\n1\n2\n3\n4\n5\n你会如何写这个函数？我想大家应该会这样写：\n\nint countprimes(int n) {\n    int count = 0;\n    for (int i = 2; i < n; i++)\n        if (isprim(i)) count++;\n    return count;\n}\n\n// 判断整数 n 是否是素数\nboolean isprime(int n) {\n    for (int i = 2; i < n; i++)\n        if (n % i == 0)\n            // 有其他整除因子\n            return false;\n    return true;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n这样写的话时间复杂度 o(n^2)，问题很大。首先你用 isprime 函数来辅助的思路就不够高效；而且就算你要用 isprime 函数，这样写算法也是存在计算冗余的。\n\n先来简单说下如果你要判断一个数是不是素数，应该如何写算法。只需稍微修改一下上面的 isprim 代码中的 for 循环条件：\n\nboolean isprime(int n) {\n    for (int i = 2; i * i <= n; i++)\n        ...\n}\n\n\n1\n2\n3\n4\n换句话说，i 不需要遍历到 n，而只需要到 sqrt(n) 即可。为什么呢，我们举个例子，假设 n = 12。\n\n12 = 2 × 6\n12 = 3 × 4\n12 = sqrt(12) × sqrt(12)\n12 = 4 × 3\n12 = 6 × 2\n\n\n1\n2\n3\n4\n5\n可以看到，后两个乘积就是前面两个反过来，反转临界点就在 sqrt(n)。\n\n换句话说，如果在 [2,sqrt(n)] 这个区间之内没有发现可整除因子，就可以直接断定 n 是素数了，因为在区间 [sqrt(n),n] 也一定不会发现可整除因子。\n\n现在，isprime 函数的时间复杂度降为 o(sqrt(n))，但是我们实现 countprimes 函数其实并不需要这个函数，以上只是希望读者明白 sqrt(n) 的含义，因为等会还会用到。\n\n# 高效实现 countprimes\n高效解决这个问题的核心思路是和上面的常规思路反着来：\n\n首先从 2 开始，我们知道 2 是一个素数，那么 2 × 2 = 4, 3 × 2 = 6, 4 × 2 = 8... 都不可能是素数了。\n\n然后我们发现 3 也是素数，那么 3 × 2 = 6, 3 × 3 = 9, 3 × 4 = 12... 也都不可能是素数了。\n\n看到这里，你是否有点明白这个排除法的逻辑了呢？先看我们的第一版代码：\n\nint countprimes(int n) {\n    boolean[] isprim = new boolean[n];\n    // 将数组都初始化为 true\n    arrays.fill(isprim, true);\n\n    for (int i = 2; i < n; i++) \n        if (isprim[i]) \n            // i 的倍数不可能是素数了\n            for (int j = 2 * i; j < n; j += i) \n                    isprim[j] = false;\n    \n    int count = 0;\n    for (int i = 2; i < n; i++)\n        if (isprim[i]) count++;\n    \n    return count;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n图片来自 wikimedia\n\n如果上面这段代码你能够理解，那么你已经掌握了整体思路，但是还有两个细微的地方可以优化。\n\n首先，回想刚才判断一个数是否是素数的 isprime 函数，由于因子的对称性，其中的 for 循环只需要遍历 [2,sqrt(n)] 就够了。这里也是类似的，我们外层的 for 循环也只需要遍历到 sqrt(n)：\n\nfor (int i = 2; i * i < n; i++) \n    if (isprim[i]) \n        ...\n\n\n1\n2\n3\n除此之外，很难注意到内层的 for 循环也可以优化。我们之前的做法是：\n\nfor (int j = 2 * i; j < n; j += i) \n    isprim[j] = false;\n\n\n1\n2\n这样可以把 i 的整数倍都标记为 false，但是仍然存在计算冗余。\n\n比如 n = 25，i = 4 时算法会标记 4 × 2 = 8，4 × 3 = 12 等等数字，但是这两个数字已经被 i = 2 和 i = 3 的 2 × 4 和 3 × 4 标记了。\n\n我们可以稍微优化一下，让 j 从 i 的平方开始遍历，而不是从 2 * i 开始：\n\nfor (int j = i * i; j < n; j += i) \n    isprim[j] = false;\n\n\n1\n2\n这样，素数计数的算法就高效实现了，其实这个算法有一个名字，叫做 sieve of eratosthenes。看下完整的最终代码：\n\nint countprimes(int n) {\n    boolean[] isprim = new boolean[n];\n    arrays.fill(isprim, true);\n    for (int i = 2; i * i < n; i++) \n        if (isprim[i]) \n            for (int j = i * i; j < n; j += i) \n                isprim[j] = false;\n    \n    int count = 0;\n    for (int i = 2; i < n; i++)\n        if (isprim[i]) count++;\n    \n    return count;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n该算法的时间复杂度比较难算，显然时间跟这两个嵌套的 for 循环有关，其操作数应该是：\n\nn/2 + n/3 + n/5 + n/7 + ... = n × (1/2 + 1/3 + 1/5 + 1/7...)\n\n括号中是素数的倒数。其最终结果是 o(n * loglogn)，有兴趣的读者可以查一下该算法的时间复杂度证明。\n\n以上就是素数算法相关的全部内容。怎么样，是不是看似简单的问题却有不少细节可以打磨呀？\n\n点击我的头像还有更多详细题解，如果本文对你有帮助，欢迎关注我的公众号 labuladong，致力于把算法问题讲清楚～ 后台回复关键词【资料】可获得我精选的经典技术书籍～\n\n{:width=400} {:align=center}\n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2020-01-04 23:56:29accepted [https://leetcode-cn.com//submissions/detail/42301977/]30 ms30.3%40.3 mbjava# 统计信息\n通过次数提交次数ac比率3872212241031.6%# 相似题目\n题目难度丑数 [https://leetcode-cn.com/problems/ugly-number/]简单丑数 ii [https://leetcode-cn.com/problems/ugly-number-ii/]中等完全平方数 [https://leetcode-cn.com/problems/perfect-squares/]中等"},{title:"206-反转链表(Reverse Linked List)",frontmatter:{title:"206-反转链表(Reverse Linked List)",date:"2018-07-01T00:00:00.000Z",categories:["简单"],tags:["链表<Linked List>"]},regularPath:"/views/%E7%AE%80%E5%8D%95/0206-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8.html",relativePath:"views/简单/0206-反转链表.md",key:"v-f3fd332e",path:"/views/%E7%AE%80%E5%8D%95/0206-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8.html",headers:[{level:2,title:"中文题目",slug:"中文题目",charIndex:2},{level:2,title:"通过代码",slug:"通过代码",charIndex:107},{level:2,title:"官方题解",slug:"官方题解",charIndex:641},{level:2,title:"提交历史",slug:"提交历史",charIndex:2193},{level:2,title:"统计信息",slug:"统计信息",charIndex:2321},{level:2,title:"相似题目",slug:"相似题目",charIndex:2357}],lastUpdated:"4/11/2021, 1:15:21 PM",headersStr:"中文题目 通过代码 官方题解 提交历史 统计信息 相似题目",content:"# 中文题目\n反转一个单链表。\n\n示例:\n\n输入: 1->2->3->4->5->NULL\n输出: 5->4->3->2->1->NULL\n\n进阶:\n你可以迭代或递归地反转链表。你能否用两种方法解决这道题？\n\n# 通过代码\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public ListNode reverseList(ListNode head) {\n         ListNode pre=null;\n            ListNode cur=head;\n            while (cur!=null){\n                ListNode next=cur.next;\n                cur.next=pre;\n                pre=cur;\n                cur=next;\n            }\n            return pre;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n# 官方题解\n# 方法一：迭代\n假设存在链表 1 → 2 → 3 → Ø，我们想要把它改成 Ø ← 1 ← 2 ← 3。\n\n在遍历列表时，将当前节点的 next 指针改为指向前一个元素。由于节点没有引用其上一个节点，因此必须事先存储其前一个元素。在更改引用之前，还需要另一个指针来存储下一个节点。不要忘记在最后返回新的头引用！\n\npublic ListNode reverseList(ListNode head) {\n    ListNode prev = null;\n    ListNode curr = head;\n    while (curr != null) {\n        ListNode nextTemp = curr.next;\n        curr.next = prev;\n        prev = curr;\n        curr = nextTemp;\n    }\n    return prev;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n复杂度分析\n\n * 时间复杂度：O(n)O(n)O(n)，假设 nnn 是列表的长度，时间复杂度是 O(n)O(n)O(n)。\n * 空间复杂度：O(1)O(1)O(1)。\n\n\n\n\n# 方法二：递归\n递归版本稍微复杂一些，其关键在于反向工作。假设列表的其余部分已经被反转，现在我该如何反转它前面的部分？\n\n假设列表为：\n\nn1→...→nk−1→nk→nk+1→...→nm→∅n_{1}\\rightarrow ... \\rightarrow n_{k-1} \\rightarrow n_{k} \\rightarrow n_{k+1} \\rightarrow ... \\rightarrow n_{m} \\rightarrow \\varnothingn1​→...→nk−1​→nk​→nk+1​→...→nm​→∅\n\n若从节点 nk+1n_{k+1}nk+1​ 到 nmn_{m}nm​ 已经被反转，而我们正处于 nkn_{k}nk​。\n\nn1→...→nk−1→nk→nk+1←...←nmn_{1}\\rightarrow ... \\rightarrow n_{k-1} \\rightarrow n_{k} \\rightarrow n_{k+1} \\leftarrow ... \\leftarrow n_{m}n1​→...→nk−1​→nk​→nk+1​←...←nm​\n\n我们希望 nk+1n_{k+1}nk+1​ 的下一个节点指向 nkn_{k}nk​。\n\n所以，nkn_{k}nk​.next.next = nkn_{k}nk​。\n\n要小心的是 n1n_{1}n1​ 的下一个必须指向 Ø 。如果你忽略了这一点，你的链表中可能会产生循环。如果使用大小为 2 的链表测试代码，则可能会捕获此错误。\n\npublic ListNode reverseList(ListNode head) {\n    if (head == null || head.next == null) return head;\n    ListNode p = reverseList(head.next);\n    head.next.next = head;\n    head.next = null;\n    return p;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n复杂度分析\n\n * 时间复杂度：O(n)O(n)O(n)，假设 nnn 是列表的长度，那么时间复杂度为 O(n)O(n)O(n)。\n * 空间复杂度：O(n)O(n)O(n)，由于使用递归，将会使用隐式栈空间。递归深度可能会达到 nnn 层。\n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-07-01 16:24:30Accepted [https://leetcode-cn.com//submissions/detail/3657272/]0 ms100.0%N/Ajava# 统计信息\n通过次数提交次数AC比率14431921719166.4%# 相似题目\n题目难度反转链表 II [https://leetcode-cn.com/problems/reverse-linked-list-ii/]中等上下翻转二叉树 [https://leetcode-cn.com/problems/binary-tree-upside-down/]中等回文链表 [https://leetcode-cn.com/problems/palindrome-linked-list/]简单",contentLowercase:"# 中文题目\n反转一个单链表。\n\n示例:\n\n输入: 1->2->3->4->5->null\n输出: 5->4->3->2->1->null\n\n进阶:\n你可以迭代或递归地反转链表。你能否用两种方法解决这道题？\n\n# 通过代码\n/**\n * definition for singly-linked list.\n * public class listnode {\n *     int val;\n *     listnode next;\n *     listnode(int x) { val = x; }\n * }\n */\nclass solution {\n    public listnode reverselist(listnode head) {\n         listnode pre=null;\n            listnode cur=head;\n            while (cur!=null){\n                listnode next=cur.next;\n                cur.next=pre;\n                pre=cur;\n                cur=next;\n            }\n            return pre;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n# 官方题解\n# 方法一：迭代\n假设存在链表 1 → 2 → 3 → ø，我们想要把它改成 ø ← 1 ← 2 ← 3。\n\n在遍历列表时，将当前节点的 next 指针改为指向前一个元素。由于节点没有引用其上一个节点，因此必须事先存储其前一个元素。在更改引用之前，还需要另一个指针来存储下一个节点。不要忘记在最后返回新的头引用！\n\npublic listnode reverselist(listnode head) {\n    listnode prev = null;\n    listnode curr = head;\n    while (curr != null) {\n        listnode nexttemp = curr.next;\n        curr.next = prev;\n        prev = curr;\n        curr = nexttemp;\n    }\n    return prev;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n复杂度分析\n\n * 时间复杂度：o(n)o(n)o(n)，假设 nnn 是列表的长度，时间复杂度是 o(n)o(n)o(n)。\n * 空间复杂度：o(1)o(1)o(1)。\n\n\n\n\n# 方法二：递归\n递归版本稍微复杂一些，其关键在于反向工作。假设列表的其余部分已经被反转，现在我该如何反转它前面的部分？\n\n假设列表为：\n\nn1→...→nk−1→nk→nk+1→...→nm→∅n_{1}\\rightarrow ... \\rightarrow n_{k-1} \\rightarrow n_{k} \\rightarrow n_{k+1} \\rightarrow ... \\rightarrow n_{m} \\rightarrow \\varnothingn1​→...→nk−1​→nk​→nk+1​→...→nm​→∅\n\n若从节点 nk+1n_{k+1}nk+1​ 到 nmn_{m}nm​ 已经被反转，而我们正处于 nkn_{k}nk​。\n\nn1→...→nk−1→nk→nk+1←...←nmn_{1}\\rightarrow ... \\rightarrow n_{k-1} \\rightarrow n_{k} \\rightarrow n_{k+1} \\leftarrow ... \\leftarrow n_{m}n1​→...→nk−1​→nk​→nk+1​←...←nm​\n\n我们希望 nk+1n_{k+1}nk+1​ 的下一个节点指向 nkn_{k}nk​。\n\n所以，nkn_{k}nk​.next.next = nkn_{k}nk​。\n\n要小心的是 n1n_{1}n1​ 的下一个必须指向 ø 。如果你忽略了这一点，你的链表中可能会产生循环。如果使用大小为 2 的链表测试代码，则可能会捕获此错误。\n\npublic listnode reverselist(listnode head) {\n    if (head == null || head.next == null) return head;\n    listnode p = reverselist(head.next);\n    head.next.next = head;\n    head.next = null;\n    return p;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n复杂度分析\n\n * 时间复杂度：o(n)o(n)o(n)，假设 nnn 是列表的长度，那么时间复杂度为 o(n)o(n)o(n)。\n * 空间复杂度：o(n)o(n)o(n)，由于使用递归，将会使用隐式栈空间。递归深度可能会达到 nnn 层。\n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-07-01 16:24:30accepted [https://leetcode-cn.com//submissions/detail/3657272/]0 ms100.0%n/ajava# 统计信息\n通过次数提交次数ac比率14431921719166.4%# 相似题目\n题目难度反转链表 ii [https://leetcode-cn.com/problems/reverse-linked-list-ii/]中等上下翻转二叉树 [https://leetcode-cn.com/problems/binary-tree-upside-down/]中等回文链表 [https://leetcode-cn.com/problems/palindrome-linked-list/]简单"},{title:"205-同构字符串(Isomorphic Strings)",frontmatter:{title:"205-同构字符串(Isomorphic Strings)",date:"2018-06-01T00:00:00.000Z",categories:["简单"],tags:["哈希表<Hash Table>"]},regularPath:"/views/%E7%AE%80%E5%8D%95/0205-%E5%90%8C%E6%9E%84%E5%AD%97%E7%AC%A6%E4%B8%B2.html",relativePath:"views/简单/0205-同构字符串.md",key:"v-c12cd844",path:"/views/%E7%AE%80%E5%8D%95/0205-%E5%90%8C%E6%9E%84%E5%AD%97%E7%AC%A6%E4%B8%B2.html",headers:[{level:2,title:"中文题目",slug:"中文题目",charIndex:2},{level:2,title:"通过代码",slug:"通过代码",charIndex:279},{level:2,title:"高赞题解",slug:"高赞题解",charIndex:2366},{level:2,title:"题解",slug:"题解",charIndex:2368},{level:2,title:"细节补充",slug:"细节补充",charIndex:2545},{level:2,title:"提交历史",slug:"提交历史",charIndex:2738},{level:2,title:"统计信息",slug:"统计信息",charIndex:3065},{level:2,title:"相似题目",slug:"相似题目",charIndex:3099}],lastUpdated:"4/11/2021, 1:15:21 PM",headersStr:"中文题目 通过代码 高赞题解 题解 细节补充 提交历史 统计信息 相似题目",content:'# 中文题目\n给定两个字符串s和t，判断它们是否是同构的。\n\n如果s中的字符可以被替换得到t，那么这两个字符串是同构的。\n\n所有出现的字符都必须用另一个字符替换，同时保留字符的顺序。两个字符不能映射到同一个字符上，但字符可以映射自己本身。\n\n示例 1:\n\n输入: s = "egg", t = "add"\n输出: true\n\n\n示例 2:\n\n输入: s = "foo", t = "bar"\n输出: false\n\n示例 3:\n\n输入: s = "paper", t = "title"\n输出: true\n\n说明:\n你可以假设s和 t 具有相同的长度。\n\n# 通过代码\nclass Solution {\n    public boolean isIsomorphic(String s, String t) {\n       int[] arr1=new int[256];\n            int[] arr2=new int[256];\n            for (int i = 0; i < s.length(); i++) {\n                char c1=s.charAt(i);\n                char c2=t.charAt(i);\n                if (arr1[c1]==0 && arr2[c2]==0){\n                    arr1[c1]=i+1;\n                    arr2[c2]=i+1;\n                    continue;\n                }else {\n                    if (arr1[c1]==arr2[c2]){\n                        continue;\n                    }else {\n                        return false;\n                    }\n                }\n            }\n            return true;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\nimport java.util.HashMap;\nclass Solution {\n    public boolean isIsomorphic(String s, String t) {\n        char[] arr1=s.toCharArray();\n            char[] arr2=t.toCharArray();\n            HashMap<Character,Integer> map1=new HashMap<>();\n            HashMap<Character,Integer> map2=new HashMap<>();\n            if (arr1.length!=arr2.length){\n                return false;\n            }\n            for (int i = 0; i < arr1.length; i++) {\n                if (map1.containsKey(arr1[i])){\n                    int count1=map1.get(arr1[i]);\n                    if (map2.containsKey(arr2[i])){\n                        int count2=map2.get(arr2[i]);\n                        if (count1==count2){\n                            continue;\n                        }else {\n                            return false;\n                        }\n                    }else {\n                        return false;\n                    }\n                }else {\n                    map1.put(arr1[i],i);\n                    if (map2.containsKey(arr2[i])){\n                        return false;\n                    }else {\n                        map2.put(arr2[i],i);\n                        continue;\n                    }\n                }\n            }\n            return true;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n# 高赞题解\n# 题解\nclass Solution:\n    def isIsomorphic(self, s: str, t: str) -> bool:\n        return [*map(s.index, s)] == [*map(t.index, t)]\n\n\n1\n2\n3\n * 同构代表两个字符串中每个位置上字符在自身第一次出现的索引相同\n\n# 细节补充\n * str 类型数据拥有内置函数 index，输入一个子字符串，可以返回子字符串在 str 中第一次出现的索引，若不存在则报错\n * map(函数，可迭代对象) 将会对（参数2：可迭代对象）中的每个元素运用（参数1：函数）并将结果按顺序储存在一个迭代器中，返回这个迭代器\n * 使用 [*……] 可对对象解包，本题中 [*map……] 等效于 list(map……)\n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-06-01 23:25:15Accepted [https://leetcode-cn.com//submissions/detail/2824855/]6 ms81.31%N/Ajava2018-06-01 23:13:47Wrong Answer [https://leetcode-cn.com//submissions/detail/2824522/]N/AN/AN/Ajava2018-06-01 23:08:22Accepted [https://leetcode-cn.com//submissions/detail/2824432/]27 ms14.74%N/Ajava# 统计信息\n通过次数提交次数AC比率252865388146.9%# 相似题目\n题目难度单词规律 [https://leetcode-cn.com/problems/word-pattern/]简单',contentLowercase:'# 中文题目\n给定两个字符串s和t，判断它们是否是同构的。\n\n如果s中的字符可以被替换得到t，那么这两个字符串是同构的。\n\n所有出现的字符都必须用另一个字符替换，同时保留字符的顺序。两个字符不能映射到同一个字符上，但字符可以映射自己本身。\n\n示例 1:\n\n输入: s = "egg", t = "add"\n输出: true\n\n\n示例 2:\n\n输入: s = "foo", t = "bar"\n输出: false\n\n示例 3:\n\n输入: s = "paper", t = "title"\n输出: true\n\n说明:\n你可以假设s和 t 具有相同的长度。\n\n# 通过代码\nclass solution {\n    public boolean isisomorphic(string s, string t) {\n       int[] arr1=new int[256];\n            int[] arr2=new int[256];\n            for (int i = 0; i < s.length(); i++) {\n                char c1=s.charat(i);\n                char c2=t.charat(i);\n                if (arr1[c1]==0 && arr2[c2]==0){\n                    arr1[c1]=i+1;\n                    arr2[c2]=i+1;\n                    continue;\n                }else {\n                    if (arr1[c1]==arr2[c2]){\n                        continue;\n                    }else {\n                        return false;\n                    }\n                }\n            }\n            return true;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\nimport java.util.hashmap;\nclass solution {\n    public boolean isisomorphic(string s, string t) {\n        char[] arr1=s.tochararray();\n            char[] arr2=t.tochararray();\n            hashmap<character,integer> map1=new hashmap<>();\n            hashmap<character,integer> map2=new hashmap<>();\n            if (arr1.length!=arr2.length){\n                return false;\n            }\n            for (int i = 0; i < arr1.length; i++) {\n                if (map1.containskey(arr1[i])){\n                    int count1=map1.get(arr1[i]);\n                    if (map2.containskey(arr2[i])){\n                        int count2=map2.get(arr2[i]);\n                        if (count1==count2){\n                            continue;\n                        }else {\n                            return false;\n                        }\n                    }else {\n                        return false;\n                    }\n                }else {\n                    map1.put(arr1[i],i);\n                    if (map2.containskey(arr2[i])){\n                        return false;\n                    }else {\n                        map2.put(arr2[i],i);\n                        continue;\n                    }\n                }\n            }\n            return true;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n# 高赞题解\n# 题解\nclass solution:\n    def isisomorphic(self, s: str, t: str) -> bool:\n        return [*map(s.index, s)] == [*map(t.index, t)]\n\n\n1\n2\n3\n * 同构代表两个字符串中每个位置上字符在自身第一次出现的索引相同\n\n# 细节补充\n * str 类型数据拥有内置函数 index，输入一个子字符串，可以返回子字符串在 str 中第一次出现的索引，若不存在则报错\n * map(函数，可迭代对象) 将会对（参数2：可迭代对象）中的每个元素运用（参数1：函数）并将结果按顺序储存在一个迭代器中，返回这个迭代器\n * 使用 [*……] 可对对象解包，本题中 [*map……] 等效于 list(map……)\n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-06-01 23:25:15accepted [https://leetcode-cn.com//submissions/detail/2824855/]6 ms81.31%n/ajava2018-06-01 23:13:47wrong answer [https://leetcode-cn.com//submissions/detail/2824522/]n/an/an/ajava2018-06-01 23:08:22accepted [https://leetcode-cn.com//submissions/detail/2824432/]27 ms14.74%n/ajava# 统计信息\n通过次数提交次数ac比率252865388146.9%# 相似题目\n题目难度单词规律 [https://leetcode-cn.com/problems/word-pattern/]简单'},{title:"172-阶乘后的零(Factorial Trailing Zeroes)",frontmatter:{title:"172-阶乘后的零(Factorial Trailing Zeroes)",date:"2021-04-11T00:00:00.000Z",categories:["简单"],tags:["数学<Math>"]},regularPath:"/views/%E7%AE%80%E5%8D%95/0172-%E9%98%B6%E4%B9%98%E5%90%8E%E7%9A%84%E9%9B%B6.html",relativePath:"views/简单/0172-阶乘后的零.md",key:"v-695ff01c",path:"/views/%E7%AE%80%E5%8D%95/0172-%E9%98%B6%E4%B9%98%E5%90%8E%E7%9A%84%E9%9B%B6.html",headers:[{level:2,title:"中文题目",slug:"中文题目",charIndex:2},{level:2,title:"通过代码",slug:"通过代码",charIndex:146},{level:2,title:"官方题解",slug:"官方题解",charIndex:363},{level:2,title:"提交历史",slug:"提交历史",charIndex:12378},{level:2,title:"统计信息",slug:"统计信息",charIndex:12512},{level:2,title:"相似题目",slug:"相似题目",charIndex:12547}],lastUpdated:"4/11/2021, 6:09:39 PM",headersStr:"中文题目 通过代码 官方题解 提交历史 统计信息 相似题目",content:"# 中文题目\n给定一个整数 n，返回 n! 结果尾数中零的数量。\n\n示例 1:\n\n输入: 3\n输出: 0\n解释: 3! = 6, 尾数中没有零。\n\n示例 2:\n\n输入: 5\n输出: 1\n解释: 5! = 120, 尾数中有 1 个零.\n\n说明: 你算法的时间复杂度应为O(logn)。\n\n# 通过代码\nclass Solution {\n    public int trailingZeroes(int n) {\n        int count = 0;\n        while(n >= 5) {\n            count += n / 5;\n            n /= 5;\n        }\n        return count;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n# 官方题解\n# 方法一：计算阶乘\n这种方法速度太慢了，但却是一个好的起点。虽然不会在面试中实现它，但是你可以简单的描述它是个解决问题的办法之一。\n\n解决这个问题的最简单的办法就是计算 n!n!n!，然后计算它的末尾数 0 个数。阶乘是通过将所有在 111 和 nnn 之间的数字相乘计算的。例如，10!=10⋅9⋅8⋅7⋅6⋅5⋅4⋅3⋅2⋅1=3,628,80010! = 10 \\cdot 9 \\cdot 8 \\cdot 7 \\cdot 6 \\cdot 5 \\cdot 4 \\cdot 3 \\cdot 2 \\cdot 1 = 3,628,80010!=10⋅9⋅8⋅7⋅6⋅5⋅4⋅3⋅2⋅1=3,628,800。因此，可以使用以下算法迭代计算阶乘。\n\ndefine function factorial(n):\n    n_factorial = 1\n    for i from 1 to n (inclusive):\n        n_factorial = n_factorial * i\n    return n_factorial\n\n\n1\n2\n3\n4\n5\n如果一个数字末尾有零，那么它可以被 101010 整除。除以 101010 将删除该零，并将所有其他数字右移一位。因此，我们可以通过反复检查数字是否可以被 101010 整除来计算末尾 0 的个数。\n\ndefine function zero_count(x):\n    zero_count = 0\n    while x is divisible by 10: \n        zero_count += 1\n        x = x / 10\n    return zero_count\n\n\n1\n2\n3\n4\n5\n6\n通过将这两个函数放到一起，我们可以计算阶乘后的零个数。\n\n算法：\n\n在 Java 中，我们需要使用 BigInteger，防止在计算阶乘的过程中溢出。\n\ndef trailingZeroes(self, n: int) -> int:\n        \n    # Calculate n!\n    n_factorial = 1\n    for i in range(2, n + 1):\n        n_factorial *= i\n    \n    # Count how many 0's are on the end.\n    zero_count = 0\n    while n_factorial % 10 == 0:\n        zero_count += 1\n        n_factorial //= 10\n        \n    return zero_count\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\nimport java.math.BigInteger;\n\npublic int trailingZeroes(int n) {\n    \n    // Calculate n!\n    BigInteger nFactorial = BigInteger.ONE;\n    for (int i = 2; i <= n; i++) {\n        nFactorial = nFactorial.multiply(BigInteger.valueOf(i));\n    }\n                    \n    // Count how many 0's are on the end.\n    int zeroCount = 0;\n    \n    while (nFactorial.mod(BigInteger.TEN).equals(BigInteger.ZERO)) {\n        nFactorial = nFactorial.divide(BigInteger.TEN);\n        zeroCount++;\n    }\n    \n    return zeroCount;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n复杂度分析\n\n * 时间复杂度：低于 O(n2)O(n ^ 2)O(n2)。\n\n计算阶乘是重复的乘法。通常，当我们知道乘法是固定大小的数字上（例如 32 位或 64 位整数）时，我们可以视为 O(1)O(1)O(1) 运算。但是，这里要乘以的数字会随着 nnn 大小而增长，所以这里不能这么做。\n\n因此，这里的第一步是考虑乘法的成本，因为我们不能假设它是 O(1)O(1)O(1)。把两个大数字相乘的流行方法它的成本是 O((log⁡x)⋅(log⁡y))O((\\log x) \\cdot (\\log y))O((logx)⋅(logy))。我们将在近似值中使用它。\n\n接下来，我们考虑以下在计算 n!n!n! 时，我们做了什么乘法运算。前几个乘法如下：\n\n1⋅2=21 \\cdot 2 = 21⋅2=22⋅3=62 \\cdot 3 = 62⋅3=66⋅4=246 \\cdot 4 = 246⋅4=2424⋅5=12024 \\cdot 5 = 12024⋅5=120120⋅6=720120 \\cdot 6 = 720120⋅6=720.........\n\n这些乘法的成本：\n\nlog⁡1⋅log⁡2\\log 1 \\cdot \\log 2log1⋅log2log⁡2⋅log⁡3\\log 2 \\cdot \\log 3log2⋅log3log⁡6⋅log⁡4\\log 6 \\cdot \\log 4log6⋅log4log⁡24⋅log⁡5\\log 24 \\cdot \\log 5log24⋅log5log⁡120⋅log⁡6\\log 120 \\cdot \\log 6log120⋅log6.........\n\n我们可以改写为：\n\nlog⁡,1!⋅log⁡,2\\log , 1! \\cdot \\log , 2log,1!⋅log,2log⁡,2!⋅log⁡,3\\log , 2! \\cdot \\log , 3log,2!⋅log,3log⁡,3!⋅log⁡,4\\log , 3! \\cdot \\log , 4log,3!⋅log,4log⁡,4!⋅log⁡,5\\log , 4! \\cdot \\log , 5log,4!⋅log,5log⁡,5!⋅log⁡,6\\log , 5! \\cdot \\log , 6log,5!⋅log,6.........\n\n发现了吗？每行的格式为 (log⁡k!)⋅(log⁡k+1)(\\log k!) \\cdot (\\log k + 1)(logk!)⋅(logk+1)，最后一行是什么？计算阶乘的最后一步是乘以 nnn。因此，最后一行必须是：\n\n看到图案了吗？每行的格式为（log⁡，k！）⋅（log⁡，k+1）（\\log，k！）\\cdot（\\log，k+1）（log，k！）⋅（log，k+1）。最后一行是什么？计算阶乘的最后一步是乘以n$。因此，最后一行必须是：\n\nlog⁡((n−1)!)⋅log⁡(n)\\log ((n - 1)!) \\cdot \\log (n)log((n−1)!)⋅log(n)\n\n因为我们一个接一个地做这些乘法运算，所以我们应该把它们相加，得到总的时间复杂度。得到：\n\nlog⁡1!⋅log⁡2+log⁡2!⋅log⁡3+log⁡3!⋅log⁡4+⋯+log⁡((n−2)!)⋅log⁡(n−1)+log⁡((n−1)!)⋅log⁡n\\log 1! \\cdot \\log 2 + \\log 2! \\cdot \\log 3 + \\log 3! \\cdot \\log 4 + \\cdots + \\log ((n - 2)!) \\cdot \\log (n - 1) + \\log ((n - 1)!) \\cdot \\log nlog1!⋅log2+log2!⋅log3+log3!⋅log4+⋯+log((n−2)!)⋅log(n−1)+log((n−1)!)⋅logn\n\n这个序列相加起来相当复杂，我们不是要找到一个确切的答案，而是通过扔掉不太重要的项，找到粗略的下界近似。\n\n在这一点上，你会发现算法比 O(n)O(n)O(n) 差，因为我们添加了 nnn 项。考虑到这个问题要求我们提出一个不低于 O(log⁡n)O(\\log n)O(logn) 的算法。我们将进一步探讨，但是如果你已经理解到这一点，已经十分棒了。\n\n注意 log⁡((n−1)!)\\log ((n - 1)!)log((n−1)!) 比 log⁡n\\log nlogn 大的多。因此，我们将删除这部分，留下 log⁡((n−1)!)\\log ((n - 1)!)log((n−1)!)。得到：\n\nlog⁡1!+log⁡2!+log⁡3!+⋯+log⁡((n−2)!)+log⁡((n−1)!)\\log 1! + \\log 2! + \\log 3! + \\cdots + \\log ((n - 2)!) + \\log ((n - 1)!)log1!+log2!+log3!+⋯+log((n−2)!)+log((n−1)!)\n\n下一部分涉及到一个 log 原则，你可能听说过，也可能没有。如果你还没听说过，那么绝对指的记住，因为它非常有用。\n\nO(log⁡n!)=O(nlog⁡n)O(\\log n!) = O(n \\log n)O(logn!)=O(nlogn)\n\n我们根据这个原则重写序列：\n\n1⋅log⁡1+2⋅log⁡2+3⋅log⁡3+⋯+(n−2)⋅log⁡(n−2)+(n−1)⋅log⁡(n−1)1 \\cdot \\log 1 + 2 \\cdot \\log 2 + 3 \\cdot \\log 3 + \\cdots + (n - 2) \\cdot \\log (n - 2) + (n - 1) \\cdot \\log (n - 1)1⋅log1+2⋅log2+3⋅log3+⋯+(n−2)⋅log(n−2)+(n−1)⋅log(n−1)\n\n像以前一样，我们把较小的项去掉，看看剩下什么：\n\n1+2+3+...+(n−2)+(n−1)1 + 2 + 3 + ... + (n - 2) + (n - 1)1+2+3+...+(n−2)+(n−1)\n\n这是个非常常见的序列，它的成本是 O(n2)O(n^2)O(n2)。\n\n那么，我们能得出什么结论呢？丢弃了项以后会使我们的时间复杂度低于真实的时间复杂度。换句话说，这个阶乘算法复杂度小于 O(n2)O(n^2)O(n2)。\n\n但是 O(n2)O(n^2)O(n2) 绝对不够好！。\n\n尽管这种丢弃项的方法看起来有点奇怪，但快速做出早期决策非常有用，而不必费心与高等数学。只有当我们决定进一步研究改算法时，才会尝试得出更加精确的时间复杂度。在这种情况下，我们的下限足够让我们相信它绝对不值得一看！\n\n第二部分，在结尾数零，与第一部分相比微不足道。\n\n * 空间复杂度：O(log⁡n!)=O(nlog⁡n)O(\\log n!) = O(n \\log n)O(logn!)=O(nlogn)，为了存储 n!n!n!，我们需要 O(log⁡n!)O(\\log n!)O(logn!) 位，而它等于 O(nlog⁡n)O(n \\log n)O(nlogn)。\n\n# 方法二：计算因子 5\n这种方法也太慢了，但是在解决问题的过程中，它很可能是提出对数方法的一个步骤。\n\n与方法 1 中那样计算阶乘不同，我们可以认识到阶乘末尾的每个 000 表示乘以 101010。\n\n那么，我们在计算 n!n!n! 时乘以 101010 的次数是多少？两个数字 aaa 和 bbb 相乘。例如，要执行 42⋅75=315042 \\cdot 75 = 315042⋅75=3150，可以重写如下：\n\n42=2⋅3⋅742 = 2 \\cdot 3 \\cdot 742=2⋅3⋅775=3⋅5⋅575 = 3 \\cdot 5 \\cdot 575=3⋅5⋅542⋅75=2⋅3⋅7⋅3⋅5⋅542 \\cdot 75 = 2 \\cdot 3 \\cdot 7 \\cdot 3 \\cdot 5 \\cdot 542⋅75=2⋅3⋅7⋅3⋅5⋅5\n\n现在，为了确定最后有多少个零，我们应该看有多少对 222 和 555 的因子。在上面的例子中，我们有一对 222 和 555 的因子。\n\n那么，这和阶乘有什么关系呢？在一个阶乘中，我们把所有 111 和 nnn 之间的数相乘，这和把所有 111 和 nnn 之间所有数字的因子相乘是一样的。\n\n例如，如果 n=16n=16n=16，我们需要查看 111 到 161616 之间所有数字的因子。我们只对 222 和 555 有兴趣。包含 555 因子的数字是 5，10，15{5，10，15}5，10，15，包含因子 222 的数字是 2、4、6、8、10、12、14、16{2、4、6、8、10、12、14、16}2、4、6、8、10、12、14、16。因为只三个完整的对，因此 16!16!16! 后有三个零。\n\n把这个放到一个算法中，我们得到：\n\ntwos = 0\nfor i from 1 to n inclusive:\n    if i is divisible by 2:\n        twos += 1\n\nfives = 0\nfor i from 1 to n inclusive:\n    if i is divisible by 5:\n        fives += 1\n\ntens = min(fives, twos)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n这可以解决大部分情况，但是有的数字存在一个以上的因子。例如，若 i = 25，那么我们只做了 fives += 1。但是我们应该 fives += 2，因为 252525 有两个因子 5。\n\n因此，我们需要计算每个数字中的因子 555。我们可以使用一个循环而不是 if 语句，我们若有因子 555 将数字除以 555。如果还有剩余的因子 555，则将重复步骤。\n\n我们可以这样做：\n\ntwos = 0\nfor i from 1 to n inclusive:\n    remaining_i = i\n    while remaining_i is divisible by 2:\n        twos += 1\n        remaining_i = remaining_i / 2\n\nfives = 0\nfor i from 1 to n inclusive:\n    remaining_i = i\n    while remaining_i is divisible by 5:\n        fives += 1\n        remaining_i = remaining_i / 5\n\ntens = min(twos, fives)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n这样我们就得到了正确答案，但是我们仍然可以做一些改进。\n\n首先，我们可以注意到因子 222 数总是比因子 555 大。为什么？因为每四个数字算作额外的因子 222，但是只有每 252525 个数字算作额外的因子 555。下图我们可以清晰的看见：\n\n\n\n因此我们可以删除计算因子 222 的过程，留下：\n\nfives = 0\nfor i from 1 to n inclusive:\n    remaining_i = i\n    while remaining_i is divisible by 5:\n        fives += 1\n        remaining_i = remaining_i / 5\n\ntens = fives\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n我们可以做最后一个优化。在上面的算法中，我们分析了从 111 到 nnn 的每个数字。但是只有 5,10,15,20,25,30,...等等5, 10, 15, 20, 25, 30, ... 等等5,10,15,20,25,30,...等等 至少有一个因子 555。所以，ww偶们不必一步一步的往上迭代，可以五步的往上迭代：因此可以修改为：\n\nfives = 0\nfor i from 5 to n inclusive in steps of 5:\n    remaining_i = i\n    while remaining_i is divisible by 5:\n        fives += 1\n        remaining_i = remaining_i / 5\n\ntens = fives\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n算法：\n\n这是我们设计的算法\n\ndef trailingZeroes(self, n: int) -> int:\n        \n    zero_count = 0\n    for i in range(5, n + 1, 5):\n        current = i\n        while current % 5 == 0:\n            zero_count += 1\n            current //= 5\n\n    return zero_count\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\npublic int trailingZeroes(int n) {\n        \n    int zeroCount = 0;\n    for (int i = 5; i <= n; i += 5) {\n        int currentFactor = i;\n        while (currentFactor % 5 == 0) {\n            zeroCount++;\n            currentFactor /= 5;\n        }\n    }\n    return zeroCount;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n或者，我们可以检查 555 的幂，而不是每次除以 555 来计算因子数。这是通过检查 i 是否可以被 555，252525，125125125 等整除来实现的。\n\ndef trailingZeroes(self, n: int) -> int:\n        \n    zero_count = 0\n    for i in range(5, n + 1, 5):\n        power_of_5 = 5\n        while i % power_of_5 == 0:\n            zero_count += 1\n            power_of_5 *= 5\n\n    return zero_count\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\npublic int trailingZeroes(int n) {\n    \n    int zeroCount = 0;\n    for (int i = 5; i <= n; i += 5) {\n        int powerOf5 = 5;\n        while (i % powerOf5 == 0) {\n            zeroCount += 1;\n            powerOf5 *= 5;\n        }\n    }\n    return zeroCount;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n复杂度分析\n\n * 时间复杂度：O(n)O(n)O(n)。\n\n在方法一中，我们不能将出发看作 O(1)O(1)O(1)，不过在此方法中，我们保持在它的范围内，因此可以将除法和乘法看作 O(1)O(1)O(1)。\n\n为了计算零计数，我们循环从 555 到 nnn 的每五个数字处理一次，这里是 O(n)O(n)O(n) 步（将 15\\frac{1}{5}51​ 作为常量处理）。\n\n在每个步骤中，虽然看起来像是执行 O(log⁡n)O(\\log n)O(logn) 操作来计算 5 的因子数，但实际上它只消耗 O(1)O(1)O(1)，因为绝大部分的数字只包含一个因子 555。可以证明，因子 555 的总数小于 2⋅n5\\frac{2 \\cdot n}{5}52⋅n​。\n\n所以我们得到 O(n)⋅O(1)=O(n)O(n) \\cdot O(1) = O(n)O(n)⋅O(1)=O(n)。\n\n * 空间复杂度：O(1)O(1)O(1)，只是用了一个整数变量。\n\n# 方法三：高效的计算因子 5\n在方法 2 中，我们找到了一种计算阶乘后的零的个数的方法，而不需要实际计算阶乘。这是通过在 555 的每个倍数上循环，从 555 到 nnn，并计算 555 的每个倍数中有多少个因子。我们把所有这些数字加起来得到最终结果。\n\n然而，无论是实际上还是对问题的要求来说，方法 2 仍然太慢。为了得出一个足够快的算法，我们需要做进一步改进，这个改进能使我们在对数时间内计算出我们的答案。\n\n思考我们之前简化的算法（但不正确），它不正确是因为对于有多个因子 555 时会计算出错，例如 252525。\n\nfives = 0\nfor i from 1 to n inclusive:\n    if i is divisible by 5:\n        fives += 1\n\n\n1\n2\n3\n4\n你会发现这是执行 n5\\frac{n}{5}5n​ 的低效方法。我们只对 555 的倍数感兴趣，不是 555 的倍数可以忽略,因此可以简化成:\n\nfives = n / 5\ntens = fives\n\n\n1\n2\n那么，如何解决有多重因子的数字呢？所有包含两个及以上的因子 555 的数字都是 252525 的倍数。所以我们可以简单的除以 252525 来计算 252525 的倍数是多少。另外，我们在 n5\\frac{n}{5}5n​ 已经计算了 252525 一次，所以我们只需要再计算额外因子一次 n25\\frac{n}{25}25n​ （而不是 2⋅n252\\cdot\\frac{n}{25}2⋅25n​）\n\n所以结合起来我们得到：\n\nfives = n / 5 + n / 25\ntens = fives\n\n\n1\n2\n但是如果有三个因子 555 呢！为了得到最终的结果，我们需要将所有的 n5\\dfrac{n}{5}5n​、n25\\dfrac{n}{25}25n​、n125\\dfrac{n}{125}125n​、n625\\dfrac{n}{625}625n​ 等相加。得到：\n\nfives=n5+n25+n125+n625+n3125+⋯fives=\\dfrac{n}{5}+\\dfrac{n}{25}+\\dfrac{n}{125}+\\dfrac{n}{625}+\\dfrac{n}{3125}+\\cdotsfives=5n​+25n​+125n​+625n​+3125n​+⋯\n\n这样看起来会一直计算下去，但是并非如此！我们使用整数除法，最终，分母将大于 nnn，因此当项等于 0 时，就可以停止我们的计算。\n\n例如，如果 n=12345n=12345n=12345，我们得到：\n\nfives=123455+1234525+12345125+12345625+123453125+1234516075+1234580375+⋯fives=\\dfrac{12345}{5}+\\dfrac{12345}{25}+\\dfrac{12345}{125}+\\dfrac{12345}{625}+\\dfrac{12345}{3125}+\\dfrac{12345}{16075}+\\dfrac{12345}{80375}+\\cdotsfives=512345​+2512345​+12512345​+62512345​+312512345​+1607512345​+8037512345​+⋯\n\n等于：\n\nfives=2469+493+98+19+3+0+0+⋯=3082fives = 2469 + 493 + 98 + 19 + 3 + 0 + 0 + \\cdots = 3082fives=2469+493+98+19+3+0+0+⋯=3082\n\n在代码中，我们可以通过循环 555 的幂来计算。\n\nfives = 0\npower_of_5 = 5\nwhile n >= power_of_5:\n    fives += n / power_of_5\n    power_of_5 *= 5\n\ntens = fives\n\n\n1\n2\n3\n4\n5\n6\n7\n算法：\n\ndef trailingZeroes(self, n: int) -> int:\n    zero_count = 0\n    current_multiple = 5\n    while n >= current_multiple:\n        zero_count += n // current_multiple\n        current_multiple *= 5\n    return zero_count\n\n\n1\n2\n3\n4\n5\n6\n7\npublic int trailingZeroes(int n) {\n    int zeroCount = 0;\n    // We need to use long because currentMultiple can potentially become\n    // larger than an int.\n    long currentMultiple = 5;\n    while (n >= currentMultiple) {\n        zeroCount += (n / currentMultiple);\n        currentMultiple *= 5;\n    }\n    return zeroCount;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n编写此算法的另一种方法是，我们不必每次尝试 555 的幂，而是每次将 nnn 本身除以 555。这也是一样的，因为我们最终得到的序列是：\n\nfives=n5+（n5）5+（（n5）5）5+⋯fives=\\dfrac{n}{5}+\\dfrac{（\\dfrac{n}{5}）}{5}+\\dfrac{（\\dfrac{（\\frac{n}{5}）}{5}）}{5}+\\cdotsfives=5n​+5（5n​）​+5（5（5n​）​）​+⋯\n\n注意，在第二步中，我们有 （n5）5\\dfrac{（\\frac{n}{5}）}{5}5（5n​）​。这是因为前一步将 nnn 本身除以 555。等等。\n\n如果你熟悉分数规则，你会发现 （n5）5\\dfrac{（\\frac{n}{5}）}{5}5（5n​）​和 n5⋅5=n25\\dfrac{n}{5\\cdot 5}=\\frac{n}{25}5⋅5n​=25n​ 是一样的。这意味着序列与：\n\nn5+n25+n125+⋯\\dfrac{n}{5}+\\dfrac{n}{25}+\\dfrac{n}{125}+\\cdots5n​+25n​+125n​+⋯\n\n因此，这种编写算法的替代方法是等价的。\n\ndef trailingZeroes(self, n: int) -> int:\n    zero_count = 0\n    while n > 0:\n        n //= 5\n        zero_count += n\n    return zero_count\n\n\n1\n2\n3\n4\n5\n6\npublic int trailingZeroes(int n) {\n    int zeroCount = 0;\n    long currentMultiple = 5;\n    while (n > 0) {\n        n /= 5;\n        zeroCount += n;\n    }\n    return zeroCount;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n复杂度分析\n\n * 时间复杂度：O(log⁡n)O(\\log n)O(logn)。在这种方法中，我们将 nnn 除以 555 的每个幂。根据定义，555 的 log⁡5n\\log_5nlog5​n 幂小于或等于 nnn。由于乘法和除法在 32 位整数范围内，我们将这些计算视为 O(1)O(1)O(1)。因此，我们正在执行 log⁡5n⋅O（1）=log⁡n\\log_5 n\\cdot O（1）=\\log nlog5​n⋅O（1）=logn 操作\n * 空间复杂度：O(1)O(1)O(1)，只是用了常数空间。\n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2021-04-11 16:50:15Accepted [https://leetcode-cn.com//submissions/detail/166513960/]1 ms100.0%35.4 MBjava# 统计信息\n通过次数提交次数AC比率7047216560842.6%# 相似题目\n题目难度数字 1 的个数 [https://leetcode-cn.com/problems/number-of-digit-one/]困难阶乘函数后 K 个零 [https://leetcode-cn.com/problems/preimage-size-of-factorial-zeroes-function/]困难",contentLowercase:"# 中文题目\n给定一个整数 n，返回 n! 结果尾数中零的数量。\n\n示例 1:\n\n输入: 3\n输出: 0\n解释: 3! = 6, 尾数中没有零。\n\n示例 2:\n\n输入: 5\n输出: 1\n解释: 5! = 120, 尾数中有 1 个零.\n\n说明: 你算法的时间复杂度应为o(logn)。\n\n# 通过代码\nclass solution {\n    public int trailingzeroes(int n) {\n        int count = 0;\n        while(n >= 5) {\n            count += n / 5;\n            n /= 5;\n        }\n        return count;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n# 官方题解\n# 方法一：计算阶乘\n这种方法速度太慢了，但却是一个好的起点。虽然不会在面试中实现它，但是你可以简单的描述它是个解决问题的办法之一。\n\n解决这个问题的最简单的办法就是计算 n!n!n!，然后计算它的末尾数 0 个数。阶乘是通过将所有在 111 和 nnn 之间的数字相乘计算的。例如，10!=10⋅9⋅8⋅7⋅6⋅5⋅4⋅3⋅2⋅1=3,628,80010! = 10 \\cdot 9 \\cdot 8 \\cdot 7 \\cdot 6 \\cdot 5 \\cdot 4 \\cdot 3 \\cdot 2 \\cdot 1 = 3,628,80010!=10⋅9⋅8⋅7⋅6⋅5⋅4⋅3⋅2⋅1=3,628,800。因此，可以使用以下算法迭代计算阶乘。\n\ndefine function factorial(n):\n    n_factorial = 1\n    for i from 1 to n (inclusive):\n        n_factorial = n_factorial * i\n    return n_factorial\n\n\n1\n2\n3\n4\n5\n如果一个数字末尾有零，那么它可以被 101010 整除。除以 101010 将删除该零，并将所有其他数字右移一位。因此，我们可以通过反复检查数字是否可以被 101010 整除来计算末尾 0 的个数。\n\ndefine function zero_count(x):\n    zero_count = 0\n    while x is divisible by 10: \n        zero_count += 1\n        x = x / 10\n    return zero_count\n\n\n1\n2\n3\n4\n5\n6\n通过将这两个函数放到一起，我们可以计算阶乘后的零个数。\n\n算法：\n\n在 java 中，我们需要使用 biginteger，防止在计算阶乘的过程中溢出。\n\ndef trailingzeroes(self, n: int) -> int:\n        \n    # calculate n!\n    n_factorial = 1\n    for i in range(2, n + 1):\n        n_factorial *= i\n    \n    # count how many 0's are on the end.\n    zero_count = 0\n    while n_factorial % 10 == 0:\n        zero_count += 1\n        n_factorial //= 10\n        \n    return zero_count\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\nimport java.math.biginteger;\n\npublic int trailingzeroes(int n) {\n    \n    // calculate n!\n    biginteger nfactorial = biginteger.one;\n    for (int i = 2; i <= n; i++) {\n        nfactorial = nfactorial.multiply(biginteger.valueof(i));\n    }\n                    \n    // count how many 0's are on the end.\n    int zerocount = 0;\n    \n    while (nfactorial.mod(biginteger.ten).equals(biginteger.zero)) {\n        nfactorial = nfactorial.divide(biginteger.ten);\n        zerocount++;\n    }\n    \n    return zerocount;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n复杂度分析\n\n * 时间复杂度：低于 o(n2)o(n ^ 2)o(n2)。\n\n计算阶乘是重复的乘法。通常，当我们知道乘法是固定大小的数字上（例如 32 位或 64 位整数）时，我们可以视为 o(1)o(1)o(1) 运算。但是，这里要乘以的数字会随着 nnn 大小而增长，所以这里不能这么做。\n\n因此，这里的第一步是考虑乘法的成本，因为我们不能假设它是 o(1)o(1)o(1)。把两个大数字相乘的流行方法它的成本是 o((log⁡x)⋅(log⁡y))o((\\log x) \\cdot (\\log y))o((logx)⋅(logy))。我们将在近似值中使用它。\n\n接下来，我们考虑以下在计算 n!n!n! 时，我们做了什么乘法运算。前几个乘法如下：\n\n1⋅2=21 \\cdot 2 = 21⋅2=22⋅3=62 \\cdot 3 = 62⋅3=66⋅4=246 \\cdot 4 = 246⋅4=2424⋅5=12024 \\cdot 5 = 12024⋅5=120120⋅6=720120 \\cdot 6 = 720120⋅6=720.........\n\n这些乘法的成本：\n\nlog⁡1⋅log⁡2\\log 1 \\cdot \\log 2log1⋅log2log⁡2⋅log⁡3\\log 2 \\cdot \\log 3log2⋅log3log⁡6⋅log⁡4\\log 6 \\cdot \\log 4log6⋅log4log⁡24⋅log⁡5\\log 24 \\cdot \\log 5log24⋅log5log⁡120⋅log⁡6\\log 120 \\cdot \\log 6log120⋅log6.........\n\n我们可以改写为：\n\nlog⁡,1!⋅log⁡,2\\log , 1! \\cdot \\log , 2log,1!⋅log,2log⁡,2!⋅log⁡,3\\log , 2! \\cdot \\log , 3log,2!⋅log,3log⁡,3!⋅log⁡,4\\log , 3! \\cdot \\log , 4log,3!⋅log,4log⁡,4!⋅log⁡,5\\log , 4! \\cdot \\log , 5log,4!⋅log,5log⁡,5!⋅log⁡,6\\log , 5! \\cdot \\log , 6log,5!⋅log,6.........\n\n发现了吗？每行的格式为 (log⁡k!)⋅(log⁡k+1)(\\log k!) \\cdot (\\log k + 1)(logk!)⋅(logk+1)，最后一行是什么？计算阶乘的最后一步是乘以 nnn。因此，最后一行必须是：\n\n看到图案了吗？每行的格式为（log⁡，k！）⋅（log⁡，k+1）（\\log，k！）\\cdot（\\log，k+1）（log，k！）⋅（log，k+1）。最后一行是什么？计算阶乘的最后一步是乘以n$。因此，最后一行必须是：\n\nlog⁡((n−1)!)⋅log⁡(n)\\log ((n - 1)!) \\cdot \\log (n)log((n−1)!)⋅log(n)\n\n因为我们一个接一个地做这些乘法运算，所以我们应该把它们相加，得到总的时间复杂度。得到：\n\nlog⁡1!⋅log⁡2+log⁡2!⋅log⁡3+log⁡3!⋅log⁡4+⋯+log⁡((n−2)!)⋅log⁡(n−1)+log⁡((n−1)!)⋅log⁡n\\log 1! \\cdot \\log 2 + \\log 2! \\cdot \\log 3 + \\log 3! \\cdot \\log 4 + \\cdots + \\log ((n - 2)!) \\cdot \\log (n - 1) + \\log ((n - 1)!) \\cdot \\log nlog1!⋅log2+log2!⋅log3+log3!⋅log4+⋯+log((n−2)!)⋅log(n−1)+log((n−1)!)⋅logn\n\n这个序列相加起来相当复杂，我们不是要找到一个确切的答案，而是通过扔掉不太重要的项，找到粗略的下界近似。\n\n在这一点上，你会发现算法比 o(n)o(n)o(n) 差，因为我们添加了 nnn 项。考虑到这个问题要求我们提出一个不低于 o(log⁡n)o(\\log n)o(logn) 的算法。我们将进一步探讨，但是如果你已经理解到这一点，已经十分棒了。\n\n注意 log⁡((n−1)!)\\log ((n - 1)!)log((n−1)!) 比 log⁡n\\log nlogn 大的多。因此，我们将删除这部分，留下 log⁡((n−1)!)\\log ((n - 1)!)log((n−1)!)。得到：\n\nlog⁡1!+log⁡2!+log⁡3!+⋯+log⁡((n−2)!)+log⁡((n−1)!)\\log 1! + \\log 2! + \\log 3! + \\cdots + \\log ((n - 2)!) + \\log ((n - 1)!)log1!+log2!+log3!+⋯+log((n−2)!)+log((n−1)!)\n\n下一部分涉及到一个 log 原则，你可能听说过，也可能没有。如果你还没听说过，那么绝对指的记住，因为它非常有用。\n\no(log⁡n!)=o(nlog⁡n)o(\\log n!) = o(n \\log n)o(logn!)=o(nlogn)\n\n我们根据这个原则重写序列：\n\n1⋅log⁡1+2⋅log⁡2+3⋅log⁡3+⋯+(n−2)⋅log⁡(n−2)+(n−1)⋅log⁡(n−1)1 \\cdot \\log 1 + 2 \\cdot \\log 2 + 3 \\cdot \\log 3 + \\cdots + (n - 2) \\cdot \\log (n - 2) + (n - 1) \\cdot \\log (n - 1)1⋅log1+2⋅log2+3⋅log3+⋯+(n−2)⋅log(n−2)+(n−1)⋅log(n−1)\n\n像以前一样，我们把较小的项去掉，看看剩下什么：\n\n1+2+3+...+(n−2)+(n−1)1 + 2 + 3 + ... + (n - 2) + (n - 1)1+2+3+...+(n−2)+(n−1)\n\n这是个非常常见的序列，它的成本是 o(n2)o(n^2)o(n2)。\n\n那么，我们能得出什么结论呢？丢弃了项以后会使我们的时间复杂度低于真实的时间复杂度。换句话说，这个阶乘算法复杂度小于 o(n2)o(n^2)o(n2)。\n\n但是 o(n2)o(n^2)o(n2) 绝对不够好！。\n\n尽管这种丢弃项的方法看起来有点奇怪，但快速做出早期决策非常有用，而不必费心与高等数学。只有当我们决定进一步研究改算法时，才会尝试得出更加精确的时间复杂度。在这种情况下，我们的下限足够让我们相信它绝对不值得一看！\n\n第二部分，在结尾数零，与第一部分相比微不足道。\n\n * 空间复杂度：o(log⁡n!)=o(nlog⁡n)o(\\log n!) = o(n \\log n)o(logn!)=o(nlogn)，为了存储 n!n!n!，我们需要 o(log⁡n!)o(\\log n!)o(logn!) 位，而它等于 o(nlog⁡n)o(n \\log n)o(nlogn)。\n\n# 方法二：计算因子 5\n这种方法也太慢了，但是在解决问题的过程中，它很可能是提出对数方法的一个步骤。\n\n与方法 1 中那样计算阶乘不同，我们可以认识到阶乘末尾的每个 000 表示乘以 101010。\n\n那么，我们在计算 n!n!n! 时乘以 101010 的次数是多少？两个数字 aaa 和 bbb 相乘。例如，要执行 42⋅75=315042 \\cdot 75 = 315042⋅75=3150，可以重写如下：\n\n42=2⋅3⋅742 = 2 \\cdot 3 \\cdot 742=2⋅3⋅775=3⋅5⋅575 = 3 \\cdot 5 \\cdot 575=3⋅5⋅542⋅75=2⋅3⋅7⋅3⋅5⋅542 \\cdot 75 = 2 \\cdot 3 \\cdot 7 \\cdot 3 \\cdot 5 \\cdot 542⋅75=2⋅3⋅7⋅3⋅5⋅5\n\n现在，为了确定最后有多少个零，我们应该看有多少对 222 和 555 的因子。在上面的例子中，我们有一对 222 和 555 的因子。\n\n那么，这和阶乘有什么关系呢？在一个阶乘中，我们把所有 111 和 nnn 之间的数相乘，这和把所有 111 和 nnn 之间所有数字的因子相乘是一样的。\n\n例如，如果 n=16n=16n=16，我们需要查看 111 到 161616 之间所有数字的因子。我们只对 222 和 555 有兴趣。包含 555 因子的数字是 5，10，15{5，10，15}5，10，15，包含因子 222 的数字是 2、4、6、8、10、12、14、16{2、4、6、8、10、12、14、16}2、4、6、8、10、12、14、16。因为只三个完整的对，因此 16!16!16! 后有三个零。\n\n把这个放到一个算法中，我们得到：\n\ntwos = 0\nfor i from 1 to n inclusive:\n    if i is divisible by 2:\n        twos += 1\n\nfives = 0\nfor i from 1 to n inclusive:\n    if i is divisible by 5:\n        fives += 1\n\ntens = min(fives, twos)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n这可以解决大部分情况，但是有的数字存在一个以上的因子。例如，若 i = 25，那么我们只做了 fives += 1。但是我们应该 fives += 2，因为 252525 有两个因子 5。\n\n因此，我们需要计算每个数字中的因子 555。我们可以使用一个循环而不是 if 语句，我们若有因子 555 将数字除以 555。如果还有剩余的因子 555，则将重复步骤。\n\n我们可以这样做：\n\ntwos = 0\nfor i from 1 to n inclusive:\n    remaining_i = i\n    while remaining_i is divisible by 2:\n        twos += 1\n        remaining_i = remaining_i / 2\n\nfives = 0\nfor i from 1 to n inclusive:\n    remaining_i = i\n    while remaining_i is divisible by 5:\n        fives += 1\n        remaining_i = remaining_i / 5\n\ntens = min(twos, fives)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n这样我们就得到了正确答案，但是我们仍然可以做一些改进。\n\n首先，我们可以注意到因子 222 数总是比因子 555 大。为什么？因为每四个数字算作额外的因子 222，但是只有每 252525 个数字算作额外的因子 555。下图我们可以清晰的看见：\n\n\n\n因此我们可以删除计算因子 222 的过程，留下：\n\nfives = 0\nfor i from 1 to n inclusive:\n    remaining_i = i\n    while remaining_i is divisible by 5:\n        fives += 1\n        remaining_i = remaining_i / 5\n\ntens = fives\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n我们可以做最后一个优化。在上面的算法中，我们分析了从 111 到 nnn 的每个数字。但是只有 5,10,15,20,25,30,...等等5, 10, 15, 20, 25, 30, ... 等等5,10,15,20,25,30,...等等 至少有一个因子 555。所以，ww偶们不必一步一步的往上迭代，可以五步的往上迭代：因此可以修改为：\n\nfives = 0\nfor i from 5 to n inclusive in steps of 5:\n    remaining_i = i\n    while remaining_i is divisible by 5:\n        fives += 1\n        remaining_i = remaining_i / 5\n\ntens = fives\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n算法：\n\n这是我们设计的算法\n\ndef trailingzeroes(self, n: int) -> int:\n        \n    zero_count = 0\n    for i in range(5, n + 1, 5):\n        current = i\n        while current % 5 == 0:\n            zero_count += 1\n            current //= 5\n\n    return zero_count\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\npublic int trailingzeroes(int n) {\n        \n    int zerocount = 0;\n    for (int i = 5; i <= n; i += 5) {\n        int currentfactor = i;\n        while (currentfactor % 5 == 0) {\n            zerocount++;\n            currentfactor /= 5;\n        }\n    }\n    return zerocount;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n或者，我们可以检查 555 的幂，而不是每次除以 555 来计算因子数。这是通过检查 i 是否可以被 555，252525，125125125 等整除来实现的。\n\ndef trailingzeroes(self, n: int) -> int:\n        \n    zero_count = 0\n    for i in range(5, n + 1, 5):\n        power_of_5 = 5\n        while i % power_of_5 == 0:\n            zero_count += 1\n            power_of_5 *= 5\n\n    return zero_count\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\npublic int trailingzeroes(int n) {\n    \n    int zerocount = 0;\n    for (int i = 5; i <= n; i += 5) {\n        int powerof5 = 5;\n        while (i % powerof5 == 0) {\n            zerocount += 1;\n            powerof5 *= 5;\n        }\n    }\n    return zerocount;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n复杂度分析\n\n * 时间复杂度：o(n)o(n)o(n)。\n\n在方法一中，我们不能将出发看作 o(1)o(1)o(1)，不过在此方法中，我们保持在它的范围内，因此可以将除法和乘法看作 o(1)o(1)o(1)。\n\n为了计算零计数，我们循环从 555 到 nnn 的每五个数字处理一次，这里是 o(n)o(n)o(n) 步（将 15\\frac{1}{5}51​ 作为常量处理）。\n\n在每个步骤中，虽然看起来像是执行 o(log⁡n)o(\\log n)o(logn) 操作来计算 5 的因子数，但实际上它只消耗 o(1)o(1)o(1)，因为绝大部分的数字只包含一个因子 555。可以证明，因子 555 的总数小于 2⋅n5\\frac{2 \\cdot n}{5}52⋅n​。\n\n所以我们得到 o(n)⋅o(1)=o(n)o(n) \\cdot o(1) = o(n)o(n)⋅o(1)=o(n)。\n\n * 空间复杂度：o(1)o(1)o(1)，只是用了一个整数变量。\n\n# 方法三：高效的计算因子 5\n在方法 2 中，我们找到了一种计算阶乘后的零的个数的方法，而不需要实际计算阶乘。这是通过在 555 的每个倍数上循环，从 555 到 nnn，并计算 555 的每个倍数中有多少个因子。我们把所有这些数字加起来得到最终结果。\n\n然而，无论是实际上还是对问题的要求来说，方法 2 仍然太慢。为了得出一个足够快的算法，我们需要做进一步改进，这个改进能使我们在对数时间内计算出我们的答案。\n\n思考我们之前简化的算法（但不正确），它不正确是因为对于有多个因子 555 时会计算出错，例如 252525。\n\nfives = 0\nfor i from 1 to n inclusive:\n    if i is divisible by 5:\n        fives += 1\n\n\n1\n2\n3\n4\n你会发现这是执行 n5\\frac{n}{5}5n​ 的低效方法。我们只对 555 的倍数感兴趣，不是 555 的倍数可以忽略,因此可以简化成:\n\nfives = n / 5\ntens = fives\n\n\n1\n2\n那么，如何解决有多重因子的数字呢？所有包含两个及以上的因子 555 的数字都是 252525 的倍数。所以我们可以简单的除以 252525 来计算 252525 的倍数是多少。另外，我们在 n5\\frac{n}{5}5n​ 已经计算了 252525 一次，所以我们只需要再计算额外因子一次 n25\\frac{n}{25}25n​ （而不是 2⋅n252\\cdot\\frac{n}{25}2⋅25n​）\n\n所以结合起来我们得到：\n\nfives = n / 5 + n / 25\ntens = fives\n\n\n1\n2\n但是如果有三个因子 555 呢！为了得到最终的结果，我们需要将所有的 n5\\dfrac{n}{5}5n​、n25\\dfrac{n}{25}25n​、n125\\dfrac{n}{125}125n​、n625\\dfrac{n}{625}625n​ 等相加。得到：\n\nfives=n5+n25+n125+n625+n3125+⋯fives=\\dfrac{n}{5}+\\dfrac{n}{25}+\\dfrac{n}{125}+\\dfrac{n}{625}+\\dfrac{n}{3125}+\\cdotsfives=5n​+25n​+125n​+625n​+3125n​+⋯\n\n这样看起来会一直计算下去，但是并非如此！我们使用整数除法，最终，分母将大于 nnn，因此当项等于 0 时，就可以停止我们的计算。\n\n例如，如果 n=12345n=12345n=12345，我们得到：\n\nfives=123455+1234525+12345125+12345625+123453125+1234516075+1234580375+⋯fives=\\dfrac{12345}{5}+\\dfrac{12345}{25}+\\dfrac{12345}{125}+\\dfrac{12345}{625}+\\dfrac{12345}{3125}+\\dfrac{12345}{16075}+\\dfrac{12345}{80375}+\\cdotsfives=512345​+2512345​+12512345​+62512345​+312512345​+1607512345​+8037512345​+⋯\n\n等于：\n\nfives=2469+493+98+19+3+0+0+⋯=3082fives = 2469 + 493 + 98 + 19 + 3 + 0 + 0 + \\cdots = 3082fives=2469+493+98+19+3+0+0+⋯=3082\n\n在代码中，我们可以通过循环 555 的幂来计算。\n\nfives = 0\npower_of_5 = 5\nwhile n >= power_of_5:\n    fives += n / power_of_5\n    power_of_5 *= 5\n\ntens = fives\n\n\n1\n2\n3\n4\n5\n6\n7\n算法：\n\ndef trailingzeroes(self, n: int) -> int:\n    zero_count = 0\n    current_multiple = 5\n    while n >= current_multiple:\n        zero_count += n // current_multiple\n        current_multiple *= 5\n    return zero_count\n\n\n1\n2\n3\n4\n5\n6\n7\npublic int trailingzeroes(int n) {\n    int zerocount = 0;\n    // we need to use long because currentmultiple can potentially become\n    // larger than an int.\n    long currentmultiple = 5;\n    while (n >= currentmultiple) {\n        zerocount += (n / currentmultiple);\n        currentmultiple *= 5;\n    }\n    return zerocount;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n编写此算法的另一种方法是，我们不必每次尝试 555 的幂，而是每次将 nnn 本身除以 555。这也是一样的，因为我们最终得到的序列是：\n\nfives=n5+（n5）5+（（n5）5）5+⋯fives=\\dfrac{n}{5}+\\dfrac{（\\dfrac{n}{5}）}{5}+\\dfrac{（\\dfrac{（\\frac{n}{5}）}{5}）}{5}+\\cdotsfives=5n​+5（5n​）​+5（5（5n​）​）​+⋯\n\n注意，在第二步中，我们有 （n5）5\\dfrac{（\\frac{n}{5}）}{5}5（5n​）​。这是因为前一步将 nnn 本身除以 555。等等。\n\n如果你熟悉分数规则，你会发现 （n5）5\\dfrac{（\\frac{n}{5}）}{5}5（5n​）​和 n5⋅5=n25\\dfrac{n}{5\\cdot 5}=\\frac{n}{25}5⋅5n​=25n​ 是一样的。这意味着序列与：\n\nn5+n25+n125+⋯\\dfrac{n}{5}+\\dfrac{n}{25}+\\dfrac{n}{125}+\\cdots5n​+25n​+125n​+⋯\n\n因此，这种编写算法的替代方法是等价的。\n\ndef trailingzeroes(self, n: int) -> int:\n    zero_count = 0\n    while n > 0:\n        n //= 5\n        zero_count += n\n    return zero_count\n\n\n1\n2\n3\n4\n5\n6\npublic int trailingzeroes(int n) {\n    int zerocount = 0;\n    long currentmultiple = 5;\n    while (n > 0) {\n        n /= 5;\n        zerocount += n;\n    }\n    return zerocount;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n复杂度分析\n\n * 时间复杂度：o(log⁡n)o(\\log n)o(logn)。在这种方法中，我们将 nnn 除以 555 的每个幂。根据定义，555 的 log⁡5n\\log_5nlog5​n 幂小于或等于 nnn。由于乘法和除法在 32 位整数范围内，我们将这些计算视为 o(1)o(1)o(1)。因此，我们正在执行 log⁡5n⋅o（1）=log⁡n\\log_5 n\\cdot o（1）=\\log nlog5​n⋅o（1）=logn 操作\n * 空间复杂度：o(1)o(1)o(1)，只是用了常数空间。\n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2021-04-11 16:50:15accepted [https://leetcode-cn.com//submissions/detail/166513960/]1 ms100.0%35.4 mbjava# 统计信息\n通过次数提交次数ac比率7047216560842.6%# 相似题目\n题目难度数字 1 的个数 [https://leetcode-cn.com/problems/number-of-digit-one/]困难阶乘函数后 k 个零 [https://leetcode-cn.com/problems/preimage-size-of-factorial-zeroes-function/]困难"},{title:"219-存在重复元素 II(Contains Duplicate II)",frontmatter:{title:"219-存在重复元素 II(Contains Duplicate II)",date:"2018-06-24T00:00:00.000Z",categories:["简单"],tags:["数组<Array>","哈希表<Hash Table>"]},regularPath:"/views/%E7%AE%80%E5%8D%95/0219-%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0%20II.html",relativePath:"views/简单/0219-存在重复元素 II.md",key:"v-386f1cf4",path:"/views/%E7%AE%80%E5%8D%95/0219-%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0%20II.html",headers:[{level:2,title:"中文题目",slug:"中文题目",charIndex:2},{level:2,title:"通过代码",slug:"通过代码",charIndex:228},{level:2,title:"官方题解",slug:"官方题解",charIndex:632},{level:2,title:"概述",slug:"概述",charIndex:639},{level:2,title:"提交历史",slug:"提交历史",charIndex:3472},{level:2,title:"统计信息",slug:"统计信息",charIndex:3813},{level:2,title:"相似题目",slug:"相似题目",charIndex:3847}],lastUpdated:"4/11/2021, 1:15:21 PM",headersStr:"中文题目 通过代码 官方题解 概述 提交历史 统计信息 相似题目",content:"# 中文题目\n给定一个整数数组和一个整数k，判断数组中是否存在两个不同的索引i和j，使得nums [i] = nums [j]，并且 i 和 j的差的绝对值最大为 k。\n\n示例 1:\n\n输入: nums = [1,2,3,1], k = 3\n输出: true\n\n示例 2:\n\n输入: nums = [1,0,1,1], k = 1\n输出: true\n\n示例 3:\n\n输入: nums = [1,2,3,1,2,3], k = 2\n输出: false\n\n# 通过代码\nimport java.util.HashSet;\nimport java.util.Set;\nclass Solution {\n    public boolean containsNearbyDuplicate(int[] nums, int k) {\n        Set<Integer> set=new HashSet<>();\n            for (int i = 0; i < nums.length; i++) {\n                if (i>k)set.remove(nums[i-k-1]);\n                if (!set.add(nums[i])) return true;\n            }\n            return false;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n# 官方题解\n# 概述\n这篇文章是为初级读者准备的，文章中会介绍了以下几种方法和数据结构： 线性搜索，二分搜索和散列表。\n\n# 方法一 （线性搜索） 【超时】\n思路将每个元素与它之前的 kkk 个元素中比较查看它们是否相等。\n\n算法\n\n这个算法维护了一个 kkk 大小的滑动窗口，然后在这个窗口里面搜索是否存在跟当前元素相等的元素。\n\npublic boolean containsNearbyDuplicate(int[] nums, int k) {\n    for (int i = 0; i < nums.length; ++i) {\n        for (int j = Math.max(i - k, 0); j < i; ++j) {\n            if (nums[i] == nums[j]) return true;\n        }\n    }\n    return false;\n}\n// Time Limit Exceeded.\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n时间复杂度分析\n\n * 时间复杂度：O(nmin⁡(k,n))O(n \\min(k,n))O(nmin(k,n))每次搜索都要花费 O(min⁡(k,n))O(\\min(k, n))O(min(k,n)) 的时间，哪怕kkk比nnn大，一次搜索中也只需比较 nnn 次。\n   \n   \n * 空间复杂度：O(1)O(1)O(1)\n   \n   \n\n# 方法二 （二叉搜索树） 【超时】\n思路\n\n通过自平衡二叉搜索树来维护一个 kkk 大小的滑动窗口。\n\n算法\n\n这个方法的核心在于降低方法一中搜索前 kkk 个元素所耗费的时间。可以想一下，我们能不能用一个更复杂的数据结构来维持这个 kkk 大小的滑动窗口内元素的有序性呢？考虑到滑动窗口内元素是严格遵守先进先出的，那么队列会是一个非常自然就能想到的数据结构。链表实现的队列可以支持在常数时间内的 删除，插入，然而 搜索 耗费的时间却是线性的，所以如果用队列来实现的话结果并不会比方法一更好。\n\n一个更好的选择是使用自平衡二叉搜索树（BST)。 BST 中搜索，删除，插入都可以保持 O(log⁡k)O(\\log k)O(logk) 的时间复杂度，其中 kkk 是 BST 中元素的个数。在大部分面试中你都不需要自己去实现一个 BST，所以把 BST 当成一个黑盒子就可以了。大部分的编程语言都会在标准库里面提供这些常见的数据结构。在 Java 里面，你可以用 TreeSet 或者是 TreeMap。在 C++ STL 里面，你可以用 std::set 或者是 std::map。\n\n假设你已经有了这样一个数据结构，伪代码是这样的：\n\n * 遍历数组，对于每个元素做以下操作： * 在 BST 中搜索当前元素，如果找到了就返回 true。\n    * 在 BST 中插入当前元素。\n    * 如果当前 BST 的大小超过了 kkk，删除当前 BST 中最旧的元素。\n   \n   \n * 返回 false。\n\npublic boolean containsNearbyDuplicate(int[] nums, int k) {\n    Set<Integer> set = new TreeSet<>();\n    for (int i = 0; i < nums.length; ++i) {\n        if (set.contains(nums[i])) return true;\n        set.add(nums[i]);\n        if (set.size() > k) {\n            set.remove(nums[i - k]);\n        }\n    }\n    return false;\n}\n// Time Limit Exceeded.\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n复杂度分析\n\n * 时间复杂度：O(nlog⁡(min⁡(k,n)))O(n \\log (\\min(k,n)))O(nlog(min(k,n)))我们会做 nnn 次 搜索，删除，插入 操作。每次操作将耗费对数时间，即为 log⁡(min⁡(k,n))\\log (\\min(k, n))log(min(k,n))。注意，虽然 kkk 可以比 nnn 大，但滑动窗口大小不会超过 nnn。\n   \n   \n * 空间复杂度：O(min⁡(n,k))O(\\min(n,k))O(min(n,k))只有滑动窗口需要开辟额外的空间，而滑动窗口的大小不会超过 O(min⁡(n,k))O(\\min(n,k))O(min(n,k))。\n   \n   \n\n注意事项\n\n这个算法在 nnn 和 kkk 很大的时候依旧会超时。\n\n# 方法三 （散列表） 【通过】\n思路\n\n用散列表来维护这个kkk大小的滑动窗口。\n\n算法\n\n在之前的方法中，我们知道了对数时间复杂度的 搜索 操作是不够的。在这个方法里面，我们需要一个支持在常量时间内完成 搜索，删除，插入 操作的数据结构，那就是散列表。这个算法的实现跟方法二几乎是一样的。\n\n * 遍历数组，对于每个元素做以下操作： * 在散列表中搜索当前元素，如果找到了就返回 true。\n    * 在散列表中插入当前元素。\n    * 如果当前散列表的大小超过了 kkk， 删除散列表中最旧的元素。\n   \n   \n * 返回 false。\n\npublic boolean containsNearbyDuplicate(int[] nums, int k) {\n    Set<Integer> set = new HashSet<>();\n    for (int i = 0; i < nums.length; ++i) {\n        if (set.contains(nums[i])) return true;\n        set.add(nums[i]);\n        if (set.size() > k) {\n            set.remove(nums[i - k]);\n        }\n    }\n    return false;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n复杂度分析\n\n * 时间复杂度：O(n)O(n)O(n)我们会做 nnn 次 搜索，删除，插入 操作，每次操作都耗费常数时间。\n   \n   \n * 空间复杂度：O(min⁡(n,k))O(\\min(n, k))O(min(n,k))开辟的额外空间取决于散列表中存储的元素的个数，也就是滑动窗口的大小 O(min⁡(n,k))O(\\min(n,k))O(min(n,k))。\n   \n   \n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-06-24 23:41:26Accepted [https://leetcode-cn.com//submissions/detail/3474542/]20 ms36.68%N/Ajava2018-06-24 23:34:41Time Limit Exceeded [https://leetcode-cn.com//submissions/detail/3474434/]N/AN/AN/Ajava2018-06-24 23:33:36Time Limit Exceeded [https://leetcode-cn.com//submissions/detail/3474423/]N/AN/AN/Ajava# 统计信息\n通过次数提交次数AC比率308218312537.1%# 相似题目\n题目难度存在重复元素 [https://leetcode-cn.com/problems/contains-duplicate/]简单存在重复元素 III [https://leetcode-cn.com/problems/contains-duplicate-iii/]中等",contentLowercase:"# 中文题目\n给定一个整数数组和一个整数k，判断数组中是否存在两个不同的索引i和j，使得nums [i] = nums [j]，并且 i 和 j的差的绝对值最大为 k。\n\n示例 1:\n\n输入: nums = [1,2,3,1], k = 3\n输出: true\n\n示例 2:\n\n输入: nums = [1,0,1,1], k = 1\n输出: true\n\n示例 3:\n\n输入: nums = [1,2,3,1,2,3], k = 2\n输出: false\n\n# 通过代码\nimport java.util.hashset;\nimport java.util.set;\nclass solution {\n    public boolean containsnearbyduplicate(int[] nums, int k) {\n        set<integer> set=new hashset<>();\n            for (int i = 0; i < nums.length; i++) {\n                if (i>k)set.remove(nums[i-k-1]);\n                if (!set.add(nums[i])) return true;\n            }\n            return false;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n# 官方题解\n# 概述\n这篇文章是为初级读者准备的，文章中会介绍了以下几种方法和数据结构： 线性搜索，二分搜索和散列表。\n\n# 方法一 （线性搜索） 【超时】\n思路将每个元素与它之前的 kkk 个元素中比较查看它们是否相等。\n\n算法\n\n这个算法维护了一个 kkk 大小的滑动窗口，然后在这个窗口里面搜索是否存在跟当前元素相等的元素。\n\npublic boolean containsnearbyduplicate(int[] nums, int k) {\n    for (int i = 0; i < nums.length; ++i) {\n        for (int j = math.max(i - k, 0); j < i; ++j) {\n            if (nums[i] == nums[j]) return true;\n        }\n    }\n    return false;\n}\n// time limit exceeded.\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n时间复杂度分析\n\n * 时间复杂度：o(nmin⁡(k,n))o(n \\min(k,n))o(nmin(k,n))每次搜索都要花费 o(min⁡(k,n))o(\\min(k, n))o(min(k,n)) 的时间，哪怕kkk比nnn大，一次搜索中也只需比较 nnn 次。\n   \n   \n * 空间复杂度：o(1)o(1)o(1)\n   \n   \n\n# 方法二 （二叉搜索树） 【超时】\n思路\n\n通过自平衡二叉搜索树来维护一个 kkk 大小的滑动窗口。\n\n算法\n\n这个方法的核心在于降低方法一中搜索前 kkk 个元素所耗费的时间。可以想一下，我们能不能用一个更复杂的数据结构来维持这个 kkk 大小的滑动窗口内元素的有序性呢？考虑到滑动窗口内元素是严格遵守先进先出的，那么队列会是一个非常自然就能想到的数据结构。链表实现的队列可以支持在常数时间内的 删除，插入，然而 搜索 耗费的时间却是线性的，所以如果用队列来实现的话结果并不会比方法一更好。\n\n一个更好的选择是使用自平衡二叉搜索树（bst)。 bst 中搜索，删除，插入都可以保持 o(log⁡k)o(\\log k)o(logk) 的时间复杂度，其中 kkk 是 bst 中元素的个数。在大部分面试中你都不需要自己去实现一个 bst，所以把 bst 当成一个黑盒子就可以了。大部分的编程语言都会在标准库里面提供这些常见的数据结构。在 java 里面，你可以用 treeset 或者是 treemap。在 c++ stl 里面，你可以用 std::set 或者是 std::map。\n\n假设你已经有了这样一个数据结构，伪代码是这样的：\n\n * 遍历数组，对于每个元素做以下操作： * 在 bst 中搜索当前元素，如果找到了就返回 true。\n    * 在 bst 中插入当前元素。\n    * 如果当前 bst 的大小超过了 kkk，删除当前 bst 中最旧的元素。\n   \n   \n * 返回 false。\n\npublic boolean containsnearbyduplicate(int[] nums, int k) {\n    set<integer> set = new treeset<>();\n    for (int i = 0; i < nums.length; ++i) {\n        if (set.contains(nums[i])) return true;\n        set.add(nums[i]);\n        if (set.size() > k) {\n            set.remove(nums[i - k]);\n        }\n    }\n    return false;\n}\n// time limit exceeded.\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n复杂度分析\n\n * 时间复杂度：o(nlog⁡(min⁡(k,n)))o(n \\log (\\min(k,n)))o(nlog(min(k,n)))我们会做 nnn 次 搜索，删除，插入 操作。每次操作将耗费对数时间，即为 log⁡(min⁡(k,n))\\log (\\min(k, n))log(min(k,n))。注意，虽然 kkk 可以比 nnn 大，但滑动窗口大小不会超过 nnn。\n   \n   \n * 空间复杂度：o(min⁡(n,k))o(\\min(n,k))o(min(n,k))只有滑动窗口需要开辟额外的空间，而滑动窗口的大小不会超过 o(min⁡(n,k))o(\\min(n,k))o(min(n,k))。\n   \n   \n\n注意事项\n\n这个算法在 nnn 和 kkk 很大的时候依旧会超时。\n\n# 方法三 （散列表） 【通过】\n思路\n\n用散列表来维护这个kkk大小的滑动窗口。\n\n算法\n\n在之前的方法中，我们知道了对数时间复杂度的 搜索 操作是不够的。在这个方法里面，我们需要一个支持在常量时间内完成 搜索，删除，插入 操作的数据结构，那就是散列表。这个算法的实现跟方法二几乎是一样的。\n\n * 遍历数组，对于每个元素做以下操作： * 在散列表中搜索当前元素，如果找到了就返回 true。\n    * 在散列表中插入当前元素。\n    * 如果当前散列表的大小超过了 kkk， 删除散列表中最旧的元素。\n   \n   \n * 返回 false。\n\npublic boolean containsnearbyduplicate(int[] nums, int k) {\n    set<integer> set = new hashset<>();\n    for (int i = 0; i < nums.length; ++i) {\n        if (set.contains(nums[i])) return true;\n        set.add(nums[i]);\n        if (set.size() > k) {\n            set.remove(nums[i - k]);\n        }\n    }\n    return false;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n复杂度分析\n\n * 时间复杂度：o(n)o(n)o(n)我们会做 nnn 次 搜索，删除，插入 操作，每次操作都耗费常数时间。\n   \n   \n * 空间复杂度：o(min⁡(n,k))o(\\min(n, k))o(min(n,k))开辟的额外空间取决于散列表中存储的元素的个数，也就是滑动窗口的大小 o(min⁡(n,k))o(\\min(n,k))o(min(n,k))。\n   \n   \n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-06-24 23:41:26accepted [https://leetcode-cn.com//submissions/detail/3474542/]20 ms36.68%n/ajava2018-06-24 23:34:41time limit exceeded [https://leetcode-cn.com//submissions/detail/3474434/]n/an/an/ajava2018-06-24 23:33:36time limit exceeded [https://leetcode-cn.com//submissions/detail/3474423/]n/an/an/ajava# 统计信息\n通过次数提交次数ac比率308218312537.1%# 相似题目\n题目难度存在重复元素 [https://leetcode-cn.com/problems/contains-duplicate/]简单存在重复元素 iii [https://leetcode-cn.com/problems/contains-duplicate-iii/]中等"},{title:"226-翻转二叉树(Invert Binary Tree)",frontmatter:{title:"226-翻转二叉树(Invert Binary Tree)",date:"2018-05-11T00:00:00.000Z",categories:["简单"],tags:["树<Tree>"]},regularPath:"/views/%E7%AE%80%E5%8D%95/0226-%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91.html",relativePath:"views/简单/0226-翻转二叉树.md",key:"v-6a1a8aca",path:"/views/%E7%AE%80%E5%8D%95/0226-%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91.html",headers:[{level:2,title:"中文题目",slug:"中文题目",charIndex:2},{level:2,title:"通过代码",slug:"通过代码",charIndex:314},{level:2,title:"官方题解",slug:"官方题解",charIndex:945},{level:2,title:"提交历史",slug:"提交历史",charIndex:2610},{level:2,title:"统计信息",slug:"统计信息",charIndex:2738}],lastUpdated:"4/11/2021, 1:15:21 PM",headersStr:"中文题目 通过代码 官方题解 提交历史 统计信息",content:"# 中文题目\n翻转一棵二叉树。\n\n示例：\n\n输入：\n\n     4\n   /   \\\n  2     7\n / \\   / \\\n1   3 6   9\n\n输出：\n\n     4\n   /   \\\n  7     2\n / \\   / \\\n9   6 3   1\n\n备注:\n这个问题是受到 Max Howell [https://twitter.com/mxcl]的 原问题 [https://twitter.com/mxcl/status/608682016205344768] 启发的 ：\n\n> 谷歌：我们90％的工程师使用您编写的软件(Homebrew)，但是您却无法在面试时在白板上写出翻转二叉树这道题，这太糟糕了。\n# 通过代码\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public TreeNode invertTree(TreeNode root) {\n        if (root == null) {\n                return null;\n            } else {\n                TreeNode temp = root.left;\n                root.left = root.right;\n                root.right = temp;\n                invertTree(root.left);\n                invertTree(root.right);\n                return root;\n            }\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n# 官方题解\n# 方法一 （递归） 【通过】\n这是一个非常经典的树的问题，这个问题很适合用递归方法来解决。\n\n算法\n\n反转一颗空树结果还是一颗空树。对于一颗根为 rrr，左子树为 \\mbox{right}， 右子树为 \\mbox{left} 的树来说，它的反转树是一颗根为 rrr，左子树为 \\mbox{right} 的反转树，右子树为 \\mbox{left} 的反转树的树。\n\npublic TreeNode invertTree(TreeNode root) {\n    if (root == null) {\n        return null;\n    }\n    TreeNode right = invertTree(root.right);\n    TreeNode left = invertTree(root.left);\n    root.left = right;\n    root.right = left;\n    return root;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n复杂度分析\n\n既然树中的每个节点都只被访问一次，那么时间复杂度就是 O(n)O(n)O(n)，其中 nnn 是树中节点的个数。在反转之前，不论怎样我们至少都得访问每个节点至少一次，因此这个问题无法做地比 O(n)O(n)O(n) 更好了。\n\n本方法使用了递归，在最坏情况下栈内需要存放 O(h)O(h)O(h) 个方法调用，其中 hhh 是树的高度。由于 h∈O(n)h\\in O(n)h∈O(n)，可得出空间复杂度为 O(n)O(n)O(n)。\n\n# 方法二 （迭代） 【通过】\n我们也可以用迭代方法来解决这个问题，这种做法和深度优先搜索（Breadth-fist Search, BFS）很接近。\n\n算法\n\n这个方法的思路就是，我们需要交换树中所有节点的左孩子和右孩子。因此可以创一个队列来存储所有左孩子和右孩子还没有被交换过的节点。开始的时候，只有根节点在这个队列里面。只要这个队列不空，就一直从队列中出队节点，然后互换这个节点的左右孩子节点，接着再把孩子节点入队到队列，对于其中的空节点不需要加入队列。最终队列一定会空，这时候所有节点的孩子节点都被互换过了，直接返回最初的根节点就可以了。\n\npublic TreeNode invertTree(TreeNode root) {\n    if (root == null) return null;\n    Queue<TreeNode> queue = new LinkedList<TreeNode>();\n    queue.add(root);\n    while (!queue.isEmpty()) {\n        TreeNode current = queue.poll();\n        TreeNode temp = current.left;\n        current.left = current.right;\n        current.right = temp;\n        if (current.left != null) queue.add(current.left);\n        if (current.right != null) queue.add(current.right);\n    }\n    return root;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n复杂度分析\n\n既然树中的每个节点都只被访问/入队一次，时间复杂度就是 O(n)O(n)O(n)，其中 nnn 是树中节点的个数。\n\n空间复杂度是 O(n)O(n)O(n)，即使在最坏的情况下，也就是队列里包含了树中所有的节点。对于一颗完整二叉树来说，叶子节点那一层拥有 ⌈n2⌉=O(n)\\lceil \\frac{n}{2}\\rceil=O(n)⌈2n​⌉=O(n) 个节点。\n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-05-11 18:04:12Accepted [https://leetcode-cn.com//submissions/detail/2180140/]0 ms100.0%N/Ajava# 统计信息\n通过次数提交次数AC比率472886454973.3%",contentLowercase:"# 中文题目\n翻转一棵二叉树。\n\n示例：\n\n输入：\n\n     4\n   /   \\\n  2     7\n / \\   / \\\n1   3 6   9\n\n输出：\n\n     4\n   /   \\\n  7     2\n / \\   / \\\n9   6 3   1\n\n备注:\n这个问题是受到 max howell [https://twitter.com/mxcl]的 原问题 [https://twitter.com/mxcl/status/608682016205344768] 启发的 ：\n\n> 谷歌：我们90％的工程师使用您编写的软件(homebrew)，但是您却无法在面试时在白板上写出翻转二叉树这道题，这太糟糕了。\n# 通过代码\n/**\n * definition for a binary tree node.\n * public class treenode {\n *     int val;\n *     treenode left;\n *     treenode right;\n *     treenode(int x) { val = x; }\n * }\n */\nclass solution {\n    public treenode inverttree(treenode root) {\n        if (root == null) {\n                return null;\n            } else {\n                treenode temp = root.left;\n                root.left = root.right;\n                root.right = temp;\n                inverttree(root.left);\n                inverttree(root.right);\n                return root;\n            }\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n# 官方题解\n# 方法一 （递归） 【通过】\n这是一个非常经典的树的问题，这个问题很适合用递归方法来解决。\n\n算法\n\n反转一颗空树结果还是一颗空树。对于一颗根为 rrr，左子树为 \\mbox{right}， 右子树为 \\mbox{left} 的树来说，它的反转树是一颗根为 rrr，左子树为 \\mbox{right} 的反转树，右子树为 \\mbox{left} 的反转树的树。\n\npublic treenode inverttree(treenode root) {\n    if (root == null) {\n        return null;\n    }\n    treenode right = inverttree(root.right);\n    treenode left = inverttree(root.left);\n    root.left = right;\n    root.right = left;\n    return root;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n复杂度分析\n\n既然树中的每个节点都只被访问一次，那么时间复杂度就是 o(n)o(n)o(n)，其中 nnn 是树中节点的个数。在反转之前，不论怎样我们至少都得访问每个节点至少一次，因此这个问题无法做地比 o(n)o(n)o(n) 更好了。\n\n本方法使用了递归，在最坏情况下栈内需要存放 o(h)o(h)o(h) 个方法调用，其中 hhh 是树的高度。由于 h∈o(n)h\\in o(n)h∈o(n)，可得出空间复杂度为 o(n)o(n)o(n)。\n\n# 方法二 （迭代） 【通过】\n我们也可以用迭代方法来解决这个问题，这种做法和深度优先搜索（breadth-fist search, bfs）很接近。\n\n算法\n\n这个方法的思路就是，我们需要交换树中所有节点的左孩子和右孩子。因此可以创一个队列来存储所有左孩子和右孩子还没有被交换过的节点。开始的时候，只有根节点在这个队列里面。只要这个队列不空，就一直从队列中出队节点，然后互换这个节点的左右孩子节点，接着再把孩子节点入队到队列，对于其中的空节点不需要加入队列。最终队列一定会空，这时候所有节点的孩子节点都被互换过了，直接返回最初的根节点就可以了。\n\npublic treenode inverttree(treenode root) {\n    if (root == null) return null;\n    queue<treenode> queue = new linkedlist<treenode>();\n    queue.add(root);\n    while (!queue.isempty()) {\n        treenode current = queue.poll();\n        treenode temp = current.left;\n        current.left = current.right;\n        current.right = temp;\n        if (current.left != null) queue.add(current.left);\n        if (current.right != null) queue.add(current.right);\n    }\n    return root;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n复杂度分析\n\n既然树中的每个节点都只被访问/入队一次，时间复杂度就是 o(n)o(n)o(n)，其中 nnn 是树中节点的个数。\n\n空间复杂度是 o(n)o(n)o(n)，即使在最坏的情况下，也就是队列里包含了树中所有的节点。对于一颗完整二叉树来说，叶子节点那一层拥有 ⌈n2⌉=o(n)\\lceil \\frac{n}{2}\\rceil=o(n)⌈2n​⌉=o(n) 个节点。\n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-05-11 18:04:12accepted [https://leetcode-cn.com//submissions/detail/2180140/]0 ms100.0%n/ajava# 统计信息\n通过次数提交次数ac比率472886454973.3%"},{title:"217-存在重复元素(Contains Duplicate)",frontmatter:{title:"217-存在重复元素(Contains Duplicate)",date:"2018-06-24T00:00:00.000Z",categories:["简单"],tags:["数组<Array>","哈希表<Hash Table>"]},regularPath:"/views/%E7%AE%80%E5%8D%95/0217-%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0.html",relativePath:"views/简单/0217-存在重复元素.md",key:"v-3febb966",path:"/views/%E7%AE%80%E5%8D%95/0217-%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0.html",headers:[{level:2,title:"中文题目",slug:"中文题目",charIndex:2},{level:2,title:"通过代码",slug:"通过代码",charIndex:189},{level:2,title:"官方题解",slug:"官方题解",charIndex:574},{level:2,title:"参考",slug:"参考",charIndex:3386},{level:2,title:"提交历史",slug:"提交历史",charIndex:3544},{level:2,title:"统计信息",slug:"统计信息",charIndex:3673},{level:2,title:"相似题目",slug:"相似题目",charIndex:3709}],lastUpdated:"4/11/2021, 1:15:21 PM",headersStr:"中文题目 通过代码 官方题解 参考 提交历史 统计信息 相似题目",content:"# 中文题目\n给定一个整数数组，判断是否存在重复元素。\n\n如果任何值在数组中出现至少两次，函数返回 true。如果数组中每个元素都不相同，则返回 false。\n\n示例 1:\n\n输入: [1,2,3,1]\n输出: true\n\n示例 2:\n\n输入: [1,2,3,4]\n输出: false\n\n示例 3:\n\n输入: [1,1,1,3,3,4,3,2,4,2]\n输出: true\n\n# 通过代码\nimport java.util.HashSet;\nimport java.util.Set;\nclass Solution {\n    public boolean containsDuplicate(int[] nums) {\n         Set<Integer> set=new HashSet<>();\n            for (int i = 0; i < nums.length; i++) {\n                if (!set.add(nums[i])){\n                    return true;\n                }\n            }\n            return false;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n# 官方题解\n本文面向初学者，介绍了以下概念：循环不变式, 线性查找，排序和哈希表。\n\n# 方法一：朴素线性查找 【超时】\n直觉\n\n对于一个有 nnn 个整数的数组，一共有 C(n,2)=n(n+1)2C(n,2) = \\frac{n(n+1)}{2}C(n,2)=2n(n+1)​ 对整数。因此，我们可以对所有的 n(n+1)2\\frac{n(n+1)}{2}2n(n+1)​ 对进行检测，看它们是否相同。\n\n算法\n\n为了实现这个思路，我们使用线性查找算法，这是最简单的查找算法。线性查找是一种检查特定值是否在列表中的算法，做法是依次逐个检查列表中的元素，直到找到满足的元素。\n\n对于本问题，我们循环遍历全部 nnn 个数。对于第 iii 个整数 nums[i]，我们对前 i-1 个整数查找 nums[i] 的重复值。若找到，则返回 True; 否则继续。在程序最后，返回 False。\n\n为了证明算法的正确性，我们定义了循环不变式。循环不变式是指在每次迭代前和后均保持不变的性质。了解循环不变式对理解循环的意义十分重要。下面就是循环不变式:\n\n> 在下一次搜索之前,搜索过的整数中没有重复的整数。\n\n\n循环不变式在循环之前为真，因为还没有搜索过的整数。每次循环，我们查找当前元素的任何可能重复。如果发现重复项,则函数返回 True 退出；如果没有发现，则不变式仍然成立。\n\n因此，如果循环结束，循环不变式说明全部 nnn 个整数中不存在重复元素。\n\npublic boolean containsDuplicate(int[] nums) {\n    for (int i = 0; i < nums.length; ++i) {\n        for (int j = 0; j < i; ++j) {\n            if (nums[j] == nums[i]) return true;  \n        }\n    }\n    return false;\n}\n// Time Limit Exceeded\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n复杂度分析\n\n * 时间复杂度 : O(n2)O(n^2)O(n2)。最坏的情况下，需要检查 n(n+1)2\\frac{n(n+1)}{2}2n(n+1)​ 对整数。因此，时间复杂度为 O(n2)O(n^2)O(n2)。\n   \n   \n * 空间复杂度 : O(1)O(1)O(1)。只使用了常数额外空间。\n   \n   \n\n注意\n\n本方法在 Leetcode 上会超时。一般而言，如果一个算法的时间复杂度为 O(n2)O(n^2)O(n2)，它最多能处理 nnn 大约为 10410^4104 的数据。当 nnn 接近 10510^5105 时就会超时。\n\n\n\n\n# 方法二：排序 【通过】\n直觉\n\n如果存在重复元素，排序后它们应该相邻。\n\n算法\n\n本方法使用排序算法。由于比较排序算法，如堆排序，可以在最坏情况下具有 O(nlog⁡n)O(n \\log n)O(nlogn) 的时间复杂度。因此，排序经常是很好的预处理方法。排序之后，我们可以扫描已排序的数组,以查找是否有任何连续的重复元素。\n\npublic boolean containsDuplicate(int[] nums) {\n    Arrays.sort(nums);\n    for (int i = 0; i < nums.length - 1; ++i) {\n        if (nums[i] == nums[i + 1]) return true;\n    }\n    return false;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n复杂度分析\n\n * 时间复杂度 : O(nlog⁡n)O(n \\log n)O(nlogn)。 排序的复杂度是 O(nlog⁡n)O(n \\log n)O(nlogn)，扫描的复杂度是 O(n)O(n)O(n)。整个算法主要由排序过程决定，因此是 O(nlog⁡n)O(n \\log n)O(nlogn)。\n   \n   \n * 空间复杂度 : O(1)O(1)O(1)。 这取决于具体的排序算法实现，通常而言，使用 堆排序 的话，是 O(1)O(1)O(1)。\n   \n   \n\n注意\n\n此处的算法实现对原始数组进行排序，修改了原始数组。通常，除非调用方清楚输入数据将被修改，否则不应该随意修改输入数据。可以先复制 nums，然后对副本进行操作。\n\n\n\n\n# 方法三：哈希表 【通过】\n直觉\n\n利用支持快速搜索和插入操作的动态数据结构。\n\n算法\n\n从方法一中我们知道，对无序数组的查找操作的时间复杂度为 O(n)O(n)O(n)，而我们会重复调用查找操作。因此，使用搜索时间更快的数据结构将加快整个算法的速度。\n\n有许多数据结构常用作动态集合,如二进制搜索树和哈希表。这里我们需要的操作是 search 和 insert。对于平衡二叉搜索树（Java 中的 TreeSet 或 TreeMap），search 和 insert 的时间复杂度均为 O(log⁡n)O(\\log n)O(logn)。对于哈希表（Java 中的 HashSet 或 HashMap），search 和 insert 的平均时间复杂度为 O(1)O(1)O(1)。因此，通过使用哈希表，我们可以达到在线性时间复杂度解决问题。\n\npublic boolean containsDuplicate(int[] nums) {\n    Set<Integer> set = new HashSet<>(nums.length);\n    for (int x: nums) {\n        if (set.contains(x)) return true;\n        set.add(x);\n    }\n    return false;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n复杂度分析\n\n * 时间复杂度 : O(n)O(n)O(n)。search() 和 insert() 各自使用 nnn 次，每个操作耗费常数时间。\n   \n   \n * 空间复杂度 : O(n)O(n)O(n)。哈希表占用的空间与元素数量是线性关系。\n   \n   \n\n注意\n\n对于一些特定的 nnn 不太大的测试样例，本方法的运行速度可能会比方法二更慢。这是因为哈希表在维护其属性时有一些开销。要注意，程序的实际运行表现和 Big-O 符号表示可能有所不同。Big-O 只是告诉我们在 充分 大的输入下，算法的相对快慢。因此，在 nnn 不够大的情况下， O(n)O(n)O(n) 的算法也可以比 O(nlog⁡n)O(n \\log n)O(nlogn)的更慢。\n\n# 参考\n * 219 存在重复元素 II [https://leetcode-cn.com/problems/contains-duplicate-ii/]\n * 220 存在重复元素 III [https://leetcode-cn.com/problems/contains-duplicate-iii/]\n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-06-24 23:48:52Accepted [https://leetcode-cn.com//submissions/detail/3474679/]13 ms57.39%N/Ajava# 统计信息\n通过次数提交次数AC比率10246019969651.3%# 相似题目\n题目难度存在重复元素 II [https://leetcode-cn.com/problems/contains-duplicate-ii/]简单存在重复元素 III [https://leetcode-cn.com/problems/contains-duplicate-iii/]中等",contentLowercase:"# 中文题目\n给定一个整数数组，判断是否存在重复元素。\n\n如果任何值在数组中出现至少两次，函数返回 true。如果数组中每个元素都不相同，则返回 false。\n\n示例 1:\n\n输入: [1,2,3,1]\n输出: true\n\n示例 2:\n\n输入: [1,2,3,4]\n输出: false\n\n示例 3:\n\n输入: [1,1,1,3,3,4,3,2,4,2]\n输出: true\n\n# 通过代码\nimport java.util.hashset;\nimport java.util.set;\nclass solution {\n    public boolean containsduplicate(int[] nums) {\n         set<integer> set=new hashset<>();\n            for (int i = 0; i < nums.length; i++) {\n                if (!set.add(nums[i])){\n                    return true;\n                }\n            }\n            return false;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n# 官方题解\n本文面向初学者，介绍了以下概念：循环不变式, 线性查找，排序和哈希表。\n\n# 方法一：朴素线性查找 【超时】\n直觉\n\n对于一个有 nnn 个整数的数组，一共有 c(n,2)=n(n+1)2c(n,2) = \\frac{n(n+1)}{2}c(n,2)=2n(n+1)​ 对整数。因此，我们可以对所有的 n(n+1)2\\frac{n(n+1)}{2}2n(n+1)​ 对进行检测，看它们是否相同。\n\n算法\n\n为了实现这个思路，我们使用线性查找算法，这是最简单的查找算法。线性查找是一种检查特定值是否在列表中的算法，做法是依次逐个检查列表中的元素，直到找到满足的元素。\n\n对于本问题，我们循环遍历全部 nnn 个数。对于第 iii 个整数 nums[i]，我们对前 i-1 个整数查找 nums[i] 的重复值。若找到，则返回 true; 否则继续。在程序最后，返回 false。\n\n为了证明算法的正确性，我们定义了循环不变式。循环不变式是指在每次迭代前和后均保持不变的性质。了解循环不变式对理解循环的意义十分重要。下面就是循环不变式:\n\n> 在下一次搜索之前,搜索过的整数中没有重复的整数。\n\n\n循环不变式在循环之前为真，因为还没有搜索过的整数。每次循环，我们查找当前元素的任何可能重复。如果发现重复项,则函数返回 true 退出；如果没有发现，则不变式仍然成立。\n\n因此，如果循环结束，循环不变式说明全部 nnn 个整数中不存在重复元素。\n\npublic boolean containsduplicate(int[] nums) {\n    for (int i = 0; i < nums.length; ++i) {\n        for (int j = 0; j < i; ++j) {\n            if (nums[j] == nums[i]) return true;  \n        }\n    }\n    return false;\n}\n// time limit exceeded\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n复杂度分析\n\n * 时间复杂度 : o(n2)o(n^2)o(n2)。最坏的情况下，需要检查 n(n+1)2\\frac{n(n+1)}{2}2n(n+1)​ 对整数。因此，时间复杂度为 o(n2)o(n^2)o(n2)。\n   \n   \n * 空间复杂度 : o(1)o(1)o(1)。只使用了常数额外空间。\n   \n   \n\n注意\n\n本方法在 leetcode 上会超时。一般而言，如果一个算法的时间复杂度为 o(n2)o(n^2)o(n2)，它最多能处理 nnn 大约为 10410^4104 的数据。当 nnn 接近 10510^5105 时就会超时。\n\n\n\n\n# 方法二：排序 【通过】\n直觉\n\n如果存在重复元素，排序后它们应该相邻。\n\n算法\n\n本方法使用排序算法。由于比较排序算法，如堆排序，可以在最坏情况下具有 o(nlog⁡n)o(n \\log n)o(nlogn) 的时间复杂度。因此，排序经常是很好的预处理方法。排序之后，我们可以扫描已排序的数组,以查找是否有任何连续的重复元素。\n\npublic boolean containsduplicate(int[] nums) {\n    arrays.sort(nums);\n    for (int i = 0; i < nums.length - 1; ++i) {\n        if (nums[i] == nums[i + 1]) return true;\n    }\n    return false;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n复杂度分析\n\n * 时间复杂度 : o(nlog⁡n)o(n \\log n)o(nlogn)。 排序的复杂度是 o(nlog⁡n)o(n \\log n)o(nlogn)，扫描的复杂度是 o(n)o(n)o(n)。整个算法主要由排序过程决定，因此是 o(nlog⁡n)o(n \\log n)o(nlogn)。\n   \n   \n * 空间复杂度 : o(1)o(1)o(1)。 这取决于具体的排序算法实现，通常而言，使用 堆排序 的话，是 o(1)o(1)o(1)。\n   \n   \n\n注意\n\n此处的算法实现对原始数组进行排序，修改了原始数组。通常，除非调用方清楚输入数据将被修改，否则不应该随意修改输入数据。可以先复制 nums，然后对副本进行操作。\n\n\n\n\n# 方法三：哈希表 【通过】\n直觉\n\n利用支持快速搜索和插入操作的动态数据结构。\n\n算法\n\n从方法一中我们知道，对无序数组的查找操作的时间复杂度为 o(n)o(n)o(n)，而我们会重复调用查找操作。因此，使用搜索时间更快的数据结构将加快整个算法的速度。\n\n有许多数据结构常用作动态集合,如二进制搜索树和哈希表。这里我们需要的操作是 search 和 insert。对于平衡二叉搜索树（java 中的 treeset 或 treemap），search 和 insert 的时间复杂度均为 o(log⁡n)o(\\log n)o(logn)。对于哈希表（java 中的 hashset 或 hashmap），search 和 insert 的平均时间复杂度为 o(1)o(1)o(1)。因此，通过使用哈希表，我们可以达到在线性时间复杂度解决问题。\n\npublic boolean containsduplicate(int[] nums) {\n    set<integer> set = new hashset<>(nums.length);\n    for (int x: nums) {\n        if (set.contains(x)) return true;\n        set.add(x);\n    }\n    return false;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n复杂度分析\n\n * 时间复杂度 : o(n)o(n)o(n)。search() 和 insert() 各自使用 nnn 次，每个操作耗费常数时间。\n   \n   \n * 空间复杂度 : o(n)o(n)o(n)。哈希表占用的空间与元素数量是线性关系。\n   \n   \n\n注意\n\n对于一些特定的 nnn 不太大的测试样例，本方法的运行速度可能会比方法二更慢。这是因为哈希表在维护其属性时有一些开销。要注意，程序的实际运行表现和 big-o 符号表示可能有所不同。big-o 只是告诉我们在 充分 大的输入下，算法的相对快慢。因此，在 nnn 不够大的情况下， o(n)o(n)o(n) 的算法也可以比 o(nlog⁡n)o(n \\log n)o(nlogn)的更慢。\n\n# 参考\n * 219 存在重复元素 ii [https://leetcode-cn.com/problems/contains-duplicate-ii/]\n * 220 存在重复元素 iii [https://leetcode-cn.com/problems/contains-duplicate-iii/]\n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-06-24 23:48:52accepted [https://leetcode-cn.com//submissions/detail/3474679/]13 ms57.39%n/ajava# 统计信息\n通过次数提交次数ac比率10246019969651.3%# 相似题目\n题目难度存在重复元素 ii [https://leetcode-cn.com/problems/contains-duplicate-ii/]简单存在重复元素 iii [https://leetcode-cn.com/problems/contains-duplicate-iii/]中等"},{title:"235-二叉搜索树的最近公共祖先(Lowest Common Ancestor of a Binary Search Tree)",frontmatter:{title:"235-二叉搜索树的最近公共祖先(Lowest Common Ancestor of a Binary Search Tree)",date:"2018-07-17T00:00:00.000Z",categories:["简单"],tags:["树<Tree>"]},regularPath:"/views/%E7%AE%80%E5%8D%95/0235-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88.html",relativePath:"views/简单/0235-二叉搜索树的最近公共祖先.md",key:"v-eacea4c0",path:"/views/%E7%AE%80%E5%8D%95/0235-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88.html",headers:[{level:2,title:"中文题目",slug:"中文题目",charIndex:2},{level:2,title:"通过代码",slug:"通过代码",charIndex:567},{level:2,title:"官方题解",slug:"官方题解",charIndex:1221},{level:2,title:"题解",slug:"题解",charIndex:1223},{level:2,title:"提交历史",slug:"提交历史",charIndex:5903},{level:2,title:"统计信息",slug:"统计信息",charIndex:6031},{level:2,title:"相似题目",slug:"相似题目",charIndex:6065}],lastUpdated:"4/11/2021, 1:15:21 PM",headersStr:"中文题目 通过代码 官方题解 题解 提交历史 统计信息 相似题目",content:'# 中文题目\n给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。\n\n百度百科 [https://baike.baidu.com/item/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/8918834?fr=aladdin]中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”\n\n例如，给定如下二叉搜索树: root = [6,2,8,0,4,7,9,null,null,3,5]\n\n\n\n\n\n示例 1:\n\n输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8\n输出: 6 \n解释: 节点 2 和节点 8 的最近公共祖先是 6。\n\n\n示例 2:\n\n输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4\n输出: 2\n解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。\n\n\n\n说明:\n\n * 所有节点的值都是唯一的。\n * p、q 为不同节点且均存在于给定的二叉搜索树中。\n\n# 通过代码\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n        if (root==null){\n                return null;\n            }\n            if (p.val<root.val && q.val<root.val)\n                return lowestCommonAncestor(root.left,p,q);\n            if (p.val>root.val&& q.val>root.val)\n                return lowestCommonAncestor(root.right,p,q);\n            return root;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n# 官方题解\n# 题解\n我们来复习一下二叉搜索树（BST）的性质：\n\n>  1. 节点 NNN 左子树上的所有节点的值都小于等于节点 NNN 的值\n 2. 节点 NNN 右子树上的所有节点的值都大于等于节点 NNN 的值\n 3. 左子树和右子树也都是 BST\n\n\n# 方法一 （递归）\n思路\n\n节点 ppp，qqq 的最近公共祖先（LCA）是距离这两个节点最近的公共祖先节点。在这里 最近 考虑的是节点的深度。下面这张图能帮助你更好的理解 最近 这个词的含义。\n\n{:width=400} {:align=center}\n\n笔记：ppp 和 qqq 其中的一个在 LCA 节点的左子树上，另一个在 LCA 节点的右子树上。\n\n也有可能是下面这种情况：\n\n{:width=400} {:align=center}\n\n算法\n\n 1. 从根节点开始遍历树\n 2. 如果节点 ppp 和节点 qqq 都在右子树上，那么以右孩子为根节点继续 1 的操作\n 3. 如果节点 ppp 和节点 qqq 都在左子树上，那么以左孩子为根节点继续 1 的操作\n 4. 如果条件 2 和条件 3 都不成立，这就意味着我们已经找到节 ppp 和节点 qqq 的 LCA 了\n\nclass Solution {\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n\n        // Value of current node or parent node.\n        int parentVal = root.val;\n\n        // Value of p\n        int pVal = p.val;\n\n        // Value of q;\n        int qVal = q.val;\n\n        if (pVal > parentVal && qVal > parentVal) {\n            // If both p and q are greater than parent\n            return lowestCommonAncestor(root.right, p, q);\n        } else if (pVal < parentVal && qVal < parentVal) {\n            // If both p and q are lesser than parent\n            return lowestCommonAncestor(root.left, p, q);\n        } else {\n            // We have found the split point, i.e. the LCA node.\n            return root;\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\nclass Solution:\n    def lowestCommonAncestor(self, root, p, q):\n        """\n        :type root: TreeNode\n        :type p: TreeNode\n        :type q: TreeNode\n        :rtype: TreeNode\n        """\n        # Value of current node or parent node.\n        parent_val = root.val\n\n        # Value of p\n        p_val = p.val\n\n        # Value of q\n        q_val = q.val\n\n        # If both p and q are greater than parent\n        if p_val > parent_val and q_val > parent_val:    \n            return self.lowestCommonAncestor(root.right, p, q)\n        # If both p and q are lesser than parent\n        elif p_val < parent_val and q_val < parent_val:    \n            return self.lowestCommonAncestor(root.left, p, q)\n        # We have found the split point, i.e. the LCA node.\n        else:\n            return root\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n复杂度分析\n\n * 时间复杂度：O(N)O(N)O(N)其中 NNN 为 BST 中节点的个数，在最坏的情况下我们可能需要访问 BST 中所有的节点。\n   \n   \n * 空间复杂度：O(N)O(N)O(N)所需开辟的额外空间主要是递归栈产生的，之所以是 NNN 是因为 BST 的高度为 NNN。\n   \n   \n\n# 方法二 （迭代）\n算法\n\n这个方法跟方法一很接近。唯一的不同是，我们用迭代的方式替代了递归来遍历整棵树。由于我们不需要回溯来找到 LCA 节点，所以我们是完全可以不利用栈或者是递归的。实际上这个问题本身就是可以迭代的，我们只需要找到分割点就可以了。这个分割点就是能让节点 ppp 和节点 qqq 不能在同一颗子树上的那个节点，或者是节点 ppp 和节点 qqq 中的一个，这种情况下其中一个节点是另一个节点的父亲节点。\n\nclass Solution {\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n\n        // Value of p\n        int pVal = p.val;\n\n        // Value of q;\n        int qVal = q.val;\n\n        // Start from the root node of the tree\n        TreeNode node = root;\n\n        // Traverse the tree\n        while (node != null) {\n\n            // Value of ancestor/parent node.\n            int parentVal = node.val;\n\n            if (pVal > parentVal && qVal > parentVal) {\n                // If both p and q are greater than parent\n                node = node.right;\n            } else if (pVal < parentVal && qVal < parentVal) {\n                // If both p and q are lesser than parent\n                node = node.left;\n            } else {\n                // We have found the split point, i.e. the LCA node.\n                return node;\n            }\n        }\n        return null;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\nclass Solution:\n    def lowestCommonAncestor(self, root, p, q):\n        """\n        :type root: TreeNode\n        :type p: TreeNode\n        :type q: TreeNode\n        :rtype: TreeNode\n        """\n\n        # Value of p\n        p_val = p.val\n\n        # Value of q\n        q_val = q.val\n\n        # Start from the root node of the tree\n        node = root\n\n        # Traverse the tree\n        while node:\n\n            # Value of current node or parent node.\n            parent_val = node.val\n\n            if p_val > parent_val and q_val > parent_val:    \n                # If both p and q are greater than parent\n                node = node.right\n            elif p_val < parent_val and q_val < parent_val:\n                # If both p and q are lesser than parent\n                node = node.left\n            else:\n                # We have found the split point, i.e. the LCA node.\n                return node\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n复杂度分析\n\n * 时间复杂度：O(N)O(N)O(N)其中 NNN 为 BST 中节点的个数，在最坏的情况下我们可能需要遍历 BST 中所有的节点。\n   \n   \n * 空间复杂度：O(1)O(1)O(1)\n   \n   \n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-07-17 22:55:09Accepted [https://leetcode-cn.com//submissions/detail/4305218/]8 ms33.27%N/Ajava# 统计信息\n通过次数提交次数AC比率342175551961.6%# 相似题目\n题目难度二叉树的最近公共祖先 [https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/]中等最小公共区域 [https://leetcode-cn.com/problems/smallest-common-region/]中等',contentLowercase:'# 中文题目\n给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。\n\n百度百科 [https://baike.baidu.com/item/%e6%9c%80%e8%bf%91%e5%85%ac%e5%85%b1%e7%a5%96%e5%85%88/8918834?fr=aladdin]中最近公共祖先的定义为：“对于有根树 t 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”\n\n例如，给定如下二叉搜索树: root = [6,2,8,0,4,7,9,null,null,3,5]\n\n\n\n\n\n示例 1:\n\n输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8\n输出: 6 \n解释: 节点 2 和节点 8 的最近公共祖先是 6。\n\n\n示例 2:\n\n输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4\n输出: 2\n解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。\n\n\n\n说明:\n\n * 所有节点的值都是唯一的。\n * p、q 为不同节点且均存在于给定的二叉搜索树中。\n\n# 通过代码\n/**\n * definition for a binary tree node.\n * public class treenode {\n *     int val;\n *     treenode left;\n *     treenode right;\n *     treenode(int x) { val = x; }\n * }\n */\nclass solution {\n    public treenode lowestcommonancestor(treenode root, treenode p, treenode q) {\n        if (root==null){\n                return null;\n            }\n            if (p.val<root.val && q.val<root.val)\n                return lowestcommonancestor(root.left,p,q);\n            if (p.val>root.val&& q.val>root.val)\n                return lowestcommonancestor(root.right,p,q);\n            return root;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n# 官方题解\n# 题解\n我们来复习一下二叉搜索树（bst）的性质：\n\n>  1. 节点 nnn 左子树上的所有节点的值都小于等于节点 nnn 的值\n 2. 节点 nnn 右子树上的所有节点的值都大于等于节点 nnn 的值\n 3. 左子树和右子树也都是 bst\n\n\n# 方法一 （递归）\n思路\n\n节点 ppp，qqq 的最近公共祖先（lca）是距离这两个节点最近的公共祖先节点。在这里 最近 考虑的是节点的深度。下面这张图能帮助你更好的理解 最近 这个词的含义。\n\n{:width=400} {:align=center}\n\n笔记：ppp 和 qqq 其中的一个在 lca 节点的左子树上，另一个在 lca 节点的右子树上。\n\n也有可能是下面这种情况：\n\n{:width=400} {:align=center}\n\n算法\n\n 1. 从根节点开始遍历树\n 2. 如果节点 ppp 和节点 qqq 都在右子树上，那么以右孩子为根节点继续 1 的操作\n 3. 如果节点 ppp 和节点 qqq 都在左子树上，那么以左孩子为根节点继续 1 的操作\n 4. 如果条件 2 和条件 3 都不成立，这就意味着我们已经找到节 ppp 和节点 qqq 的 lca 了\n\nclass solution {\n    public treenode lowestcommonancestor(treenode root, treenode p, treenode q) {\n\n        // value of current node or parent node.\n        int parentval = root.val;\n\n        // value of p\n        int pval = p.val;\n\n        // value of q;\n        int qval = q.val;\n\n        if (pval > parentval && qval > parentval) {\n            // if both p and q are greater than parent\n            return lowestcommonancestor(root.right, p, q);\n        } else if (pval < parentval && qval < parentval) {\n            // if both p and q are lesser than parent\n            return lowestcommonancestor(root.left, p, q);\n        } else {\n            // we have found the split point, i.e. the lca node.\n            return root;\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\nclass solution:\n    def lowestcommonancestor(self, root, p, q):\n        """\n        :type root: treenode\n        :type p: treenode\n        :type q: treenode\n        :rtype: treenode\n        """\n        # value of current node or parent node.\n        parent_val = root.val\n\n        # value of p\n        p_val = p.val\n\n        # value of q\n        q_val = q.val\n\n        # if both p and q are greater than parent\n        if p_val > parent_val and q_val > parent_val:    \n            return self.lowestcommonancestor(root.right, p, q)\n        # if both p and q are lesser than parent\n        elif p_val < parent_val and q_val < parent_val:    \n            return self.lowestcommonancestor(root.left, p, q)\n        # we have found the split point, i.e. the lca node.\n        else:\n            return root\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n复杂度分析\n\n * 时间复杂度：o(n)o(n)o(n)其中 nnn 为 bst 中节点的个数，在最坏的情况下我们可能需要访问 bst 中所有的节点。\n   \n   \n * 空间复杂度：o(n)o(n)o(n)所需开辟的额外空间主要是递归栈产生的，之所以是 nnn 是因为 bst 的高度为 nnn。\n   \n   \n\n# 方法二 （迭代）\n算法\n\n这个方法跟方法一很接近。唯一的不同是，我们用迭代的方式替代了递归来遍历整棵树。由于我们不需要回溯来找到 lca 节点，所以我们是完全可以不利用栈或者是递归的。实际上这个问题本身就是可以迭代的，我们只需要找到分割点就可以了。这个分割点就是能让节点 ppp 和节点 qqq 不能在同一颗子树上的那个节点，或者是节点 ppp 和节点 qqq 中的一个，这种情况下其中一个节点是另一个节点的父亲节点。\n\nclass solution {\n    public treenode lowestcommonancestor(treenode root, treenode p, treenode q) {\n\n        // value of p\n        int pval = p.val;\n\n        // value of q;\n        int qval = q.val;\n\n        // start from the root node of the tree\n        treenode node = root;\n\n        // traverse the tree\n        while (node != null) {\n\n            // value of ancestor/parent node.\n            int parentval = node.val;\n\n            if (pval > parentval && qval > parentval) {\n                // if both p and q are greater than parent\n                node = node.right;\n            } else if (pval < parentval && qval < parentval) {\n                // if both p and q are lesser than parent\n                node = node.left;\n            } else {\n                // we have found the split point, i.e. the lca node.\n                return node;\n            }\n        }\n        return null;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\nclass solution:\n    def lowestcommonancestor(self, root, p, q):\n        """\n        :type root: treenode\n        :type p: treenode\n        :type q: treenode\n        :rtype: treenode\n        """\n\n        # value of p\n        p_val = p.val\n\n        # value of q\n        q_val = q.val\n\n        # start from the root node of the tree\n        node = root\n\n        # traverse the tree\n        while node:\n\n            # value of current node or parent node.\n            parent_val = node.val\n\n            if p_val > parent_val and q_val > parent_val:    \n                # if both p and q are greater than parent\n                node = node.right\n            elif p_val < parent_val and q_val < parent_val:\n                # if both p and q are lesser than parent\n                node = node.left\n            else:\n                # we have found the split point, i.e. the lca node.\n                return node\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n复杂度分析\n\n * 时间复杂度：o(n)o(n)o(n)其中 nnn 为 bst 中节点的个数，在最坏的情况下我们可能需要遍历 bst 中所有的节点。\n   \n   \n * 空间复杂度：o(1)o(1)o(1)\n   \n   \n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-07-17 22:55:09accepted [https://leetcode-cn.com//submissions/detail/4305218/]8 ms33.27%n/ajava# 统计信息\n通过次数提交次数ac比率342175551961.6%# 相似题目\n题目难度二叉树的最近公共祖先 [https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/]中等最小公共区域 [https://leetcode-cn.com/problems/smallest-common-region/]中等'},{title:"242-有效的字母异位词(Valid Anagram)",frontmatter:{title:"242-有效的字母异位词(Valid Anagram)",date:"2018-05-29T00:00:00.000Z",categories:["简单"],tags:["排序<Sort>","哈希表<Hash Table>"]},regularPath:"/views/%E7%AE%80%E5%8D%95/0242-%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D.html",relativePath:"views/简单/0242-有效的字母异位词.md",key:"v-0e89010e",path:"/views/%E7%AE%80%E5%8D%95/0242-%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D.html",headers:[{level:2,title:"中文题目",slug:"中文题目",charIndex:2},{level:2,title:"通过代码",slug:"通过代码",charIndex:214},{level:2,title:"官方题解",slug:"官方题解",charIndex:3190},{level:2,title:"提交历史",slug:"提交历史",charIndex:5494},{level:2,title:"统计信息",slug:"统计信息",charIndex:5919},{level:2,title:"相似题目",slug:"相似题目",charIndex:5954}],lastUpdated:"4/11/2021, 1:15:21 PM",headersStr:"中文题目 通过代码 官方题解 提交历史 统计信息 相似题目",content:"# 中文题目\n给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。\n\n示例 1:\n\n输入: s = \"anagram\", t = \"nagaram\"\n输出: true\n\n\n示例 2:\n\n输入: s = \"rat\", t = \"car\"\n输出: false\n\n说明:\n你可以假设字符串只包含小写字母。\n\n进阶:\n如果输入字符串包含 unicode 字符怎么办？你能否调整你的解法来应对这种情况？\n\n# 通过代码\nclass Solution {\n    \tpublic boolean isAnagram(String s, String t) {\n        if(s.length() == 0&&t.length()== 0){\n        \treturn true;\n        }\n        if(s.length() !=t.length()){\n        \treturn false;\n        }\n\t\t\n\t\tint arr[] = new int[256];\n        char[] sCharArr=s.toCharArray();\n        char[] tCharArr = t.toCharArray();\n        for(char sc :sCharArr){\n        \tarr[sc]+=1;\n        }\n        for(char tc:tCharArr){\n        \tarr[tc]-=1;\n        }\n        for(int i = 0;i < 256;i++){\n        \tif(arr[i]!=0){\n        \t\treturn false;\n        \t}\n        }\n\t\treturn true;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\nimport java.util.HashMap;\nclass Solution {\n    public boolean isAnagram(String s, String t) {\n         HashMap<Character,Integer> map=new HashMap<>();\n            for (int i = 0; i < s.length(); i++) {\n                if (map.containsKey(s.charAt(i))){\n                    int count=map.get(s.charAt(i));\n                    map.put(s.charAt(i),++count);\n                }else {\n                    map.put(s.charAt(i),1);\n                }\n            }\n            for (int i = 0; i < t.length(); i++) {\n                if (map.containsKey(t.charAt(i))){\n                    int count=map.get(t.charAt(i));\n                    if (count>0){\n                        map.put(t.charAt(i),--count);\n                    }else {\n                        return false;\n                    }\n                }else {\n                    return false;\n                }\n            }\n          for (Character c:map.keySet()\n                 ) {\n                if (map.get(c)!=0){\n                    return false;\n                }\n            }\n            return true;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\nimport java.util.HashMap;\nclass Solution {\n    public boolean isAnagram(String s, String t) {\n         HashMap<Character,Integer> map=new HashMap<>();\n            for (int i = 0; i < s.length(); i++) {\n                if (map.containsKey(s.charAt(i))){\n                    int count=map.get(s.charAt(i));\n                    map.put(s.charAt(i),++count);\n                }else {\n                    map.put(s.charAt(i),1);\n                }\n            }\n            for (int i = 0; i < t.length(); i++) {\n                if (map.containsKey(t.charAt(i))){\n                    int count=map.get(t.charAt(i));\n                    if (count>0){\n                        map.put(t.charAt(i),--count);\n                    }else {\n                        return false;\n                    }\n                }else {\n                    return false;\n                }\n            }\n          for (Character c:map.keySet()\n                 ) {\n                if (map.get(c)!=0){\n                    return false;\n                }\n            }\n            return true;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n# 官方题解\n# 方法一：排序\n算法：通过将 sss 的字母重新排列成 ttt 来生成变位词。因此，如果 TTT 是 SSS 的变位词，对两个字符串进行排序将产生两个相同的字符串。此外，如果 sss 和 ttt 的长度不同，ttt 不能是 sss 的变位词，我们可以提前返回。\n\npublic boolean isAnagram(String s, String t) {\n    if (s.length() != t.length()) {\n        return false;\n    }\n    char[] str1 = s.toCharArray();\n    char[] str2 = t.toCharArray();\n    Arrays.sort(str1);\n    Arrays.sort(str2);\n    return Arrays.equals(str1, str2);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n复杂度分析\n\n * 时间复杂度：O(nlog⁡n)O(n \\log n)O(nlogn)，假设 nnn 是 sss 的长度，排序成本 O(nlog⁡n)O(n\\log n)O(nlogn) 和比较两个字符串的成本 O(n)O(n)O(n)。排序时间占主导地位，总体时间复杂度为 O(nlog⁡n)O(n \\log n)O(nlogn)。\n * 空间复杂度：O(1)O(1)O(1)，空间取决于排序实现，如果使用 heapsort，通常需要 O(1)O(1)O(1) 辅助空间。注意，在 Java 中，toCharArray() 制作了一个字符串的拷贝，所以它花费 O(n)O(n)O(n) 额外的空间，但是我们忽略了这一复杂性分析，因为： * 这依赖于语言的细节。\n    * 这取决于函数的设计方式。例如，可以将函数参数类型更改为 char[]。\n   \n   \n\n# 方法二：哈希表\n算法：\n\n 1. 为了检查 ttt 是否是 sss 的重新排列，我们可以计算两个字符串中每个字母的出现次数并进行比较。因为 SSS 和 TTT 都只包含 A−ZA-ZA−Z 的字母，所以一个简单的 26 位计数器表就足够了。\n 2. 我们需要两个计数器数表进行比较吗？实际上不是，因为我们可以用一个计数器表计算 sss 字母的频率，用 ttt 减少计数器表中的每个字母的计数器，然后检查计数器是否回到零。\n\npublic boolean isAnagram(String s, String t) {\n    if (s.length() != t.length()) {\n        return false;\n    }\n    int[] counter = new int[26];\n    for (int i = 0; i < s.length(); i++) {\n        counter[s.charAt(i) - 'a']++;\n        counter[t.charAt(i) - 'a']--;\n    }\n    for (int count : counter) {\n        if (count != 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n 3. 或者我们可以先用计数器表计算 sss，然后用 ttt 减少计数器表中的每个字母的计数器。如果在任何时候计数器低于零，我们知道 ttt 包含一个不在 sss 中的额外字母，并立即返回 FALSE。\n\npublic boolean isAnagram(String s, String t) {\n    if (s.length() != t.length()) {\n        return false;\n    }\n    int[] table = new int[26];\n    for (int i = 0; i < s.length(); i++) {\n        table[s.charAt(i) - 'a']++;\n    }\n    for (int i = 0; i < t.length(); i++) {\n        table[t.charAt(i) - 'a']--;\n        if (table[t.charAt(i) - 'a'] < 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n复杂度分析\n\n * 时间复杂度：O(n)O(n)O(n)。时间复杂度为 O(n)O(n)O(n) 因为访问计数器表是一个固定的时间操作。\n * 空间复杂度：O(1)O(1)O(1)。尽管我们使用了额外的空间，但是空间的复杂性是 O(1)O(1)O(1)，因为无论 NNN 有多大，表的大小都保持不变。\n\n进阶：如果输入字符串包含 unicode 字符怎么办？你能否调整你的解法来应对这种情况？\n\n解答：使用哈希表而不是固定大小的计数器。想象一下，分配一个大的数组来适应整个 Unicode 字符范围，这个范围可能超过 100万。哈希表是一种更通用的解决方案，可以适应任何字符范围。\n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-05-29 23:50:33Accepted [https://leetcode-cn.com//submissions/detail/2739628/]2 ms99.78%N/Ajava2018-05-29 23:50:15Accepted [https://leetcode-cn.com//submissions/detail/2739613/]63 ms5.12%N/Ajava2018-05-29 23:49:09Accepted [https://leetcode-cn.com//submissions/detail/2739573/]50 ms5.26%N/Ajava2018-05-29 23:48:06Wrong Answer [https://leetcode-cn.com//submissions/detail/2739530/]N/AN/AN/Ajava# 统计信息\n通过次数提交次数AC比率6785711731357.8%# 相似题目\n题目难度字母异位词分组 [https://leetcode-cn.com/problems/group-anagrams/]中等回文排列 [https://leetcode-cn.com/problems/palindrome-permutation/]简单找到字符串中所有字母异位词 [https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/]中等",contentLowercase:"# 中文题目\n给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。\n\n示例 1:\n\n输入: s = \"anagram\", t = \"nagaram\"\n输出: true\n\n\n示例 2:\n\n输入: s = \"rat\", t = \"car\"\n输出: false\n\n说明:\n你可以假设字符串只包含小写字母。\n\n进阶:\n如果输入字符串包含 unicode 字符怎么办？你能否调整你的解法来应对这种情况？\n\n# 通过代码\nclass solution {\n    \tpublic boolean isanagram(string s, string t) {\n        if(s.length() == 0&&t.length()== 0){\n        \treturn true;\n        }\n        if(s.length() !=t.length()){\n        \treturn false;\n        }\n\t\t\n\t\tint arr[] = new int[256];\n        char[] schararr=s.tochararray();\n        char[] tchararr = t.tochararray();\n        for(char sc :schararr){\n        \tarr[sc]+=1;\n        }\n        for(char tc:tchararr){\n        \tarr[tc]-=1;\n        }\n        for(int i = 0;i < 256;i++){\n        \tif(arr[i]!=0){\n        \t\treturn false;\n        \t}\n        }\n\t\treturn true;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\nimport java.util.hashmap;\nclass solution {\n    public boolean isanagram(string s, string t) {\n         hashmap<character,integer> map=new hashmap<>();\n            for (int i = 0; i < s.length(); i++) {\n                if (map.containskey(s.charat(i))){\n                    int count=map.get(s.charat(i));\n                    map.put(s.charat(i),++count);\n                }else {\n                    map.put(s.charat(i),1);\n                }\n            }\n            for (int i = 0; i < t.length(); i++) {\n                if (map.containskey(t.charat(i))){\n                    int count=map.get(t.charat(i));\n                    if (count>0){\n                        map.put(t.charat(i),--count);\n                    }else {\n                        return false;\n                    }\n                }else {\n                    return false;\n                }\n            }\n          for (character c:map.keyset()\n                 ) {\n                if (map.get(c)!=0){\n                    return false;\n                }\n            }\n            return true;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\nimport java.util.hashmap;\nclass solution {\n    public boolean isanagram(string s, string t) {\n         hashmap<character,integer> map=new hashmap<>();\n            for (int i = 0; i < s.length(); i++) {\n                if (map.containskey(s.charat(i))){\n                    int count=map.get(s.charat(i));\n                    map.put(s.charat(i),++count);\n                }else {\n                    map.put(s.charat(i),1);\n                }\n            }\n            for (int i = 0; i < t.length(); i++) {\n                if (map.containskey(t.charat(i))){\n                    int count=map.get(t.charat(i));\n                    if (count>0){\n                        map.put(t.charat(i),--count);\n                    }else {\n                        return false;\n                    }\n                }else {\n                    return false;\n                }\n            }\n          for (character c:map.keyset()\n                 ) {\n                if (map.get(c)!=0){\n                    return false;\n                }\n            }\n            return true;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n# 官方题解\n# 方法一：排序\n算法：通过将 sss 的字母重新排列成 ttt 来生成变位词。因此，如果 ttt 是 sss 的变位词，对两个字符串进行排序将产生两个相同的字符串。此外，如果 sss 和 ttt 的长度不同，ttt 不能是 sss 的变位词，我们可以提前返回。\n\npublic boolean isanagram(string s, string t) {\n    if (s.length() != t.length()) {\n        return false;\n    }\n    char[] str1 = s.tochararray();\n    char[] str2 = t.tochararray();\n    arrays.sort(str1);\n    arrays.sort(str2);\n    return arrays.equals(str1, str2);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n复杂度分析\n\n * 时间复杂度：o(nlog⁡n)o(n \\log n)o(nlogn)，假设 nnn 是 sss 的长度，排序成本 o(nlog⁡n)o(n\\log n)o(nlogn) 和比较两个字符串的成本 o(n)o(n)o(n)。排序时间占主导地位，总体时间复杂度为 o(nlog⁡n)o(n \\log n)o(nlogn)。\n * 空间复杂度：o(1)o(1)o(1)，空间取决于排序实现，如果使用 heapsort，通常需要 o(1)o(1)o(1) 辅助空间。注意，在 java 中，tochararray() 制作了一个字符串的拷贝，所以它花费 o(n)o(n)o(n) 额外的空间，但是我们忽略了这一复杂性分析，因为： * 这依赖于语言的细节。\n    * 这取决于函数的设计方式。例如，可以将函数参数类型更改为 char[]。\n   \n   \n\n# 方法二：哈希表\n算法：\n\n 1. 为了检查 ttt 是否是 sss 的重新排列，我们可以计算两个字符串中每个字母的出现次数并进行比较。因为 sss 和 ttt 都只包含 a−za-za−z 的字母，所以一个简单的 26 位计数器表就足够了。\n 2. 我们需要两个计数器数表进行比较吗？实际上不是，因为我们可以用一个计数器表计算 sss 字母的频率，用 ttt 减少计数器表中的每个字母的计数器，然后检查计数器是否回到零。\n\npublic boolean isanagram(string s, string t) {\n    if (s.length() != t.length()) {\n        return false;\n    }\n    int[] counter = new int[26];\n    for (int i = 0; i < s.length(); i++) {\n        counter[s.charat(i) - 'a']++;\n        counter[t.charat(i) - 'a']--;\n    }\n    for (int count : counter) {\n        if (count != 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n 3. 或者我们可以先用计数器表计算 sss，然后用 ttt 减少计数器表中的每个字母的计数器。如果在任何时候计数器低于零，我们知道 ttt 包含一个不在 sss 中的额外字母，并立即返回 false。\n\npublic boolean isanagram(string s, string t) {\n    if (s.length() != t.length()) {\n        return false;\n    }\n    int[] table = new int[26];\n    for (int i = 0; i < s.length(); i++) {\n        table[s.charat(i) - 'a']++;\n    }\n    for (int i = 0; i < t.length(); i++) {\n        table[t.charat(i) - 'a']--;\n        if (table[t.charat(i) - 'a'] < 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n复杂度分析\n\n * 时间复杂度：o(n)o(n)o(n)。时间复杂度为 o(n)o(n)o(n) 因为访问计数器表是一个固定的时间操作。\n * 空间复杂度：o(1)o(1)o(1)。尽管我们使用了额外的空间，但是空间的复杂性是 o(1)o(1)o(1)，因为无论 nnn 有多大，表的大小都保持不变。\n\n进阶：如果输入字符串包含 unicode 字符怎么办？你能否调整你的解法来应对这种情况？\n\n解答：使用哈希表而不是固定大小的计数器。想象一下，分配一个大的数组来适应整个 unicode 字符范围，这个范围可能超过 100万。哈希表是一种更通用的解决方案，可以适应任何字符范围。\n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-05-29 23:50:33accepted [https://leetcode-cn.com//submissions/detail/2739628/]2 ms99.78%n/ajava2018-05-29 23:50:15accepted [https://leetcode-cn.com//submissions/detail/2739613/]63 ms5.12%n/ajava2018-05-29 23:49:09accepted [https://leetcode-cn.com//submissions/detail/2739573/]50 ms5.26%n/ajava2018-05-29 23:48:06wrong answer [https://leetcode-cn.com//submissions/detail/2739530/]n/an/an/ajava# 统计信息\n通过次数提交次数ac比率6785711731357.8%# 相似题目\n题目难度字母异位词分组 [https://leetcode-cn.com/problems/group-anagrams/]中等回文排列 [https://leetcode-cn.com/problems/palindrome-permutation/]简单找到字符串中所有字母异位词 [https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/]中等"},{title:"237-删除链表中的节点(Delete Node in a Linked List)",frontmatter:{title:"237-删除链表中的节点(Delete Node in a Linked List)",date:"2018-07-15T00:00:00.000Z",categories:["简单"],tags:["链表<Linked List>"]},regularPath:"/views/%E7%AE%80%E5%8D%95/0237-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9.html",relativePath:"views/简单/0237-删除链表中的节点.md",key:"v-371682cc",path:"/views/%E7%AE%80%E5%8D%95/0237-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9.html",headers:[{level:2,title:"中文题目",slug:"中文题目",charIndex:2},{level:2,title:"通过代码",slug:"通过代码",charIndex:402},{level:2,title:"官方题解",slug:"官方题解",charIndex:919},{level:2,title:"提交历史",slug:"提交历史",charIndex:1338},{level:2,title:"统计信息",slug:"统计信息",charIndex:1466},{level:2,title:"相似题目",slug:"相似题目",charIndex:1500}],lastUpdated:"4/11/2021, 1:15:21 PM",headersStr:"中文题目 通过代码 官方题解 提交历史 统计信息 相似题目",content:'# 中文题目\n请编写一个函数，使其可以删除某个链表中给定的（非末尾）节点，你将只被给定要求被删除的节点。\n\n现有一个链表 -- head = [4,5,1,9]，它可以表示为:\n\n\n\n\n\n示例 1:\n\n输入: head = [4,5,1,9], node = 5\n输出: [4,1,9]\n解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -> 1 -> 9.\n\n\n示例 2:\n\n输入: head = [4,5,1,9], node = 1\n输出: [4,5,9]\n解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -> 5 -> 9.\n\n\n\n\n说明:\n\n * 链表至少包含两个节点。\n * 链表中所有节点的值都是唯一的。\n * 给定的节点为非末尾节点并且一定是链表中的一个有效节点。\n * 不要从你的函数中返回任何结果。\n\n# 通过代码\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public void deleteNode(ListNode node) {\n         if (node==null){\n                return;\n            }\n            if (node.next==null){\n                node=null;\n                return;\n            }\n            node.val=node.next.val;\n            node.next=node.next.next;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n# 官方题解\n# 方法：与下一个节点交换\n从链表里删除一个节点 node 的最常见方法是修改之前节点的 next 指针，使其指向之后的节点。\n\n{:width="300px"}\n\n因为，我们无法访问我们想要删除的节点 之前 的节点，我们始终不能修改该节点的 next 指针。相反，我们必须将想要删除的节点的值替换为它后面节点中的值，然后删除它之后的节点。\n\n{:width="300px"}\n\n{:width="300px"}\n\n{:width="246px"}\n\n因为我们知道要删除的节点不是列表的末尾，所以我们可以保证这种方法是可行的。\n\npublic void deleteNode(ListNode node) {\n    node.val = node.next.val;\n    node.next = node.next.next;\n}\n\n\n1\n2\n3\n4\n复杂度分析\n\n时间和空间复杂度都是：O(1)O(1)O(1)。\n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-07-15 22:19:43Accepted [https://leetcode-cn.com//submissions/detail/4216084/]0 ms100.0%N/Ajava# 统计信息\n通过次数提交次数AC比率720929076479.4%# 相似题目\n题目难度移除链表元素 [https://leetcode-cn.com/problems/remove-linked-list-elements/]简单',contentLowercase:'# 中文题目\n请编写一个函数，使其可以删除某个链表中给定的（非末尾）节点，你将只被给定要求被删除的节点。\n\n现有一个链表 -- head = [4,5,1,9]，它可以表示为:\n\n\n\n\n\n示例 1:\n\n输入: head = [4,5,1,9], node = 5\n输出: [4,1,9]\n解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -> 1 -> 9.\n\n\n示例 2:\n\n输入: head = [4,5,1,9], node = 1\n输出: [4,5,9]\n解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -> 5 -> 9.\n\n\n\n\n说明:\n\n * 链表至少包含两个节点。\n * 链表中所有节点的值都是唯一的。\n * 给定的节点为非末尾节点并且一定是链表中的一个有效节点。\n * 不要从你的函数中返回任何结果。\n\n# 通过代码\n/**\n * definition for singly-linked list.\n * public class listnode {\n *     int val;\n *     listnode next;\n *     listnode(int x) { val = x; }\n * }\n */\nclass solution {\n    public void deletenode(listnode node) {\n         if (node==null){\n                return;\n            }\n            if (node.next==null){\n                node=null;\n                return;\n            }\n            node.val=node.next.val;\n            node.next=node.next.next;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n# 官方题解\n# 方法：与下一个节点交换\n从链表里删除一个节点 node 的最常见方法是修改之前节点的 next 指针，使其指向之后的节点。\n\n{:width="300px"}\n\n因为，我们无法访问我们想要删除的节点 之前 的节点，我们始终不能修改该节点的 next 指针。相反，我们必须将想要删除的节点的值替换为它后面节点中的值，然后删除它之后的节点。\n\n{:width="300px"}\n\n{:width="300px"}\n\n{:width="246px"}\n\n因为我们知道要删除的节点不是列表的末尾，所以我们可以保证这种方法是可行的。\n\npublic void deletenode(listnode node) {\n    node.val = node.next.val;\n    node.next = node.next.next;\n}\n\n\n1\n2\n3\n4\n复杂度分析\n\n时间和空间复杂度都是：o(1)o(1)o(1)。\n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-07-15 22:19:43accepted [https://leetcode-cn.com//submissions/detail/4216084/]0 ms100.0%n/ajava# 统计信息\n通过次数提交次数ac比率720929076479.4%# 相似题目\n题目难度移除链表元素 [https://leetcode-cn.com/problems/remove-linked-list-elements/]简单'},{title:"257-二叉树的所有路径(Binary Tree Paths)",frontmatter:{title:"257-二叉树的所有路径(Binary Tree Paths)",date:"2018-07-17T00:00:00.000Z",categories:["简单"],tags:["树<Tree>","深度优先搜索<Depth-first Search>"]},regularPath:"/views/%E7%AE%80%E5%8D%95/0257-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84.html",relativePath:"views/简单/0257-二叉树的所有路径.md",key:"v-812258f8",path:"/views/%E7%AE%80%E5%8D%95/0257-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84.html",headers:[{level:2,title:"中文题目",slug:"中文题目",charIndex:2},{level:2,title:"通过代码",slug:"通过代码",charIndex:154},{level:2,title:"官方题解",slug:"官方题解",charIndex:1204},{level:2,title:"提交历史",slug:"提交历史",charIndex:5530},{level:2,title:"统计信息",slug:"统计信息",charIndex:5659},{level:2,title:"相似题目",slug:"相似题目",charIndex:5693}],lastUpdated:"4/11/2021, 1:15:21 PM",headersStr:"中文题目 通过代码 官方题解 提交历史 统计信息 相似题目",content:'# 中文题目\n给定一个二叉树，返回所有从根节点到叶子节点的路径。\n\n说明:叶子节点是指没有子节点的节点。\n\n示例:\n\n输入:\n\n   1\n /   \\\n2     3\n \\\n  5\n\n输出: ["1->2->5", "1->3"]\n\n解释: 所有根节点到叶子节点的路径为: 1->2->5, 1->3\n\n# 通过代码\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nimport java.util.LinkedList;\nimport java.util.List;\nclass Solution {\n    public List<String> binaryTreePaths(TreeNode root) {\n        List<String> res=new LinkedList<>();\n            if (root==null){\n                return res;\n            }\n            if (root.left==null && root.right==null){\n                res.add(String.valueOf(root.val));\n                return res;\n            }\n            List<String> lefts=binaryTreePaths(root.left);\n            for (int i = 0; i < lefts.size(); i++) {\n                res.add(root.val+"->"+lefts.get(i));\n            }\n            List<String> rights=binaryTreePaths(root.right);\n            for (int i = 0; i < rights.size(); i++) {\n                res.add(root.val+"->"+rights.get(i));\n            }\n            return res;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n# 官方题解\n# 二叉树的定义\n首先给出 TreeNode 的定义，我们将会在后续的代码实现中使用它。\n\n/* Definition for a binary tree node. */\npublic class TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n\n    TreeNode(int x) {\n      val = x;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\nclass TreeNode(object):\n    """ Definition of a binary tree node."""\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\n\n1\n2\n3\n4\n5\n6\n# 方法一：递归\n最直观的方法是使用递归。在递归遍历二叉树时，需要考虑当前的节点和它的孩子节点。如果当前的节点不是叶子节点，则在当前的路径末尾添加该节点，并递归遍历该节点的每一个孩子节点。如果当前的节点是叶子节点，则在当前的路径末尾添加该节点后，就得到了一条从根节点到叶子节点的路径，可以把该路径加入到答案中。\n\nclass Solution {\n    public void construct_paths(TreeNode root, String path, LinkedList<String> paths) {\n        if (root != null) {\n            path += Integer.toString(root.val);\n            if ((root.left == null) && (root.right == null))  // 当前节点是叶子节点\n                paths.add(path);  // 把路径加入到答案中\n            else {\n                path += "->";  // 当前节点不是叶子节点，继续递归遍历\n                construct_paths(root.left, path, paths);\n                construct_paths(root.right, path, paths);\n            }\n        }\n    }\n\n    public List<String> binaryTreePaths(TreeNode root) {\n        LinkedList<String> paths = new LinkedList();\n        construct_paths(root, "", paths);\n        return paths;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\nclass Solution:\n    def binaryTreePaths(self, root):\n        """\n        :type root: TreeNode\n        :rtype: List[str]\n        """\n        def construct_paths(root, path):\n            if root:\n                path += str(root.val)\n                if not root.left and not root.right:  # 当前节点是叶子节点\n                    paths.append(path)  # 把路径加入到答案中\n                else:\n                    path += \'->\'  # 当前节点不是叶子节点，继续递归遍历\n                    construct_paths(root.left, path)\n                    construct_paths(root.right, path)\n\n        paths = []\n        construct_paths(root, \'\')\n        return paths\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n复杂度分析\n\n * 时间复杂度：每个节点只会被访问一次，因此时间复杂度为 O(N)O(N)O(N)，其中 NNN 表示节点数目。\n * 空间复杂度：O(N)O(N)O(N)。这里不考虑存储答案 paths 使用的空间，仅考虑额外的空间复杂度。额外的空间复杂度为递归时使用的栈空间，在最坏情况下，当二叉树中每个节点只有一个孩子节点时，递归的层数为 NNN，此时空间复杂度为 O(N)O(N)O(N)。在最好情况下，当二叉树为平衡二叉树时，它的高度为 log⁡(N)\\log(N)log(N)，此时空间复杂度为 O(log⁡(N))O(\\log(N))O(log(N))。\n\n# 方法二：迭代\n上面的算法也可以使用迭代（宽度优先搜索）的方法实现。我们维护一个队列，存储节点以及根到该节点的路径。一开始这个队列里只有根节点。在每一步迭代中，我们取出队列中的首节点，如果它是一个叶子节点，则将它对应的路径加入到答案中。如果它不是一个叶子节点，则将它的所有孩子节点加入到队列的末尾。当队列为空时，迭代结束。\n\n<,,,,,,>\n\nclass Solution {\n    public List<String> binaryTreePaths(TreeNode root) {\n        LinkedList<String> paths = new LinkedList();\n        if (root == null)\n            return paths;\n\n        LinkedList<TreeNode> node_stack = new LinkedList();\n        LinkedList<String> path_stack = new LinkedList();\n        node_stack.add(root);\n        path_stack.add(Integer.toString(root.val));\n        TreeNode node;\n        String path;\n        while (!node_stack.isEmpty()) {\n            node = node_stack.pollLast();\n            path = path_stack.pollLast();\n            if ((node.left == null) && (node.right == null))\n                paths.add(path);\n            if (node.left != null) {\n                node_stack.add(node.left);\n                path_stack.add(path + "->" + Integer.toString(node.left.val));\n            }\n            if (node.right != null) {\n                node_stack.add(node.right);\n                path_stack.add(path + "->" + Integer.toString(node.right.val));\n            }\n        }\n        return paths;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\nclass Solution:\n    def binaryTreePaths(self, root):\n        """\n        :type root: TreeNode\n        :rtype: List[str]\n        """\n        if not root:\n            return []\n        \n        paths = []\n        stack = [(root, str(root.val))]\n        while stack:\n            node, path = stack.pop()\n            if not node.left and not node.right:\n                paths.append(path)\n            if node.left:\n                stack.append((node.left, path + \'->\' + str(node.left.val)))\n            if node.right:\n                stack.append((node.right, path + \'->\' + str(node.right.val)))\n        \n        return paths\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n复杂度分析\n\n * 时间复杂度：O(N)O(N)O(N)，每个节点只会被访问一次。\n * 空间复杂度：O(N)O(N)O(N)，在最坏情况下，队列中有 NNN 个节点。\n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-07-17 21:17:17Accepted [https://leetcode-cn.com//submissions/detail/4298596/]13 ms11.07%N/Ajava# 统计信息\n通过次数提交次数AC比率222203610961.5%# 相似题目\n题目难度路径总和 II [https://leetcode-cn.com/problems/path-sum-ii/]中等从叶结点开始的最小字符串 [https://leetcode-cn.com/problems/smallest-string-starting-from-leaf/]中等',contentLowercase:'# 中文题目\n给定一个二叉树，返回所有从根节点到叶子节点的路径。\n\n说明:叶子节点是指没有子节点的节点。\n\n示例:\n\n输入:\n\n   1\n /   \\\n2     3\n \\\n  5\n\n输出: ["1->2->5", "1->3"]\n\n解释: 所有根节点到叶子节点的路径为: 1->2->5, 1->3\n\n# 通过代码\n/**\n * definition for a binary tree node.\n * public class treenode {\n *     int val;\n *     treenode left;\n *     treenode right;\n *     treenode(int x) { val = x; }\n * }\n */\nimport java.util.linkedlist;\nimport java.util.list;\nclass solution {\n    public list<string> binarytreepaths(treenode root) {\n        list<string> res=new linkedlist<>();\n            if (root==null){\n                return res;\n            }\n            if (root.left==null && root.right==null){\n                res.add(string.valueof(root.val));\n                return res;\n            }\n            list<string> lefts=binarytreepaths(root.left);\n            for (int i = 0; i < lefts.size(); i++) {\n                res.add(root.val+"->"+lefts.get(i));\n            }\n            list<string> rights=binarytreepaths(root.right);\n            for (int i = 0; i < rights.size(); i++) {\n                res.add(root.val+"->"+rights.get(i));\n            }\n            return res;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n# 官方题解\n# 二叉树的定义\n首先给出 treenode 的定义，我们将会在后续的代码实现中使用它。\n\n/* definition for a binary tree node. */\npublic class treenode {\n    int val;\n    treenode left;\n    treenode right;\n\n    treenode(int x) {\n      val = x;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\nclass treenode(object):\n    """ definition of a binary tree node."""\n    def __init__(self, x):\n        self.val = x\n        self.left = none\n        self.right = none\n\n\n1\n2\n3\n4\n5\n6\n# 方法一：递归\n最直观的方法是使用递归。在递归遍历二叉树时，需要考虑当前的节点和它的孩子节点。如果当前的节点不是叶子节点，则在当前的路径末尾添加该节点，并递归遍历该节点的每一个孩子节点。如果当前的节点是叶子节点，则在当前的路径末尾添加该节点后，就得到了一条从根节点到叶子节点的路径，可以把该路径加入到答案中。\n\nclass solution {\n    public void construct_paths(treenode root, string path, linkedlist<string> paths) {\n        if (root != null) {\n            path += integer.tostring(root.val);\n            if ((root.left == null) && (root.right == null))  // 当前节点是叶子节点\n                paths.add(path);  // 把路径加入到答案中\n            else {\n                path += "->";  // 当前节点不是叶子节点，继续递归遍历\n                construct_paths(root.left, path, paths);\n                construct_paths(root.right, path, paths);\n            }\n        }\n    }\n\n    public list<string> binarytreepaths(treenode root) {\n        linkedlist<string> paths = new linkedlist();\n        construct_paths(root, "", paths);\n        return paths;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\nclass solution:\n    def binarytreepaths(self, root):\n        """\n        :type root: treenode\n        :rtype: list[str]\n        """\n        def construct_paths(root, path):\n            if root:\n                path += str(root.val)\n                if not root.left and not root.right:  # 当前节点是叶子节点\n                    paths.append(path)  # 把路径加入到答案中\n                else:\n                    path += \'->\'  # 当前节点不是叶子节点，继续递归遍历\n                    construct_paths(root.left, path)\n                    construct_paths(root.right, path)\n\n        paths = []\n        construct_paths(root, \'\')\n        return paths\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n复杂度分析\n\n * 时间复杂度：每个节点只会被访问一次，因此时间复杂度为 o(n)o(n)o(n)，其中 nnn 表示节点数目。\n * 空间复杂度：o(n)o(n)o(n)。这里不考虑存储答案 paths 使用的空间，仅考虑额外的空间复杂度。额外的空间复杂度为递归时使用的栈空间，在最坏情况下，当二叉树中每个节点只有一个孩子节点时，递归的层数为 nnn，此时空间复杂度为 o(n)o(n)o(n)。在最好情况下，当二叉树为平衡二叉树时，它的高度为 log⁡(n)\\log(n)log(n)，此时空间复杂度为 o(log⁡(n))o(\\log(n))o(log(n))。\n\n# 方法二：迭代\n上面的算法也可以使用迭代（宽度优先搜索）的方法实现。我们维护一个队列，存储节点以及根到该节点的路径。一开始这个队列里只有根节点。在每一步迭代中，我们取出队列中的首节点，如果它是一个叶子节点，则将它对应的路径加入到答案中。如果它不是一个叶子节点，则将它的所有孩子节点加入到队列的末尾。当队列为空时，迭代结束。\n\n<,,,,,,>\n\nclass solution {\n    public list<string> binarytreepaths(treenode root) {\n        linkedlist<string> paths = new linkedlist();\n        if (root == null)\n            return paths;\n\n        linkedlist<treenode> node_stack = new linkedlist();\n        linkedlist<string> path_stack = new linkedlist();\n        node_stack.add(root);\n        path_stack.add(integer.tostring(root.val));\n        treenode node;\n        string path;\n        while (!node_stack.isempty()) {\n            node = node_stack.polllast();\n            path = path_stack.polllast();\n            if ((node.left == null) && (node.right == null))\n                paths.add(path);\n            if (node.left != null) {\n                node_stack.add(node.left);\n                path_stack.add(path + "->" + integer.tostring(node.left.val));\n            }\n            if (node.right != null) {\n                node_stack.add(node.right);\n                path_stack.add(path + "->" + integer.tostring(node.right.val));\n            }\n        }\n        return paths;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\nclass solution:\n    def binarytreepaths(self, root):\n        """\n        :type root: treenode\n        :rtype: list[str]\n        """\n        if not root:\n            return []\n        \n        paths = []\n        stack = [(root, str(root.val))]\n        while stack:\n            node, path = stack.pop()\n            if not node.left and not node.right:\n                paths.append(path)\n            if node.left:\n                stack.append((node.left, path + \'->\' + str(node.left.val)))\n            if node.right:\n                stack.append((node.right, path + \'->\' + str(node.right.val)))\n        \n        return paths\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n复杂度分析\n\n * 时间复杂度：o(n)o(n)o(n)，每个节点只会被访问一次。\n * 空间复杂度：o(n)o(n)o(n)，在最坏情况下，队列中有 nnn 个节点。\n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-07-17 21:17:17accepted [https://leetcode-cn.com//submissions/detail/4298596/]13 ms11.07%n/ajava# 统计信息\n通过次数提交次数ac比率222203610961.5%# 相似题目\n题目难度路径总和 ii [https://leetcode-cn.com/problems/path-sum-ii/]中等从叶结点开始的最小字符串 [https://leetcode-cn.com/problems/smallest-string-starting-from-leaf/]中等'},{title:"268-缺失数字(Missing Number)",frontmatter:{title:"268-缺失数字(Missing Number)",date:"2020-01-09T00:00:00.000Z",categories:["简单"],tags:["位运算<Bit Manipulation>","数组<Array>","数学<Math>"]},regularPath:"/views/%E7%AE%80%E5%8D%95/0268-%E7%BC%BA%E5%A4%B1%E6%95%B0%E5%AD%97.html",relativePath:"views/简单/0268-缺失数字.md",key:"v-35ed2a6a",path:"/views/%E7%AE%80%E5%8D%95/0268-%E7%BC%BA%E5%A4%B1%E6%95%B0%E5%AD%97.html",headers:[{level:2,title:"中文题目",slug:"中文题目",charIndex:2},{level:2,title:"通过代码",slug:"通过代码",charIndex:167},{level:2,title:"官方题解",slug:"官方题解",charIndex:769},{level:2,title:"提交历史",slug:"提交历史",charIndex:5832},{level:2,title:"统计信息",slug:"统计信息",charIndex:6067},{level:2,title:"相似题目",slug:"相似题目",charIndex:6101}],lastUpdated:"4/11/2021, 1:15:21 PM",headersStr:"中文题目 通过代码 官方题解 提交历史 统计信息 相似题目",content:"# 中文题目\n给定一个包含 0, 1, 2, ..., n中n个数的序列，找出 0 .. n中没有出现在序列中的那个数。\n\n示例 1:\n\n输入: [3,0,1]\n输出: 2\n\n\n示例 2:\n\n输入: [9,6,4,2,3,5,7,0,1]\n输出: 8\n\n\n说明:\n你的算法应具有线性时间复杂度。你能否仅使用额外常数空间来实现?\n\n# 通过代码\nclass Solution {\n    public int missingNumber(int[] nums) {\n        int res=nums.length;\n        for (int i = 0; i < nums.length; i++) {\n            res=res^(i^nums[i]);\n        }\n        return res;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\nclass Solution {\n    public int missingNumber(int[] nums) {\n        int[] arr=new int[nums.length+1];\n        for (int i = 0; i < nums.length; i++) {\n            arr[nums[i]]=1;\n        }\n        for (int i = 0; i < arr.length; i++) {\n            if (arr[i]==0){\n                return i;\n            }\n        }\n        return 0;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n# 官方题解\n# 方法一：排序\n分析\n\n如果数组是有序的，那么就很容易知道缺失的数字是哪个了。\n\n算法\n\n首先我们对数组进行排序，随后我们可以在常数时间内判断两种特殊情况：0 没有出现在数组的首位，以及 nnn 没有出现在数组的末位。如果这两种特殊情况都不满足，那么缺失的数字一定在 0 和 nnn 之间（不包括两者）。此时我们可以在线性时间内扫描这个数组，如果某一个数比它前面的那个数大了超过 1，那么这两个数之间的那个数即为缺失的数字。\n\nclass Solution {\n    public int missingNumber(int[] nums) {\n        Arrays.sort(nums);\n\n        // 判断 n 是否出现在末位\n        if (nums[nums.length-1] != nums.length) {\n            return nums.length;\n        }\n        // 判断 0 是否出现在首位\n        else if (nums[0] != 0) {\n            return 0;\n        }\n\n        // 此时缺失的数字一定在 (0, n) 中\n        for (int i = 1; i < nums.length; i++) {\n            int expectedNum = nums[i-1] + 1;\n            if (nums[i] != expectedNum) {\n                return expectedNum;\n            }\n        }\n\n        // 未缺失任何数字（保证函数有返回值）\n        return -1;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\nclass Solution:\n    def missingNumber(self, nums):\n        nums.sort()\n\n        # Ensure that n is at the last index\n        if nums[-1] != len(nums):\n            return len(nums)\n        # Ensure that 0 is at the first index\n        elif nums[0] != 0:\n            return 0\n\n        # If we get here, then the missing number is on the range (0, n)\n        for i in range(1, len(nums)):\n            expected_num = nums[i-1] + 1\n            if nums[i] != expected_num:\n                return expected_num\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n复杂度分析\n\n * 时间复杂度：O(nlog⁡n)O(n\\log n)O(nlogn)。由于排序的时间复杂度为 O(nlog⁡n)O(n\\log n)O(nlogn)，扫描数组的时间复杂度为 O(n)O(n)O(n)，因此总的时间复杂度为 O(nlog⁡n)O(n\\log n)O(nlogn)。\n * 空间复杂度：O(1)O(1)O(1) 或 O(n)O(n)O(n)。空间复杂度取决于使用的排序算法，根据排序算法是否进行原地排序（即不使用额外的数组进行临时存储），空间复杂度为 O(1)O(1)O(1) 或 O(n)O(n)O(n)。\n\n# 方法二：哈希表\n分析\n\n我们可以直接查询每个数是否在数组中出现过来找出缺失的数字。如果使用哈希表，那么每一次查询操作都是常数时间的。\n\n算法\n\n我们将数组中的所有数插入到一个集合中，这样每次查询操作的时间复杂度都是 O(1)O(1)O(1) 的。\n\nclass Solution {\n    public int missingNumber(int[] nums) {\n        Set<Integer> numSet = new HashSet<Integer>();\n        for (int num : nums) numSet.add(num);\n\n        int expectedNumCount = nums.length + 1;\n        for (int number = 0; number < expectedNumCount; number++) {\n            if (!numSet.contains(number)) {\n                return number;\n            }\n        }\n        return -1;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\nclass Solution:\n    def missingNumber(self, nums):\n        num_set = set(nums)\n        n = len(nums) + 1\n        for number in range(n):\n            if number not in num_set:\n                return number\n\n\n1\n2\n3\n4\n5\n6\n7\n复杂度分析\n\n * 时间复杂度：O(n)O(n)O(n)。集合的插入操作的时间复杂度都是 O(1)O(1)O(1)，一共插入了 nnn 个数，时间复杂度为 O(n)O(n)O(n)。集合的查询操作的时间复杂度同样是 O(1)O(1)O(1)，最多查询 n+1n+1n+1 次，时间复杂度为 O(n)O(n)O(n)。因此总的时间复杂度为 O(n)O(n)O(n)。\n * 空间复杂度：O(n)O(n)O(n)。集合中会存储 nnn 个数，因此空间复杂度为 O(n)O(n)O(n)。\n\n# 方法三：位运算\n分析\n\n由于异或运算（XOR）满足结合律，并且对一个数进行两次完全相同的异或运算会得到原来的数，因此我们可以通过异或运算找到缺失的数字。\n\n算法\n\n我们知道数组中有 nnn 个数，并且缺失的数在 [0..n][0..n][0..n] 中。因此我们可以先得到 [0..n][0..n][0..n] 的异或值，再将结果对数组中的每一个数进行一次异或运算。未缺失的数在 [0..n][0..n][0..n] 和数组中各出现一次，因此异或后得到 0。而缺失的数字只在 [0..n][0..n][0..n] 中出现了一次，在数组中没有出现，因此最终的异或结果即为这个缺失的数字。\n\n在编写代码时，由于 [0..n][0..n][0..n] 恰好是这个数组的下标加上 nnn，因此可以用一次循环完成所有的异或运算，例如下面这个例子：\n\n下标0123数字0134可以将结果的初始值设为 nnn，再对数组中的每一个数以及它的下标进行一个异或运算，即：\n\nmissing=4∧(0∧0)∧(1∧1)∧(2∧3)∧(3∧4)=(4∧4)∧(0∧0)∧(1∧1)∧(3∧3)∧2=0∧0∧0∧0∧2=2\\begin{aligned} \\mathrm{missing} &= 4 \\wedge (0 \\wedge 0) \\wedge (1 \\wedge 1) \\wedge (2 \\wedge 3) \\wedge (3 \\wedge 4) \\\\ &= (4 \\wedge 4) \\wedge (0 \\wedge 0) \\wedge (1 \\wedge 1) \\wedge (3 \\wedge 3) \\wedge 2 \\\\ &= 0 \\wedge 0 \\wedge 0 \\wedge 0 \\wedge 2 \\\\ &= 2 \\end{aligned}missing​=4∧(0∧0)∧(1∧1)∧(2∧3)∧(3∧4)=(4∧4)∧(0∧0)∧(1∧1)∧(3∧3)∧2=0∧0∧0∧0∧2=2​\n\n就得到了缺失的数字为 2。\n\nclass Solution {\n    public int missingNumber(int[] nums) {\n        int missing = nums.length;\n        for (int i = 0; i < nums.length; i++) {\n            missing ^= i ^ nums[i];\n        }\n        return missing;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\nclass Solution:\n    def missingNumber(self, nums):\n        missing = len(nums)\n        for i, num in enumerate(nums):\n            missing ^= i ^ num\n        return missing\n\n\n1\n2\n3\n4\n5\n6\n复杂度分析\n\n * 时间复杂度：O(n)O(n)O(n)。这里假设异或运算的时间复杂度是常数的，总共会进行 O(n)O(n)O(n) 次异或运算，因此总的时间复杂度为 O(n)O(n)O(n)。\n * 空间复杂度：O(1)O(1)O(1)。算法中只用到了 O(1)O(1)O(1) 的额外空间，用来存储答案。\n\n# 方法四：数学\n分析\n\n我们可以用 高斯求和公式 [https://baike.baidu.com/item/%E9%AB%98%E6%96%AF%E6%B1%82%E5%92%8C] 求出 [0..n][0..n][0..n] 的和，减去数组中所有数的和，就得到了缺失的数字。高斯求和公式即\n\n∑i=0ni=n(n+1)2\\sum_{i=0}^{n}i = \\frac{n(n+1)}{2}i=0∑n​i=2n(n+1)​\n\n算法\n\n我们在线性时间内可以求出数组中所有数的和，并在常数时间内求出前 n+1n+1n+1 个自然数（包括 0）的和，将后者减去前者，就得到了缺失的数字。\n\nclass Solution {\n    public int missingNumber(int[] nums) {\n        int expectedSum = nums.length*(nums.length + 1)/2;\n        int actualSum = 0;\n        for (int num : nums) actualSum += num;\n        return expectedSum - actualSum;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\nclass Solution:\n    def missingNumber(self, nums):\n        expected_sum = len(nums)*(len(nums)+1)//2\n        actual_sum = sum(nums)\n        return expected_sum - actual_sum\n\n\n1\n2\n3\n4\n5\n复杂度分析\n\n * 时间复杂度：O(n)O(n)O(n)。求出数组中所有数的和的时间复杂度为 O(n)O(n)O(n)，高斯求和公式的时间复杂度为 O(1)O(1)O(1)，因此总的时间复杂度为 O(n)O(n)O(n)。\n * 空间复杂度：O(1)O(1)O(1)。算法中只用到了 O(1)O(1)O(1) 的额外空间，用来存储答案。\n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2020-01-09 22:22:44Accepted [https://leetcode-cn.com//submissions/detail/42916726/]1 ms91.2%38.2 MBjava2020-01-09 22:18:25Accepted [https://leetcode-cn.com//submissions/detail/42916251/]1 ms91.2%39.3 MBjava# 统计信息\n通过次数提交次数AC比率453088445253.6%# 相似题目\n题目难度缺失的第一个正数 [https://leetcode-cn.com/problems/first-missing-positive/]困难只出现一次的数字 [https://leetcode-cn.com/problems/single-number/]简单寻找重复数 [https://leetcode-cn.com/problems/find-the-duplicate-number/]中等情侣牵手 [https://leetcode-cn.com/problems/couples-holding-hands/]困难",contentLowercase:"# 中文题目\n给定一个包含 0, 1, 2, ..., n中n个数的序列，找出 0 .. n中没有出现在序列中的那个数。\n\n示例 1:\n\n输入: [3,0,1]\n输出: 2\n\n\n示例 2:\n\n输入: [9,6,4,2,3,5,7,0,1]\n输出: 8\n\n\n说明:\n你的算法应具有线性时间复杂度。你能否仅使用额外常数空间来实现?\n\n# 通过代码\nclass solution {\n    public int missingnumber(int[] nums) {\n        int res=nums.length;\n        for (int i = 0; i < nums.length; i++) {\n            res=res^(i^nums[i]);\n        }\n        return res;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\nclass solution {\n    public int missingnumber(int[] nums) {\n        int[] arr=new int[nums.length+1];\n        for (int i = 0; i < nums.length; i++) {\n            arr[nums[i]]=1;\n        }\n        for (int i = 0; i < arr.length; i++) {\n            if (arr[i]==0){\n                return i;\n            }\n        }\n        return 0;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n# 官方题解\n# 方法一：排序\n分析\n\n如果数组是有序的，那么就很容易知道缺失的数字是哪个了。\n\n算法\n\n首先我们对数组进行排序，随后我们可以在常数时间内判断两种特殊情况：0 没有出现在数组的首位，以及 nnn 没有出现在数组的末位。如果这两种特殊情况都不满足，那么缺失的数字一定在 0 和 nnn 之间（不包括两者）。此时我们可以在线性时间内扫描这个数组，如果某一个数比它前面的那个数大了超过 1，那么这两个数之间的那个数即为缺失的数字。\n\nclass solution {\n    public int missingnumber(int[] nums) {\n        arrays.sort(nums);\n\n        // 判断 n 是否出现在末位\n        if (nums[nums.length-1] != nums.length) {\n            return nums.length;\n        }\n        // 判断 0 是否出现在首位\n        else if (nums[0] != 0) {\n            return 0;\n        }\n\n        // 此时缺失的数字一定在 (0, n) 中\n        for (int i = 1; i < nums.length; i++) {\n            int expectednum = nums[i-1] + 1;\n            if (nums[i] != expectednum) {\n                return expectednum;\n            }\n        }\n\n        // 未缺失任何数字（保证函数有返回值）\n        return -1;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\nclass solution:\n    def missingnumber(self, nums):\n        nums.sort()\n\n        # ensure that n is at the last index\n        if nums[-1] != len(nums):\n            return len(nums)\n        # ensure that 0 is at the first index\n        elif nums[0] != 0:\n            return 0\n\n        # if we get here, then the missing number is on the range (0, n)\n        for i in range(1, len(nums)):\n            expected_num = nums[i-1] + 1\n            if nums[i] != expected_num:\n                return expected_num\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n复杂度分析\n\n * 时间复杂度：o(nlog⁡n)o(n\\log n)o(nlogn)。由于排序的时间复杂度为 o(nlog⁡n)o(n\\log n)o(nlogn)，扫描数组的时间复杂度为 o(n)o(n)o(n)，因此总的时间复杂度为 o(nlog⁡n)o(n\\log n)o(nlogn)。\n * 空间复杂度：o(1)o(1)o(1) 或 o(n)o(n)o(n)。空间复杂度取决于使用的排序算法，根据排序算法是否进行原地排序（即不使用额外的数组进行临时存储），空间复杂度为 o(1)o(1)o(1) 或 o(n)o(n)o(n)。\n\n# 方法二：哈希表\n分析\n\n我们可以直接查询每个数是否在数组中出现过来找出缺失的数字。如果使用哈希表，那么每一次查询操作都是常数时间的。\n\n算法\n\n我们将数组中的所有数插入到一个集合中，这样每次查询操作的时间复杂度都是 o(1)o(1)o(1) 的。\n\nclass solution {\n    public int missingnumber(int[] nums) {\n        set<integer> numset = new hashset<integer>();\n        for (int num : nums) numset.add(num);\n\n        int expectednumcount = nums.length + 1;\n        for (int number = 0; number < expectednumcount; number++) {\n            if (!numset.contains(number)) {\n                return number;\n            }\n        }\n        return -1;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\nclass solution:\n    def missingnumber(self, nums):\n        num_set = set(nums)\n        n = len(nums) + 1\n        for number in range(n):\n            if number not in num_set:\n                return number\n\n\n1\n2\n3\n4\n5\n6\n7\n复杂度分析\n\n * 时间复杂度：o(n)o(n)o(n)。集合的插入操作的时间复杂度都是 o(1)o(1)o(1)，一共插入了 nnn 个数，时间复杂度为 o(n)o(n)o(n)。集合的查询操作的时间复杂度同样是 o(1)o(1)o(1)，最多查询 n+1n+1n+1 次，时间复杂度为 o(n)o(n)o(n)。因此总的时间复杂度为 o(n)o(n)o(n)。\n * 空间复杂度：o(n)o(n)o(n)。集合中会存储 nnn 个数，因此空间复杂度为 o(n)o(n)o(n)。\n\n# 方法三：位运算\n分析\n\n由于异或运算（xor）满足结合律，并且对一个数进行两次完全相同的异或运算会得到原来的数，因此我们可以通过异或运算找到缺失的数字。\n\n算法\n\n我们知道数组中有 nnn 个数，并且缺失的数在 [0..n][0..n][0..n] 中。因此我们可以先得到 [0..n][0..n][0..n] 的异或值，再将结果对数组中的每一个数进行一次异或运算。未缺失的数在 [0..n][0..n][0..n] 和数组中各出现一次，因此异或后得到 0。而缺失的数字只在 [0..n][0..n][0..n] 中出现了一次，在数组中没有出现，因此最终的异或结果即为这个缺失的数字。\n\n在编写代码时，由于 [0..n][0..n][0..n] 恰好是这个数组的下标加上 nnn，因此可以用一次循环完成所有的异或运算，例如下面这个例子：\n\n下标0123数字0134可以将结果的初始值设为 nnn，再对数组中的每一个数以及它的下标进行一个异或运算，即：\n\nmissing=4∧(0∧0)∧(1∧1)∧(2∧3)∧(3∧4)=(4∧4)∧(0∧0)∧(1∧1)∧(3∧3)∧2=0∧0∧0∧0∧2=2\\begin{aligned} \\mathrm{missing} &= 4 \\wedge (0 \\wedge 0) \\wedge (1 \\wedge 1) \\wedge (2 \\wedge 3) \\wedge (3 \\wedge 4) \\\\ &= (4 \\wedge 4) \\wedge (0 \\wedge 0) \\wedge (1 \\wedge 1) \\wedge (3 \\wedge 3) \\wedge 2 \\\\ &= 0 \\wedge 0 \\wedge 0 \\wedge 0 \\wedge 2 \\\\ &= 2 \\end{aligned}missing​=4∧(0∧0)∧(1∧1)∧(2∧3)∧(3∧4)=(4∧4)∧(0∧0)∧(1∧1)∧(3∧3)∧2=0∧0∧0∧0∧2=2​\n\n就得到了缺失的数字为 2。\n\nclass solution {\n    public int missingnumber(int[] nums) {\n        int missing = nums.length;\n        for (int i = 0; i < nums.length; i++) {\n            missing ^= i ^ nums[i];\n        }\n        return missing;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\nclass solution:\n    def missingnumber(self, nums):\n        missing = len(nums)\n        for i, num in enumerate(nums):\n            missing ^= i ^ num\n        return missing\n\n\n1\n2\n3\n4\n5\n6\n复杂度分析\n\n * 时间复杂度：o(n)o(n)o(n)。这里假设异或运算的时间复杂度是常数的，总共会进行 o(n)o(n)o(n) 次异或运算，因此总的时间复杂度为 o(n)o(n)o(n)。\n * 空间复杂度：o(1)o(1)o(1)。算法中只用到了 o(1)o(1)o(1) 的额外空间，用来存储答案。\n\n# 方法四：数学\n分析\n\n我们可以用 高斯求和公式 [https://baike.baidu.com/item/%e9%ab%98%e6%96%af%e6%b1%82%e5%92%8c] 求出 [0..n][0..n][0..n] 的和，减去数组中所有数的和，就得到了缺失的数字。高斯求和公式即\n\n∑i=0ni=n(n+1)2\\sum_{i=0}^{n}i = \\frac{n(n+1)}{2}i=0∑n​i=2n(n+1)​\n\n算法\n\n我们在线性时间内可以求出数组中所有数的和，并在常数时间内求出前 n+1n+1n+1 个自然数（包括 0）的和，将后者减去前者，就得到了缺失的数字。\n\nclass solution {\n    public int missingnumber(int[] nums) {\n        int expectedsum = nums.length*(nums.length + 1)/2;\n        int actualsum = 0;\n        for (int num : nums) actualsum += num;\n        return expectedsum - actualsum;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\nclass solution:\n    def missingnumber(self, nums):\n        expected_sum = len(nums)*(len(nums)+1)//2\n        actual_sum = sum(nums)\n        return expected_sum - actual_sum\n\n\n1\n2\n3\n4\n5\n复杂度分析\n\n * 时间复杂度：o(n)o(n)o(n)。求出数组中所有数的和的时间复杂度为 o(n)o(n)o(n)，高斯求和公式的时间复杂度为 o(1)o(1)o(1)，因此总的时间复杂度为 o(n)o(n)o(n)。\n * 空间复杂度：o(1)o(1)o(1)。算法中只用到了 o(1)o(1)o(1) 的额外空间，用来存储答案。\n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2020-01-09 22:22:44accepted [https://leetcode-cn.com//submissions/detail/42916726/]1 ms91.2%38.2 mbjava2020-01-09 22:18:25accepted [https://leetcode-cn.com//submissions/detail/42916251/]1 ms91.2%39.3 mbjava# 统计信息\n通过次数提交次数ac比率453088445253.6%# 相似题目\n题目难度缺失的第一个正数 [https://leetcode-cn.com/problems/first-missing-positive/]困难只出现一次的数字 [https://leetcode-cn.com/problems/single-number/]简单寻找重复数 [https://leetcode-cn.com/problems/find-the-duplicate-number/]中等情侣牵手 [https://leetcode-cn.com/problems/couples-holding-hands/]困难"},{title:"278-第一个错误的版本(First Bad Version)",frontmatter:{title:"278-第一个错误的版本(First Bad Version)",date:"2020-01-03T00:00:00.000Z",categories:["简单"],tags:["二分查找<Binary Search>"]},regularPath:"/views/%E7%AE%80%E5%8D%95/0278-%E7%AC%AC%E4%B8%80%E4%B8%AA%E9%94%99%E8%AF%AF%E7%9A%84%E7%89%88%E6%9C%AC.html",relativePath:"views/简单/0278-第一个错误的版本.md",key:"v-b9ae42f8",path:"/views/%E7%AE%80%E5%8D%95/0278-%E7%AC%AC%E4%B8%80%E4%B8%AA%E9%94%99%E8%AF%AF%E7%9A%84%E7%89%88%E6%9C%AC.html",headers:[{level:2,title:"中文题目",slug:"中文题目",charIndex:2},{level:2,title:"通过代码",slug:"通过代码",charIndex:390},{level:2,title:"官方题解",slug:"官方题解",charIndex:947},{level:2,title:"提交历史",slug:"提交历史",charIndex:3231},{level:2,title:"统计信息",slug:"统计信息",charIndex:3565},{level:2,title:"相似题目",slug:"相似题目",charIndex:3599}],lastUpdated:"4/11/2021, 1:15:21 PM",headersStr:"中文题目 通过代码 官方题解 提交历史 统计信息 相似题目",content:"# 中文题目\n你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。\n\n假设你有 n 个版本 [1, 2, ..., n]，你想找出导致之后所有版本出错的第一个错误的版本。\n\n你可以通过调用bool isBadVersion(version)接口来判断版本号 version 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。\n\n示例:\n\n给定 n = 5，并且 version = 4 是第一个错误的版本。\n\n调用 isBadVersion(3) -> false\n调用 isBadVersion(5) -> true\n调用 isBadVersion(4) -> true\n\n所以，4 是第一个错误的版本。 \n\n# 通过代码\n/* The isBadVersion API is defined in the parent class VersionControl.\n      boolean isBadVersion(int version); */\n\npublic class Solution extends VersionControl {\n    public int firstBadVersion(int n) {\n        int left = 1;\n        int right = n;\n        while (left < right) {\n            int middle = left + ( right - left) /2 ;\n            if (isBadVersion(middle)){\n                right=middle;\n            }else {\n                left = middle+1;\n            }\n        }\n        return left;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n# 官方题解\n这是一道较为简单的题目，但是有一个小陷阱。除此之外，这道题的算法是比较显然的。\n\n# 方法一：线性扫描 [超出时间限制]\n最直接的方法是进行一次线性扫描，即对 [1..n][1..n][1..n] 都调用一次 isBadVersion。\n\npublic int firstBadVersion(int n) {\n    for (int i = 1; i < n; i++) {\n        if (isBadVersion(i)) {\n            return i;\n        }\n    }\n    return n;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n复杂度分析\n\n * 时间复杂度：O(n)O(n)O(n)。在最坏的情况下，最多可能会调用 isBadVersion n−1n-1n−1 次，因此总的时间复杂度为 O(n)O(n)O(n)。\n * 空间复杂度：O(1)O(1)O(1)。\n\n# 方法二：二分查找 [通过]\n不难看出，这道题可以用经典的二分查找算法求解。我们通过一个例子，来说明二分查找如何在每次操作中减少一半的搜索空间，以此减少时间复杂度。\n\n场景一：isBadVersion(mid) => false\n\n 1 2 3 4 5 6 7 8 9\n G G G G G G B B B       G = 正确版本，B = 错误版本\n |       |       |\nleft    mid    right\n\n\n场景一中，isBadVersion(mid) 返回 false，因此我们知道 mid\\mathrm{mid}mid 左侧（包括自身）的所有版本都是正确的。所以我们令 left=mid+1\\mathrm{left}=\\mathrm{mid}+1left=mid+1，把下一次的搜索空间变为 [mid+1,right][\\mathrm{mid}+1,\\mathrm{right}][mid+1,right]。\n\n场景二：isBadVersion(mid) => true\n\n 1 2 3 4 5 6 7 8 9\n G G G B B B B B B       G = 正确版本，B = 错误版本\n |       |       |\nleft    mid    right\n\n\n场景二中，isBadVersion(mid) 返回 true，因此我们知道 mid\\mathrm{mid}mid 右侧（不包括自身）的所有版本的不可能是第一个错误的版本。所以我们令 right=mid\\mathrm{right}=\\mathrm{mid}right=mid，把下一次的搜索空间变为 [left,mid][\\mathrm{left},\\mathrm{mid}][left,mid]。\n\n在二分查找的每次操作中，我们都用 left\\mathrm{left}left 和 right\\mathrm{right}right 表示搜索空间的左右边界，因此在初始化时，需要将 left\\mathrm{left}left 的值设置为 1，并将 right\\mathrm{right}right 的值设置为 nnn。当某一次操作后，left\\mathrm{left}left 和 right\\mathrm{right}right 的值相等，此时它们就表示了第一个错误版本的位置。可以用数学归纳法 证明 [http://www.cs.cornell.edu/courses/cs211/2006sp/Lectures/L06-Induction/binary_search.html] 二分查找算法的正确性。\n\n在二分查找中，选取 mid\\mathrm{mid}mid 的方法一般为 mid=⌊12(left+right)⌋\\mathrm{mid}=\\lfloor\\frac{1}{2}(\\mathrm{left}+\\mathrm{right})\\rfloormid=⌊21​(left+right)⌋。如果使用的编程语言会有整数溢出的情况（例如 C++，Java），那么可以用 mid=left+⌊12(right−left)⌋\\mathrm{mid}=\\mathrm{left}+\\lfloor\\frac{1}{2}(\\mathrm{right}-\\mathrm{left})\\rfloormid=left+⌊21​(right−left)⌋代替前者。\n\npublic int firstBadVersion(int n) {\n    int left = 1;\n    int right = n;\n    while (left < right) {\n        int mid = left + (right - left) / 2;\n        if (isBadVersion(mid)) {\n            right = mid;\n        } else {\n            left = mid + 1;\n        }\n    }\n    return left;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n复杂度分析\n\n * 时间复杂度：O(log⁡n)O(\\log n)O(logn)。搜索空间每次减少一半，因此时间复杂度为 O(log⁡n)O(\\log n)O(logn)。\n * 空间复杂度：O(1)O(1)O(1)。\n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2020-01-03 22:37:23Accepted [https://leetcode-cn.com//submissions/detail/42194825/]13 ms79.62%33.1 MBjava2020-01-03 22:30:19Wrong Answer [https://leetcode-cn.com//submissions/detail/42194229/]N/AN/AN/Ajava2020-01-03 22:27:46Wrong Answer [https://leetcode-cn.com//submissions/detail/42194008/]N/AN/AN/Ajava# 统计信息\n通过次数提交次数AC比率328599161935.9%# 相似题目\n题目难度在排序数组中查找元素的第一个和最后一个位置 [https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/]中等搜索插入位置 [https://leetcode-cn.com/problems/search-insert-position/]简单猜数字大小 [https://leetcode-cn.com/problems/guess-number-higher-or-lower/]简单",contentLowercase:"# 中文题目\n你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。\n\n假设你有 n 个版本 [1, 2, ..., n]，你想找出导致之后所有版本出错的第一个错误的版本。\n\n你可以通过调用bool isbadversion(version)接口来判断版本号 version 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 api 的次数。\n\n示例:\n\n给定 n = 5，并且 version = 4 是第一个错误的版本。\n\n调用 isbadversion(3) -> false\n调用 isbadversion(5) -> true\n调用 isbadversion(4) -> true\n\n所以，4 是第一个错误的版本。 \n\n# 通过代码\n/* the isbadversion api is defined in the parent class versioncontrol.\n      boolean isbadversion(int version); */\n\npublic class solution extends versioncontrol {\n    public int firstbadversion(int n) {\n        int left = 1;\n        int right = n;\n        while (left < right) {\n            int middle = left + ( right - left) /2 ;\n            if (isbadversion(middle)){\n                right=middle;\n            }else {\n                left = middle+1;\n            }\n        }\n        return left;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n# 官方题解\n这是一道较为简单的题目，但是有一个小陷阱。除此之外，这道题的算法是比较显然的。\n\n# 方法一：线性扫描 [超出时间限制]\n最直接的方法是进行一次线性扫描，即对 [1..n][1..n][1..n] 都调用一次 isbadversion。\n\npublic int firstbadversion(int n) {\n    for (int i = 1; i < n; i++) {\n        if (isbadversion(i)) {\n            return i;\n        }\n    }\n    return n;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n复杂度分析\n\n * 时间复杂度：o(n)o(n)o(n)。在最坏的情况下，最多可能会调用 isbadversion n−1n-1n−1 次，因此总的时间复杂度为 o(n)o(n)o(n)。\n * 空间复杂度：o(1)o(1)o(1)。\n\n# 方法二：二分查找 [通过]\n不难看出，这道题可以用经典的二分查找算法求解。我们通过一个例子，来说明二分查找如何在每次操作中减少一半的搜索空间，以此减少时间复杂度。\n\n场景一：isbadversion(mid) => false\n\n 1 2 3 4 5 6 7 8 9\n g g g g g g b b b       g = 正确版本，b = 错误版本\n |       |       |\nleft    mid    right\n\n\n场景一中，isbadversion(mid) 返回 false，因此我们知道 mid\\mathrm{mid}mid 左侧（包括自身）的所有版本都是正确的。所以我们令 left=mid+1\\mathrm{left}=\\mathrm{mid}+1left=mid+1，把下一次的搜索空间变为 [mid+1,right][\\mathrm{mid}+1,\\mathrm{right}][mid+1,right]。\n\n场景二：isbadversion(mid) => true\n\n 1 2 3 4 5 6 7 8 9\n g g g b b b b b b       g = 正确版本，b = 错误版本\n |       |       |\nleft    mid    right\n\n\n场景二中，isbadversion(mid) 返回 true，因此我们知道 mid\\mathrm{mid}mid 右侧（不包括自身）的所有版本的不可能是第一个错误的版本。所以我们令 right=mid\\mathrm{right}=\\mathrm{mid}right=mid，把下一次的搜索空间变为 [left,mid][\\mathrm{left},\\mathrm{mid}][left,mid]。\n\n在二分查找的每次操作中，我们都用 left\\mathrm{left}left 和 right\\mathrm{right}right 表示搜索空间的左右边界，因此在初始化时，需要将 left\\mathrm{left}left 的值设置为 1，并将 right\\mathrm{right}right 的值设置为 nnn。当某一次操作后，left\\mathrm{left}left 和 right\\mathrm{right}right 的值相等，此时它们就表示了第一个错误版本的位置。可以用数学归纳法 证明 [http://www.cs.cornell.edu/courses/cs211/2006sp/lectures/l06-induction/binary_search.html] 二分查找算法的正确性。\n\n在二分查找中，选取 mid\\mathrm{mid}mid 的方法一般为 mid=⌊12(left+right)⌋\\mathrm{mid}=\\lfloor\\frac{1}{2}(\\mathrm{left}+\\mathrm{right})\\rfloormid=⌊21​(left+right)⌋。如果使用的编程语言会有整数溢出的情况（例如 c++，java），那么可以用 mid=left+⌊12(right−left)⌋\\mathrm{mid}=\\mathrm{left}+\\lfloor\\frac{1}{2}(\\mathrm{right}-\\mathrm{left})\\rfloormid=left+⌊21​(right−left)⌋代替前者。\n\npublic int firstbadversion(int n) {\n    int left = 1;\n    int right = n;\n    while (left < right) {\n        int mid = left + (right - left) / 2;\n        if (isbadversion(mid)) {\n            right = mid;\n        } else {\n            left = mid + 1;\n        }\n    }\n    return left;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n复杂度分析\n\n * 时间复杂度：o(log⁡n)o(\\log n)o(logn)。搜索空间每次减少一半，因此时间复杂度为 o(log⁡n)o(\\log n)o(logn)。\n * 空间复杂度：o(1)o(1)o(1)。\n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2020-01-03 22:37:23accepted [https://leetcode-cn.com//submissions/detail/42194825/]13 ms79.62%33.1 mbjava2020-01-03 22:30:19wrong answer [https://leetcode-cn.com//submissions/detail/42194229/]n/an/an/ajava2020-01-03 22:27:46wrong answer [https://leetcode-cn.com//submissions/detail/42194008/]n/an/an/ajava# 统计信息\n通过次数提交次数ac比率328599161935.9%# 相似题目\n题目难度在排序数组中查找元素的第一个和最后一个位置 [https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/]中等搜索插入位置 [https://leetcode-cn.com/problems/search-insert-position/]简单猜数字大小 [https://leetcode-cn.com/problems/guess-number-higher-or-lower/]简单"},{title:"283-移动零(Move Zeroes)",frontmatter:{title:"283-移动零(Move Zeroes)",date:"2021-04-14T00:00:00.000Z",categories:["简单"],tags:["数组<Array>","双指针<Two Pointers>"]},regularPath:"/views/%E7%AE%80%E5%8D%95/0283-%E7%A7%BB%E5%8A%A8%E9%9B%B6.html",relativePath:"views/简单/0283-移动零.md",key:"v-2f53649e",path:"/views/%E7%AE%80%E5%8D%95/0283-%E7%A7%BB%E5%8A%A8%E9%9B%B6.html",headers:[{level:2,title:"中文题目",slug:"中文题目",charIndex:2},{level:2,title:"通过代码",slug:"通过代码",charIndex:143},{level:2,title:"我的笔记",slug:"我的笔记",charIndex:4225},{level:2,title:"高赞题解",slug:"高赞题解",charIndex:4257},{level:2,title:"两次遍历",slug:"两次遍历",charIndex:4264},{level:2,title:"一次遍历",slug:"一次遍历",charIndex:4282},{level:2,title:"提交历史",slug:"提交历史",charIndex:6390},{level:2,title:"统计信息",slug:"统计信息",charIndex:7129},{level:2,title:"相似题目",slug:"相似题目",charIndex:7165}],lastUpdated:"4/11/2021, 1:15:21 PM",headersStr:"中文题目 通过代码 我的笔记 高赞题解 两次遍历 一次遍历 提交历史 统计信息 相似题目",content:'# 中文题目\n给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。\n\n示例:\n\n输入: [0,1,0,3,12]\n输出: [1,3,12,0,0]\n\n说明:\n\n 1. 必须在原数组上操作，不能拷贝额外的数组。\n 2. 尽量减少操作次数。\n\n# 通过代码\n    class Solution {\n        public void moveZeroes(int[] nums) {\n            int j = 0;\n            for(int i = 1; i<nums.length; i++){\n                if(nums[j] == 0){\n                    if(nums[i] != 0){\n                        nums[j] = nums[i];\n                        nums[i] = 0;\n                        j++;\n                    }\n                }\n                else{\n                    j++;\n                }\n            }\n        }\n\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n    class Solution {\n        public void moveZeroes(int[] nums) {\n            int length = nums.length;\n            int index = 0;\n            for (int i = 0; i < length; i++) {\n                if (nums[i] != 0) {\n                    nums[index++] = nums[i];\n                }\n            }\n            while (index < length) {\n                nums[index++] = 0;\n            }\n\n            for (int i = 0; i < nums.length; i++) {\n                System.out.println(nums[i]);\n            }\n        }\n\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\nclass Solution {\npublic:\n    void moveZeroes(vector<int>& nums) {\n         int k=0;\n            for (int i = 0; i < nums.size(); i++) {\n                if (nums[i])\n                    swap(nums[k++],nums[i]);\n            }\n    }\n};\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n    class Solution {\n        public void moveZeroes(int[] nums) {\n            int j = 0;\n            for(int i = 1; i<nums.length; i++){\n                if(nums[j] == 0){\n                    if(nums[i] != 0){\n                        nums[j] = nums[i];\n                        nums[i] = 0;\n                        j++;\n                    }\n                }\n                else{\n                    j++;\n                }\n            }\n        }\n\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n    class Solution {\n        public void moveZeroes(int[] nums) {\n            int length = nums.length;\n            int index = 0;\n            for (int i = 0; i < length; i++) {\n                if (nums[i] != 0) {\n                    nums[index++] = nums[i];\n                }\n            }\n            while (index < length) {\n                nums[index++] = 0;\n            }\n\n            for (int i = 0; i < nums.length; i++) {\n                System.out.println(nums[i]);\n            }\n        }\n\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n    class Solution {\n        public void moveZeroes(int[] nums) {\n            int pos;\n            for (int i = nums.length-1; i >=0 ; i--) {\n                pos=i;\n                if (nums[i]==0){\n                    for (int j = i+1; j < nums.length; j++,i++) {\n                        swap(nums,i,j);\n                    }\n                }\n                i=pos;\n            }\n            // for (int i = 0; i < nums.length; i++) {\n            //     System.out.println(nums[i]);\n            // }\n        }\n\n        private void swap(int[] nums, int i, int j) {\n            int temp=nums[i];\n            nums[i]=nums[j];\n            nums[j]=temp;\n        }\n\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\nclass Solution {\n    public void moveZeroes(int[] nums) {\n        int i=0;\n            for (int j = 0; j < nums.length; j++) {\n                if (nums[j]!=0){\n                    int temp=nums[j];\n                    nums[j]=nums[i];\n                    nums[i]=temp;\n                    i++;\n                }\n            }\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\nclass Solution {\n    public void moveZeroes(int[] nums) {\n        int i=0;\n            for (int j = 0; j < nums.length; j++) {\n                if (nums[j]!=0){\n                    int temp=nums[j];\n                    nums[j]=nums[i];\n                    nums[i]=temp;\n                    i++;\n                }\n            }\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\nclass Solution {\npublic:\n    void moveZeroes(vector<int>& nums) {\n         int k=0;\n            for (int i = 0; i < nums.size(); i++) {\n                if (nums[i])\n                    swap(nums[k++],nums[i]);\n            }\n    }\n};\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n# 我的笔记\n可以通过双指针的方式，也可以通过两重循环的方式\n\n# 高赞题解\n# 两次遍历\n我们创建两个指针i和j，第一次遍历的时候指针j用来记录当前有多少非0元素。即遍历的时候每遇到一个非0元素就将其往数组左边挪，第一次遍历完后，j指针的下标就指向了最后一个非0元素下标。\n第二次遍历的时候，起始位置就从j开始到结束，将剩下的这段区域内的元素全部置为0。\n动画演示：\n\n{:width="450px"}{:align="center"} 时间复杂度: O(n)\n空间复杂度: O(1)\n代码实现:\n\nclass Solution {\n\tpublic void moveZeroes(int[] nums) {\n\t\tif(nums==null) {\n\t\t\treturn;\n\t\t}\n\t\t//第一次遍历的时候，j指针记录非0的个数，只要是非0的统统都赋给nums[j]\n\t\tint j = 0;\n\t\tfor(int i=0;i<nums.length;++i) {\n\t\t\tif(nums[i]!=0) {\n\t\t\t\tnums[j++] = nums[i];\n\t\t\t}\n\t\t}\n\t\t//非0元素统计完了，剩下的都是0了\n\t\t//所以第二次遍历把末尾的元素都赋为0即可\n\t\tfor(int i=j;i<nums.length;++i) {\n\t\t\tnums[i] = 0;\n\t\t}\n\t}\n}\t\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\nclass Solution(object):\n\tdef moveZeroes(self, nums):\n\t\t"""\n\t\t:type nums: List[int]\n\t\t:rtype: None Do not return anything, modify nums in-place instead.\n\t\t"""\n\t\tif not nums:\n\t\t\treturn 0\n\t\t# 第一次遍历的时候，j指针记录非0的个数，只要是非0的统统都赋给nums[j]\t\n\t\tj = 0\n\t\tfor i in xrange(len(nums)):\n\t\t\tif nums[i]:\n\t\t\t\tnums[j] = nums[i]\n\t\t\t\tj += 1\n\t\t# 非0元素统计完了，剩下的都是0了\n\t\t# 所以第二次遍历把末尾的元素都赋为0即可\n\t\tfor i in xrange(j,len(nums)):\n\t\t\tnums[i] = 0\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n# 一次遍历\n这里参考了快速排序的思想，快速排序首先要确定一个待分割的元素做中间点x，然后把所有小于等于x的元素放到x的左边，大于x的元素放到其右边。\n这里我们可以用0当做这个中间点，把不等于0(注意题目没说不能有负数)的放到中间点的左边，等于0的放到其右边。 这的中间点就是0本身，所以实现起来比快速排序简单很多，我们使用两个指针i和j，只要nums[i]!=0，我们就交换nums[i]和nums[j]\n请对照动态图来理解：\n{:width="450px"}{:align="center"} 时间复杂度: O(n)\n空间复杂度: O(1)\n代码实现:\n\nclass Solution {\n\tpublic void moveZeroes(int[] nums) {\n\t\tif(nums==null) {\n\t\t\treturn;\n\t\t}\n\t\t//两个指针i和j\n\t\tint j = 0;\n\t\tfor(int i=0;i<nums.length;i++) {\n\t\t\t//当前元素!=0，就把其交换到左边，等于0的交换到右边\n\t\t\tif(nums[i]!=0) {\n\t\t\t\tint tmp = nums[i];\n\t\t\t\tnums[i] = nums[j];\n\t\t\t\tnums[j++] = tmp;\n\t\t\t}\n\t\t}\n\t}\n}\t\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\nclass Solution(object):\n\tdef moveZeroes(self, nums):\n\t\t"""\n\t\t:type nums: List[int]\n\t\t:rtype: None Do not return anything, modify nums in-place instead.\n\t\t"""\n\t\tif not nums:\n\t\t\treturn 0\n\t\t# 两个指针i和j\n\t\tj = 0\n\t\tfor i in xrange(len(nums)):\n\t\t\t# 当前元素!=0，就把其交换到左边，等于0的交换到右边\n\t\t\tif nums[i]:\n\t\t\t\tnums[j],nums[i] = nums[i],nums[j]\n\t\t\t\tj += 1\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n(全文完)\n\n欢迎关注 👉👉👉 我 [https://leetcode-cn.com/u/wang_ni_ma/] 👈👈👈\n\n如果能再点个赞 👍👍 就更感激啦 💓💓\n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2021-04-14 21:26:17Accepted [https://leetcode-cn.com//submissions/detail/167926066/]0 ms100.0%38.8 MBjava2021-04-14 20:56:49Accepted [https://leetcode-cn.com//submissions/detail/167911705/]33 ms100.0%39.5 MBjava2021-04-14 20:42:35Accepted [https://leetcode-cn.com//submissions/detail/167905204/]11 ms100.0%39 MBjava2018-07-27 20:00:47Accepted [https://leetcode-cn.com//submissions/detail/4739642/]2 ms100.0%N/Ajava2018-05-13 23:56:34Accepted [https://leetcode-cn.com//submissions/detail/2235574/]3 ms100.0%N/Ajava2018-05-13 23:50:43Accepted [https://leetcode-cn.com//submissions/detail/2235408/]16 ms100.0%N/Acpp2018-05-13 23:50:16Wrong Answer [https://leetcode-cn.com//submissions/detail/2235398/]N/AN/AN/Acpp# 统计信息\n通过次数提交次数AC比率35117055095663.7%# 相似题目\n题目难度移除元素 [https://leetcode-cn.com/problems/remove-element/]简单',contentLowercase:'# 中文题目\n给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。\n\n示例:\n\n输入: [0,1,0,3,12]\n输出: [1,3,12,0,0]\n\n说明:\n\n 1. 必须在原数组上操作，不能拷贝额外的数组。\n 2. 尽量减少操作次数。\n\n# 通过代码\n    class solution {\n        public void movezeroes(int[] nums) {\n            int j = 0;\n            for(int i = 1; i<nums.length; i++){\n                if(nums[j] == 0){\n                    if(nums[i] != 0){\n                        nums[j] = nums[i];\n                        nums[i] = 0;\n                        j++;\n                    }\n                }\n                else{\n                    j++;\n                }\n            }\n        }\n\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n    class solution {\n        public void movezeroes(int[] nums) {\n            int length = nums.length;\n            int index = 0;\n            for (int i = 0; i < length; i++) {\n                if (nums[i] != 0) {\n                    nums[index++] = nums[i];\n                }\n            }\n            while (index < length) {\n                nums[index++] = 0;\n            }\n\n            for (int i = 0; i < nums.length; i++) {\n                system.out.println(nums[i]);\n            }\n        }\n\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\nclass solution {\npublic:\n    void movezeroes(vector<int>& nums) {\n         int k=0;\n            for (int i = 0; i < nums.size(); i++) {\n                if (nums[i])\n                    swap(nums[k++],nums[i]);\n            }\n    }\n};\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n    class solution {\n        public void movezeroes(int[] nums) {\n            int j = 0;\n            for(int i = 1; i<nums.length; i++){\n                if(nums[j] == 0){\n                    if(nums[i] != 0){\n                        nums[j] = nums[i];\n                        nums[i] = 0;\n                        j++;\n                    }\n                }\n                else{\n                    j++;\n                }\n            }\n        }\n\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n    class solution {\n        public void movezeroes(int[] nums) {\n            int length = nums.length;\n            int index = 0;\n            for (int i = 0; i < length; i++) {\n                if (nums[i] != 0) {\n                    nums[index++] = nums[i];\n                }\n            }\n            while (index < length) {\n                nums[index++] = 0;\n            }\n\n            for (int i = 0; i < nums.length; i++) {\n                system.out.println(nums[i]);\n            }\n        }\n\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n    class solution {\n        public void movezeroes(int[] nums) {\n            int pos;\n            for (int i = nums.length-1; i >=0 ; i--) {\n                pos=i;\n                if (nums[i]==0){\n                    for (int j = i+1; j < nums.length; j++,i++) {\n                        swap(nums,i,j);\n                    }\n                }\n                i=pos;\n            }\n            // for (int i = 0; i < nums.length; i++) {\n            //     system.out.println(nums[i]);\n            // }\n        }\n\n        private void swap(int[] nums, int i, int j) {\n            int temp=nums[i];\n            nums[i]=nums[j];\n            nums[j]=temp;\n        }\n\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\nclass solution {\n    public void movezeroes(int[] nums) {\n        int i=0;\n            for (int j = 0; j < nums.length; j++) {\n                if (nums[j]!=0){\n                    int temp=nums[j];\n                    nums[j]=nums[i];\n                    nums[i]=temp;\n                    i++;\n                }\n            }\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\nclass solution {\n    public void movezeroes(int[] nums) {\n        int i=0;\n            for (int j = 0; j < nums.length; j++) {\n                if (nums[j]!=0){\n                    int temp=nums[j];\n                    nums[j]=nums[i];\n                    nums[i]=temp;\n                    i++;\n                }\n            }\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\nclass solution {\npublic:\n    void movezeroes(vector<int>& nums) {\n         int k=0;\n            for (int i = 0; i < nums.size(); i++) {\n                if (nums[i])\n                    swap(nums[k++],nums[i]);\n            }\n    }\n};\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n# 我的笔记\n可以通过双指针的方式，也可以通过两重循环的方式\n\n# 高赞题解\n# 两次遍历\n我们创建两个指针i和j，第一次遍历的时候指针j用来记录当前有多少非0元素。即遍历的时候每遇到一个非0元素就将其往数组左边挪，第一次遍历完后，j指针的下标就指向了最后一个非0元素下标。\n第二次遍历的时候，起始位置就从j开始到结束，将剩下的这段区域内的元素全部置为0。\n动画演示：\n\n{:width="450px"}{:align="center"} 时间复杂度: o(n)\n空间复杂度: o(1)\n代码实现:\n\nclass solution {\n\tpublic void movezeroes(int[] nums) {\n\t\tif(nums==null) {\n\t\t\treturn;\n\t\t}\n\t\t//第一次遍历的时候，j指针记录非0的个数，只要是非0的统统都赋给nums[j]\n\t\tint j = 0;\n\t\tfor(int i=0;i<nums.length;++i) {\n\t\t\tif(nums[i]!=0) {\n\t\t\t\tnums[j++] = nums[i];\n\t\t\t}\n\t\t}\n\t\t//非0元素统计完了，剩下的都是0了\n\t\t//所以第二次遍历把末尾的元素都赋为0即可\n\t\tfor(int i=j;i<nums.length;++i) {\n\t\t\tnums[i] = 0;\n\t\t}\n\t}\n}\t\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\nclass solution(object):\n\tdef movezeroes(self, nums):\n\t\t"""\n\t\t:type nums: list[int]\n\t\t:rtype: none do not return anything, modify nums in-place instead.\n\t\t"""\n\t\tif not nums:\n\t\t\treturn 0\n\t\t# 第一次遍历的时候，j指针记录非0的个数，只要是非0的统统都赋给nums[j]\t\n\t\tj = 0\n\t\tfor i in xrange(len(nums)):\n\t\t\tif nums[i]:\n\t\t\t\tnums[j] = nums[i]\n\t\t\t\tj += 1\n\t\t# 非0元素统计完了，剩下的都是0了\n\t\t# 所以第二次遍历把末尾的元素都赋为0即可\n\t\tfor i in xrange(j,len(nums)):\n\t\t\tnums[i] = 0\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n# 一次遍历\n这里参考了快速排序的思想，快速排序首先要确定一个待分割的元素做中间点x，然后把所有小于等于x的元素放到x的左边，大于x的元素放到其右边。\n这里我们可以用0当做这个中间点，把不等于0(注意题目没说不能有负数)的放到中间点的左边，等于0的放到其右边。 这的中间点就是0本身，所以实现起来比快速排序简单很多，我们使用两个指针i和j，只要nums[i]!=0，我们就交换nums[i]和nums[j]\n请对照动态图来理解：\n{:width="450px"}{:align="center"} 时间复杂度: o(n)\n空间复杂度: o(1)\n代码实现:\n\nclass solution {\n\tpublic void movezeroes(int[] nums) {\n\t\tif(nums==null) {\n\t\t\treturn;\n\t\t}\n\t\t//两个指针i和j\n\t\tint j = 0;\n\t\tfor(int i=0;i<nums.length;i++) {\n\t\t\t//当前元素!=0，就把其交换到左边，等于0的交换到右边\n\t\t\tif(nums[i]!=0) {\n\t\t\t\tint tmp = nums[i];\n\t\t\t\tnums[i] = nums[j];\n\t\t\t\tnums[j++] = tmp;\n\t\t\t}\n\t\t}\n\t}\n}\t\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\nclass solution(object):\n\tdef movezeroes(self, nums):\n\t\t"""\n\t\t:type nums: list[int]\n\t\t:rtype: none do not return anything, modify nums in-place instead.\n\t\t"""\n\t\tif not nums:\n\t\t\treturn 0\n\t\t# 两个指针i和j\n\t\tj = 0\n\t\tfor i in xrange(len(nums)):\n\t\t\t# 当前元素!=0，就把其交换到左边，等于0的交换到右边\n\t\t\tif nums[i]:\n\t\t\t\tnums[j],nums[i] = nums[i],nums[j]\n\t\t\t\tj += 1\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n(全文完)\n\n欢迎关注 👉👉👉 我 [https://leetcode-cn.com/u/wang_ni_ma/] 👈👈👈\n\n如果能再点个赞 👍👍 就更感激啦 💓💓\n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2021-04-14 21:26:17accepted [https://leetcode-cn.com//submissions/detail/167926066/]0 ms100.0%38.8 mbjava2021-04-14 20:56:49accepted [https://leetcode-cn.com//submissions/detail/167911705/]33 ms100.0%39.5 mbjava2021-04-14 20:42:35accepted [https://leetcode-cn.com//submissions/detail/167905204/]11 ms100.0%39 mbjava2018-07-27 20:00:47accepted [https://leetcode-cn.com//submissions/detail/4739642/]2 ms100.0%n/ajava2018-05-13 23:56:34accepted [https://leetcode-cn.com//submissions/detail/2235574/]3 ms100.0%n/ajava2018-05-13 23:50:43accepted [https://leetcode-cn.com//submissions/detail/2235408/]16 ms100.0%n/acpp2018-05-13 23:50:16wrong answer [https://leetcode-cn.com//submissions/detail/2235398/]n/an/an/acpp# 统计信息\n通过次数提交次数ac比率35117055095663.7%# 相似题目\n题目难度移除元素 [https://leetcode-cn.com/problems/remove-element/]简单'},{title:"290-单词规律(Word Pattern)",frontmatter:{title:"290-单词规律(Word Pattern)",date:"2018-06-01T00:00:00.000Z",categories:["简单"],tags:["哈希表<Hash Table>"]},regularPath:"/views/%E7%AE%80%E5%8D%95/0290-%E5%8D%95%E8%AF%8D%E8%A7%84%E5%BE%8B.html",relativePath:"views/简单/0290-单词规律.md",key:"v-3f69c3c2",path:"/views/%E7%AE%80%E5%8D%95/0290-%E5%8D%95%E8%AF%8D%E8%A7%84%E5%BE%8B.html",headers:[{level:2,title:"中文题目",slug:"中文题目",charIndex:2},{level:2,title:"通过代码",slug:"通过代码",charIndex:410},{level:2,title:"高赞题解",slug:"高赞题解",charIndex:1786},{level:2,title:"提交历史",slug:"提交历史",charIndex:1959},{level:2,title:"统计信息",slug:"统计信息",charIndex:2087},{level:2,title:"相似题目",slug:"相似题目",charIndex:2121}],lastUpdated:"4/11/2021, 1:15:21 PM",headersStr:"中文题目 通过代码 高赞题解 提交历史 统计信息 相似题目",content:'# 中文题目\n给定一种规律 pattern和一个字符串str，判断 str 是否遵循相同的规律。\n\n这里的遵循指完全匹配，例如，pattern里的每个字母和字符串str中的每个非空单词之间存在着双向连接的对应规律。\n\n示例1:\n\n输入: pattern = "abba", str = "dog cat cat dog"\n输出: true\n\n示例 2:\n\n输入:pattern = "abba", str = "dog cat cat fish"\n输出: false\n\n示例 3:\n\n输入: pattern = "aaaa", str = "dog cat cat dog"\n输出: false\n\n示例 4:\n\n输入: pattern = "abba", str = "dog dog dog dog"\n输出: false\n\n说明:\n你可以假设pattern只包含小写字母，str包含了由单个空格分隔的小写字母。\n\n# 通过代码\nimport java.util.HashMap;\nclass Solution {\n    public boolean wordPattern(String pattern, String str) {\n         HashMap<Character,Integer> map1=new HashMap<>();\n            HashMap<String,Integer> map2=new HashMap<>();\n            char[] arr1=pattern.toCharArray();\n            String[] arr2=str.split(" ");\n            if (arr1.length!=arr2.length){\n                return false;\n            }\n            for (int i = 0; i < arr1.length; i++) {\n                if (map1.containsKey(arr1[i])){\n                    int count1=map1.get(arr1[i]);\n                    if (map2.containsKey(arr2[i])){\n                        int count2=map2.get(arr2[i]);\n                        if (count1==count2){\n                            continue;\n                        }else {\n                            return false;\n                        }\n                    }else {\n                        return false;\n                    }\n                }else {\n                    map1.put(arr1[i],i);\n                    if (map2.containsKey(arr2[i])){\n                        return false;\n                    }else {\n                        map2.put(arr2[i],i);\n                        continue;\n                    }\n                }\n            }\n            return true;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n# 高赞题解\n# class Solution:\ndef wordPattern(self, pattern: str, str: str) -> bool:\n    res=str.split()\n    return list(map(pattern.index, pattern))==list(map(res.index,res))\n\n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-06-01 22:56:43Accepted [https://leetcode-cn.com//submissions/detail/2824240/]2 ms30.74%N/Ajava# 统计信息\n通过次数提交次数AC比率160643868641.5%# 相似题目\n题目难度同构字符串 [https://leetcode-cn.com/problems/isomorphic-strings/]简单单词规律 II [https://leetcode-cn.com/problems/word-pattern-ii/]困难',contentLowercase:'# 中文题目\n给定一种规律 pattern和一个字符串str，判断 str 是否遵循相同的规律。\n\n这里的遵循指完全匹配，例如，pattern里的每个字母和字符串str中的每个非空单词之间存在着双向连接的对应规律。\n\n示例1:\n\n输入: pattern = "abba", str = "dog cat cat dog"\n输出: true\n\n示例 2:\n\n输入:pattern = "abba", str = "dog cat cat fish"\n输出: false\n\n示例 3:\n\n输入: pattern = "aaaa", str = "dog cat cat dog"\n输出: false\n\n示例 4:\n\n输入: pattern = "abba", str = "dog dog dog dog"\n输出: false\n\n说明:\n你可以假设pattern只包含小写字母，str包含了由单个空格分隔的小写字母。\n\n# 通过代码\nimport java.util.hashmap;\nclass solution {\n    public boolean wordpattern(string pattern, string str) {\n         hashmap<character,integer> map1=new hashmap<>();\n            hashmap<string,integer> map2=new hashmap<>();\n            char[] arr1=pattern.tochararray();\n            string[] arr2=str.split(" ");\n            if (arr1.length!=arr2.length){\n                return false;\n            }\n            for (int i = 0; i < arr1.length; i++) {\n                if (map1.containskey(arr1[i])){\n                    int count1=map1.get(arr1[i]);\n                    if (map2.containskey(arr2[i])){\n                        int count2=map2.get(arr2[i]);\n                        if (count1==count2){\n                            continue;\n                        }else {\n                            return false;\n                        }\n                    }else {\n                        return false;\n                    }\n                }else {\n                    map1.put(arr1[i],i);\n                    if (map2.containskey(arr2[i])){\n                        return false;\n                    }else {\n                        map2.put(arr2[i],i);\n                        continue;\n                    }\n                }\n            }\n            return true;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n# 高赞题解\n# class solution:\ndef wordpattern(self, pattern: str, str: str) -> bool:\n    res=str.split()\n    return list(map(pattern.index, pattern))==list(map(res.index,res))\n\n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-06-01 22:56:43accepted [https://leetcode-cn.com//submissions/detail/2824240/]2 ms30.74%n/ajava# 统计信息\n通过次数提交次数ac比率160643868641.5%# 相似题目\n题目难度同构字符串 [https://leetcode-cn.com/problems/isomorphic-strings/]简单单词规律 ii [https://leetcode-cn.com/problems/word-pattern-ii/]困难'},{title:"303-区域和检索 - 数组不可变(Range Sum Query - Immutable)",frontmatter:{title:"303-区域和检索 - 数组不可变(Range Sum Query - Immutable)",date:"2018-05-08T00:00:00.000Z",categories:["简单"],tags:["动态规划<Dynamic Programming>"]},regularPath:"/views/%E7%AE%80%E5%8D%95/0303-%E5%8C%BA%E5%9F%9F%E5%92%8C%E6%A3%80%E7%B4%A2%20-%20%E6%95%B0%E7%BB%84%E4%B8%8D%E5%8F%AF%E5%8F%98.html",relativePath:"views/简单/0303-区域和检索 - 数组不可变.md",key:"v-b8b51226",path:"/views/%E7%AE%80%E5%8D%95/0303-%E5%8C%BA%E5%9F%9F%E5%92%8C%E6%A3%80%E7%B4%A2%20-%20%E6%95%B0%E7%BB%84%E4%B8%8D%E5%8F%AF%E5%8F%98.html",headers:[{level:2,title:"中文题目",slug:"中文题目",charIndex:2},{level:2,title:"通过代码",slug:"通过代码",charIndex:219},{level:2,title:"官方题解",slug:"官方题解",charIndex:804},{level:3,title:"方法三：缓存",slug:"方法三：缓存",charIndex:2001},{level:2,title:"提交历史",slug:"提交历史",charIndex:2957},{level:2,title:"统计信息",slug:"统计信息",charIndex:3087},{level:2,title:"相似题目",slug:"相似题目",charIndex:3121}],lastUpdated:"4/11/2021, 1:15:21 PM",headersStr:"中文题目 通过代码 官方题解 方法三：缓存 提交历史 统计信息 相似题目",content:"# 中文题目\n给定一个整数数组nums，求出数组从索引i到j(i≤j) 范围内元素的总和，包含i, j两点。\n\n示例：\n\n给定 nums = [-2, 0, 3, -5, 2, -1]，求和函数为 sumRange()\n\nsumRange(0, 2) -> 1\nsumRange(2, 5) -> -1\nsumRange(0, 5) -> -3\n\n说明:\n\n 1. 你可以假设数组不可变。\n 2. 会多次调用sumRange方法。\n\n# 通过代码\nclass NumArray {\n\n    int[] nums;\n        public NumArray(int[] nums) {\n            for (int i = 1; i <nums.length ; i++) {\n                nums[i]+=nums[i-1];\n            }\n            this.nums=nums;\n        }\n\n        public int sumRange(int i, int j) {\n           if (i==0){\n               return nums[j];\n           }\n           return nums[j]-nums[i-1];\n        }\n}\n\n/**\n * Your NumArray object will be instantiated and called as such:\n * NumArray obj = new NumArray(nums);\n * int param_1 = obj.sumRange(i,j);\n */\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n# 官方题解\n# 方法一：暴力法[超过时间限制]\n每次调用 sumrange 时，我们都使用for循环将索引 iii 到 jjj 之间的每个元素相加。\n\nprivate int[] data;\n\npublic NumArray(int[] nums) {\n    data = nums;\n}\n\npublic int sumRange(int i, int j) {\n    int sum = 0;\n    for (int k = i; k <= j; k++) {\n        sum += data[k];\n    }\n    return sum;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n复杂度分析\n\n * 时间复杂度：每次查询的时间 O(n)O(n)O(n)，每个 sumrange 查询需要 O(n)O(n)O(n) 时间。\n * 空间复杂度：O(1)O(1)O(1)，请注意，data 是对 nums 的引用，不是它的副本。\n\n# 方法二：缓存\n假设 sumrange 被调用 1000次，其参数完全相同。我们怎么能加快速度？ 我们可以用额外的空间换取速度。通过预先计算所有的范围和可能性并将其结果存储在哈希表中，我们可以将查询加速到常量时间。\n\nprivate Map<Pair<Integer, Integer>, Integer> map = new HashMap<>();\n\npublic NumArray(int[] nums) {\n    for (int i = 0; i < nums.length; i++) {\n        int sum = 0;\n        for (int j = i; j < nums.length; j++) {\n            sum += nums[j];\n            map.put(Pair.create(i, j), sum);\n        }\n    }\n}\n\npublic int sumRange(int i, int j) {\n    return map.get(Pair.create(i, j));\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n复杂度分析\n\n * 时间复杂度：每次查询的时间 O(1)O(1)O(1)，O(n2)O(n^2)O(n2) 时间用来预计算。在构造函数中完成的预计算需要 O(n2)O(n^2)O(n2) 时间。每个 sumrange 查询的时间复杂性是 O(1)O(1)O(1) 因为哈希表的查找操作是常量时间。\n * 空间复杂度：O(n2)O(n^2)O(n2)，所需的额外空间为 O(n2)O(n^2)O(n2) 因为 iii 和 jjj 都有 nnn 个候选空间。\n\n# 方法三：缓存\n * 上面的方法需要很大的空间，我们可以优化它吗？\n * 假设我们预先计算了从数字 000 到 kkk 的累积和。我们可以用这个信息得出 sum(i，j)sum(i，j)sum(i，j) 吗？\n * 让我们将 sum[k]sum[k]sum[k] 定义为 nums[0⋯k−1]nums[0\\cdots k-1]nums[0⋯k−1] 的累积和（包括这两个值）：\n\nsum[k]={∑i=0k−1nums[i],k>00,k=0sum[k] = \\left\\{ \\begin{array}{rl} \\sum_{i=0}^{k-1}nums[i] & , k > 0 \\\\ 0 &, k = 0 \\end{array} \\right.sum[k]={∑i=0k−1​nums[i]0​,k>0,k=0​\n\n * 现在，我们可以计算 sumrange 如下：\n\nsumrange（i，j）=sum[j+1]−sum[i]sumrange（i，j）=sum[j+1]-sum[i]sumrange（i，j）=sum[j+1]−sum[i]\n\nprivate int[] sum;\n\npublic NumArray(int[] nums) {\n    sum = new int[nums.length + 1];\n    for (int i = 0; i < nums.length; i++) {\n        sum[i + 1] = sum[i] + nums[i];\n    }\n}\n\npublic int sumRange(int i, int j) {\n    return sum[j + 1] - sum[i];\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n * 注意，在上面的代码中，我们插入了一个虚拟 0 作为 sum 数组中的第一个元素。这个技巧可以避免在 sumrange 函数中进行额外的条件检查。\n\n复杂度分析\n\n * 时间复杂度：每次查询的时间 O(1)O(1)O(1)，O(N)O(N)O(N) 预计算时间。由于累积和被缓存，每个sumrange查询都可以用 O(1)O(1)O(1) 时间计算。\n * 空间复杂度：O(n)O(n)O(n).\n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-05-08 23:19:19Accepted [https://leetcode-cn.com//submissions/detail/2090504/]197 ms22.43%N/Ajava# 统计信息\n通过次数提交次数AC比率261294416759.2%# 相似题目\n题目难度二维区域和检索 - 矩阵不可变 [https://leetcode-cn.com/problems/range-sum-query-2d-immutable/]中等区域和检索 - 数组可修改 [https://leetcode-cn.com/problems/range-sum-query-mutable/]中等和等于 k 的最长子数组长度 [https://leetcode-cn.com/problems/maximum-size-subarray-sum-equals-k/]中等",contentLowercase:"# 中文题目\n给定一个整数数组nums，求出数组从索引i到j(i≤j) 范围内元素的总和，包含i, j两点。\n\n示例：\n\n给定 nums = [-2, 0, 3, -5, 2, -1]，求和函数为 sumrange()\n\nsumrange(0, 2) -> 1\nsumrange(2, 5) -> -1\nsumrange(0, 5) -> -3\n\n说明:\n\n 1. 你可以假设数组不可变。\n 2. 会多次调用sumrange方法。\n\n# 通过代码\nclass numarray {\n\n    int[] nums;\n        public numarray(int[] nums) {\n            for (int i = 1; i <nums.length ; i++) {\n                nums[i]+=nums[i-1];\n            }\n            this.nums=nums;\n        }\n\n        public int sumrange(int i, int j) {\n           if (i==0){\n               return nums[j];\n           }\n           return nums[j]-nums[i-1];\n        }\n}\n\n/**\n * your numarray object will be instantiated and called as such:\n * numarray obj = new numarray(nums);\n * int param_1 = obj.sumrange(i,j);\n */\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n# 官方题解\n# 方法一：暴力法[超过时间限制]\n每次调用 sumrange 时，我们都使用for循环将索引 iii 到 jjj 之间的每个元素相加。\n\nprivate int[] data;\n\npublic numarray(int[] nums) {\n    data = nums;\n}\n\npublic int sumrange(int i, int j) {\n    int sum = 0;\n    for (int k = i; k <= j; k++) {\n        sum += data[k];\n    }\n    return sum;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n复杂度分析\n\n * 时间复杂度：每次查询的时间 o(n)o(n)o(n)，每个 sumrange 查询需要 o(n)o(n)o(n) 时间。\n * 空间复杂度：o(1)o(1)o(1)，请注意，data 是对 nums 的引用，不是它的副本。\n\n# 方法二：缓存\n假设 sumrange 被调用 1000次，其参数完全相同。我们怎么能加快速度？ 我们可以用额外的空间换取速度。通过预先计算所有的范围和可能性并将其结果存储在哈希表中，我们可以将查询加速到常量时间。\n\nprivate map<pair<integer, integer>, integer> map = new hashmap<>();\n\npublic numarray(int[] nums) {\n    for (int i = 0; i < nums.length; i++) {\n        int sum = 0;\n        for (int j = i; j < nums.length; j++) {\n            sum += nums[j];\n            map.put(pair.create(i, j), sum);\n        }\n    }\n}\n\npublic int sumrange(int i, int j) {\n    return map.get(pair.create(i, j));\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n复杂度分析\n\n * 时间复杂度：每次查询的时间 o(1)o(1)o(1)，o(n2)o(n^2)o(n2) 时间用来预计算。在构造函数中完成的预计算需要 o(n2)o(n^2)o(n2) 时间。每个 sumrange 查询的时间复杂性是 o(1)o(1)o(1) 因为哈希表的查找操作是常量时间。\n * 空间复杂度：o(n2)o(n^2)o(n2)，所需的额外空间为 o(n2)o(n^2)o(n2) 因为 iii 和 jjj 都有 nnn 个候选空间。\n\n# 方法三：缓存\n * 上面的方法需要很大的空间，我们可以优化它吗？\n * 假设我们预先计算了从数字 000 到 kkk 的累积和。我们可以用这个信息得出 sum(i，j)sum(i，j)sum(i，j) 吗？\n * 让我们将 sum[k]sum[k]sum[k] 定义为 nums[0⋯k−1]nums[0\\cdots k-1]nums[0⋯k−1] 的累积和（包括这两个值）：\n\nsum[k]={∑i=0k−1nums[i],k>00,k=0sum[k] = \\left\\{ \\begin{array}{rl} \\sum_{i=0}^{k-1}nums[i] & , k > 0 \\\\ 0 &, k = 0 \\end{array} \\right.sum[k]={∑i=0k−1​nums[i]0​,k>0,k=0​\n\n * 现在，我们可以计算 sumrange 如下：\n\nsumrange（i，j）=sum[j+1]−sum[i]sumrange（i，j）=sum[j+1]-sum[i]sumrange（i，j）=sum[j+1]−sum[i]\n\nprivate int[] sum;\n\npublic numarray(int[] nums) {\n    sum = new int[nums.length + 1];\n    for (int i = 0; i < nums.length; i++) {\n        sum[i + 1] = sum[i] + nums[i];\n    }\n}\n\npublic int sumrange(int i, int j) {\n    return sum[j + 1] - sum[i];\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n * 注意，在上面的代码中，我们插入了一个虚拟 0 作为 sum 数组中的第一个元素。这个技巧可以避免在 sumrange 函数中进行额外的条件检查。\n\n复杂度分析\n\n * 时间复杂度：每次查询的时间 o(1)o(1)o(1)，o(n)o(n)o(n) 预计算时间。由于累积和被缓存，每个sumrange查询都可以用 o(1)o(1)o(1) 时间计算。\n * 空间复杂度：o(n)o(n)o(n).\n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-05-08 23:19:19accepted [https://leetcode-cn.com//submissions/detail/2090504/]197 ms22.43%n/ajava# 统计信息\n通过次数提交次数ac比率261294416759.2%# 相似题目\n题目难度二维区域和检索 - 矩阵不可变 [https://leetcode-cn.com/problems/range-sum-query-2d-immutable/]中等区域和检索 - 数组可修改 [https://leetcode-cn.com/problems/range-sum-query-mutable/]中等和等于 k 的最长子数组长度 [https://leetcode-cn.com/problems/maximum-size-subarray-sum-equals-k/]中等"},{title:"344-反转字符串(Reverse String)",frontmatter:{title:"344-反转字符串(Reverse String)",date:"2018-05-16T00:00:00.000Z",categories:["简单"],tags:["双指针<Two Pointers>","字符串<String>"]},regularPath:"/views/%E7%AE%80%E5%8D%95/0344-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2.html",relativePath:"views/简单/0344-反转字符串.md",key:"v-72faf49f",path:"/views/%E7%AE%80%E5%8D%95/0344-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2.html",headers:[{level:2,title:"中文题目",slug:"中文题目",charIndex:2},{level:2,title:"通过代码",slug:"通过代码",charIndex:342},{level:2,title:"官方题解",slug:"官方题解",charIndex:2005},{level:2,title:"提交历史",slug:"提交历史",charIndex:3957},{level:2,title:"统计信息",slug:"统计信息",charIndex:4389},{level:2,title:"相似题目",slug:"相似题目",charIndex:4425}],lastUpdated:"4/11/2021, 1:15:21 PM",headersStr:"中文题目 通过代码 官方题解 提交历史 统计信息 相似题目",content:'# 中文题目\n编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。\n\n不要给另外的数组分配额外的空间，你必须原地 [https://baike.baidu.com/item/原地算法]修改输入数组、使用 O(1) 的额外空间解决这一问题。\n\n你可以假设数组中的所有字符都是 ASCII [https://baike.baidu.com/item/ASCII] 码表中的可打印字符。\n\n\n\n示例 1：\n\n输入：["h","e","l","l","o"]\n输出：["o","l","l","e","h"]\n\n\n示例 2：\n\n输入：["H","a","n","n","a","h"]\n输出：["h","a","n","n","a","H"]\n\n# 通过代码\nclass Solution {\n    public String reverseString(String s) {\n        if (s.length()==0){\n                return "";\n            }\n            int lo=0;\n            int hi=s.length()-1;\n            char[] arr=s.toCharArray();\n            while (lo<hi){\n                char temp=arr[lo];\n                arr[lo]=arr[hi];\n                arr[hi]=temp;\n                lo++;\n                hi--;\n            }\n            return String.valueOf(arr);\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\nclass Solution {\n    public String reverseString(String s) {\n        if (s.length()==0){\n                return "";\n            }\n            int lo=0;\n            int hi=s.length()-1;\n            char[] arr=s.toCharArray();\n            while (lo<hi){\n                char temp=arr[lo];\n                arr[lo]=arr[hi];\n                arr[hi]=temp;\n                lo++;\n                hi--;\n            }\n            return String.valueOf(arr);\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\nclass Solution {\n    public String reverseString(String s) {\n        if (s.length()==0){\n                return "";\n            }\n            int lo=0;\n            int hi=s.length()-1;\n            StringBuffer sb=new StringBuffer(s);\n            while (lo<hi){\n                Character c1=sb.charAt(lo);\n                Character c2=sb.charAt(hi);\n                if (c1!=c2){\n                    sb.replace(lo,lo+1,c2.toString());\n                    sb.replace(hi,hi+1,c1.toString());\n                }\n                lo++;\n                hi--;\n            }\n            return sb.toString();\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n# 官方题解\n# 概述\n我们可以使用 python 简短的语句实现\n\nclass Solution:\n    def reverseString(self, s):\n        s.reverse()\n\n\n1\n2\n3\n我们来谈论以下两个方面：\n\n * 原地反转字符串是否代表了只使用了常数级空间。\n * 双指针法\n\n# 方法一：递归\n原地反转字符串是否代表了空间复杂度为常数？\n\n不，原地反转字符串是一种不使用辅助数据结构的算法。\n\n我们使用递归的方法去反转字符串，它是原地反转，但是空间复杂度却不是常数级空间，因为递归过程中使用了堆栈空间。算法：我们实现递归函数 helper，它接受两个参数：left 左指针和 right 右指针。\n\n * 如果 left>=right，不做任何操作。\n * 否则交换 s[left] 和 s[right] 和调用 helper(left + 1, right - 1)。 首次调用函数我们传递首尾指针反转整个字符串 return helper(0, len(s) - 1)。\n\nclass Solution:\n    def reverseString(self, s):\n        def helper(left, right):\n            if left < right:\n                s[left], s[right] = s[right], s[left]\n                helper(left + 1, right - 1)\n\n        helper(0, len(s) - 1)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\nclass Solution {\n  public void helper(char[] s, int left, int right) {\n    if (left >= right) return;\n    char tmp = s[left];\n    s[left++] = s[right];\n    s[right--] = tmp;\n    helper(s, left, right);\n  }\n\n  public void reverseString(char[] s) {\n    helper(s, 0, s.length - 1);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n复杂度分析\n\n * 时间复杂度：O(N)\\mathcal{O}(N)O(N)。执行了 N/2N/2N/2 次的交换。\n * 空间复杂度：O(N)\\mathcal{O}(N)O(N)，递归过程中使用的堆栈空间。\n\n# 方法二：双指针法\n双指针法是使用两个指针，一个左指针 left，右指针 right，开始工作时 left 指向首元素，right 指向尾元素。交换两个指针指向的元素，并向中间移动，直到两个指针相遇。\n\n算法：\n\n * 将 left 指向首元素，right 指向尾元素。\n * 当 left<right： * 交换 s[left] 和 s[right]。\n    * left++\n    * right++\n   \n   \n\nclass Solution:\n    def reverseString(self, s):\n        left, right = 0, len(s) - 1\n        while left < right:\n            s[left], s[right] = s[right], s[left]\n            left, right = left + 1, right - 1\n\n\n1\n2\n3\n4\n5\n6\nclass Solution {\n    public void reverseString(char[] s) {\n        int left = 0, right = s.length - 1;\n        while (left < right) {\n            char tmp = s[left];\n            s[left++] = s[right];\n            s[right--] = tmp;\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n复杂度分析\n\n * 时间复杂度：O(N)\\mathcal{O}(N)O(N)。执行了 N/2N/2N/2 次的交换。\n * 空间复杂度：O(1)\\mathcal{O}(1)O(1)，只使用了常数级空间。\n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-05-16 19:55:56Accepted [https://leetcode-cn.com//submissions/detail/2335090/]2 ms27.74%N/Ajava2018-05-16 19:55:31Accepted [https://leetcode-cn.com//submissions/detail/2335080/]5 ms6.38%N/Ajava2018-05-16 19:54:53Time Limit Exceeded [https://leetcode-cn.com//submissions/detail/2335066/]N/AN/AN/Ajava2018-05-16 19:51:41Accepted [https://leetcode-cn.com//submissions/detail/2335001/]648 ms5.16%N/Ajava# 统计信息\n通过次数提交次数AC比率10195114883068.5%# 相似题目\n题目难度反转字符串中的元音字母 [https://leetcode-cn.com/problems/reverse-vowels-of-a-string/]简单反转字符串 II [https://leetcode-cn.com/problems/reverse-string-ii/]简单',contentLowercase:'# 中文题目\n编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。\n\n不要给另外的数组分配额外的空间，你必须原地 [https://baike.baidu.com/item/原地算法]修改输入数组、使用 o(1) 的额外空间解决这一问题。\n\n你可以假设数组中的所有字符都是 ascii [https://baike.baidu.com/item/ascii] 码表中的可打印字符。\n\n\n\n示例 1：\n\n输入：["h","e","l","l","o"]\n输出：["o","l","l","e","h"]\n\n\n示例 2：\n\n输入：["h","a","n","n","a","h"]\n输出：["h","a","n","n","a","h"]\n\n# 通过代码\nclass solution {\n    public string reversestring(string s) {\n        if (s.length()==0){\n                return "";\n            }\n            int lo=0;\n            int hi=s.length()-1;\n            char[] arr=s.tochararray();\n            while (lo<hi){\n                char temp=arr[lo];\n                arr[lo]=arr[hi];\n                arr[hi]=temp;\n                lo++;\n                hi--;\n            }\n            return string.valueof(arr);\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\nclass solution {\n    public string reversestring(string s) {\n        if (s.length()==0){\n                return "";\n            }\n            int lo=0;\n            int hi=s.length()-1;\n            char[] arr=s.tochararray();\n            while (lo<hi){\n                char temp=arr[lo];\n                arr[lo]=arr[hi];\n                arr[hi]=temp;\n                lo++;\n                hi--;\n            }\n            return string.valueof(arr);\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\nclass solution {\n    public string reversestring(string s) {\n        if (s.length()==0){\n                return "";\n            }\n            int lo=0;\n            int hi=s.length()-1;\n            stringbuffer sb=new stringbuffer(s);\n            while (lo<hi){\n                character c1=sb.charat(lo);\n                character c2=sb.charat(hi);\n                if (c1!=c2){\n                    sb.replace(lo,lo+1,c2.tostring());\n                    sb.replace(hi,hi+1,c1.tostring());\n                }\n                lo++;\n                hi--;\n            }\n            return sb.tostring();\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n# 官方题解\n# 概述\n我们可以使用 python 简短的语句实现\n\nclass solution:\n    def reversestring(self, s):\n        s.reverse()\n\n\n1\n2\n3\n我们来谈论以下两个方面：\n\n * 原地反转字符串是否代表了只使用了常数级空间。\n * 双指针法\n\n# 方法一：递归\n原地反转字符串是否代表了空间复杂度为常数？\n\n不，原地反转字符串是一种不使用辅助数据结构的算法。\n\n我们使用递归的方法去反转字符串，它是原地反转，但是空间复杂度却不是常数级空间，因为递归过程中使用了堆栈空间。算法：我们实现递归函数 helper，它接受两个参数：left 左指针和 right 右指针。\n\n * 如果 left>=right，不做任何操作。\n * 否则交换 s[left] 和 s[right] 和调用 helper(left + 1, right - 1)。 首次调用函数我们传递首尾指针反转整个字符串 return helper(0, len(s) - 1)。\n\nclass solution:\n    def reversestring(self, s):\n        def helper(left, right):\n            if left < right:\n                s[left], s[right] = s[right], s[left]\n                helper(left + 1, right - 1)\n\n        helper(0, len(s) - 1)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\nclass solution {\n  public void helper(char[] s, int left, int right) {\n    if (left >= right) return;\n    char tmp = s[left];\n    s[left++] = s[right];\n    s[right--] = tmp;\n    helper(s, left, right);\n  }\n\n  public void reversestring(char[] s) {\n    helper(s, 0, s.length - 1);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n复杂度分析\n\n * 时间复杂度：o(n)\\mathcal{o}(n)o(n)。执行了 n/2n/2n/2 次的交换。\n * 空间复杂度：o(n)\\mathcal{o}(n)o(n)，递归过程中使用的堆栈空间。\n\n# 方法二：双指针法\n双指针法是使用两个指针，一个左指针 left，右指针 right，开始工作时 left 指向首元素，right 指向尾元素。交换两个指针指向的元素，并向中间移动，直到两个指针相遇。\n\n算法：\n\n * 将 left 指向首元素，right 指向尾元素。\n * 当 left<right： * 交换 s[left] 和 s[right]。\n    * left++\n    * right++\n   \n   \n\nclass solution:\n    def reversestring(self, s):\n        left, right = 0, len(s) - 1\n        while left < right:\n            s[left], s[right] = s[right], s[left]\n            left, right = left + 1, right - 1\n\n\n1\n2\n3\n4\n5\n6\nclass solution {\n    public void reversestring(char[] s) {\n        int left = 0, right = s.length - 1;\n        while (left < right) {\n            char tmp = s[left];\n            s[left++] = s[right];\n            s[right--] = tmp;\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n复杂度分析\n\n * 时间复杂度：o(n)\\mathcal{o}(n)o(n)。执行了 n/2n/2n/2 次的交换。\n * 空间复杂度：o(1)\\mathcal{o}(1)o(1)，只使用了常数级空间。\n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-05-16 19:55:56accepted [https://leetcode-cn.com//submissions/detail/2335090/]2 ms27.74%n/ajava2018-05-16 19:55:31accepted [https://leetcode-cn.com//submissions/detail/2335080/]5 ms6.38%n/ajava2018-05-16 19:54:53time limit exceeded [https://leetcode-cn.com//submissions/detail/2335066/]n/an/an/ajava2018-05-16 19:51:41accepted [https://leetcode-cn.com//submissions/detail/2335001/]648 ms5.16%n/ajava# 统计信息\n通过次数提交次数ac比率10195114883068.5%# 相似题目\n题目难度反转字符串中的元音字母 [https://leetcode-cn.com/problems/reverse-vowels-of-a-string/]简单反转字符串 ii [https://leetcode-cn.com/problems/reverse-string-ii/]简单'},{title:"345-反转字符串中的元音字母(Reverse Vowels of a String)",frontmatter:{title:"345-反转字符串中的元音字母(Reverse Vowels of a String)",date:"2018-05-16T00:00:00.000Z",categories:["简单"],tags:["双指针<Two Pointers>","字符串<String>"]},regularPath:"/views/%E7%AE%80%E5%8D%95/0345-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%85%83%E9%9F%B3%E5%AD%97%E6%AF%8D.html",relativePath:"views/简单/0345-反转字符串中的元音字母.md",key:"v-f36f62ca",path:"/views/%E7%AE%80%E5%8D%95/0345-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%85%83%E9%9F%B3%E5%AD%97%E6%AF%8D.html",headers:[{level:2,title:"中文题目",slug:"中文题目",charIndex:2},{level:2,title:"通过代码",slug:"通过代码",charIndex:130},{level:2,title:"高赞题解",slug:"高赞题解",charIndex:1338},{level:2,title:"分析：",slug:"分析：",charIndex:1492},{level:2,title:"解法1：双指针法，利用set判断是否是元音字符",slug:"解法1：双指针法，利用set判断是否是元音字符",charIndex:1542},{level:2,title:"解法2：更改了查找元音字符的查找方式",slug:"解法2：更改了查找元音字符的查找方式",charIndex:2237},{level:2,title:"提交历史",slug:"提交历史",charIndex:2806},{level:2,title:"统计信息",slug:"统计信息",charIndex:2934},{level:2,title:"相似题目",slug:"相似题目",charIndex:2968}],lastUpdated:"4/11/2021, 1:15:21 PM",headersStr:"中文题目 通过代码 高赞题解 分析： 解法1：双指针法，利用set判断是否是元音字符 解法2：更改了查找元音字符的查找方式 提交历史 统计信息 相似题目",content:"# 中文题目\n编写一个函数，以字符串作为输入，反转该字符串中的元音字母。\n\n示例 1:\n\n输入: \"hello\"\n输出: \"holle\"\n\n\n示例 2:\n\n输入: \"leetcode\"\n输出: \"leotcede\"\n\n说明:\n元音字母不包含字母\"y\"。\n\n# 通过代码\nclass Solution {\n      public static String reverseVowels(String s) {\n            char[] arr=s.toCharArray();\n            int lo=0;\n            int hi=s.length()-1;\n            while (lo<hi){\n                if (valid(arr[lo]) && valid(arr[hi])){\n                    char c=arr[lo];\n                    arr[lo]=arr[hi];\n                    arr[hi]=c;\n                    lo++;\n                    hi--;\n                }\n                if (!valid(arr[lo])){\n                   lo++;\n                }\n                if (!valid(arr[hi])){\n                    hi--;\n                }\n\n            }\n            return String.valueOf(arr);\n        }\n\n        private static boolean valid(char c){\n            switch (c){\n                case 'a':\n                case 'A':\n                case 'e':\n                case 'E':\n                case 'i':\n                case 'I':\n                case 'o':\n                case 'O':\n                case 'u':\n                case 'U':\n                    return true;\n                    default:return false;\n            }\n        }\n    \n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n# 高赞题解\n# 反转字符串中的元音字母\n编写一个函数，以字符串作为输入，反转该字符串中的元音字母。\n\n示例 1:\n\n输入: \"hello\"\n输出: \"holle\"\n\n\n1\n2\n示例 2:\n\n输入: \"leetcode\"\n输出: \"leotcede\"\n\n\n1\n2\n说明: 元音字母不包含字母\"y\"。\n\n\n\n\n# 分析：\n * 是将单词中的元音序列反转\n * 元音包括a，e，i，o，u，A，E，I，O，U\n\n# 解法1：双指针法，利用set判断是否是元音字符\nclass Solution {\npublic:\n    string reverseVowels(string s) {\n        set<char> a;\n        a.insert('a');\n        a.insert('e');\n        a.insert('i');\n        a.insert('o');\n        a.insert('u');\n        a.insert('A');\n        a.insert('E');\n        a.insert('I');\n        a.insert('O');\n        a.insert('U');\n        int i=0;\n        int j=s.size()-1;\n        while(i<j)\n        {\n            while(!(a.find(s[i])!=a.end())&&i<j)\n                i++;\n            while(!(a.find(s[j])!=a.end())&&i<j)\n                j--;\n            swap(s[i++],s[j--]);\n        }\n        return s;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n# 解法2：更改了查找元音字符的查找方式\nclass Solution {\npublic:\n    bool find(char c)\n    {\n        return c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u'\n        ||c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U';\n    }\n    string reverseVowels(string s) {\n        int i=0;\n        int j=s.size()-1;\n        while(i<j)\n        {\n            while(!find(s[i])&&i<j)\n                i++;\n            while(!find(s[j])&&i<j)\n                j--;\n            swap(s[i++],s[j--]);\n        }\n        return s;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-05-16 20:37:39Accepted [https://leetcode-cn.com//submissions/detail/2336293/]4 ms81.65%N/Ajava# 统计信息\n通过次数提交次数AC比率219844512248.7%# 相似题目\n题目难度反转字符串 [https://leetcode-cn.com/problems/reverse-string/]简单删去字符串中的元音 [https://leetcode-cn.com/problems/remove-vowels-from-a-string/]简单",contentLowercase:"# 中文题目\n编写一个函数，以字符串作为输入，反转该字符串中的元音字母。\n\n示例 1:\n\n输入: \"hello\"\n输出: \"holle\"\n\n\n示例 2:\n\n输入: \"leetcode\"\n输出: \"leotcede\"\n\n说明:\n元音字母不包含字母\"y\"。\n\n# 通过代码\nclass solution {\n      public static string reversevowels(string s) {\n            char[] arr=s.tochararray();\n            int lo=0;\n            int hi=s.length()-1;\n            while (lo<hi){\n                if (valid(arr[lo]) && valid(arr[hi])){\n                    char c=arr[lo];\n                    arr[lo]=arr[hi];\n                    arr[hi]=c;\n                    lo++;\n                    hi--;\n                }\n                if (!valid(arr[lo])){\n                   lo++;\n                }\n                if (!valid(arr[hi])){\n                    hi--;\n                }\n\n            }\n            return string.valueof(arr);\n        }\n\n        private static boolean valid(char c){\n            switch (c){\n                case 'a':\n                case 'a':\n                case 'e':\n                case 'e':\n                case 'i':\n                case 'i':\n                case 'o':\n                case 'o':\n                case 'u':\n                case 'u':\n                    return true;\n                    default:return false;\n            }\n        }\n    \n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n# 高赞题解\n# 反转字符串中的元音字母\n编写一个函数，以字符串作为输入，反转该字符串中的元音字母。\n\n示例 1:\n\n输入: \"hello\"\n输出: \"holle\"\n\n\n1\n2\n示例 2:\n\n输入: \"leetcode\"\n输出: \"leotcede\"\n\n\n1\n2\n说明: 元音字母不包含字母\"y\"。\n\n\n\n\n# 分析：\n * 是将单词中的元音序列反转\n * 元音包括a，e，i，o，u，a，e，i，o，u\n\n# 解法1：双指针法，利用set判断是否是元音字符\nclass solution {\npublic:\n    string reversevowels(string s) {\n        set<char> a;\n        a.insert('a');\n        a.insert('e');\n        a.insert('i');\n        a.insert('o');\n        a.insert('u');\n        a.insert('a');\n        a.insert('e');\n        a.insert('i');\n        a.insert('o');\n        a.insert('u');\n        int i=0;\n        int j=s.size()-1;\n        while(i<j)\n        {\n            while(!(a.find(s[i])!=a.end())&&i<j)\n                i++;\n            while(!(a.find(s[j])!=a.end())&&i<j)\n                j--;\n            swap(s[i++],s[j--]);\n        }\n        return s;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n# 解法2：更改了查找元音字符的查找方式\nclass solution {\npublic:\n    bool find(char c)\n    {\n        return c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u'\n        ||c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u';\n    }\n    string reversevowels(string s) {\n        int i=0;\n        int j=s.size()-1;\n        while(i<j)\n        {\n            while(!find(s[i])&&i<j)\n                i++;\n            while(!find(s[j])&&i<j)\n                j--;\n            swap(s[i++],s[j--]);\n        }\n        return s;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-05-16 20:37:39accepted [https://leetcode-cn.com//submissions/detail/2336293/]4 ms81.65%n/ajava# 统计信息\n通过次数提交次数ac比率219844512248.7%# 相似题目\n题目难度反转字符串 [https://leetcode-cn.com/problems/reverse-string/]简单删去字符串中的元音 [https://leetcode-cn.com/problems/remove-vowels-from-a-string/]简单"},{title:"349-两个数组的交集(Intersection of Two Arrays)",frontmatter:{title:"349-两个数组的交集(Intersection of Two Arrays)",date:"2018-05-29T00:00:00.000Z",categories:["简单"],tags:["排序<Sort>","哈希表<Hash Table>","双指针<Two Pointers>","二分查找<Binary Search>"]},regularPath:"/views/%E7%AE%80%E5%8D%95/0349-%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86.html",relativePath:"views/简单/0349-两个数组的交集.md",key:"v-24aef886",path:"/views/%E7%AE%80%E5%8D%95/0349-%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86.html",headers:[{level:2,title:"中文题目",slug:"中文题目",charIndex:2},{level:2,title:"通过代码",slug:"通过代码",charIndex:192},{level:2,title:"官方题解",slug:"官方题解",charIndex:894},{level:2,title:"提交历史",slug:"提交历史",charIndex:3593},{level:2,title:"统计信息",slug:"统计信息",charIndex:3820},{level:2,title:"相似题目",slug:"相似题目",charIndex:3854}],lastUpdated:"4/11/2021, 1:15:21 PM",headersStr:"中文题目 通过代码 官方题解 提交历史 统计信息 相似题目",content:'# 中文题目\n给定两个数组，编写一个函数来计算它们的交集。\n\n示例 1:\n\n输入: nums1 = [1,2,2,1], nums2 = [2,2]\n输出: [2]\n\n\n示例 2:\n\n输入: nums1 = [4,9,5], nums2 = [9,4,9,8,4]\n输出: [9,4]\n\n说明:\n\n * 输出结果中的每个元素一定是唯一的。\n * 我们可以不考虑输出结果的顺序。\n\n# 通过代码\nimport java.util.HashSet;\nclass Solution {\n    public int[] intersection(int[] nums1, int[] nums2) {\n       HashSet<Integer> set1=new HashSet<Integer>();\n            for (int i :\n                    nums1) {\n                set1.add(i);\n            }\n            HashSet<Integer> set2=new HashSet<>();\n            for (int i:nums2){\n                if (set1.contains(i)){\n                    set2.add(i);\n                }\n            }\n            int[] arr=new int[set2.size()];\n            int count=0;\n            for (int i :\n                    set2) {\n                arr[count++]=i;\n            }\n            return arr;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n# 官方题解\n# 方法一：两个 set\n幼稚的方法是根据第一个数组 nums1 迭代并检查每个值是否存在在 nums2 内。如果存在将值添加到输出。这样的方法会导致 O(n×m)O(n \\times m)O(n×m) 的时间复杂性，其中 n 和 m 是数组的长度。\n\n为了在线性时间内解决这个问题，我们使用集合 set，在 O(1)O(1)O(1) 时间复杂度实现操作。\n\n其思想是将两个数组转换为集合 set，然后迭代较小的集合检查是否存在在较大集合中。平均情况下，这种方法的时间复杂度为 O(n+m)O(n+m)O(n+m)。\n\n<,,,,,>\n\n实现：\n\nclass Solution:\n    def set_intersection(self, set1, set2):\n        return [x for x in set1 if x in set2]\n        \n    def intersection(self, nums1, nums2):\n        """\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        """  \n        set1 = set(nums1)\n        set2 = set(nums2)\n        \n        if len(set1) < len(set2):\n            return self.set_intersection(set1, set2)\n        else:\n            return self.set_intersection(set2, set1)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\nclass Solution {\n  public int[] set_intersection(HashSet<Integer> set1, HashSet<Integer> set2) {\n    int [] output = new int[set1.size()];\n    int idx = 0;\n    for (Integer s : set1)\n      if (set2.contains(s)) output[idx++] = s;\n\n    return Arrays.copyOf(output, idx);\n  }\n\n  public int[] intersection(int[] nums1, int[] nums2) {\n    HashSet<Integer> set1 = new HashSet<Integer>();\n    for (Integer n : nums1) set1.add(n);\n    HashSet<Integer> set2 = new HashSet<Integer>();\n    for (Integer n : nums2) set2.add(n);\n\n    if (set1.size() < set2.size()) return set_intersection(set1, set2);\n    else return set_intersection(set2, set1);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n复杂度分析\n\n * 时间复杂度：O(m+n)O(m+n)O(m+n)，其中 n 和 m 是数组的长度。O(n)O(n)O(n) 的时间用于转换 nums1 在集合中，O(m)O(m)O(m) 的时间用于转换 nums2 到集合中，并且平均情况下，集合的操作为 O(1)O(1)O(1)。\n * 空间复杂度：O(m+n)O(m+n)O(m+n)，最坏的情况是数组中的所有元素都不同。\n\n# 方法二：内置函数\n内置的函数在一般情况下的时间复杂度是 O(n+m)O(n+m)O(n+m) 且时间复杂度最坏的情况是 O(n×m)O(n \\times m)O(n×m) 。\n\n在 Python 中提供了交集的操作，在 Java 提供了 retainAll() 函数.\n\n实现:\n\nclass Solution:\n    def intersection(self, nums1, nums2):\n        """\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        """  \n        set1 = set(nums1)\n        set2 = set(nums2)\n        return list(set2 & set1)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\nclass Solution {\n  public int[] intersection(int[] nums1, int[] nums2) {\n    HashSet<Integer> set1 = new HashSet<Integer>();\n    for (Integer n : nums1) set1.add(n);\n    HashSet<Integer> set2 = new HashSet<Integer>();\n    for (Integer n : nums2) set2.add(n);\n\n    set1.retainAll(set2);\n\n    int [] output = new int[set1.size()];\n    int idx = 0;\n    for (int s : set1) output[idx++] = s;\n    return output;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n复杂度分析\n\n * 时间复杂度：一般情况下是 O(m+n)O(m+n)O(m+n)，最坏情况下是 O(m×n)O(m \\times n)O(m×n)。\n * 空间复杂度：最坏的情况是 O(m+n)O(m+n)O(m+n)，当数组中的元素全部不一样时。\n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-05-29 23:05:14Accepted [https://leetcode-cn.com//submissions/detail/2738077/]5 ms39.64%N/Ajava2018-05-29 22:57:16Wrong Answer [https://leetcode-cn.com//submissions/detail/2737932/]N/AN/AN/Ajava# 统计信息\n通过次数提交次数AC比率471996967267.7%# 相似题目\n题目难度两个数组的交集 II [https://leetcode-cn.com/problems/intersection-of-two-arrays-ii/]简单三个有序数组的交集 [https://leetcode-cn.com/problems/intersection-of-three-sorted-arrays/]简单',contentLowercase:'# 中文题目\n给定两个数组，编写一个函数来计算它们的交集。\n\n示例 1:\n\n输入: nums1 = [1,2,2,1], nums2 = [2,2]\n输出: [2]\n\n\n示例 2:\n\n输入: nums1 = [4,9,5], nums2 = [9,4,9,8,4]\n输出: [9,4]\n\n说明:\n\n * 输出结果中的每个元素一定是唯一的。\n * 我们可以不考虑输出结果的顺序。\n\n# 通过代码\nimport java.util.hashset;\nclass solution {\n    public int[] intersection(int[] nums1, int[] nums2) {\n       hashset<integer> set1=new hashset<integer>();\n            for (int i :\n                    nums1) {\n                set1.add(i);\n            }\n            hashset<integer> set2=new hashset<>();\n            for (int i:nums2){\n                if (set1.contains(i)){\n                    set2.add(i);\n                }\n            }\n            int[] arr=new int[set2.size()];\n            int count=0;\n            for (int i :\n                    set2) {\n                arr[count++]=i;\n            }\n            return arr;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n# 官方题解\n# 方法一：两个 set\n幼稚的方法是根据第一个数组 nums1 迭代并检查每个值是否存在在 nums2 内。如果存在将值添加到输出。这样的方法会导致 o(n×m)o(n \\times m)o(n×m) 的时间复杂性，其中 n 和 m 是数组的长度。\n\n为了在线性时间内解决这个问题，我们使用集合 set，在 o(1)o(1)o(1) 时间复杂度实现操作。\n\n其思想是将两个数组转换为集合 set，然后迭代较小的集合检查是否存在在较大集合中。平均情况下，这种方法的时间复杂度为 o(n+m)o(n+m)o(n+m)。\n\n<,,,,,>\n\n实现：\n\nclass solution:\n    def set_intersection(self, set1, set2):\n        return [x for x in set1 if x in set2]\n        \n    def intersection(self, nums1, nums2):\n        """\n        :type nums1: list[int]\n        :type nums2: list[int]\n        :rtype: list[int]\n        """  \n        set1 = set(nums1)\n        set2 = set(nums2)\n        \n        if len(set1) < len(set2):\n            return self.set_intersection(set1, set2)\n        else:\n            return self.set_intersection(set2, set1)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\nclass solution {\n  public int[] set_intersection(hashset<integer> set1, hashset<integer> set2) {\n    int [] output = new int[set1.size()];\n    int idx = 0;\n    for (integer s : set1)\n      if (set2.contains(s)) output[idx++] = s;\n\n    return arrays.copyof(output, idx);\n  }\n\n  public int[] intersection(int[] nums1, int[] nums2) {\n    hashset<integer> set1 = new hashset<integer>();\n    for (integer n : nums1) set1.add(n);\n    hashset<integer> set2 = new hashset<integer>();\n    for (integer n : nums2) set2.add(n);\n\n    if (set1.size() < set2.size()) return set_intersection(set1, set2);\n    else return set_intersection(set2, set1);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n复杂度分析\n\n * 时间复杂度：o(m+n)o(m+n)o(m+n)，其中 n 和 m 是数组的长度。o(n)o(n)o(n) 的时间用于转换 nums1 在集合中，o(m)o(m)o(m) 的时间用于转换 nums2 到集合中，并且平均情况下，集合的操作为 o(1)o(1)o(1)。\n * 空间复杂度：o(m+n)o(m+n)o(m+n)，最坏的情况是数组中的所有元素都不同。\n\n# 方法二：内置函数\n内置的函数在一般情况下的时间复杂度是 o(n+m)o(n+m)o(n+m) 且时间复杂度最坏的情况是 o(n×m)o(n \\times m)o(n×m) 。\n\n在 python 中提供了交集的操作，在 java 提供了 retainall() 函数.\n\n实现:\n\nclass solution:\n    def intersection(self, nums1, nums2):\n        """\n        :type nums1: list[int]\n        :type nums2: list[int]\n        :rtype: list[int]\n        """  \n        set1 = set(nums1)\n        set2 = set(nums2)\n        return list(set2 & set1)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\nclass solution {\n  public int[] intersection(int[] nums1, int[] nums2) {\n    hashset<integer> set1 = new hashset<integer>();\n    for (integer n : nums1) set1.add(n);\n    hashset<integer> set2 = new hashset<integer>();\n    for (integer n : nums2) set2.add(n);\n\n    set1.retainall(set2);\n\n    int [] output = new int[set1.size()];\n    int idx = 0;\n    for (int s : set1) output[idx++] = s;\n    return output;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n复杂度分析\n\n * 时间复杂度：一般情况下是 o(m+n)o(m+n)o(m+n)，最坏情况下是 o(m×n)o(m \\times n)o(m×n)。\n * 空间复杂度：最坏的情况是 o(m+n)o(m+n)o(m+n)，当数组中的元素全部不一样时。\n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-05-29 23:05:14accepted [https://leetcode-cn.com//submissions/detail/2738077/]5 ms39.64%n/ajava2018-05-29 22:57:16wrong answer [https://leetcode-cn.com//submissions/detail/2737932/]n/an/an/ajava# 统计信息\n通过次数提交次数ac比率471996967267.7%# 相似题目\n题目难度两个数组的交集 ii [https://leetcode-cn.com/problems/intersection-of-two-arrays-ii/]简单三个有序数组的交集 [https://leetcode-cn.com/problems/intersection-of-three-sorted-arrays/]简单'},{title:"350-两个数组的交集 II(Intersection of Two Arrays II)",frontmatter:{title:"350-两个数组的交集 II(Intersection of Two Arrays II)",date:"2018-05-29T00:00:00.000Z",categories:["简单"],tags:["排序<Sort>","哈希表<Hash Table>","双指针<Two Pointers>","二分查找<Binary Search>"]},regularPath:"/views/%E7%AE%80%E5%8D%95/0350-%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86%20II.html",relativePath:"views/简单/0350-两个数组的交集 II.md",key:"v-33b19a42",path:"/views/%E7%AE%80%E5%8D%95/0350-%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86%20II.html",headers:[{level:2,title:"中文题目",slug:"中文题目",charIndex:2},{level:2,title:"通过代码",slug:"通过代码",charIndex:331},{level:2,title:"官方题解",slug:"官方题解",charIndex:1470},{level:2,title:"提交历史",slug:"提交历史",charIndex:5130},{level:2,title:"统计信息",slug:"统计信息",charIndex:5753},{level:2,title:"相似题目",slug:"相似题目",charIndex:5788}],lastUpdated:"4/11/2021, 1:15:21 PM",headersStr:"中文题目 通过代码 官方题解 提交历史 统计信息 相似题目",content:"# 中文题目\n给定两个数组，编写一个函数来计算它们的交集。\n\n示例 1:\n\n输入: nums1 = [1,2,2,1], nums2 = [2,2]\n输出: [2,2]\n\n\n示例 2:\n\n输入: nums1 = [4,9,5], nums2 = [9,4,9,8,4]\n输出: [4,9]\n\n说明：\n\n * 输出结果中每个元素出现的次数，应与元素在两个数组中出现的次数一致。\n * 我们可以不考虑输出结果的顺序。\n\n进阶:\n\n * 如果给定的数组已经排好序呢？你将如何优化你的算法？\n * 如果nums1的大小比nums2小很多，哪种方法更优？\n * 如果nums2的元素存储在磁盘上，磁盘内存是有限的，并且你不能一次加载所有的元素到内存中，你该怎么办？\n\n# 通过代码\nimport java.util.ArrayList;\nimport java.util.HashMap;\nclass Solution {\n    public int[] intersect(int[] nums1, int[] nums2) {\n         HashMap<Integer,Integer> map=new HashMap<>();\n            for (int i = 0; i < nums1.length; i++) {\n                if (map.containsKey(nums1[i])){\n                    int count=map.get(nums1[i]);\n                    map.put(nums1[i],++count);\n                }\n                else {\n                    map.put(nums1[i],1);\n                }\n            }\n            ArrayList<Integer> list=new ArrayList<>();\n            for (int i :\n                    nums2) {\n                if (map.containsKey(i)){\n                     int num=map.get(i);\n                    if (num >0){\n                        map.put(i,--num);\n                        list.add(i);\n                    }\n                }\n            }\n            int a=0;\n            int[] arr=new int[list.size()];\n            for (int i :\n                    list) {\n                arr[a++]=i;\n            }\n            return arr;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n# 官方题解\n# 方法一：哈希映射\n前面的问题 349. 两个数组的交集 [https://leetcode-cn.com/problems/intersection-of-two-arrays/]，我们使用 set 来实现线性时间复杂度。在这里，我们需要使用 HashMap 来跟踪每个数字出现的次数。\n\n我们先在 HashMap 记录一个数组中的存在的数字和对应出现的次数。然后，我们遍历第二个数组，检查数字在 HashMap 中是否存在，如果存在且计数为正，则将该数字添加到答案并减少 HashMap 中的计数。检查数组的大小并对较小的数组进行哈希映射是一个小细节，当其中一个数组较大时，会减少内存的使用。\n\n算法：\n\n * 如果 nums1 元素个数大于 nums2，则交换数组元素。\n * 对于 nums1 的每个元素，添加到 HashMap m 中，如果元素已经存在则增加对应的计数。\n * 初始化 k = 0，记录当前交集元素个数。\n * 遍历数组 nums2： * 检查元素在 m 是否存在，若存在且计数为正： * 将元素拷贝到 nums1[k]，且 k++。\n       * 减少 m 中对应元素的计数。\n      \n      \n   \n   \n * 返回 nums1 前 k 个元素。\n\nvector<int> intersect(vector<int>& nums1, vector<int>& nums2) {\n    if (nums1.size() > nums2.size()) {\n        return intersect(nums2, nums1);\n    }\n    unordered_map<int, int> m;\n    for (auto n : nums1) {\n        ++m[n];\n    }\n    int k = 0;\n    for (auto n : nums2) {\n        auto it = m.find(n);\n        if (it != end(m) && --it->second >= 0) {\n            nums1[k++] = n;\n        }\n    }\n    return vector(begin(nums1), begin(nums1) + k);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\npublic int[] intersect(int[] nums1, int[] nums2) {\n    if (nums1.length > nums2.length) {\n        return intersect(nums2, nums1);\n    }\n    HashMap<Integer, Integer> m = new HashMap<>();\n    for (int n : nums1) {\n        m.put(n, m.getOrDefault(n, 0) + 1);\n    }\n    int k = 0;\n    for (int n : nums2) {\n        int cnt = m.getOrDefault(n, 0);\n        if (cnt > 0) {\n            nums1[k++] = n;\n            m.put(n, cnt - 1);\n        }\n    }\n    return Arrays.copyOfRange(nums1, 0, k);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n复杂度分析\n\n * 时间复杂度：O(n+m)\\mathcal{O}(n + m)O(n+m)。其中 nnn，mmm 分别代表了数组的大小。\n * 空间复杂度：O(min⁡(n,m))\\mathcal{O}(\\min(n, m))O(min(n,m))，我们对较小的数组进行哈希映射使用的空间。\n\n# 方法二：排序\n当输入数据是有序的，推荐使用此方法。在这里，我们对两个数组进行排序，并且使用两个指针在一次扫面找出公共的数字。\n\n算法：\n\n * 对数组 nums1 和 nums2 排序。\n * 初始化指针 i，j 和 k 为 0。\n * 指针 i 指向 nums1，指针 j 指向 nums2： * 如果 nums1[i] < nums2[j]，则 i++。\n    * 如果 nums1[i] > nums2[j]，则 j++。\n    * 如果 nums1[i] == nums2[j]，将元素拷贝到 nums1[k]，且 i++，j++，k++。\n   \n   \n * 返回数组 nums1 前 k 个元素。\n\nvector<int> intersect(vector<int>& nums1, vector<int>& nums2) {\n    sort(begin(nums1), end(nums1));\n    sort(begin(nums2), end(nums2));\n    int i = 0, j = 0, k = 0;\n    while (i < nums1.size() && j < nums2.size()) {\n        if (nums1[i] < nums2[j]) {\n            ++i;\n        } else if (nums1[i] > nums2[j]) {\n            ++j;\n        } else {\n            nums1[k++] = nums1[i++];\n            ++j;\n        }\n    }\n    return vector<int>(begin(nums1), begin(nums1) + k);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\npublic int[] intersect(int[] nums1, int[] nums2) {\n    Arrays.sort(nums1);\n    Arrays.sort(nums2);\n    int i = 0, j = 0, k = 0;\n    while (i < nums1.length && j < nums2.length) {\n        if (nums1[i] < nums2[j]) {\n            ++i;\n        } else if (nums1[i] > nums2[j]) {\n            ++j;\n        } else {\n            nums1[k++] = nums1[i++];\n            ++j;\n        }\n    }\n    return Arrays.copyOfRange(nums1, 0, k);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n复杂度分析\n\n * 时间复杂度：O(nlog⁡n+mlog⁡m)\\mathcal{O}(n\\log{n} + m\\log{m})O(nlogn+mlogm)。其中 nnn，mmm 分别代表了数组的大小。我们对数组进行了排序然后进行了线性扫描。\n * 空间复杂度：O(1)O(1)O(1)，我们忽略存储答案所使用的空间，因为它对算法本身并不重要。\n\n# 方法三：\n算法：\n\n这类似于方法 2。我们不使用两个指针进行迭代，而是使用内置函数来查找公共元素。在 C++ 中，我们可以使用 set_intersection 来排序数组（或 multisets）。\n\n在 Java 中的 retainAll 方法并不关心一个元素在另一个集合中出现的次数。\n\nvector<int> intersect(vector<int>& nums1, vector<int>& nums2) {\n    sort(begin(nums1), end(nums1));\n    sort(begin(nums2), end(nums2));\n    nums1.erase(set_intersection(begin(nums1), end(nums1), \n        begin(nums2), end(nums2), begin(nums1)), end(nums1));\n    return nums1;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n复杂度分析\n\n * 时空复杂度：与方法二相同。\n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-05-29 23:31:02Accepted [https://leetcode-cn.com//submissions/detail/2738741/]6 ms35.69%N/Ajava2018-05-29 23:28:52Wrong Answer [https://leetcode-cn.com//submissions/detail/2738627/]N/AN/AN/Ajava2018-05-29 23:27:23Wrong Answer [https://leetcode-cn.com//submissions/detail/2738556/]N/AN/AN/Ajava2018-05-29 23:24:34Wrong Answer [https://leetcode-cn.com//submissions/detail/2738468/]N/AN/AN/Ajava2018-05-29 23:23:48Wrong Answer [https://leetcode-cn.com//submissions/detail/2738445/]N/AN/AN/Ajava2018-05-29 23:22:25Wrong Answer [https://leetcode-cn.com//submissions/detail/2738422/]N/AN/AN/Ajava# 统计信息\n通过次数提交次数AC比率6210513510246.0%# 相似题目\n题目难度两个数组的交集 [https://leetcode-cn.com/problems/intersection-of-two-arrays/]简单查找常用字符 [https://leetcode-cn.com/problems/find-common-characters/]简单",contentLowercase:"# 中文题目\n给定两个数组，编写一个函数来计算它们的交集。\n\n示例 1:\n\n输入: nums1 = [1,2,2,1], nums2 = [2,2]\n输出: [2,2]\n\n\n示例 2:\n\n输入: nums1 = [4,9,5], nums2 = [9,4,9,8,4]\n输出: [4,9]\n\n说明：\n\n * 输出结果中每个元素出现的次数，应与元素在两个数组中出现的次数一致。\n * 我们可以不考虑输出结果的顺序。\n\n进阶:\n\n * 如果给定的数组已经排好序呢？你将如何优化你的算法？\n * 如果nums1的大小比nums2小很多，哪种方法更优？\n * 如果nums2的元素存储在磁盘上，磁盘内存是有限的，并且你不能一次加载所有的元素到内存中，你该怎么办？\n\n# 通过代码\nimport java.util.arraylist;\nimport java.util.hashmap;\nclass solution {\n    public int[] intersect(int[] nums1, int[] nums2) {\n         hashmap<integer,integer> map=new hashmap<>();\n            for (int i = 0; i < nums1.length; i++) {\n                if (map.containskey(nums1[i])){\n                    int count=map.get(nums1[i]);\n                    map.put(nums1[i],++count);\n                }\n                else {\n                    map.put(nums1[i],1);\n                }\n            }\n            arraylist<integer> list=new arraylist<>();\n            for (int i :\n                    nums2) {\n                if (map.containskey(i)){\n                     int num=map.get(i);\n                    if (num >0){\n                        map.put(i,--num);\n                        list.add(i);\n                    }\n                }\n            }\n            int a=0;\n            int[] arr=new int[list.size()];\n            for (int i :\n                    list) {\n                arr[a++]=i;\n            }\n            return arr;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n# 官方题解\n# 方法一：哈希映射\n前面的问题 349. 两个数组的交集 [https://leetcode-cn.com/problems/intersection-of-two-arrays/]，我们使用 set 来实现线性时间复杂度。在这里，我们需要使用 hashmap 来跟踪每个数字出现的次数。\n\n我们先在 hashmap 记录一个数组中的存在的数字和对应出现的次数。然后，我们遍历第二个数组，检查数字在 hashmap 中是否存在，如果存在且计数为正，则将该数字添加到答案并减少 hashmap 中的计数。检查数组的大小并对较小的数组进行哈希映射是一个小细节，当其中一个数组较大时，会减少内存的使用。\n\n算法：\n\n * 如果 nums1 元素个数大于 nums2，则交换数组元素。\n * 对于 nums1 的每个元素，添加到 hashmap m 中，如果元素已经存在则增加对应的计数。\n * 初始化 k = 0，记录当前交集元素个数。\n * 遍历数组 nums2： * 检查元素在 m 是否存在，若存在且计数为正： * 将元素拷贝到 nums1[k]，且 k++。\n       * 减少 m 中对应元素的计数。\n      \n      \n   \n   \n * 返回 nums1 前 k 个元素。\n\nvector<int> intersect(vector<int>& nums1, vector<int>& nums2) {\n    if (nums1.size() > nums2.size()) {\n        return intersect(nums2, nums1);\n    }\n    unordered_map<int, int> m;\n    for (auto n : nums1) {\n        ++m[n];\n    }\n    int k = 0;\n    for (auto n : nums2) {\n        auto it = m.find(n);\n        if (it != end(m) && --it->second >= 0) {\n            nums1[k++] = n;\n        }\n    }\n    return vector(begin(nums1), begin(nums1) + k);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\npublic int[] intersect(int[] nums1, int[] nums2) {\n    if (nums1.length > nums2.length) {\n        return intersect(nums2, nums1);\n    }\n    hashmap<integer, integer> m = new hashmap<>();\n    for (int n : nums1) {\n        m.put(n, m.getordefault(n, 0) + 1);\n    }\n    int k = 0;\n    for (int n : nums2) {\n        int cnt = m.getordefault(n, 0);\n        if (cnt > 0) {\n            nums1[k++] = n;\n            m.put(n, cnt - 1);\n        }\n    }\n    return arrays.copyofrange(nums1, 0, k);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n复杂度分析\n\n * 时间复杂度：o(n+m)\\mathcal{o}(n + m)o(n+m)。其中 nnn，mmm 分别代表了数组的大小。\n * 空间复杂度：o(min⁡(n,m))\\mathcal{o}(\\min(n, m))o(min(n,m))，我们对较小的数组进行哈希映射使用的空间。\n\n# 方法二：排序\n当输入数据是有序的，推荐使用此方法。在这里，我们对两个数组进行排序，并且使用两个指针在一次扫面找出公共的数字。\n\n算法：\n\n * 对数组 nums1 和 nums2 排序。\n * 初始化指针 i，j 和 k 为 0。\n * 指针 i 指向 nums1，指针 j 指向 nums2： * 如果 nums1[i] < nums2[j]，则 i++。\n    * 如果 nums1[i] > nums2[j]，则 j++。\n    * 如果 nums1[i] == nums2[j]，将元素拷贝到 nums1[k]，且 i++，j++，k++。\n   \n   \n * 返回数组 nums1 前 k 个元素。\n\nvector<int> intersect(vector<int>& nums1, vector<int>& nums2) {\n    sort(begin(nums1), end(nums1));\n    sort(begin(nums2), end(nums2));\n    int i = 0, j = 0, k = 0;\n    while (i < nums1.size() && j < nums2.size()) {\n        if (nums1[i] < nums2[j]) {\n            ++i;\n        } else if (nums1[i] > nums2[j]) {\n            ++j;\n        } else {\n            nums1[k++] = nums1[i++];\n            ++j;\n        }\n    }\n    return vector<int>(begin(nums1), begin(nums1) + k);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\npublic int[] intersect(int[] nums1, int[] nums2) {\n    arrays.sort(nums1);\n    arrays.sort(nums2);\n    int i = 0, j = 0, k = 0;\n    while (i < nums1.length && j < nums2.length) {\n        if (nums1[i] < nums2[j]) {\n            ++i;\n        } else if (nums1[i] > nums2[j]) {\n            ++j;\n        } else {\n            nums1[k++] = nums1[i++];\n            ++j;\n        }\n    }\n    return arrays.copyofrange(nums1, 0, k);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n复杂度分析\n\n * 时间复杂度：o(nlog⁡n+mlog⁡m)\\mathcal{o}(n\\log{n} + m\\log{m})o(nlogn+mlogm)。其中 nnn，mmm 分别代表了数组的大小。我们对数组进行了排序然后进行了线性扫描。\n * 空间复杂度：o(1)o(1)o(1)，我们忽略存储答案所使用的空间，因为它对算法本身并不重要。\n\n# 方法三：\n算法：\n\n这类似于方法 2。我们不使用两个指针进行迭代，而是使用内置函数来查找公共元素。在 c++ 中，我们可以使用 set_intersection 来排序数组（或 multisets）。\n\n在 java 中的 retainall 方法并不关心一个元素在另一个集合中出现的次数。\n\nvector<int> intersect(vector<int>& nums1, vector<int>& nums2) {\n    sort(begin(nums1), end(nums1));\n    sort(begin(nums2), end(nums2));\n    nums1.erase(set_intersection(begin(nums1), end(nums1), \n        begin(nums2), end(nums2), begin(nums1)), end(nums1));\n    return nums1;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n复杂度分析\n\n * 时空复杂度：与方法二相同。\n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-05-29 23:31:02accepted [https://leetcode-cn.com//submissions/detail/2738741/]6 ms35.69%n/ajava2018-05-29 23:28:52wrong answer [https://leetcode-cn.com//submissions/detail/2738627/]n/an/an/ajava2018-05-29 23:27:23wrong answer [https://leetcode-cn.com//submissions/detail/2738556/]n/an/an/ajava2018-05-29 23:24:34wrong answer [https://leetcode-cn.com//submissions/detail/2738468/]n/an/an/ajava2018-05-29 23:23:48wrong answer [https://leetcode-cn.com//submissions/detail/2738445/]n/an/an/ajava2018-05-29 23:22:25wrong answer [https://leetcode-cn.com//submissions/detail/2738422/]n/an/an/ajava# 统计信息\n通过次数提交次数ac比率6210513510246.0%# 相似题目\n题目难度两个数组的交集 [https://leetcode-cn.com/problems/intersection-of-two-arrays/]简单查找常用字符 [https://leetcode-cn.com/problems/find-common-characters/]简单"},{title:"387-字符串中的第一个唯一字符(First Unique Character in a String)",frontmatter:{title:"387-字符串中的第一个唯一字符(First Unique Character in a String)",date:"2018-08-07T00:00:00.000Z",categories:["简单"],tags:["哈希表<Hash Table>","字符串<String>"]},regularPath:"/views/%E7%AE%80%E5%8D%95/0387-%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%94%AF%E4%B8%80%E5%AD%97%E7%AC%A6.html",relativePath:"views/简单/0387-字符串中的第一个唯一字符.md",key:"v-57525a9a",path:"/views/%E7%AE%80%E5%8D%95/0387-%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%94%AF%E4%B8%80%E5%AD%97%E7%AC%A6.html",headers:[{level:2,title:"中文题目",slug:"中文题目",charIndex:2},{level:2,title:"通过代码",slug:"通过代码",charIndex:136},{level:2,title:"官方题解",slug:"官方题解",charIndex:594},{level:2,title:"提交历史",slug:"提交历史",charIndex:1981},{level:2,title:"统计信息",slug:"统计信息",charIndex:2109},{level:2,title:"相似题目",slug:"相似题目",charIndex:2144}],lastUpdated:"4/11/2021, 1:15:21 PM",headersStr:"中文题目 通过代码 官方题解 提交历史 统计信息 相似题目",content:'# 中文题目\n给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。\n\n案例:\n\n\ns = "leetcode"\n返回 0.\n\ns = "loveleetcode",\n返回 2.\n\n\n\n\n注意事项：您可以假定该字符串只包含小写字母。\n\n# 通过代码\nclass Solution {\n    public int firstUniqChar(String s) {\n         int[] arr=new int[26];\n            Arrays.fill(arr,0);\n            for (int i = 0; i < s.length(); i++) {\n                arr[s.charAt(i)-\'a\']++;\n            }\n            for (int i = 0; i < s.length(); i++) {\n                if (arr[s.charAt(i)-\'a\']==1){\n                    return i;\n                }\n            }\n            return -1;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n# 官方题解\n# 方法一： 线性时间复杂度解法\n这道题最优的解法就是线性复杂度了，为了保证每个元素是唯一的，至少得把每个字符都遍历一遍。\n\n算法的思路就是遍历一遍字符串，然后把字符串中每个字符出现的次数保存在一个散列表中。这个过程的时间复杂度为 O(N)O(N)O(N)，其中 NNN 为字符串的长度。\n\n接下来需要再遍历一次字符串，这一次利用散列表来检查遍历的每个字符是不是唯一的。如果当前字符唯一，直接返回当前下标就可以了。第二次遍历的时间复杂度也是 O(N)O(N)O(N)。\n\n<,,,,,,,,,,,,,,>\n\nclass Solution {\n    public int firstUniqChar(String s) {\n        HashMap<Character, Integer> count = new HashMap<Character, Integer>();\n        int n = s.length();\n        // build hash map : character and how often it appears\n        for (int i = 0; i < n; i++) {\n            char c = s.charAt(i);\n            count.put(c, count.getOrDefault(c, 0) + 1);\n        }\n        \n        // find the index\n        for (int i = 0; i < n; i++) {\n            if (count.get(s.charAt(i)) == 1) \n                return i;\n        }\n        return -1;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\nclass Solution:\n    def firstUniqChar(self, s: str) -> int:\n        """\n        :type s: str\n        :rtype: int\n        """\n        # build hash map : character and how often it appears\n        count = collections.Counter(s)\n        \n        # find the index\n        for idx, ch in enumerate(s):\n            if count[ch] == 1:\n                return idx\n        return -1\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n复杂度分析\n\n * 时间复杂度： O(N)O(N)O(N)只遍历了两遍字符串，同时散列表中查找操作是常数时间复杂度的。\n   \n   \n * 空间复杂度： O(N)O(N)O(N)用到了散列表来存储字符串中每个元素出现的次数。\n   \n   \n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-08-07 20:47:37Accepted [https://leetcode-cn.com//submissions/detail/5250491/]26 ms58.3%N/Ajava# 统计信息\n通过次数提交次数AC比率5661413260842.7%# 相似题目\n题目难度根据字符出现频率排序 [https://leetcode-cn.com/problems/sort-characters-by-frequency/]中等',contentLowercase:'# 中文题目\n给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。\n\n案例:\n\n\ns = "leetcode"\n返回 0.\n\ns = "loveleetcode",\n返回 2.\n\n\n\n\n注意事项：您可以假定该字符串只包含小写字母。\n\n# 通过代码\nclass solution {\n    public int firstuniqchar(string s) {\n         int[] arr=new int[26];\n            arrays.fill(arr,0);\n            for (int i = 0; i < s.length(); i++) {\n                arr[s.charat(i)-\'a\']++;\n            }\n            for (int i = 0; i < s.length(); i++) {\n                if (arr[s.charat(i)-\'a\']==1){\n                    return i;\n                }\n            }\n            return -1;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n# 官方题解\n# 方法一： 线性时间复杂度解法\n这道题最优的解法就是线性复杂度了，为了保证每个元素是唯一的，至少得把每个字符都遍历一遍。\n\n算法的思路就是遍历一遍字符串，然后把字符串中每个字符出现的次数保存在一个散列表中。这个过程的时间复杂度为 o(n)o(n)o(n)，其中 nnn 为字符串的长度。\n\n接下来需要再遍历一次字符串，这一次利用散列表来检查遍历的每个字符是不是唯一的。如果当前字符唯一，直接返回当前下标就可以了。第二次遍历的时间复杂度也是 o(n)o(n)o(n)。\n\n<,,,,,,,,,,,,,,>\n\nclass solution {\n    public int firstuniqchar(string s) {\n        hashmap<character, integer> count = new hashmap<character, integer>();\n        int n = s.length();\n        // build hash map : character and how often it appears\n        for (int i = 0; i < n; i++) {\n            char c = s.charat(i);\n            count.put(c, count.getordefault(c, 0) + 1);\n        }\n        \n        // find the index\n        for (int i = 0; i < n; i++) {\n            if (count.get(s.charat(i)) == 1) \n                return i;\n        }\n        return -1;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\nclass solution:\n    def firstuniqchar(self, s: str) -> int:\n        """\n        :type s: str\n        :rtype: int\n        """\n        # build hash map : character and how often it appears\n        count = collections.counter(s)\n        \n        # find the index\n        for idx, ch in enumerate(s):\n            if count[ch] == 1:\n                return idx\n        return -1\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n复杂度分析\n\n * 时间复杂度： o(n)o(n)o(n)只遍历了两遍字符串，同时散列表中查找操作是常数时间复杂度的。\n   \n   \n * 空间复杂度： o(n)o(n)o(n)用到了散列表来存储字符串中每个元素出现的次数。\n   \n   \n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-08-07 20:47:37accepted [https://leetcode-cn.com//submissions/detail/5250491/]26 ms58.3%n/ajava# 统计信息\n通过次数提交次数ac比率5661413260842.7%# 相似题目\n题目难度根据字符出现频率排序 [https://leetcode-cn.com/problems/sort-characters-by-frequency/]中等'},{title:"404-左叶子之和(Sum of Left Leaves)",frontmatter:{title:"404-左叶子之和(Sum of Left Leaves)",date:"2018-09-07T00:00:00.000Z",categories:["简单"],tags:["树<Tree>"]},regularPath:"/views/%E7%AE%80%E5%8D%95/0404-%E5%B7%A6%E5%8F%B6%E5%AD%90%E4%B9%8B%E5%92%8C.html",relativePath:"views/简单/0404-左叶子之和.md",key:"v-861ad970",path:"/views/%E7%AE%80%E5%8D%95/0404-%E5%B7%A6%E5%8F%B6%E5%AD%90%E4%B9%8B%E5%92%8C.html",headers:[{level:2,title:"中文题目",slug:"中文题目",charIndex:2},{level:2,title:"通过代码",slug:"通过代码",charIndex:111},{level:2,title:"高赞题解",slug:"高赞题解",charIndex:958},{level:3,title:"1. 递归",slug:"_1-递归",charIndex:965},{level:3,title:"2. 迭代",slug:"_2-迭代",charIndex:1392},{level:2,title:"提交历史",slug:"提交历史",charIndex:1947},{level:2,title:"统计信息",slug:"统计信息",charIndex:2075}],lastUpdated:"4/11/2021, 1:15:21 PM",headersStr:"中文题目 通过代码 高赞题解 1. 递归 2. 迭代 提交历史 统计信息",content:"# 中文题目\n计算给定二叉树的所有左叶子之和。\n\n示例：\n\n\n    3\n   / \\\n  9  20\n    /  \\\n   15   7\n\n在这个二叉树中，有两个左叶子，分别是 9 和 15，所以返回 24\n\n\n\n# 通过代码\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public int sumOfLeftLeaves(TreeNode root) {\n         int sum=0;\n            Stack<TreeNode> stack=new Stack<TreeNode>();\n            stack.push(root);\n            while (!stack.isEmpty()){\n                TreeNode node=stack.pop();\n                if (node !=null){\n                    if (node.left!=null && node.left.left==null && node.left.right==null){\n                        sum+=node.left.val;\n                    }\n                    stack.push(node.left);\n                    stack.push(node.right);\n                }\n            }\n            return sum;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n# 高赞题解\n# 1. 递归\n总和等于左子树的值加上右子树的值，终止条件是当前节点为左子叶或者为空节点。代码如下：\n\nclass Solution:\n    def sumOfLeftLeaves(self, root: TreeNode) -> int:\n        if not root:\n            return 0\n        if root and root.left and not root.left.left and not root.left.right:\n            return root.left.val+self.sumOfLeftLeaves(root.right)\n        return self.sumOfLeftLeaves(root.left) + self.sumOfLeftLeaves(root.right)\n\n\n1\n2\n3\n4\n5\n6\n7\n# 复杂度分析\n时空复杂度均是O(n)\n\n# 2. 迭代\n采用迭代法先序遍历，判断当前节点的左子树是否为叶子节点。代码如下：\n\nclass Solution:\n    def sumOfLeftLeaves(self, root: TreeNode) -> int:\n        sum_ = 0\n        if not root:\n            return 0\n        ans = [root]\n        while ans:\n            r = ans.pop()\n            if r.left and not r.left.left and not r.left.right:\n                sum_ += r.left.val\n            if r.left:\n                ans.append(r.left)\n            if r.right:\n                ans.append(r.right)\n        return sum_\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n# 复杂度分析\n时空复杂度均是：O(n)，当实际上比上一题的时空复杂度表现要好。\n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-09-07 16:18:41Accepted [https://leetcode-cn.com//submissions/detail/6703779/]7 ms24.01%N/Ajava# 统计信息\n通过次数提交次数AC比率149572823853.0%",contentLowercase:"# 中文题目\n计算给定二叉树的所有左叶子之和。\n\n示例：\n\n\n    3\n   / \\\n  9  20\n    /  \\\n   15   7\n\n在这个二叉树中，有两个左叶子，分别是 9 和 15，所以返回 24\n\n\n\n# 通过代码\n/**\n * definition for a binary tree node.\n * public class treenode {\n *     int val;\n *     treenode left;\n *     treenode right;\n *     treenode(int x) { val = x; }\n * }\n */\nclass solution {\n    public int sumofleftleaves(treenode root) {\n         int sum=0;\n            stack<treenode> stack=new stack<treenode>();\n            stack.push(root);\n            while (!stack.isempty()){\n                treenode node=stack.pop();\n                if (node !=null){\n                    if (node.left!=null && node.left.left==null && node.left.right==null){\n                        sum+=node.left.val;\n                    }\n                    stack.push(node.left);\n                    stack.push(node.right);\n                }\n            }\n            return sum;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n# 高赞题解\n# 1. 递归\n总和等于左子树的值加上右子树的值，终止条件是当前节点为左子叶或者为空节点。代码如下：\n\nclass solution:\n    def sumofleftleaves(self, root: treenode) -> int:\n        if not root:\n            return 0\n        if root and root.left and not root.left.left and not root.left.right:\n            return root.left.val+self.sumofleftleaves(root.right)\n        return self.sumofleftleaves(root.left) + self.sumofleftleaves(root.right)\n\n\n1\n2\n3\n4\n5\n6\n7\n# 复杂度分析\n时空复杂度均是o(n)\n\n# 2. 迭代\n采用迭代法先序遍历，判断当前节点的左子树是否为叶子节点。代码如下：\n\nclass solution:\n    def sumofleftleaves(self, root: treenode) -> int:\n        sum_ = 0\n        if not root:\n            return 0\n        ans = [root]\n        while ans:\n            r = ans.pop()\n            if r.left and not r.left.left and not r.left.right:\n                sum_ += r.left.val\n            if r.left:\n                ans.append(r.left)\n            if r.right:\n                ans.append(r.right)\n        return sum_\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n# 复杂度分析\n时空复杂度均是：o(n)，当实际上比上一题的时空复杂度表现要好。\n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-09-07 16:18:41accepted [https://leetcode-cn.com//submissions/detail/6703779/]7 ms24.01%n/ajava# 统计信息\n通过次数提交次数ac比率149572823853.0%"},{title:"374-猜数字大小(Guess Number Higher or Lower)",frontmatter:{title:"374-猜数字大小(Guess Number Higher or Lower)",date:"2021-05-23T00:00:00.000Z",categories:["简单"],tags:["二分查找<Binary Search>"]},regularPath:"/views/%E7%AE%80%E5%8D%95/0374-%E7%8C%9C%E6%95%B0%E5%AD%97%E5%A4%A7%E5%B0%8F.html",relativePath:"views/简单/0374-猜数字大小.md",key:"v-9549f80c",path:"/views/%E7%AE%80%E5%8D%95/0374-%E7%8C%9C%E6%95%B0%E5%AD%97%E5%A4%A7%E5%B0%8F.html",headers:[{level:2,title:"中文题目",slug:"中文题目",charIndex:2},{level:2,title:"通过代码",slug:"通过代码",charIndex:450},{level:2,title:"官方题解",slug:"官方题解",charIndex:1280},{level:3,title:"进阶",slug:"进阶",charIndex:4111},{level:2,title:"提交历史",slug:"提交历史",charIndex:5802},{level:2,title:"统计信息",slug:"统计信息",charIndex:5943},{level:2,title:"相似题目",slug:"相似题目",charIndex:5978}],headersStr:"中文题目 通过代码 官方题解 进阶 提交历史 统计信息 相似题目",content:"# 中文题目\n猜数字游戏的规则如下：\n\n * 每轮游戏，我都会从1到n 随机选择一个数字。 请你猜选出的是哪个数字。\n * 如果你猜错了，我会告诉你，你猜测的数字比我选出的数字是大了还是小了。\n\n你可以通过调用一个预先定义好的接口 int guess(int num) 来获取猜测结果，返回值一共有 3 种可能的情况（-1，1或 0）：\n\n * -1：我选出的数字比你猜的数字小 pick < num\n * 1：我选出的数字比你猜的数字大 pick > num\n * 0：我选出的数字和你猜的数字一样。恭喜！你猜对了！pick == num\n\n返回我选出的数字。\n\n\n\n示例 1：\n\n\n输入：n = 10, pick = 6\n输出：6\n\n\n示例 2：\n\n\n输入：n = 1, pick = 1\n输出：1\n\n\n示例 3：\n\n\n输入：n = 2, pick = 1\n输出：1\n\n\n示例 4：\n\n\n输入：n = 2, pick = 2\n输出：2\n\n\n\n\n提示：\n\n * 1 31 - 1\n * 1 \n\n# 通过代码\n/** \n * Forward declaration of guess API.\n * @param  num   your guess\n * @return \t     -1 if num is lower than the guess number\n *\t\t\t      1 if num is higher than the guess number\n *               otherwise return 0\n * int guess(int num);\n */\n\npublic class Solution extends GuessGame {\npublic int guessNumber(int n) {\n            int left=0;\n            int right=n;\n            int mid;\n            while (left<=right){\n                mid=left+(right-left)/2;\n                int res=guess(mid);\n                if (res==0){\n                    return mid;\n                }else if (res <0){\n                    right=mid-1;\n                }else {\n                    left=mid+1;\n                }\n            }\n            return -1;\n        }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n# 官方题解\n# 方法 1：暴力\n我们从 1 到 n-1 检查每一个数字，并调用 guessguessguess 函数。如果输入数字返回 0 说明它是答案。\n\n/* The guess API is defined in the parent class GuessGame.\n   @param num, your guess\n   @return -1 if my number is lower, 1 if my number is higher, otherwise return 0\n      int guess(int num); */\n\npublic class Solution extends GuessGame {\n    public int guessNumber(int n) {\n        for (int i = 1; i < n; i++)\n            if (guess(i) == 0)\n                return i;\n        return n;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n复杂度分析\n\n * 时间复杂度： O(n)O(n)O(n) 。我们从 1 到 n 扫描检查所有的数字。\n * 空间复杂度： O(1)O(1)O(1) 。不需要使用额外空间。\n\n# 方法 2：使用二分查找\n算法\n\n我们可以直接使用二分查找来找到需要的数字。我们从中间的数字开始，将数字传递到 guessguessguess 函数里。如果返回 -1, ，说明中间数字比答案大，就查找更小的那一半。类似的，如果返回 1 ，我们查找更大的一半，直到找到答案。\n\n/* The guess API is defined in the parent class GuessGame.\n   @param num, your guess\n   @return -1 if my number is lower, 1 if my number is higher, otherwise return 0\n      int guess(int num); */\n\npublic class Solution extends GuessGame {\n    public int guessNumber(int n) {\n        int low = 1;\n        int high = n;\n        while (low <= high) {\n            int mid = low + (high - low) / 2;\n            int res = guess(mid);\n            if (res == 0)\n                return mid;\n            else if (res < 0)\n                high = mid - 1;\n            else\n                low = mid + 1;\n        }\n        return -1;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n复杂度分析：\n\n * 时间复杂度： O(log⁡2n)O\\big(\\log_2 n\\big)O(log2​n) 。为二分查找的时间复杂度。\n * 空间复杂度： O(1)O(1)O(1) 。没有使用额外的空间。\n\n# 方法 3：三分查找\n算法\n\n在二分查找中，我们选择中间元素作为分隔点。而在三分查找中，我们选择两个分隔点（比方记作 m1m1m1 和 m2m2m2），那么给定范围会被分成 3 个相等长度的部分。如果答案 numnumnum 比 m1m1m1 小，那么我们对 m1m1m1 左边的区间做三分查找。如果 numnumnum 在 m1m1m1 和 m2m2m2 中间，我们对中间区域进行三分查找。否则我们对 m2m2m2 右边的区域进行三分查找。\n\n/* The guess API is defined in the parent class GuessGame.\n   @param num, your guess\n   @return -1 if my number is lower, 1 if my number is higher, otherwise return 0\n      int guess(int num); */\n\npublic class Solution extends GuessGame {\n    public int guessNumber(int n) {\n        int low = 1;\n        int high = n;\n        while (low <= high) {\n            int mid1 = low + (high - low) / 3;\n            int mid2 = high - (high - low) / 3;\n            int res1 = guess(mid1);\n            int res2 = guess(mid2);\n            if (res1 == 0)\n                return mid1;\n            if (res2 == 0)\n                return mid2;\n            else if (res1 < 0)\n                high = mid1 - 1;\n            else if (res2 > 0)\n                low = mid2 + 1;\n            else {\n                low = mid1 + 1;\n                high = mid2 - 1;\n            }\n        }\n        return -1;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n复杂度分析\n\n * 时间复杂度： O(log⁡3n)O\\big(\\log_3 n \\big)O(log3​n) 。为三分查找所需的时间复杂度。\n * 空间复杂度： O(1)O(1)O(1) 。没有使用额外的空间。\n\n# 进阶\n看起来三分查找会比二分查找更快，但是为什么二分查找使用得更广泛？\n\n# 二分查找和三分查找的比较\n三分查找比二分查找效果要更差，下面的递归式求出了二分查找最坏情况下的渐近复杂度。\n\nT(n)=T(n2)+2,T(1)=1T(n2)=T(n22)+2∴T(n)=T(n22)+2×2=T(n23)+3×2=…=T(n2log⁡2n)+2log⁡2n=T(1)+2log⁡2n=1+2log⁡2n\\begin{aligned} T(n) &= T\\bigg(\\frac{n}{2} \\ \\bigg) + 2, \\quad T(1) = 1 \\\\ T\\bigg(\\frac{n}{2} \\ \\bigg) &= T\\bigg(\\frac{n}{2^2} \\ \\bigg) + 2 \\\\ \\\\ \\therefore{} \\quad T(n) &= T\\bigg(\\frac{n}{2^2} \\ \\bigg) + 2 \\times 2 \\\\ &= T\\bigg(\\frac{n}{2^3} \\ \\bigg) + 3 \\times 2 \\\\ &= \\ldots \\\\ &= T\\bigg(\\frac{n}{2^{\\log_2 n}} \\ \\bigg) + 2 \\log_2 n \\\\ &= T(1) + 2 \\log_2 n \\\\ &= 1 + 2 \\log_2 n \\end{aligned}T(n)T(2n​)∴T(n)​=T(2n​)+2,T(1)=1=T(22n​)+2=T(22n​)+2×2=T(23n​)+3×2=…=T(2log2​nn​)+2log2​n=T(1)+2log2​n=1+2log2​n​\n\n下面的递归式求出了三分查找最坏情况下的渐近时间复杂度。\n\nT(n)=T(n3)+4,T(1)=1T(n3)=T(n32)+4∴T(n)=T(n32)+2×4=T(n33)+3×4=…=T(n3log⁡3n)+4log⁡3n=T(1)+4log⁡3n=1+4log⁡3n\\begin{aligned} T(n) &= T\\bigg(\\frac{n}{3} \\ \\bigg) + 4, \\quad T(1) = 1 \\\\ T\\bigg(\\frac{n}{3} \\ \\bigg) &= T\\bigg(\\frac{n}{3^2} \\ \\bigg) + 4 \\\\ \\\\ \\therefore{} \\quad T(n) &= T\\bigg(\\frac{n}{3^2} \\ \\bigg) + 2 \\times 4 \\\\ &= T\\bigg(\\frac{n}{3^3} \\ \\bigg) + 3 \\times 4 \\\\ &= \\ldots \\\\ &= T\\bigg(\\frac{n}{3^{\\log_3 n}} \\ \\bigg) + 4 \\log_3 n \\\\ &= T(1) + 4 \\log_3 n \\\\ &= 1 + 4 \\log_3 n \\end{aligned}T(n)T(3n​)∴T(n)​=T(3n​)+4,T(1)=1=T(32n​)+4=T(32n​)+2×4=T(33n​)+3×4=…=T(3log3​nn​)+4log3​n=T(1)+4log3​n=1+4log3​n​\n\n如上所示，二分查找和三分查找最坏情况的比较是 1+4log⁡3n1 + 4 \\log_3 n1+4log3​n 和 1+2log⁡2n1 + 2 \\log_2 n1+2log2​n 之间的比较。为了比较哪个更大，我们只需要比较表达式 2log⁡3n2 \\log_3 n2log3​n 和 log⁡2n\\log_2 nlog2​n 。表达式 2log⁡3n2 \\log_3 n2log3​n 可以被写作 2log⁡23×log⁡2n\\frac{2}{\\log_2 3} \\times \\log_2 nlog2​32​×log2​n 。因此 2log⁡23\\frac{2}{\\log_2 3}log2​32​ 比 1 大，所以最坏情况下三分查找比较次数比二分查找最坏情况要多。\n\n# 提交历史\n提交时间提交结果标记状态我的注释执行时间战胜比例内存消耗语言2021-05-23 18:32:33Accepted [https://leetcode-cn.com/submissions/detail/180142045/]0 ms100.0%34.8 MBjava# 统计信息\n通过次数提交次数AC比率5046710533547.9%# 相似题目\n题目难度第一个错误的版本 [https://leetcode-cn.com/problems/first-bad-version/]简单猜数字大小 II [https://leetcode-cn.com/problems/guess-number-higher-or-lower-ii/]中等找到 K 个最接近的元素 [https://leetcode-cn.com/problems/find-k-closest-elements/]中等",contentLowercase:"# 中文题目\n猜数字游戏的规则如下：\n\n * 每轮游戏，我都会从1到n 随机选择一个数字。 请你猜选出的是哪个数字。\n * 如果你猜错了，我会告诉你，你猜测的数字比我选出的数字是大了还是小了。\n\n你可以通过调用一个预先定义好的接口 int guess(int num) 来获取猜测结果，返回值一共有 3 种可能的情况（-1，1或 0）：\n\n * -1：我选出的数字比你猜的数字小 pick < num\n * 1：我选出的数字比你猜的数字大 pick > num\n * 0：我选出的数字和你猜的数字一样。恭喜！你猜对了！pick == num\n\n返回我选出的数字。\n\n\n\n示例 1：\n\n\n输入：n = 10, pick = 6\n输出：6\n\n\n示例 2：\n\n\n输入：n = 1, pick = 1\n输出：1\n\n\n示例 3：\n\n\n输入：n = 2, pick = 1\n输出：1\n\n\n示例 4：\n\n\n输入：n = 2, pick = 2\n输出：2\n\n\n\n\n提示：\n\n * 1 31 - 1\n * 1 \n\n# 通过代码\n/** \n * forward declaration of guess api.\n * @param  num   your guess\n * @return \t     -1 if num is lower than the guess number\n *\t\t\t      1 if num is higher than the guess number\n *               otherwise return 0\n * int guess(int num);\n */\n\npublic class solution extends guessgame {\npublic int guessnumber(int n) {\n            int left=0;\n            int right=n;\n            int mid;\n            while (left<=right){\n                mid=left+(right-left)/2;\n                int res=guess(mid);\n                if (res==0){\n                    return mid;\n                }else if (res <0){\n                    right=mid-1;\n                }else {\n                    left=mid+1;\n                }\n            }\n            return -1;\n        }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n# 官方题解\n# 方法 1：暴力\n我们从 1 到 n-1 检查每一个数字，并调用 guessguessguess 函数。如果输入数字返回 0 说明它是答案。\n\n/* the guess api is defined in the parent class guessgame.\n   @param num, your guess\n   @return -1 if my number is lower, 1 if my number is higher, otherwise return 0\n      int guess(int num); */\n\npublic class solution extends guessgame {\n    public int guessnumber(int n) {\n        for (int i = 1; i < n; i++)\n            if (guess(i) == 0)\n                return i;\n        return n;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n复杂度分析\n\n * 时间复杂度： o(n)o(n)o(n) 。我们从 1 到 n 扫描检查所有的数字。\n * 空间复杂度： o(1)o(1)o(1) 。不需要使用额外空间。\n\n# 方法 2：使用二分查找\n算法\n\n我们可以直接使用二分查找来找到需要的数字。我们从中间的数字开始，将数字传递到 guessguessguess 函数里。如果返回 -1, ，说明中间数字比答案大，就查找更小的那一半。类似的，如果返回 1 ，我们查找更大的一半，直到找到答案。\n\n/* the guess api is defined in the parent class guessgame.\n   @param num, your guess\n   @return -1 if my number is lower, 1 if my number is higher, otherwise return 0\n      int guess(int num); */\n\npublic class solution extends guessgame {\n    public int guessnumber(int n) {\n        int low = 1;\n        int high = n;\n        while (low <= high) {\n            int mid = low + (high - low) / 2;\n            int res = guess(mid);\n            if (res == 0)\n                return mid;\n            else if (res < 0)\n                high = mid - 1;\n            else\n                low = mid + 1;\n        }\n        return -1;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n复杂度分析：\n\n * 时间复杂度： o(log⁡2n)o\\big(\\log_2 n\\big)o(log2​n) 。为二分查找的时间复杂度。\n * 空间复杂度： o(1)o(1)o(1) 。没有使用额外的空间。\n\n# 方法 3：三分查找\n算法\n\n在二分查找中，我们选择中间元素作为分隔点。而在三分查找中，我们选择两个分隔点（比方记作 m1m1m1 和 m2m2m2），那么给定范围会被分成 3 个相等长度的部分。如果答案 numnumnum 比 m1m1m1 小，那么我们对 m1m1m1 左边的区间做三分查找。如果 numnumnum 在 m1m1m1 和 m2m2m2 中间，我们对中间区域进行三分查找。否则我们对 m2m2m2 右边的区域进行三分查找。\n\n/* the guess api is defined in the parent class guessgame.\n   @param num, your guess\n   @return -1 if my number is lower, 1 if my number is higher, otherwise return 0\n      int guess(int num); */\n\npublic class solution extends guessgame {\n    public int guessnumber(int n) {\n        int low = 1;\n        int high = n;\n        while (low <= high) {\n            int mid1 = low + (high - low) / 3;\n            int mid2 = high - (high - low) / 3;\n            int res1 = guess(mid1);\n            int res2 = guess(mid2);\n            if (res1 == 0)\n                return mid1;\n            if (res2 == 0)\n                return mid2;\n            else if (res1 < 0)\n                high = mid1 - 1;\n            else if (res2 > 0)\n                low = mid2 + 1;\n            else {\n                low = mid1 + 1;\n                high = mid2 - 1;\n            }\n        }\n        return -1;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n复杂度分析\n\n * 时间复杂度： o(log⁡3n)o\\big(\\log_3 n \\big)o(log3​n) 。为三分查找所需的时间复杂度。\n * 空间复杂度： o(1)o(1)o(1) 。没有使用额外的空间。\n\n# 进阶\n看起来三分查找会比二分查找更快，但是为什么二分查找使用得更广泛？\n\n# 二分查找和三分查找的比较\n三分查找比二分查找效果要更差，下面的递归式求出了二分查找最坏情况下的渐近复杂度。\n\nt(n)=t(n2)+2,t(1)=1t(n2)=t(n22)+2∴t(n)=t(n22)+2×2=t(n23)+3×2=…=t(n2log⁡2n)+2log⁡2n=t(1)+2log⁡2n=1+2log⁡2n\\begin{aligned} t(n) &= t\\bigg(\\frac{n}{2} \\ \\bigg) + 2, \\quad t(1) = 1 \\\\ t\\bigg(\\frac{n}{2} \\ \\bigg) &= t\\bigg(\\frac{n}{2^2} \\ \\bigg) + 2 \\\\ \\\\ \\therefore{} \\quad t(n) &= t\\bigg(\\frac{n}{2^2} \\ \\bigg) + 2 \\times 2 \\\\ &= t\\bigg(\\frac{n}{2^3} \\ \\bigg) + 3 \\times 2 \\\\ &= \\ldots \\\\ &= t\\bigg(\\frac{n}{2^{\\log_2 n}} \\ \\bigg) + 2 \\log_2 n \\\\ &= t(1) + 2 \\log_2 n \\\\ &= 1 + 2 \\log_2 n \\end{aligned}t(n)t(2n​)∴t(n)​=t(2n​)+2,t(1)=1=t(22n​)+2=t(22n​)+2×2=t(23n​)+3×2=…=t(2log2​nn​)+2log2​n=t(1)+2log2​n=1+2log2​n​\n\n下面的递归式求出了三分查找最坏情况下的渐近时间复杂度。\n\nt(n)=t(n3)+4,t(1)=1t(n3)=t(n32)+4∴t(n)=t(n32)+2×4=t(n33)+3×4=…=t(n3log⁡3n)+4log⁡3n=t(1)+4log⁡3n=1+4log⁡3n\\begin{aligned} t(n) &= t\\bigg(\\frac{n}{3} \\ \\bigg) + 4, \\quad t(1) = 1 \\\\ t\\bigg(\\frac{n}{3} \\ \\bigg) &= t\\bigg(\\frac{n}{3^2} \\ \\bigg) + 4 \\\\ \\\\ \\therefore{} \\quad t(n) &= t\\bigg(\\frac{n}{3^2} \\ \\bigg) + 2 \\times 4 \\\\ &= t\\bigg(\\frac{n}{3^3} \\ \\bigg) + 3 \\times 4 \\\\ &= \\ldots \\\\ &= t\\bigg(\\frac{n}{3^{\\log_3 n}} \\ \\bigg) + 4 \\log_3 n \\\\ &= t(1) + 4 \\log_3 n \\\\ &= 1 + 4 \\log_3 n \\end{aligned}t(n)t(3n​)∴t(n)​=t(3n​)+4,t(1)=1=t(32n​)+4=t(32n​)+2×4=t(33n​)+3×4=…=t(3log3​nn​)+4log3​n=t(1)+4log3​n=1+4log3​n​\n\n如上所示，二分查找和三分查找最坏情况的比较是 1+4log⁡3n1 + 4 \\log_3 n1+4log3​n 和 1+2log⁡2n1 + 2 \\log_2 n1+2log2​n 之间的比较。为了比较哪个更大，我们只需要比较表达式 2log⁡3n2 \\log_3 n2log3​n 和 log⁡2n\\log_2 nlog2​n 。表达式 2log⁡3n2 \\log_3 n2log3​n 可以被写作 2log⁡23×log⁡2n\\frac{2}{\\log_2 3} \\times \\log_2 nlog2​32​×log2​n 。因此 2log⁡23\\frac{2}{\\log_2 3}log2​32​ 比 1 大，所以最坏情况下三分查找比较次数比二分查找最坏情况要多。\n\n# 提交历史\n提交时间提交结果标记状态我的注释执行时间战胜比例内存消耗语言2021-05-23 18:32:33accepted [https://leetcode-cn.com/submissions/detail/180142045/]0 ms100.0%34.8 mbjava# 统计信息\n通过次数提交次数ac比率5046710533547.9%# 相似题目\n题目难度第一个错误的版本 [https://leetcode-cn.com/problems/first-bad-version/]简单猜数字大小 ii [https://leetcode-cn.com/problems/guess-number-higher-or-lower-ii/]中等找到 k 个最接近的元素 [https://leetcode-cn.com/problems/find-k-closest-elements/]中等"},{title:"367-有效的完全平方数(Valid Perfect Square)",frontmatter:{title:"367-有效的完全平方数(Valid Perfect Square)",date:"2020-01-01T00:00:00.000Z",categories:["简单"],tags:["数学<Math>","二分查找<Binary Search>"]},regularPath:"/views/%E7%AE%80%E5%8D%95/0367-%E6%9C%89%E6%95%88%E7%9A%84%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0.html",relativePath:"views/简单/0367-有效的完全平方数.md",key:"v-c89f9d26",path:"/views/%E7%AE%80%E5%8D%95/0367-%E6%9C%89%E6%95%88%E7%9A%84%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0.html",headers:[{level:2,title:"中文题目",slug:"中文题目",charIndex:2},{level:2,title:"通过代码",slug:"通过代码",charIndex:137},{level:2,title:"官方题解",slug:"官方题解",charIndex:1702},{level:2,title:"提交历史",slug:"提交历史",charIndex:4724},{level:2,title:"统计信息",slug:"统计信息",charIndex:5265},{level:2,title:"相似题目",slug:"相似题目",charIndex:5299}],lastUpdated:"4/11/2021, 1:15:21 PM",headersStr:"中文题目 通过代码 官方题解 提交历史 统计信息 相似题目",content:"# 中文题目\n给定一个正整数 num，编写一个函数，如果 num 是一个完全平方数，则返回 True，否则返回 False。\n\n说明：不要使用任何内置的库函数，如 sqrt。\n\n示例 1：\n\n输入：16\n输出：True\n\n示例 2：\n\n输入：14\n输出：False\n\n\n# 通过代码\nclass Solution {\n    public boolean isPerfectSquare(int num) {\n        //可以使用折半查找的方式来降低复杂度\n        long left = 1;\n        long right = num;\n\n        while (left <= right){\n            //注意右移的时候可能会出现数字越界，得使用long\n            long middle = (left+right) >> 1;\n            long res = (long) Math.pow(middle,2);\n            if ( res == num ){\n                return true;\n            }\n            if (res > num){\n                right = middle-1;\n            }else {\n                left = middle+1;\n            }\n        }\n        return num == 0;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\nclass Solution {\n    public boolean isPerfectSquare(int num) {\n        //可以使用折半查找的方式来降低复杂度\n        long left = 1;\n        long right = num;\n\n        while (left <= right){\n            long middle = (left+right) >> 1;\n            long res = (long) Math.pow(middle,2);\n            if ( res == num ){\n                return true;\n            }\n            if (left == middle || right == middle){\n                return false;\n            }\n            if (res > num){\n                right = middle;\n            }else {\n                left = middle;\n            }\n        }\n        return num == 0;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\nclass Solution {\n    public boolean isPerfectSquare(int num) {\n        //大于0的完全平方数由 1+3+5+7...的奇数和组成\n        for (int i = 1; num > 0; i+= 2) {\n            if ((num -= i) == 0){\n                return true;\n            }\n        }\n        return num == 0;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n# 官方题解\n# 概述：\n平方根相关问题通常可以在对数时间内求解。这里列出了从最坏到最好的三种标准对数时间的方法：\n\n * 递归\n * 二分查找\n * 牛顿迭代法\n\n后面两个算法是最有趣的，让我们详细的讨论它。\n\n这些解决方法都有相同的起点。num 是一个有效的完全平方数若 x∗x==numx * x == \\textrm{num}x∗x==num。\n\n# 方法一：二分查找\n * 若 num < 2，返回 true。\n * 设置左边界为 2，右边界为 num/2。\n * 当 left <= right： * 令 x = (left + right) / 2 作为一个猜测，计算 guess_squared = x * x 与 num 做比较： * 如果 guess_squared == num，则 num 是一个完全平方数，返回 true。\n       * 如果 guess_squared > num ，设置右边界 right = x-1。\n       * 否则设置左边界为 left = x+1。\n      \n      \n   \n   \n * 如果在循环体内没有找到，则说明 num 不是完全平方数，返回 false。\n\n\n\n算法：\n\nclass Solution:\n    def isPerfectSquare(self, num: int) -> bool:\n        if num < 2:\n            return True\n        \n        left, right = 2, num // 2\n        \n        while left <= right:\n            x = left + (right - left) // 2\n            guess_squared = x * x\n            if guess_squared == num:\n                return True\n            if guess_squared > num:\n                right = x - 1\n            else:\n                left = x + 1\n        \n        return False\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\nclass Solution {\n  public boolean isPerfectSquare(int num) {\n    if (num < 2) {\n      return true;\n    }\n\n    long left = 2, right = num / 2, x, guessSquared;\n    while (left <= right) {\n      x = left + (right - left) / 2;\n      guessSquared = x * x;\n      if (guessSquared == num) {\n        return true;\n      }\n      if (guessSquared > num) {\n        right = x - 1;\n      } else {\n        left = x + 1;\n      }\n    }\n    return false;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n复杂度分析\n\n * 时间复杂度：O(log⁡N)\\mathcal{O}(\\log N)O(logN)。\n * 空间复杂度：O(1)\\mathcal{O}(1)O(1)。\n\n# 方法二：牛顿迭代法\n牛顿迭代法：公式是如何推导的呢？让我们做一个非常粗略的推导。\n\n问题是找出：f(x)=x2−num=0f(x) = x^2 - \\textrm{num} = 0f(x)=x2−num=0 的根。\n\n牛顿迭代法的思想是从一个初始近似值开始，然后作一系列改进的逼近根的过程。举个例子：我们取 xkx_kxk​ 作为根的初始近似值，然后在 (xk，f(xk))(x_k，f(x_k))(xk​，f(xk​)) 处做切线与 xxx 轴相交经过 xk+1x_{k+1}xk+1​。\n\n通过斜率可写等价公式 f(xk)xk−xk+1=f′(xk)\\frac{f(x_k)}{x_k-x_{k+1}} = f'(x_k)xk​−xk+1​f(xk​)​=f′(xk​)\n\n转换后得 xk+1=xk−f(xk)f′(xk)x_{k + 1} = x_k - \\frac{f(x_k)}{f'(x_k)}xk+1​=xk​−f′(xk​)f(xk​)​\n\n将以下公式代入\n\n * f(xk)=xk2−numf(x_k) = x_k^2 - \\textrm{num}f(xk​)=xk2​−num\n * f′(xk)=2xkf'(x_k) = 2x_kf′(xk​)=2xk​\n\n得到 xk+1=12(xk+numxk)x_{k + 1} = \\frac{1}{2}\\left(x_k + \\frac{\\textrm{num}}{x_k}\\right)xk+1​=21​(xk​+xk​num​)\n\n算法：\n\n * 我们取 num/2 作为初始近似值。\n * 当 x * x > num，用牛顿迭代法取计算下一个近似值：x=12(x+numx)x = \\frac{1}{2}\\left(x + \\frac{\\textrm{num}}{x}\\right)x=21​(x+xnum​)。\n * 返回 x*x == num。\n\nclass Solution:\n    def isPerfectSquare(self, num: int) -> bool:\n        if num < 2:\n            return True\n        \n        x = num // 2\n        while x * x > num:\n            x = (x + num // x) // 2\n        return x * x == num\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\nclass Solution {\n  public boolean isPerfectSquare(int num) {\n    if (num < 2) return true;\n\n    long x = num / 2;\n    while (x * x > num) {\n      x = (x + num / x) / 2;\n    }\n    return (x * x == num);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n复杂度分析\n\n * 时间复杂度：O(log⁡N)\\mathcal{O}(\\log N)O(logN)。\n * 空间复杂度：O(1)\\mathcal{O}(1)O(1)。\n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2020-01-01 20:41:34Accepted [https://leetcode-cn.com//submissions/detail/41938581/]0 ms100.0%32.9 MBjava2020-01-01 20:39:09Accepted [https://leetcode-cn.com//submissions/detail/41938374/]0 ms100.0%33.2 MBjava2020-01-01 20:36:07Wrong Answer [https://leetcode-cn.com//submissions/detail/41938114/]N/AN/AN/Ajava2020-01-01 20:25:43Wrong Answer [https://leetcode-cn.com//submissions/detail/41937320/]N/AN/AN/Ajava2020-01-01 17:59:05Accepted [https://leetcode-cn.com//submissions/detail/41926434/]2 ms20.04%33.1 MBjava# 统计信息\n通过次数提交次数AC比率213094970742.9%# 相似题目\n题目难度x 的平方根 [https://leetcode-cn.com/problems/sqrtx/]简单平方数之和 [https://leetcode-cn.com/problems/sum-of-square-numbers/]简单",contentLowercase:"# 中文题目\n给定一个正整数 num，编写一个函数，如果 num 是一个完全平方数，则返回 true，否则返回 false。\n\n说明：不要使用任何内置的库函数，如 sqrt。\n\n示例 1：\n\n输入：16\n输出：true\n\n示例 2：\n\n输入：14\n输出：false\n\n\n# 通过代码\nclass solution {\n    public boolean isperfectsquare(int num) {\n        //可以使用折半查找的方式来降低复杂度\n        long left = 1;\n        long right = num;\n\n        while (left <= right){\n            //注意右移的时候可能会出现数字越界，得使用long\n            long middle = (left+right) >> 1;\n            long res = (long) math.pow(middle,2);\n            if ( res == num ){\n                return true;\n            }\n            if (res > num){\n                right = middle-1;\n            }else {\n                left = middle+1;\n            }\n        }\n        return num == 0;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\nclass solution {\n    public boolean isperfectsquare(int num) {\n        //可以使用折半查找的方式来降低复杂度\n        long left = 1;\n        long right = num;\n\n        while (left <= right){\n            long middle = (left+right) >> 1;\n            long res = (long) math.pow(middle,2);\n            if ( res == num ){\n                return true;\n            }\n            if (left == middle || right == middle){\n                return false;\n            }\n            if (res > num){\n                right = middle;\n            }else {\n                left = middle;\n            }\n        }\n        return num == 0;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\nclass solution {\n    public boolean isperfectsquare(int num) {\n        //大于0的完全平方数由 1+3+5+7...的奇数和组成\n        for (int i = 1; num > 0; i+= 2) {\n            if ((num -= i) == 0){\n                return true;\n            }\n        }\n        return num == 0;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n# 官方题解\n# 概述：\n平方根相关问题通常可以在对数时间内求解。这里列出了从最坏到最好的三种标准对数时间的方法：\n\n * 递归\n * 二分查找\n * 牛顿迭代法\n\n后面两个算法是最有趣的，让我们详细的讨论它。\n\n这些解决方法都有相同的起点。num 是一个有效的完全平方数若 x∗x==numx * x == \\textrm{num}x∗x==num。\n\n# 方法一：二分查找\n * 若 num < 2，返回 true。\n * 设置左边界为 2，右边界为 num/2。\n * 当 left <= right： * 令 x = (left + right) / 2 作为一个猜测，计算 guess_squared = x * x 与 num 做比较： * 如果 guess_squared == num，则 num 是一个完全平方数，返回 true。\n       * 如果 guess_squared > num ，设置右边界 right = x-1。\n       * 否则设置左边界为 left = x+1。\n      \n      \n   \n   \n * 如果在循环体内没有找到，则说明 num 不是完全平方数，返回 false。\n\n\n\n算法：\n\nclass solution:\n    def isperfectsquare(self, num: int) -> bool:\n        if num < 2:\n            return true\n        \n        left, right = 2, num // 2\n        \n        while left <= right:\n            x = left + (right - left) // 2\n            guess_squared = x * x\n            if guess_squared == num:\n                return true\n            if guess_squared > num:\n                right = x - 1\n            else:\n                left = x + 1\n        \n        return false\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\nclass solution {\n  public boolean isperfectsquare(int num) {\n    if (num < 2) {\n      return true;\n    }\n\n    long left = 2, right = num / 2, x, guesssquared;\n    while (left <= right) {\n      x = left + (right - left) / 2;\n      guesssquared = x * x;\n      if (guesssquared == num) {\n        return true;\n      }\n      if (guesssquared > num) {\n        right = x - 1;\n      } else {\n        left = x + 1;\n      }\n    }\n    return false;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n复杂度分析\n\n * 时间复杂度：o(log⁡n)\\mathcal{o}(\\log n)o(logn)。\n * 空间复杂度：o(1)\\mathcal{o}(1)o(1)。\n\n# 方法二：牛顿迭代法\n牛顿迭代法：公式是如何推导的呢？让我们做一个非常粗略的推导。\n\n问题是找出：f(x)=x2−num=0f(x) = x^2 - \\textrm{num} = 0f(x)=x2−num=0 的根。\n\n牛顿迭代法的思想是从一个初始近似值开始，然后作一系列改进的逼近根的过程。举个例子：我们取 xkx_kxk​ 作为根的初始近似值，然后在 (xk，f(xk))(x_k，f(x_k))(xk​，f(xk​)) 处做切线与 xxx 轴相交经过 xk+1x_{k+1}xk+1​。\n\n通过斜率可写等价公式 f(xk)xk−xk+1=f′(xk)\\frac{f(x_k)}{x_k-x_{k+1}} = f'(x_k)xk​−xk+1​f(xk​)​=f′(xk​)\n\n转换后得 xk+1=xk−f(xk)f′(xk)x_{k + 1} = x_k - \\frac{f(x_k)}{f'(x_k)}xk+1​=xk​−f′(xk​)f(xk​)​\n\n将以下公式代入\n\n * f(xk)=xk2−numf(x_k) = x_k^2 - \\textrm{num}f(xk​)=xk2​−num\n * f′(xk)=2xkf'(x_k) = 2x_kf′(xk​)=2xk​\n\n得到 xk+1=12(xk+numxk)x_{k + 1} = \\frac{1}{2}\\left(x_k + \\frac{\\textrm{num}}{x_k}\\right)xk+1​=21​(xk​+xk​num​)\n\n算法：\n\n * 我们取 num/2 作为初始近似值。\n * 当 x * x > num，用牛顿迭代法取计算下一个近似值：x=12(x+numx)x = \\frac{1}{2}\\left(x + \\frac{\\textrm{num}}{x}\\right)x=21​(x+xnum​)。\n * 返回 x*x == num。\n\nclass solution:\n    def isperfectsquare(self, num: int) -> bool:\n        if num < 2:\n            return true\n        \n        x = num // 2\n        while x * x > num:\n            x = (x + num // x) // 2\n        return x * x == num\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\nclass solution {\n  public boolean isperfectsquare(int num) {\n    if (num < 2) return true;\n\n    long x = num / 2;\n    while (x * x > num) {\n      x = (x + num / x) / 2;\n    }\n    return (x * x == num);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n复杂度分析\n\n * 时间复杂度：o(log⁡n)\\mathcal{o}(\\log n)o(logn)。\n * 空间复杂度：o(1)\\mathcal{o}(1)o(1)。\n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2020-01-01 20:41:34accepted [https://leetcode-cn.com//submissions/detail/41938581/]0 ms100.0%32.9 mbjava2020-01-01 20:39:09accepted [https://leetcode-cn.com//submissions/detail/41938374/]0 ms100.0%33.2 mbjava2020-01-01 20:36:07wrong answer [https://leetcode-cn.com//submissions/detail/41938114/]n/an/an/ajava2020-01-01 20:25:43wrong answer [https://leetcode-cn.com//submissions/detail/41937320/]n/an/an/ajava2020-01-01 17:59:05accepted [https://leetcode-cn.com//submissions/detail/41926434/]2 ms20.04%33.1 mbjava# 统计信息\n通过次数提交次数ac比率213094970742.9%# 相似题目\n题目难度x 的平方根 [https://leetcode-cn.com/problems/sqrtx/]简单平方数之和 [https://leetcode-cn.com/problems/sum-of-square-numbers/]简单"},{title:"434-字符串中的单词数(Number of Segments in a String)",frontmatter:{title:"434-字符串中的单词数(Number of Segments in a String)",date:"2020-01-05T00:00:00.000Z",categories:["简单"],tags:["字符串<String>"]},regularPath:"/views/%E7%AE%80%E5%8D%95/0434-%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%8D%95%E8%AF%8D%E6%95%B0.html",relativePath:"views/简单/0434-字符串中的单词数.md",key:"v-4a51aa00",path:"/views/%E7%AE%80%E5%8D%95/0434-%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%8D%95%E8%AF%8D%E6%95%B0.html",headers:[{level:2,title:"中文题目",slug:"中文题目",charIndex:2},{level:2,title:"通过代码",slug:"通过代码",charIndex:112},{level:2,title:"官方题解",slug:"官方题解",charIndex:309},{level:2,title:"提交历史",slug:"提交历史",charIndex:2312},{level:2,title:"统计信息",slug:"统计信息",charIndex:2945}],lastUpdated:"4/11/2021, 1:15:21 PM",headersStr:"中文题目 通过代码 官方题解 提交历史 统计信息",content:'# 中文题目\n统计字符串中的单词个数，这里的单词指的是连续的不是空格的字符。\n\n请注意，你可以假定字符串里不包括任何不可打印的字符。\n\n示例:\n\n输入: "Hello, my name is John"\n输出: 5\n\n\n# 通过代码\nclass Solution {\n    public int countSegments(String s) {\n        // 注意连续空格，字符串开头是空格\n        return (s == null ||s.trim().equals("")) ? 0 : s.trim().split("\\\\s+").length;\n    }\n}\n\n1\n2\n3\n4\n5\n# 官方题解\n# 方法一：使用语言内置函数 【通过】\n直觉\n\n在执行效率不如代码可读性重要的情况下，使用语言内置的函数解决问题更好些。\n\n算法\n\n本问题有一些边缘情况需要考虑，至少在Java中如此。首先，开头的一个或多个空格会导致 split 函数在字符串开头产生一个错误的 ""，因此我们使用内置的 trim 函数来移除这些空格。其次，如果结果为空字符串，可以直接输出 0。由于 split 函数的下述特性，这一点很重要：\n\nString[] tokens = "".split("\\\\s++");\ntokens.length; // 1\ntokens[0]; // ""\n\n\n1\n2\n3\n当抵达最后的 return 语句，我们将修整过的字符串以一个或多个空格字符切分（split 函数可以使用正则表达式），并返回结果数组的长度。\n\n用 Python 写的代码要短很多，这是由于 Python 的 split 函数和 Java 相比有很多不同之处，更加适合此类问题。值得注意的是，当对空字符串使用 split 时，会返回空数组。这是由于 Python 会在 split 之前隐式地调用 trim (在Python lingo 中是 strip)。\n\nclass Solution {\n    public int countSegments(String s) {\n        String trimmed = s.trim();\n        if (trimmed.equals("")) {\n            return 0;\n        }\n        return trimmed.split("\\\\s+").length;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\nclass Solution:\n    def countSegments(self, s):\n        return len(s.split())\n\n\n1\n2\n3\n复杂度分析\n\n * 时间复杂度 : O(n){O}(n)O(n)。\n   \n   这里用到的内置函数（无论是 Java 还是 Python）的时间复杂度或为 O(n){O}(n)O(n)，或为 O(1){O}(1)O(1) ，故整个算法可以在线性复杂度内完成。\n   \n   \n * 空间复杂度 : O(n){O}(n)O(n)。\n   \n   split 函数 (不管哪种语言) 返回长度为 O(n){O}(n)O(n) 的数组/列表，故算法使用线性的额外空间。\n   \n   \n\n\n\n\n# 方法二：原地法 【通过】\n直觉\n\n如果无法容忍线性的额外空间，可以使用在线性时间和常数空间内解决问题的简单算法。\n\n算法\n\n计算单词的数量，就等同于计数单词开始的下标个数。因此，只需要定义好下标的条件，就可以遍历整个字符串，检测每个下标。定义如下：若该下标前为空格（或者为初始下标），且自身不为空格，则其为单词开始的下标。该条件可以以常数时间检测。最后，返回满足条件的下标个数。\n\nclass Solution {\n    public int countSegments(String s) {\n        int segmentCount = 0;\n\n        for (int i = 0; i < s.length(); i++) {\n            if ((i == 0 || s.charAt(i-1) == \' \') && s.charAt(i) != \' \') {\n                segmentCount++;\n            }\n        }\n\n        return segmentCount;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\nclass Solution:\n    def countSegments(self, s):\n        segment_count = 0\n\n        for i in range(len(s)):\n            if (i == 0 or s[i-1] == \' \') and s[i] != \' \':\n                segment_count += 1\n\n        return segment_count\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n复杂度分析\n\n * 时间复杂度 : O(n){O}(n)O(n)。\n   \n   对每个下标进行常数时间的检测。\n   \n   \n * 空间复杂度 : O(1){O}(1)O(1)。\n   \n   只使用了额外的几个整数，因此使用的空间为常数。\n   \n   \n\n\n\n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2020-01-05 15:07:42Accepted [https://leetcode-cn.com//submissions/detail/42341932/]2 ms35.03%34.2 MBjava2020-01-05 15:05:33Wrong Answer [https://leetcode-cn.com//submissions/detail/42341675/]N/AN/AN/Ajava2020-01-05 15:04:06Wrong Answer [https://leetcode-cn.com//submissions/detail/42341553/]N/AN/AN/Ajava2020-01-05 15:01:36Wrong Answer [https://leetcode-cn.com//submissions/detail/42341312/]N/AN/AN/Ajava2020-01-05 14:59:01Wrong Answer [https://leetcode-cn.com//submissions/detail/42341070/]N/AN/AN/Ajava2020-01-05 14:57:17Wrong Answer [https://leetcode-cn.com//submissions/detail/42340906/]N/AN/AN/Ajava# 统计信息\n通过次数提交次数AC比率113083381133.4%',contentLowercase:'# 中文题目\n统计字符串中的单词个数，这里的单词指的是连续的不是空格的字符。\n\n请注意，你可以假定字符串里不包括任何不可打印的字符。\n\n示例:\n\n输入: "hello, my name is john"\n输出: 5\n\n\n# 通过代码\nclass solution {\n    public int countsegments(string s) {\n        // 注意连续空格，字符串开头是空格\n        return (s == null ||s.trim().equals("")) ? 0 : s.trim().split("\\\\s+").length;\n    }\n}\n\n1\n2\n3\n4\n5\n# 官方题解\n# 方法一：使用语言内置函数 【通过】\n直觉\n\n在执行效率不如代码可读性重要的情况下，使用语言内置的函数解决问题更好些。\n\n算法\n\n本问题有一些边缘情况需要考虑，至少在java中如此。首先，开头的一个或多个空格会导致 split 函数在字符串开头产生一个错误的 ""，因此我们使用内置的 trim 函数来移除这些空格。其次，如果结果为空字符串，可以直接输出 0。由于 split 函数的下述特性，这一点很重要：\n\nstring[] tokens = "".split("\\\\s++");\ntokens.length; // 1\ntokens[0]; // ""\n\n\n1\n2\n3\n当抵达最后的 return 语句，我们将修整过的字符串以一个或多个空格字符切分（split 函数可以使用正则表达式），并返回结果数组的长度。\n\n用 python 写的代码要短很多，这是由于 python 的 split 函数和 java 相比有很多不同之处，更加适合此类问题。值得注意的是，当对空字符串使用 split 时，会返回空数组。这是由于 python 会在 split 之前隐式地调用 trim (在python lingo 中是 strip)。\n\nclass solution {\n    public int countsegments(string s) {\n        string trimmed = s.trim();\n        if (trimmed.equals("")) {\n            return 0;\n        }\n        return trimmed.split("\\\\s+").length;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\nclass solution:\n    def countsegments(self, s):\n        return len(s.split())\n\n\n1\n2\n3\n复杂度分析\n\n * 时间复杂度 : o(n){o}(n)o(n)。\n   \n   这里用到的内置函数（无论是 java 还是 python）的时间复杂度或为 o(n){o}(n)o(n)，或为 o(1){o}(1)o(1) ，故整个算法可以在线性复杂度内完成。\n   \n   \n * 空间复杂度 : o(n){o}(n)o(n)。\n   \n   split 函数 (不管哪种语言) 返回长度为 o(n){o}(n)o(n) 的数组/列表，故算法使用线性的额外空间。\n   \n   \n\n\n\n\n# 方法二：原地法 【通过】\n直觉\n\n如果无法容忍线性的额外空间，可以使用在线性时间和常数空间内解决问题的简单算法。\n\n算法\n\n计算单词的数量，就等同于计数单词开始的下标个数。因此，只需要定义好下标的条件，就可以遍历整个字符串，检测每个下标。定义如下：若该下标前为空格（或者为初始下标），且自身不为空格，则其为单词开始的下标。该条件可以以常数时间检测。最后，返回满足条件的下标个数。\n\nclass solution {\n    public int countsegments(string s) {\n        int segmentcount = 0;\n\n        for (int i = 0; i < s.length(); i++) {\n            if ((i == 0 || s.charat(i-1) == \' \') && s.charat(i) != \' \') {\n                segmentcount++;\n            }\n        }\n\n        return segmentcount;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\nclass solution:\n    def countsegments(self, s):\n        segment_count = 0\n\n        for i in range(len(s)):\n            if (i == 0 or s[i-1] == \' \') and s[i] != \' \':\n                segment_count += 1\n\n        return segment_count\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n复杂度分析\n\n * 时间复杂度 : o(n){o}(n)o(n)。\n   \n   对每个下标进行常数时间的检测。\n   \n   \n * 空间复杂度 : o(1){o}(1)o(1)。\n   \n   只使用了额外的几个整数，因此使用的空间为常数。\n   \n   \n\n\n\n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2020-01-05 15:07:42accepted [https://leetcode-cn.com//submissions/detail/42341932/]2 ms35.03%34.2 mbjava2020-01-05 15:05:33wrong answer [https://leetcode-cn.com//submissions/detail/42341675/]n/an/an/ajava2020-01-05 15:04:06wrong answer [https://leetcode-cn.com//submissions/detail/42341553/]n/an/an/ajava2020-01-05 15:01:36wrong answer [https://leetcode-cn.com//submissions/detail/42341312/]n/an/an/ajava2020-01-05 14:59:01wrong answer [https://leetcode-cn.com//submissions/detail/42341070/]n/an/an/ajava2020-01-05 14:57:17wrong answer [https://leetcode-cn.com//submissions/detail/42340906/]n/an/an/ajava# 统计信息\n通过次数提交次数ac比率113083381133.4%'},{title:"447-回旋镖的数量(Number of Boomerangs)",frontmatter:{title:"447-回旋镖的数量(Number of Boomerangs)",date:"2018-06-20T00:00:00.000Z",categories:["简单"],tags:["哈希表<Hash Table>"]},regularPath:"/views/%E7%AE%80%E5%8D%95/0447-%E5%9B%9E%E6%97%8B%E9%95%96%E7%9A%84%E6%95%B0%E9%87%8F.html",relativePath:"views/简单/0447-回旋镖的数量.md",key:"v-0d795ffd",path:"/views/%E7%AE%80%E5%8D%95/0447-%E5%9B%9E%E6%97%8B%E9%95%96%E7%9A%84%E6%95%B0%E9%87%8F.html",headers:[{level:2,title:"中文题目",slug:"中文题目",charIndex:2},{level:2,title:"通过代码",slug:"通过代码",charIndex:231},{level:2,title:"高赞题解",slug:"高赞题解",charIndex:1425},{level:2,title:"提交历史",slug:"提交历史",charIndex:2422},{level:2,title:"统计信息",slug:"统计信息",charIndex:2552},{level:2,title:"相似题目",slug:"相似题目",charIndex:2585}],lastUpdated:"4/11/2021, 1:15:21 PM",headersStr:"中文题目 通过代码 高赞题解 提交历史 统计信息 相似题目",content:"# 中文题目\n给定平面上n 对不同的点，“回旋镖” 是由点表示的元组(i, j, k)，其中i和j之间的距离和i和k之间的距离相等（需要考虑元组的顺序）。\n\n找到所有回旋镖的数量。你可以假设n 最大为 500，所有点的坐标在闭区间 [-10000, 10000] 中。\n\n示例:\n\n\n输入:\n[[0,0],[1,0],[2,0]]\n\n输出:\n2\n\n解释:\n两个回旋镖为 [[1,0],[0,0],[2,0]] 和 [[1,0],[2,0],[0,0]]\n\n\n# 通过代码\nimport java.util.HashMap; \nclass Solution {\n        public  int numberOfBoomerangs(int[][] points) {\n            int res=0;\n            for (int i = 0; i < points.length; i++) {\n                HashMap<Long,Integer> map=new HashMap<>();\n                for (int j = 0; j < points.length; j++) {\n                    if (i!=j){\n                        long dis=getDistance(points[i],points[j]);\n                        if (map.containsKey(dis)){\n                            int count=map.get(dis);\n                            map.put(dis,++count);\n                        }else {\n                            map.put(dis,1);\n                        }\n                    }\n                }\n                for (Integer v:map.values()) {\n                    if (v>=2){\n                        res+=(v*(v-1));\n                    }\n                }\n            }\n            return res;\n        }\n\n        private static long getDistance(int[] point, int[] point1) {\n            return (point[0]-point1[0])*(point[0]-point1[0])+\n                    (point[1]-point1[1])*(point[1]-point1[1]);\n        }\n    }\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n# 高赞题解\n/**\n\n * Project:\n * Author : zhaozhen\n * Email :\n * Date : 2019/9/15\n * \n * 解题思路: 排列组合的使用\n * \n * 将当前点作为第一个点，计算与非当前点的距离，保存在hashMap中，若计算距离距离在hashMap中已有值，则表明之前有相同的距离，res，因为可以换位，则乘以2，并更新到当前hash中（可以与当前距离相同\n * 的任意一个点交换位置）.当前点作为第一个点结束之后，清空hashMap，继续以下一个点作为第一个点。\n * \n\n*/\n\npublic int numberOfBoomerangs(int[][] points) {\n    int res = 0;\n    HashMap<Integer,Integer> hashMap= new HashMap<>();\n    for(int i = 0;i < points.length;i++){\n        hashMap.clear();\n        for(int j = 0;j < points.length;j++){\n            if(i == j){\n                continue;\n            }\n            int d =  (points[i][0] - points[j][0])*(points[i][0] - points[j][0]) + (points[i][1] - points[j][1])*(points[i][1] - points[j][1]);\n            if(hashMap.containsKey(d)){\n                res += hashMap.get(d) * 2;               \n                hashMap.put(d, hashMap.get(d) + 1);\n            }else{\n                hashMap.put(d,1);\n            }\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-06-20 23:13:41Accepted [https://leetcode-cn.com//submissions/detail/3359068/]206 ms14.36%N/Ajava# 统计信息\n通过次数提交次数AC比率84951510756.2%# 相似题目\n题目难度直线镜像 [https://leetcode-cn.com/problems/line-reflection/]中等",contentLowercase:"# 中文题目\n给定平面上n 对不同的点，“回旋镖” 是由点表示的元组(i, j, k)，其中i和j之间的距离和i和k之间的距离相等（需要考虑元组的顺序）。\n\n找到所有回旋镖的数量。你可以假设n 最大为 500，所有点的坐标在闭区间 [-10000, 10000] 中。\n\n示例:\n\n\n输入:\n[[0,0],[1,0],[2,0]]\n\n输出:\n2\n\n解释:\n两个回旋镖为 [[1,0],[0,0],[2,0]] 和 [[1,0],[2,0],[0,0]]\n\n\n# 通过代码\nimport java.util.hashmap; \nclass solution {\n        public  int numberofboomerangs(int[][] points) {\n            int res=0;\n            for (int i = 0; i < points.length; i++) {\n                hashmap<long,integer> map=new hashmap<>();\n                for (int j = 0; j < points.length; j++) {\n                    if (i!=j){\n                        long dis=getdistance(points[i],points[j]);\n                        if (map.containskey(dis)){\n                            int count=map.get(dis);\n                            map.put(dis,++count);\n                        }else {\n                            map.put(dis,1);\n                        }\n                    }\n                }\n                for (integer v:map.values()) {\n                    if (v>=2){\n                        res+=(v*(v-1));\n                    }\n                }\n            }\n            return res;\n        }\n\n        private static long getdistance(int[] point, int[] point1) {\n            return (point[0]-point1[0])*(point[0]-point1[0])+\n                    (point[1]-point1[1])*(point[1]-point1[1]);\n        }\n    }\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n# 高赞题解\n/**\n\n * project:\n * author : zhaozhen\n * email :\n * date : 2019/9/15\n * \n * 解题思路: 排列组合的使用\n * \n * 将当前点作为第一个点，计算与非当前点的距离，保存在hashmap中，若计算距离距离在hashmap中已有值，则表明之前有相同的距离，res，因为可以换位，则乘以2，并更新到当前hash中（可以与当前距离相同\n * 的任意一个点交换位置）.当前点作为第一个点结束之后，清空hashmap，继续以下一个点作为第一个点。\n * \n\n*/\n\npublic int numberofboomerangs(int[][] points) {\n    int res = 0;\n    hashmap<integer,integer> hashmap= new hashmap<>();\n    for(int i = 0;i < points.length;i++){\n        hashmap.clear();\n        for(int j = 0;j < points.length;j++){\n            if(i == j){\n                continue;\n            }\n            int d =  (points[i][0] - points[j][0])*(points[i][0] - points[j][0]) + (points[i][1] - points[j][1])*(points[i][1] - points[j][1]);\n            if(hashmap.containskey(d)){\n                res += hashmap.get(d) * 2;               \n                hashmap.put(d, hashmap.get(d) + 1);\n            }else{\n                hashmap.put(d,1);\n            }\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-06-20 23:13:41accepted [https://leetcode-cn.com//submissions/detail/3359068/]206 ms14.36%n/ajava# 统计信息\n通过次数提交次数ac比率84951510756.2%# 相似题目\n题目难度直线镜像 [https://leetcode-cn.com/problems/line-reflection/]中等"},{title:"455-分发饼干(Assign Cookies)",frontmatter:{title:"455-分发饼干(Assign Cookies)",date:"2018-07-25T00:00:00.000Z",categories:["简单"],tags:["贪心算法<Greedy>"]},regularPath:"/views/%E7%AE%80%E5%8D%95/0455-%E5%88%86%E5%8F%91%E9%A5%BC%E5%B9%B2.html",relativePath:"views/简单/0455-分发饼干.md",key:"v-16b46357",path:"/views/%E7%AE%80%E5%8D%95/0455-%E5%88%86%E5%8F%91%E9%A5%BC%E5%B9%B2.html",headers:[{level:2,title:"中文题目",slug:"中文题目",charIndex:2},{level:2,title:"通过代码",slug:"通过代码",charIndex:446},{level:2,title:"高赞题解",slug:"高赞题解",charIndex:1551},{level:2,title:"提交历史",slug:"提交历史",charIndex:2206},{level:2,title:"统计信息",slug:"统计信息",charIndex:2435}],lastUpdated:"4/11/2021, 1:15:21 PM",headersStr:"中文题目 通过代码 高赞题解 提交历史 统计信息",content:"# 中文题目\n假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。对每个孩子 i ，都有一个胃口值 gi ，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j ，都有一个尺寸 sj。如果 sj >= gi，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。\n\n注意：\n\n你可以假设胃口值为正。\n一个小朋友最多只能拥有一块饼干。\n\n示例 1:\n\n\n输入: [1,2,3], [1,1]\n\n输出: 1\n\n解释: \n你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。\n虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。\n所以你应该输出1。\n\n\n示例 2:\n\n\n输入: [1,2], [1,2,3]\n\n输出: 2\n\n解释: \n你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。\n你拥有的饼干数量和尺寸都足以让所有孩子满足。\n所以你应该输出2.\n\n\n# 通过代码\nimport java.util.Arrays;\nclass Solution {\n    public int findContentChildren(int[] g, int[] s) {\n        Arrays.sort(g);\n            Arrays.sort(s);\n            int res=0;\n            int gi=g.length-1;\n            int si=s.length-1;\n            while (gi>=0 && si>=0){\n                if (s[si] >= g[gi]){\n                    gi--;\n                    si--;\n                    res++;\n                }else {\n                    gi--;\n                }\n            }\n            return res;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\nimport java.util.Arrays;\nclass Solution {\n    public int findContentChildren(int[] g, int[] s) {\n        Arrays.sort(g);\n            Arrays.sort(s);\n            int res=0;\n            int gi=g.length-1;\n            int si=s.length-1;\n            while (gi>=0 && si>=0){\n                if (s[si] >= g[gi]){\n                    gi--;\n                    si--;\n                    res++;\n                }else {\n                    gi--;\n                }\n            }\n            return res;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n# 高赞题解\n * Step1 给孩子和饼干都排序\n * Step2 分别维护一个index\n * Step3 策略：如果当前饼干可以满足胃口，则count 和 两个index加一，否则饼干的index加一(更大的饼干)\n\nclass Solution {\npublic:\n    int findContentChildren(vector<int>& g, vector<int>& s) {\n        int count = 0;\n        int gi = 0, si = 0;\n        sort(g.begin(), g.end());\n        sort(s.begin(), s.end());\n        while(gi < g.size() && si < s.size()) {\n            if(s[si] >= g[gi]) {\n                count += 1;\n                si+=1;\n                gi+=1;\n            }\n            else if(s[si] < g[gi]) {\n                si+=1;\n            }\n        }\n        return count;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-07-25 20:40:00Accepted [https://leetcode-cn.com//submissions/detail/4647967/]14 ms20.33%N/Ajava2018-07-25 20:39:35Accepted [https://leetcode-cn.com//submissions/detail/4647955/]21 ms11.67%N/Ajava# 统计信息\n通过次数提交次数AC比率226634310852.6%",contentLowercase:"# 中文题目\n假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。对每个孩子 i ，都有一个胃口值 gi ，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j ，都有一个尺寸 sj。如果 sj >= gi，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。\n\n注意：\n\n你可以假设胃口值为正。\n一个小朋友最多只能拥有一块饼干。\n\n示例 1:\n\n\n输入: [1,2,3], [1,1]\n\n输出: 1\n\n解释: \n你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。\n虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。\n所以你应该输出1。\n\n\n示例 2:\n\n\n输入: [1,2], [1,2,3]\n\n输出: 2\n\n解释: \n你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。\n你拥有的饼干数量和尺寸都足以让所有孩子满足。\n所以你应该输出2.\n\n\n# 通过代码\nimport java.util.arrays;\nclass solution {\n    public int findcontentchildren(int[] g, int[] s) {\n        arrays.sort(g);\n            arrays.sort(s);\n            int res=0;\n            int gi=g.length-1;\n            int si=s.length-1;\n            while (gi>=0 && si>=0){\n                if (s[si] >= g[gi]){\n                    gi--;\n                    si--;\n                    res++;\n                }else {\n                    gi--;\n                }\n            }\n            return res;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\nimport java.util.arrays;\nclass solution {\n    public int findcontentchildren(int[] g, int[] s) {\n        arrays.sort(g);\n            arrays.sort(s);\n            int res=0;\n            int gi=g.length-1;\n            int si=s.length-1;\n            while (gi>=0 && si>=0){\n                if (s[si] >= g[gi]){\n                    gi--;\n                    si--;\n                    res++;\n                }else {\n                    gi--;\n                }\n            }\n            return res;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n# 高赞题解\n * step1 给孩子和饼干都排序\n * step2 分别维护一个index\n * step3 策略：如果当前饼干可以满足胃口，则count 和 两个index加一，否则饼干的index加一(更大的饼干)\n\nclass solution {\npublic:\n    int findcontentchildren(vector<int>& g, vector<int>& s) {\n        int count = 0;\n        int gi = 0, si = 0;\n        sort(g.begin(), g.end());\n        sort(s.begin(), s.end());\n        while(gi < g.size() && si < s.size()) {\n            if(s[si] >= g[gi]) {\n                count += 1;\n                si+=1;\n                gi+=1;\n            }\n            else if(s[si] < g[gi]) {\n                si+=1;\n            }\n        }\n        return count;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-07-25 20:40:00accepted [https://leetcode-cn.com//submissions/detail/4647967/]14 ms20.33%n/ajava2018-07-25 20:39:35accepted [https://leetcode-cn.com//submissions/detail/4647955/]21 ms11.67%n/ajava# 统计信息\n通过次数提交次数ac比率226634310852.6%"},{title:"437-路径总和 III(Path Sum III)",frontmatter:{title:"437-路径总和 III(Path Sum III)",date:"2018-07-17T00:00:00.000Z",categories:["简单"],tags:["树<Tree>"]},regularPath:"/views/%E7%AE%80%E5%8D%95/0437-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C%20III.html",relativePath:"views/简单/0437-路径总和 III.md",key:"v-fa0e71a0",path:"/views/%E7%AE%80%E5%8D%95/0437-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C%20III.html",headers:[{level:2,title:"中文题目",slug:"中文题目",charIndex:2},{level:2,title:"通过代码",slug:"通过代码",charIndex:344},{level:2,title:"高赞题解",slug:"高赞题解",charIndex:1261},{level:2,title:"提交历史",slug:"提交历史",charIndex:2797},{level:2,title:"统计信息",slug:"统计信息",charIndex:2925},{level:2,title:"相似题目",slug:"相似题目",charIndex:2959}],lastUpdated:"4/11/2021, 1:15:21 PM",headersStr:"中文题目 通过代码 高赞题解 提交历史 统计信息 相似题目",content:"# 中文题目\n给定一个二叉树，它的每个结点都存放着一个整数值。\n\n找出路径和等于给定数值的路径总数。\n\n路径不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。\n\n二叉树不超过1000个节点，且节点数值范围是 [-1000000,1000000] 的整数。\n\n示例：\n\nroot = [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8\n\n      10\n     /  \\\n    5   -3\n   / \\    \\\n  3   2   11\n / \\   \\\n3  -2   1\n\n返回 3。和等于 8 的路径有:\n\n1.  5 -> 3\n2.  5 -> 2 -> 1\n3.  -3 -> 11\n\n\n# 通过代码\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public int pathSum(TreeNode root, int sum) {\n            if (root==null){\n                return 0;\n            }\n            int res=findPath(root,sum);\n            res+=pathSum(root.left,sum);\n            res+=pathSum(root.right,sum);\n            return res;\n        }\n\n        public int findPath (TreeNode node,int sum){\n            if (node==null){\n                return 0;\n            }\n            int res=0;\n            if (node.val==sum){\n                res+=1;\n            }\n            res+=findPath(node.left,sum-node.val);\n            res+=findPath(node.right,sum-node.val);\n            return res;\n        }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n# 高赞题解\n# 解法思路（一）\n * 路径的开头可以不是根节点，结束也可以不是叶子节点，是不是有点复杂？\n * 如果问题是这样：找出以根节点为开始，任意节点可作为结束，且路径上的节点和为 sum 的路径的个数；\n * 是不是前序遍历一遍二叉树就可以得到所有这样的路径？是的；\n * 如果这个问题解决了，那么原问题可以分解成多个这个问题；\n * 是不是和数线段是同一个问题，只不过线段变成了二叉树；\n * 在解决了以根节点开始的所有路径后，就要找以根节点的左孩子和右孩子开始的所有路径，三个节点构成了一个递归结构；\n * 递归真的好简单又好难；\n\n# 解法实现（一）\n# 时间复杂度\n * O(n)，n为树的节点个数；\n\n# 空间复杂度\n * O(h)，h为树的高度；\n\n# 关键字\n二叉树 递归 前序遍历 路径和 路径数量 数线段 双递归\n\n# 实现细节\n * sum - root.val 好好体会一下，挺有意思的；\n\npackage leetcode._437;\n\npublic class Solution437_1 {\n\n    public static class TreeNode {\n        int val;\n        TreeNode left;\n        TreeNode right;\n        TreeNode(int x) { val = x; }\n    }\n\n    /**\n     * 求以 root 为根的二叉树，所有和为 sum 的路径；\n     * 路径的开头不一定是 root，结尾也不一定是叶子节点；\n     * @param root\n     * @param sum\n     * @return\n     */\n    public int pathSum(TreeNode root, int sum) {\n\n        if (root == null) {\n            return 0;\n        }\n\n        return paths(root, sum) \n                + pathSum(root.left, sum) \n                + pathSum(root.right, sum);\n    }\n\n    private int paths(TreeNode root, int sum) {\n\n        if (root == null) {\n            return 0;\n        }\n\n        int res = 0;\n        if (root.val == sum) {\n            res += 1;            \n        }\n        \n        res += paths(root.left, sum - root.val);\n        res += paths(root.right, sum - root.val);\n        \n        return res;\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n返回 LeetCode [Java] 目录 [https://www.jianshu.com/p/2cc66577f7d7]\n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-07-17 21:41:16Accepted [https://leetcode-cn.com//submissions/detail/4299764/]26 ms7.15%N/Ajava# 统计信息\n通过次数提交次数AC比率180323385253.3%# 相似题目\n题目难度路径总和 [https://leetcode-cn.com/problems/path-sum/]简单路径总和 II [https://leetcode-cn.com/problems/path-sum-ii/]中等路径和 IV [https://leetcode-cn.com/problems/path-sum-iv/]中等最长同值路径 [https://leetcode-cn.com/problems/longest-univalue-path/]简单",contentLowercase:"# 中文题目\n给定一个二叉树，它的每个结点都存放着一个整数值。\n\n找出路径和等于给定数值的路径总数。\n\n路径不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。\n\n二叉树不超过1000个节点，且节点数值范围是 [-1000000,1000000] 的整数。\n\n示例：\n\nroot = [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8\n\n      10\n     /  \\\n    5   -3\n   / \\    \\\n  3   2   11\n / \\   \\\n3  -2   1\n\n返回 3。和等于 8 的路径有:\n\n1.  5 -> 3\n2.  5 -> 2 -> 1\n3.  -3 -> 11\n\n\n# 通过代码\n/**\n * definition for a binary tree node.\n * public class treenode {\n *     int val;\n *     treenode left;\n *     treenode right;\n *     treenode(int x) { val = x; }\n * }\n */\nclass solution {\n    public int pathsum(treenode root, int sum) {\n            if (root==null){\n                return 0;\n            }\n            int res=findpath(root,sum);\n            res+=pathsum(root.left,sum);\n            res+=pathsum(root.right,sum);\n            return res;\n        }\n\n        public int findpath (treenode node,int sum){\n            if (node==null){\n                return 0;\n            }\n            int res=0;\n            if (node.val==sum){\n                res+=1;\n            }\n            res+=findpath(node.left,sum-node.val);\n            res+=findpath(node.right,sum-node.val);\n            return res;\n        }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n# 高赞题解\n# 解法思路（一）\n * 路径的开头可以不是根节点，结束也可以不是叶子节点，是不是有点复杂？\n * 如果问题是这样：找出以根节点为开始，任意节点可作为结束，且路径上的节点和为 sum 的路径的个数；\n * 是不是前序遍历一遍二叉树就可以得到所有这样的路径？是的；\n * 如果这个问题解决了，那么原问题可以分解成多个这个问题；\n * 是不是和数线段是同一个问题，只不过线段变成了二叉树；\n * 在解决了以根节点开始的所有路径后，就要找以根节点的左孩子和右孩子开始的所有路径，三个节点构成了一个递归结构；\n * 递归真的好简单又好难；\n\n# 解法实现（一）\n# 时间复杂度\n * o(n)，n为树的节点个数；\n\n# 空间复杂度\n * o(h)，h为树的高度；\n\n# 关键字\n二叉树 递归 前序遍历 路径和 路径数量 数线段 双递归\n\n# 实现细节\n * sum - root.val 好好体会一下，挺有意思的；\n\npackage leetcode._437;\n\npublic class solution437_1 {\n\n    public static class treenode {\n        int val;\n        treenode left;\n        treenode right;\n        treenode(int x) { val = x; }\n    }\n\n    /**\n     * 求以 root 为根的二叉树，所有和为 sum 的路径；\n     * 路径的开头不一定是 root，结尾也不一定是叶子节点；\n     * @param root\n     * @param sum\n     * @return\n     */\n    public int pathsum(treenode root, int sum) {\n\n        if (root == null) {\n            return 0;\n        }\n\n        return paths(root, sum) \n                + pathsum(root.left, sum) \n                + pathsum(root.right, sum);\n    }\n\n    private int paths(treenode root, int sum) {\n\n        if (root == null) {\n            return 0;\n        }\n\n        int res = 0;\n        if (root.val == sum) {\n            res += 1;            \n        }\n        \n        res += paths(root.left, sum - root.val);\n        res += paths(root.right, sum - root.val);\n        \n        return res;\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n返回 leetcode [java] 目录 [https://www.jianshu.com/p/2cc66577f7d7]\n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-07-17 21:41:16accepted [https://leetcode-cn.com//submissions/detail/4299764/]26 ms7.15%n/ajava# 统计信息\n通过次数提交次数ac比率180323385253.3%# 相似题目\n题目难度路径总和 [https://leetcode-cn.com/problems/path-sum/]简单路径总和 ii [https://leetcode-cn.com/problems/path-sum-ii/]中等路径和 iv [https://leetcode-cn.com/problems/path-sum-iv/]中等最长同值路径 [https://leetcode-cn.com/problems/longest-univalue-path/]简单"},{title:"476-数字的补数(Number Complement)",frontmatter:{title:"476-数字的补数(Number Complement)",date:"2018-12-17T00:00:00.000Z",categories:["简单"],tags:["位运算<Bit Manipulation>"]},regularPath:"/views/%E7%AE%80%E5%8D%95/0476-%E6%95%B0%E5%AD%97%E7%9A%84%E8%A1%A5%E6%95%B0.html",relativePath:"views/简单/0476-数字的补数.md",key:"v-487d573a",path:"/views/%E7%AE%80%E5%8D%95/0476-%E6%95%B0%E5%AD%97%E7%9A%84%E8%A1%A5%E6%95%B0.html",headers:[{level:2,title:"中文题目",slug:"中文题目",charIndex:2},{level:2,title:"通过代码",slug:"通过代码",charIndex:219},{level:2,title:"高赞题解",slug:"高赞题解",charIndex:1256},{level:2,title:"提交历史",slug:"提交历史",charIndex:1640},{level:2,title:"统计信息",slug:"统计信息",charIndex:1879}],lastUpdated:"4/11/2021, 1:15:21 PM",headersStr:"中文题目 通过代码 高赞题解 提交历史 统计信息",content:'# 中文题目\n给定一个正整数，输出它的补数。补数是对该数的二进制表示取反。\n\n注意:\n\n 1. 给定的整数保证在32位带符号整数的范围内。\n 2. 你可以假定二进制数不包含前导零位。\n\n示例 1:\n\n\n输入: 5\n输出: 2\n解释: 5的二进制表示为101（没有前导零位），其补数为010。所以你需要输出2。\n\n\n示例 2:\n\n\n输入: 1\n输出: 0\n解释: 1的二进制表示为1（没有前导零位），其补数为0。所以你需要输出0。\n\n\n# 通过代码\nclass Solution {\n    public int findComplement(int num) {\n        String str=Integer.toBinaryString(num);\n            StringBuilder stringBuilder=new StringBuilder();\n            for (int i = 0; i < str.length(); i++) {\n                if (str.charAt(i)==\'1\'){\n                    stringBuilder.append("0");\n                }else {\n                    stringBuilder.append("1");\n                }\n            }\n            return Integer.parseInt(stringBuilder.toString(),2);\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\nclass Solution {\n    public int findComplement(int num) {\n        String str=Integer.toBinaryString(num);\n            StringBuilder stringBuilder=new StringBuilder();\n            for (int i = 0; i < str.length(); i++) {\n                if (str.charAt(i)==\'1\'){\n                    stringBuilder.append("0");\n                }else {\n                    stringBuilder.append("1");\n                }\n            }\n            return Integer.parseInt(stringBuilder.toString(),2);\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n# 高赞题解\n5的二进制是：0101，7的二进制是： 0111，它们的抑或为：0010，去掉前导零位即为取反。 再来一个例子，假设a为1110 0101，b为1111 1111，a^b = 0001 1010是a的取反。也就是说二进制位数与num相同，且全为1的数tmp与num的抑或即为所求。\n\nclass Solution {\npublic:\n    int findComplement(int num) {\n        int tmp = 1;\n        while (tmp < num)\n        {\n            tmp <<= 1;\n            tmp += 1;\n        }\n        return (tmp^num);\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-12-17 20:13:37Accepted [https://leetcode-cn.com//submissions/detail/10564546/]12 ms10.24%23.2 MBjava2018-12-17 20:12:07Accepted [https://leetcode-cn.com//submissions/detail/10564470/]12 ms10.24%28.5 MBjava# 统计信息\n通过次数提交次数AC比率163502406367.9%',contentLowercase:'# 中文题目\n给定一个正整数，输出它的补数。补数是对该数的二进制表示取反。\n\n注意:\n\n 1. 给定的整数保证在32位带符号整数的范围内。\n 2. 你可以假定二进制数不包含前导零位。\n\n示例 1:\n\n\n输入: 5\n输出: 2\n解释: 5的二进制表示为101（没有前导零位），其补数为010。所以你需要输出2。\n\n\n示例 2:\n\n\n输入: 1\n输出: 0\n解释: 1的二进制表示为1（没有前导零位），其补数为0。所以你需要输出0。\n\n\n# 通过代码\nclass solution {\n    public int findcomplement(int num) {\n        string str=integer.tobinarystring(num);\n            stringbuilder stringbuilder=new stringbuilder();\n            for (int i = 0; i < str.length(); i++) {\n                if (str.charat(i)==\'1\'){\n                    stringbuilder.append("0");\n                }else {\n                    stringbuilder.append("1");\n                }\n            }\n            return integer.parseint(stringbuilder.tostring(),2);\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\nclass solution {\n    public int findcomplement(int num) {\n        string str=integer.tobinarystring(num);\n            stringbuilder stringbuilder=new stringbuilder();\n            for (int i = 0; i < str.length(); i++) {\n                if (str.charat(i)==\'1\'){\n                    stringbuilder.append("0");\n                }else {\n                    stringbuilder.append("1");\n                }\n            }\n            return integer.parseint(stringbuilder.tostring(),2);\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n# 高赞题解\n5的二进制是：0101，7的二进制是： 0111，它们的抑或为：0010，去掉前导零位即为取反。 再来一个例子，假设a为1110 0101，b为1111 1111，a^b = 0001 1010是a的取反。也就是说二进制位数与num相同，且全为1的数tmp与num的抑或即为所求。\n\nclass solution {\npublic:\n    int findcomplement(int num) {\n        int tmp = 1;\n        while (tmp < num)\n        {\n            tmp <<= 1;\n            tmp += 1;\n        }\n        return (tmp^num);\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-12-17 20:13:37accepted [https://leetcode-cn.com//submissions/detail/10564546/]12 ms10.24%23.2 mbjava2018-12-17 20:12:07accepted [https://leetcode-cn.com//submissions/detail/10564470/]12 ms10.24%28.5 mbjava# 统计信息\n通过次数提交次数ac比率163502406367.9%'},{title:"485-最大连续1的个数(Max Consecutive Ones)",frontmatter:{title:"485-最大连续1的个数(Max Consecutive Ones)",date:"2020-01-09T00:00:00.000Z",categories:["简单"],tags:["数组<Array>"]},regularPath:"/views/%E7%AE%80%E5%8D%95/0485-%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD1%E7%9A%84%E4%B8%AA%E6%95%B0.html",relativePath:"views/简单/0485-最大连续1的个数.md",key:"v-55c55936",path:"/views/%E7%AE%80%E5%8D%95/0485-%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD1%E7%9A%84%E4%B8%AA%E6%95%B0.html",headers:[{level:2,title:"中文题目",slug:"中文题目",charIndex:2},{level:2,title:"通过代码",slug:"通过代码",charIndex:156},{level:2,title:"官方题解",slug:"官方题解",charIndex:568},{level:2,title:"提交历史",slug:"提交历史",charIndex:2078},{level:2,title:"统计信息",slug:"统计信息",charIndex:2211},{level:2,title:"相似题目",slug:"相似题目",charIndex:2245}],lastUpdated:"4/11/2021, 1:15:21 PM",headersStr:"中文题目 通过代码 官方题解 提交历史 统计信息 相似题目",content:"# 中文题目\n给定一个二进制数组， 计算其中最大连续1的个数。\n\n示例 1:\n\n\n输入: [1,1,0,1,1,1]\n输出: 3\n解释: 开头的两位和最后的三位都是连续1，所以最大连续1的个数是 3.\n\n\n注意：\n\n * 输入的数组只包含0 和1。\n * 输入数组的长度是正整数，且不超过 10,000。\n\n# 通过代码\nclass Solution {\n    public int findMaxConsecutiveOnes(int[] nums) {\n        int max=0;\n        int count=0;\n        for (int i = 0; i < nums.length; i++) {\n            if (nums[i]==1){\n                ++count;\n            }else {\n                max = (count>max)?count:max;\n                count=0;\n            }\n        }\n        return (count>max)?count:max;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n# 官方题解\n# 方法一：一次遍历\n题目的约束让这个问题变得简单，使得我们可以在一次遍历解决它。\n\n算法：\n\n * 用一个计数器 count 记录 1 的数量，另一个计数器 maxCount 记录当前最大的 1 的数量。\n * 当我们遇到 1 时，count 加一。\n * 当我们遇到 0 时： * 将 count 与 maxCount 比较，maxCoiunt 记录较大值。\n    * 将 count 设为 0。\n   \n   \n * 返回 maxCount。\n\nclass Solution {\n  public int findMaxConsecutiveOnes(int[] nums) {\n    int count = 0;\n    int maxCount = 0;\n    for(int i = 0; i < nums.length; i++) {\n      if(nums[i] == 1) {\n        // Increment the count of 1's by one.\n        count += 1;\n      } else {\n        // Find the maximum till now.\n        maxCount = Math.max(maxCount, count);\n        // Reset count of 1.\n        count = 0;\n      }\n    }\n    return Math.max(maxCount, count);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\nclass Solution:\n    def findMaxConsecutiveOnes(self, nums: List[int]) -> int:\n        count = max_count = 0\n        for num in nums:\n            if num == 1:\n                # Increment the count of 1's by one.\n                count += 1\n            else:\n                # Find the maximum till now.\n                max_count = max(max_count, count)\n                # Reset count of 1.\n                count = 0\n        return max(max_count, count)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n复杂度分析\n\n * 时间复杂度：O(N)O(N)O(N)。NNN 值得是数组的长度。\n * 空间复杂度：O(1)O(1)O(1)，仅仅使用了 count 和 maxCount。\n\n# 方法二：\n * 在 Python 中可以使用 map 和 join 来解决此问题。\n * 使用 splits 函数在 0 处分割将数组转换成字符串。\n * 在获取子串的最大长度就是最大连续 1 的长度。\n\ndef findMaxConsecutiveOnes(self, nums):\n  return max(map(len, ''.join(map(str, nums)).split('0')))\n\n\n1\n2\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2020-01-09 22:52:47Accepted [https://leetcode-cn.com//submissions/detail/42920021/]2 ms100.0%39.4 MBjava# 统计信息\n通过次数提交次数AC比率259594692555.3%# 相似题目\n题目难度最大连续1的个数 II [https://leetcode-cn.com/problems/max-consecutive-ones-ii/]中等最大连续1的个数 III [https://leetcode-cn.com/problems/max-consecutive-ones-iii/]中等",contentLowercase:"# 中文题目\n给定一个二进制数组， 计算其中最大连续1的个数。\n\n示例 1:\n\n\n输入: [1,1,0,1,1,1]\n输出: 3\n解释: 开头的两位和最后的三位都是连续1，所以最大连续1的个数是 3.\n\n\n注意：\n\n * 输入的数组只包含0 和1。\n * 输入数组的长度是正整数，且不超过 10,000。\n\n# 通过代码\nclass solution {\n    public int findmaxconsecutiveones(int[] nums) {\n        int max=0;\n        int count=0;\n        for (int i = 0; i < nums.length; i++) {\n            if (nums[i]==1){\n                ++count;\n            }else {\n                max = (count>max)?count:max;\n                count=0;\n            }\n        }\n        return (count>max)?count:max;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n# 官方题解\n# 方法一：一次遍历\n题目的约束让这个问题变得简单，使得我们可以在一次遍历解决它。\n\n算法：\n\n * 用一个计数器 count 记录 1 的数量，另一个计数器 maxcount 记录当前最大的 1 的数量。\n * 当我们遇到 1 时，count 加一。\n * 当我们遇到 0 时： * 将 count 与 maxcount 比较，maxcoiunt 记录较大值。\n    * 将 count 设为 0。\n   \n   \n * 返回 maxcount。\n\nclass solution {\n  public int findmaxconsecutiveones(int[] nums) {\n    int count = 0;\n    int maxcount = 0;\n    for(int i = 0; i < nums.length; i++) {\n      if(nums[i] == 1) {\n        // increment the count of 1's by one.\n        count += 1;\n      } else {\n        // find the maximum till now.\n        maxcount = math.max(maxcount, count);\n        // reset count of 1.\n        count = 0;\n      }\n    }\n    return math.max(maxcount, count);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\nclass solution:\n    def findmaxconsecutiveones(self, nums: list[int]) -> int:\n        count = max_count = 0\n        for num in nums:\n            if num == 1:\n                # increment the count of 1's by one.\n                count += 1\n            else:\n                # find the maximum till now.\n                max_count = max(max_count, count)\n                # reset count of 1.\n                count = 0\n        return max(max_count, count)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n复杂度分析\n\n * 时间复杂度：o(n)o(n)o(n)。nnn 值得是数组的长度。\n * 空间复杂度：o(1)o(1)o(1)，仅仅使用了 count 和 maxcount。\n\n# 方法二：\n * 在 python 中可以使用 map 和 join 来解决此问题。\n * 使用 splits 函数在 0 处分割将数组转换成字符串。\n * 在获取子串的最大长度就是最大连续 1 的长度。\n\ndef findmaxconsecutiveones(self, nums):\n  return max(map(len, ''.join(map(str, nums)).split('0')))\n\n\n1\n2\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2020-01-09 22:52:47accepted [https://leetcode-cn.com//submissions/detail/42920021/]2 ms100.0%39.4 mbjava# 统计信息\n通过次数提交次数ac比率259594692555.3%# 相似题目\n题目难度最大连续1的个数 ii [https://leetcode-cn.com/problems/max-consecutive-ones-ii/]中等最大连续1的个数 iii [https://leetcode-cn.com/problems/max-consecutive-ones-iii/]中等"},{title:"561-数组拆分 I(Array Partition I)",frontmatter:{title:"561-数组拆分 I(Array Partition I)",date:"2019-12-22T00:00:00.000Z",categories:["简单"],tags:["数组<Array>"]},regularPath:"/views/%E7%AE%80%E5%8D%95/0561-%E6%95%B0%E7%BB%84%E6%8B%86%E5%88%86%20I.html",relativePath:"views/简单/0561-数组拆分 I.md",key:"v-25479726",path:"/views/%E7%AE%80%E5%8D%95/0561-%E6%95%B0%E7%BB%84%E6%8B%86%E5%88%86%20I.html",headers:[{level:2,title:"中文题目",slug:"中文题目",charIndex:2},{level:2,title:"通过代码",slug:"通过代码",charIndex:244},{level:2,title:"官方题解",slug:"官方题解",charIndex:811},{level:2,title:"提交历史",slug:"提交历史",charIndex:4692},{level:2,title:"统计信息",slug:"统计信息",charIndex:5152}],lastUpdated:"4/11/2021, 1:15:21 PM",headersStr:"中文题目 通过代码 官方题解 提交历史 统计信息",content:"# 中文题目\n给定长度为2n的数组, 你的任务是将这些数分成n 对, 例如 (a1, b1), (a2, b2), ..., (an, bn) ，使得从1 到 n 的 min(ai, bi) 总和最大。\n\n示例 1:\n\n\n输入: [1,4,3,2]\n\n输出: 4\n解释: n 等于 2, 最大总和为 4 = min(1, 2) + min(3, 4).\n\n\n提示:\n\n 1. n是正整数,范围在 [1, 10000].\n 2. 数组中的元素范围在 [-10000, 10000].\n\n# 通过代码\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar arrayPairSum = function(nums) {\n    return nums.sort((a,b)=>a-b).filter((item,index)=> index % 2 === 0).reduce((t,i)=> t+i)\n};\n\n1\n2\n3\n4\n5\n6\nclass Solution:\n    def arrayPairSum(self, nums: List[int]) -> int:\n        nums.sort()\n        return sum(nums[::2])\n\n\n1\n2\n3\n4\nclass Solution {\n    public int arrayPairSum(int[] nums) {\n        Arrays.sort(nums);\n        int sum=0;\n        for(int i=0;i<nums.length;i=i+2){\n            sum+=nums[i];\n        }\n        return sum;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n# 官方题解\n# 方法一 暴力求解 [超过时间限制]\n算法\n\n最简单的解决方案是考虑 numsnumsnums 数组的元素每个可能的配对集。为了生成所有可能的配对，我们使用函数 permute（nums，current_index）。此函数创建给定数组元素的所有可能排列。\n\n为此，permute将当前元素 currentindexcurrent_indexcurrenti​ndex 的索引作为参数之一，然后，它将当前元素与数组中的每个其他元素交换，向右移动，以便生成数组元素的新排序。在完成交换之后，它再次调用 permute，但这次使用数组中下一个元素的索引。返回时，我们反转当前函数调用中的交换。\n\n因此，当到达数组的末尾时，会生成数组元素的新排序。考虑配对的元素，使得每对的第一个元素来自新数组的前半部分，第二个元素来自数组的后半部分。因此，我们总结了所有这些可能配对中的最小元素，并找出它们的最大总和。\n\n下面的动画描述了排列的生成方式。\n\n<,,,,,,,,,,>\n\npublic class Solution {\n    int max_sum = Integer.MIN_VALUE;\n    public int arrayPairSum(int[] nums) {\n        permute(nums, 0);\n        return max_sum;\n    }\n    public void permute(int[] nums, int l) {\n        if (l == nums.length - 1) {\n            int sum = 0;\n            for (int i = 0; i < nums.length / 2; i++) {\n                sum += Math.min(nums[i], nums[nums.length / 2 + i]);\n            }\n            max_sum = Math.max(max_sum, sum);\n        }\n        for (int i = l; i < nums.length; i++) {\n            swap(nums, i, l);\n            permute(nums, l + 1);\n            swap(nums, i, l);\n        }\n    }\n    public void swap(int[] nums, int x, int y) {\n        int temp = nums[x];\n        nums[x] = nums[y];\n        nums[y] = temp;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n复杂度分析\n\n * 时间复杂度：O(n!)O(n!)O(n!)。对于数组中的 nnn 元素，总共可以 nnn 排列。\n   \n   \n * 空间复杂度：O(1)O(1)O(1)。仅需使用常数级的额外空间。\n   \n   \n\n\n\n\n# 方法二 排序 [通过]\n算法\n\n为了理解这种方法，让我们从不同的角度来看待问题。我们需要形成数组元​​素的配对，使得这种配对中最小的总和最大。因此，我们可以查看选择配对中最小值的操作，比如 (a,b)(a,b)(a,b) 可能会产生的最大损失 a−ba-ba−b (如果 a>ba > ba>b)。\n\n如果这类配对产生的总损失最小化，那么总金额现在将达到最大值。只有当为配对选择的数字比数组的其他元素更接近彼此时，才有可能将每个配对中的损失最小化。\n\n考虑到这一点，我们可以对给定数组的元素进行排序，并直接按排序顺序形成元素的配对。这将导致元素的配对，它们之间的差异最小，从而导致所需总和的最大化。\n\npublic class Solution {\n    public int arrayPairSum(int[] nums) {\n        Arrays.sort(nums);\n        int sum = 0;\n        for (int i = 0; i < nums.length; i += 2) {\n            sum += nums[i];\n        }\n        return sum;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n复杂度分析\n\n * 时间复杂度：O(nlog(n))O\\big(nlog(n)\\big)O(nlog(n))。排序需要 O(nlog(n))O\\big(nlog(n)\\big)O(nlog(n)) 的时间。另外会有一次数组的遍历。\n   \n   \n * 空间复杂度：O(1)O(1)O(1)。仅仅需要常数级的空间.\n   \n   \n\n\n\n\n# 方法三 使用额外的空间 [通过]\n算法\n\n这种方法在某种程度上与排序方法有关。由于给定数组中的元素范围有限 [-10000, 10000]，我们可以使用 arrarrarr 的哈希表，这样 arr[i]arr [i]arr[i] 存储 （i−10000）th（i-10000）^ {th}（i−10000）th 元素的出现频率。 这个减法操作可以保证这个哈希表可以能够存下范围内的所有数字。\n\n因此，现在我们可以直接以递增的顺序遍历哈希表，而不是对数组的元素进行排序。但是，任何元素也可能在给定数组中多次出现。我们需要考虑这个因素。\n\n为此，考虑一个例子：nums：[a，b，a，b，b，a]。这个数组的排序顺序是 nums_sorted：[a，a，a，b，b，b]。（我们实际上并没有在这种方法中对数组进行排序，但是排序的数组仅用于演示）。从前面的方法，我们知道所需的配对集是 （a，a），（a，b），（b，b）（a，a），（a，b），（b，b）（a，a），（a，b），（b，b）。现在，我们可以看到，在选择最小元素时，aaa 将被选择两次，bbb 将仅被选择一次。发生这种情况是因为要选择的 aaa 的数量已经由 aaa 的频率确定，其余的地方将由 bbb 填补。这是因为，为了得到正确的结果，我们需要按升序考虑元素。因此，较低的数字总是优先被添加到最终结果。\n\n但是，如果排序的元素采用以下形式：nums_sorted：[a，a，b，b，b，b]，正确的配对将是 （a，a），（b，b），（b，b））（a，a），（b，b），（b，b） ）（a，a），（b，b），（b，b））。同样，在这种情况下，所选择的aaa的数量已经预先确定，但由于 aaa 的数量是奇数，因此它不会影响最终总和中 bbb 的选择。\n\n因此，基于上面的讨论，我们遍历哈希表 arrarrarr。如果当前元素出现 reqireq_ireqi​ 次，并且其中一个元素与右边区域中的其他元素配对（考虑虚拟排序数组），我们考虑当前元素 ⌈freqi2⌉\\left\\lceil\\frac{freq_i}{2}\\right\\rceil⌈2freqi​​⌉ 次数以及数组中出现的下一个元素 ⌊freqj2⌋\\left\\lfloor\\frac {freq_j}{2}\\right\\rfloor⌊2freqj​​⌋ 最终总和的次数。为了传播这个左边对所选数字的影响，我们使用了一个标志 ddd。如果当前集合中有剩余元素将被再次考虑，则此标志设置为 1。在从下一组中选择元素时，会考虑已考虑的相同额外元素。\n\n在遍历哈希表时，我们确定需要考虑每个元素的正确次数，如上所述。请注意，如果数组中不存在哈希表的当前元素，则标志 ddd 和 sumsumsum保持不变。\n\n下面的代码受到 @fallcreek [https://leetcode.com/fallcreek]的启发\n\npublic class Solution {\n    public int arrayPairSum(int[] nums) {\n        int[] arr = new int[20001];\n        int lim = 10000;\n        for (int num: nums)\n            arr[num + lim]++;\n        int d = 0, sum = 0;\n        for (int i = -10000; i <= 10000; i++) {\n            sum += (arr[i + lim] + 1 - d) / 2 * i;\n            d = (2 + arr[i + lim] - d) % 2;\n        }\n        return sum;\n    }\n} \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n复杂度分析\n\n * 时间复杂度：O(n)O(n)O(n)。需要遍历一次哈希表 arrarrarr。\n   \n   \n * 空间复杂度：O(n)O(n)O(n)。存储一个大小为nnn哈希表 arrarrarr 所需要的空间。\n   \n   \n\n\n\n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2019-12-22 01:12:23Accepted [https://leetcode-cn.com//submissions/detail/40815332/]136 ms5.23%40.8 MBjavascript2019-12-22 01:11:53Accepted [https://leetcode-cn.com//submissions/detail/40815322/]320 ms5.23%15.2 MBpython32019-12-22 01:11:12Accepted [https://leetcode-cn.com//submissions/detail/40815306/]18 ms91.64%39.4 MBjava2019-12-22 01:09:44Time Limit Exceeded [https://leetcode-cn.com//submissions/detail/40815280/]N/AN/AN/Ajava# 统计信息\n通过次数提交次数AC比率270933918269.1%",contentLowercase:"# 中文题目\n给定长度为2n的数组, 你的任务是将这些数分成n 对, 例如 (a1, b1), (a2, b2), ..., (an, bn) ，使得从1 到 n 的 min(ai, bi) 总和最大。\n\n示例 1:\n\n\n输入: [1,4,3,2]\n\n输出: 4\n解释: n 等于 2, 最大总和为 4 = min(1, 2) + min(3, 4).\n\n\n提示:\n\n 1. n是正整数,范围在 [1, 10000].\n 2. 数组中的元素范围在 [-10000, 10000].\n\n# 通过代码\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar arraypairsum = function(nums) {\n    return nums.sort((a,b)=>a-b).filter((item,index)=> index % 2 === 0).reduce((t,i)=> t+i)\n};\n\n1\n2\n3\n4\n5\n6\nclass solution:\n    def arraypairsum(self, nums: list[int]) -> int:\n        nums.sort()\n        return sum(nums[::2])\n\n\n1\n2\n3\n4\nclass solution {\n    public int arraypairsum(int[] nums) {\n        arrays.sort(nums);\n        int sum=0;\n        for(int i=0;i<nums.length;i=i+2){\n            sum+=nums[i];\n        }\n        return sum;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n# 官方题解\n# 方法一 暴力求解 [超过时间限制]\n算法\n\n最简单的解决方案是考虑 numsnumsnums 数组的元素每个可能的配对集。为了生成所有可能的配对，我们使用函数 permute（nums，current_index）。此函数创建给定数组元素的所有可能排列。\n\n为此，permute将当前元素 currentindexcurrent_indexcurrenti​ndex 的索引作为参数之一，然后，它将当前元素与数组中的每个其他元素交换，向右移动，以便生成数组元素的新排序。在完成交换之后，它再次调用 permute，但这次使用数组中下一个元素的索引。返回时，我们反转当前函数调用中的交换。\n\n因此，当到达数组的末尾时，会生成数组元素的新排序。考虑配对的元素，使得每对的第一个元素来自新数组的前半部分，第二个元素来自数组的后半部分。因此，我们总结了所有这些可能配对中的最小元素，并找出它们的最大总和。\n\n下面的动画描述了排列的生成方式。\n\n<,,,,,,,,,,>\n\npublic class solution {\n    int max_sum = integer.min_value;\n    public int arraypairsum(int[] nums) {\n        permute(nums, 0);\n        return max_sum;\n    }\n    public void permute(int[] nums, int l) {\n        if (l == nums.length - 1) {\n            int sum = 0;\n            for (int i = 0; i < nums.length / 2; i++) {\n                sum += math.min(nums[i], nums[nums.length / 2 + i]);\n            }\n            max_sum = math.max(max_sum, sum);\n        }\n        for (int i = l; i < nums.length; i++) {\n            swap(nums, i, l);\n            permute(nums, l + 1);\n            swap(nums, i, l);\n        }\n    }\n    public void swap(int[] nums, int x, int y) {\n        int temp = nums[x];\n        nums[x] = nums[y];\n        nums[y] = temp;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n复杂度分析\n\n * 时间复杂度：o(n!)o(n!)o(n!)。对于数组中的 nnn 元素，总共可以 nnn 排列。\n   \n   \n * 空间复杂度：o(1)o(1)o(1)。仅需使用常数级的额外空间。\n   \n   \n\n\n\n\n# 方法二 排序 [通过]\n算法\n\n为了理解这种方法，让我们从不同的角度来看待问题。我们需要形成数组元​​素的配对，使得这种配对中最小的总和最大。因此，我们可以查看选择配对中最小值的操作，比如 (a,b)(a,b)(a,b) 可能会产生的最大损失 a−ba-ba−b (如果 a>ba > ba>b)。\n\n如果这类配对产生的总损失最小化，那么总金额现在将达到最大值。只有当为配对选择的数字比数组的其他元素更接近彼此时，才有可能将每个配对中的损失最小化。\n\n考虑到这一点，我们可以对给定数组的元素进行排序，并直接按排序顺序形成元素的配对。这将导致元素的配对，它们之间的差异最小，从而导致所需总和的最大化。\n\npublic class solution {\n    public int arraypairsum(int[] nums) {\n        arrays.sort(nums);\n        int sum = 0;\n        for (int i = 0; i < nums.length; i += 2) {\n            sum += nums[i];\n        }\n        return sum;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n复杂度分析\n\n * 时间复杂度：o(nlog(n))o\\big(nlog(n)\\big)o(nlog(n))。排序需要 o(nlog(n))o\\big(nlog(n)\\big)o(nlog(n)) 的时间。另外会有一次数组的遍历。\n   \n   \n * 空间复杂度：o(1)o(1)o(1)。仅仅需要常数级的空间.\n   \n   \n\n\n\n\n# 方法三 使用额外的空间 [通过]\n算法\n\n这种方法在某种程度上与排序方法有关。由于给定数组中的元素范围有限 [-10000, 10000]，我们可以使用 arrarrarr 的哈希表，这样 arr[i]arr [i]arr[i] 存储 （i−10000）th（i-10000）^ {th}（i−10000）th 元素的出现频率。 这个减法操作可以保证这个哈希表可以能够存下范围内的所有数字。\n\n因此，现在我们可以直接以递增的顺序遍历哈希表，而不是对数组的元素进行排序。但是，任何元素也可能在给定数组中多次出现。我们需要考虑这个因素。\n\n为此，考虑一个例子：nums：[a，b，a，b，b，a]。这个数组的排序顺序是 nums_sorted：[a，a，a，b，b，b]。（我们实际上并没有在这种方法中对数组进行排序，但是排序的数组仅用于演示）。从前面的方法，我们知道所需的配对集是 （a，a），（a，b），（b，b）（a，a），（a，b），（b，b）（a，a），（a，b），（b，b）。现在，我们可以看到，在选择最小元素时，aaa 将被选择两次，bbb 将仅被选择一次。发生这种情况是因为要选择的 aaa 的数量已经由 aaa 的频率确定，其余的地方将由 bbb 填补。这是因为，为了得到正确的结果，我们需要按升序考虑元素。因此，较低的数字总是优先被添加到最终结果。\n\n但是，如果排序的元素采用以下形式：nums_sorted：[a，a，b，b，b，b]，正确的配对将是 （a，a），（b，b），（b，b））（a，a），（b，b），（b，b） ）（a，a），（b，b），（b，b））。同样，在这种情况下，所选择的aaa的数量已经预先确定，但由于 aaa 的数量是奇数，因此它不会影响最终总和中 bbb 的选择。\n\n因此，基于上面的讨论，我们遍历哈希表 arrarrarr。如果当前元素出现 reqireq_ireqi​ 次，并且其中一个元素与右边区域中的其他元素配对（考虑虚拟排序数组），我们考虑当前元素 ⌈freqi2⌉\\left\\lceil\\frac{freq_i}{2}\\right\\rceil⌈2freqi​​⌉ 次数以及数组中出现的下一个元素 ⌊freqj2⌋\\left\\lfloor\\frac {freq_j}{2}\\right\\rfloor⌊2freqj​​⌋ 最终总和的次数。为了传播这个左边对所选数字的影响，我们使用了一个标志 ddd。如果当前集合中有剩余元素将被再次考虑，则此标志设置为 1。在从下一组中选择元素时，会考虑已考虑的相同额外元素。\n\n在遍历哈希表时，我们确定需要考虑每个元素的正确次数，如上所述。请注意，如果数组中不存在哈希表的当前元素，则标志 ddd 和 sumsumsum保持不变。\n\n下面的代码受到 @fallcreek [https://leetcode.com/fallcreek]的启发\n\npublic class solution {\n    public int arraypairsum(int[] nums) {\n        int[] arr = new int[20001];\n        int lim = 10000;\n        for (int num: nums)\n            arr[num + lim]++;\n        int d = 0, sum = 0;\n        for (int i = -10000; i <= 10000; i++) {\n            sum += (arr[i + lim] + 1 - d) / 2 * i;\n            d = (2 + arr[i + lim] - d) % 2;\n        }\n        return sum;\n    }\n} \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n复杂度分析\n\n * 时间复杂度：o(n)o(n)o(n)。需要遍历一次哈希表 arrarrarr。\n   \n   \n * 空间复杂度：o(n)o(n)o(n)。存储一个大小为nnn哈希表 arrarrarr 所需要的空间。\n   \n   \n\n\n\n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2019-12-22 01:12:23accepted [https://leetcode-cn.com//submissions/detail/40815332/]136 ms5.23%40.8 mbjavascript2019-12-22 01:11:53accepted [https://leetcode-cn.com//submissions/detail/40815322/]320 ms5.23%15.2 mbpython32019-12-22 01:11:12accepted [https://leetcode-cn.com//submissions/detail/40815306/]18 ms91.64%39.4 mbjava2019-12-22 01:09:44time limit exceeded [https://leetcode-cn.com//submissions/detail/40815280/]n/an/an/ajava# 统计信息\n通过次数提交次数ac比率270933918269.1%"},{title:"566-重塑矩阵(Reshape the Matrix)",frontmatter:{title:"566-重塑矩阵(Reshape the Matrix)",date:"2020-01-12T00:00:00.000Z",categories:["简单"],tags:["数组<Array>"]},regularPath:"/views/%E7%AE%80%E5%8D%95/0566-%E9%87%8D%E5%A1%91%E7%9F%A9%E9%98%B5.html",relativePath:"views/简单/0566-重塑矩阵.md",key:"v-3529fb88",path:"/views/%E7%AE%80%E5%8D%95/0566-%E9%87%8D%E5%A1%91%E7%9F%A9%E9%98%B5.html",headers:[{level:2,title:"中文题目",slug:"中文题目",charIndex:2},{level:2,title:"通过代码",slug:"通过代码",charIndex:493},{level:2,title:"官方题解",slug:"官方题解",charIndex:1108},{level:2,title:"提交历史",slug:"提交历史",charIndex:4508},{level:2,title:"统计信息",slug:"统计信息",charIndex:4640}],lastUpdated:"4/11/2021, 1:15:21 PM",headersStr:"中文题目 通过代码 官方题解 提交历史 统计信息",content:"# 中文题目\n在MATLAB中，有一个非常有用的函数 reshape，它可以将一个矩阵重塑为另一个大小不同的新矩阵，但保留其原始数据。\n\n给出一个由二维数组表示的矩阵，以及两个正整数r和c，分别表示想要的重构的矩阵的行数和列数。\n\n重构后的矩阵需要将原始矩阵的所有元素以相同的行遍历顺序填充。\n\n如果具有给定参数的reshape操作是可行且合理的，则输出新的重塑矩阵；否则，输出原始矩阵。\n\n示例 1:\n\n\n输入: \nnums = \n[[1,2],\n [3,4]]\nr = 1, c = 4\n输出: \n[[1,2,3,4]]\n解释:\n行遍历nums的结果是 [1,2,3,4]。新的矩阵是 1 * 4 矩阵, 用之前的元素值一行一行填充新矩阵。\n\n\n示例 2:\n\n\n输入: \nnums = \n[[1,2],\n [3,4]]\nr = 2, c = 4\n输出: \n[[1,2],\n [3,4]]\n解释:\n没有办法将 2 * 2 矩阵转化为 2 * 4 矩阵。 所以输出原矩阵。\n\n\n注意：\n\n 1. 给定矩阵的宽和高范围在 [1, 100]。\n 2. 给定的 r 和 c 都是正数。\n\n# 通过代码\nclass Solution {\n    public int[][] matrixReshape(int[][] nums, int r, int c) {\n        int[][] arr=new int[r][c];\n        int a=nums.length;\n        int b=nums[0].length;\n        if (a*b==r*c){\n            int[] array = Arrays.stream(nums).flatMapToInt(x -> Arrays.stream(x)).toArray();\n            int count=0;\n            for (int i = 0; i < r; i++) {\n                for (int j = 0; j < c; j++) {\n                    arr[i][j]=array[count++];\n                }\n            }\n            return arr;\n        }else {\n            return nums;\n        }\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n# 官方题解\n# 方法一 使用队列 [通过]\n算法\n\n最简单的方法是通过以行方式读取元素来提取给定矩阵的所有元素。在此实现中，我们使用队列来放置提取的元素。然后，我们可以取出以串行顺序形成的队列元素，并再次按行逐行排列所得到的所需矩阵中的元素。\n\n如果原始矩阵中的元素数量不等于所得矩阵中的元素数量，则不可能形成所得矩阵。\n\npublic class Solution {\n    public int[][] matrixReshape(int[][] nums, int r, int c) {\n        int[][] res = new int[r][c];\n        if (nums.length == 0 || r * c != nums.length * nums[0].length)\n            return nums;\n        int count = 0;\n        Queue < Integer > queue = new LinkedList < > ();\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = 0; j < nums[0].length; j++) {\n                queue.add(nums[i][j]);\n            }\n        }\n        for (int i = 0; i < r; i++) {\n            for (int j = 0; j < c; j++) {\n                res[i][j] = queue.remove();\n            }\n        }\n        return res;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n复杂度分析\n\n * 时间复杂度：O(m∗n)O(m*n)O(m∗n)。我们遍历 m∗nm * nm∗n 元素两次。这里，mmm 和 nnn 分别表示给定矩阵的行数和列数。\n   \n   \n * 空间复杂度：O(m∗n)O(m*n)O(m∗n)。形成的队列大小为 m∗nm*nm∗n 。\n   \n   \n\n\n\n\n# 方法二 不用额外空间 [通过]\n算法\n\n我们不必像在暴力方法中那样不必要地使用队列，而是可以在逐行顺序迭代给定矩阵的同时，直接将数字放在结果矩阵中。在将数字放入结果数组时，我们固定一个特定的行，并继续增加列数，直到我们到达ccc指示的所需列的末尾。此时，我们通过递增来更新行索引，并将列索引重置为从0开始。因此，我们可以节省队列消耗的空间，以便存储只需要复制到新数组中的数据。\n\npublic class Solution {\n    public int[][] matrixReshape(int[][] nums, int r, int c) {\n        int[][] res = new int[r][c];\n        if (nums.length == 0 || r * c != nums.length * nums[0].length)\n            return nums;\n        int rows = 0, cols = 0;\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = 0; j < nums[0].length; j++) {\n                res[rows][cols] = nums[i][j];\n                cols++;\n                if (cols == c) {\n                    rows++;\n                    cols = 0;\n                }\n            }\n        }\n        return res;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n复杂度分析\n\n * 时间复杂度：O(m∗n)O(m*n)O(m∗n)。我们只遍历整个矩阵 m∗nm*nm∗n。这里，mmm 和 nnn 指的是给定矩阵中的行数和列数。\n   \n   \n * 空间复杂度：O(m∗n)O(m*n)O(m∗n)。使用大小为 m∗nm*nm∗n 的结果矩阵。\n   \n   \n\n\n\n\n# 方法三 除法和取模 [通过]\n算法\n\n在上一种方法中，我们需要跟踪我们何时到达结果矩阵的列的末尾，并且需要通过每次检查当前索引来更新当前行和列号以放置提取的元素。我们可以利用数学来帮助解决，而不是在每一步都进行限制性检查。\n\n这种方法背后的想法如下。你知道二维数组是如何存储在主存中的（本质上是一维）吗？它仅在内部表示为一维阵列。元素nums[i][j]nums [i] [j]nums[i][j] numsnumsnums 数组通过使用以下形式的索引以一维数组的形式表示：$ nums [n * i + j] ，其中，其中，其中 m 是给定矩阵中的列数。以相反的顺序查看相同的内容，同时将元素放在结果矩阵中的元素中，我们可以使用是给定矩阵中的列数。以相反的顺序查看相同的内容，同时将元素放在结果矩阵中的元素中，我们可以使用是给定矩阵中的列数。以相反的顺序查看相同的内容，同时将元素放在结果矩阵中的元素中，我们可以使用 count 变量，该变量对于遍历的每个元素都会递增，就像我们将元素放在一维中一样结果数组。但是，要将变量，该变量对于遍历的每个元素都会递增，就像我们将元素放在一维中一样结果数组。但是，要将变量，该变量对于遍历的每个元素都会递增，就像我们将元素放在一维中一样结果数组。但是，要将 count 转换回列数为转换回列数为转换回列数为 c 的二维矩阵索引，我们可以获得的二维矩阵索引，我们可以获得的二维矩阵索引，我们可以获得 res [count / c] [count \\％c] 的索引，其中的索引，其中的索引，其中 count / c 是行号和是行号和是行号和 count \\％c $是列数字。因此，我们可以节省每一步所需的额外检查。\n\npublic class Solution {\n    public int[][] matrixReshape(int[][] nums, int r, int c) {\n        int[][] res = new int[r][c];\n        if (nums.length == 0 || r * c != nums.length * nums[0].length)\n            return nums;\n        int count = 0;\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = 0; j < nums[0].length; j++) {\n                res[count / c][count % c] = nums[i][j];\n                count++;\n            }\n        }\n        return res;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n复杂度分析\n\n * 时间复杂度：O(m∗n)O(m*n)O(m∗n)。我们只遍历整个矩阵 m∗nm*nm∗n 。这里，mmm 和 nnn 指的是给定矩阵中的行数和列数。\n   \n   \n * 空间复杂度：O(m∗n)O(m*n)O(m∗n)。使用大小为 m∗nm*nm∗n 的矩阵存储结果。\n   \n   \n\n\n\n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2020-01-12 17:15:03Accepted [https://leetcode-cn.com//submissions/detail/43194918/]10 ms11.44%46 MBjava# 统计信息\n通过次数提交次数AC比率120711910763.2%",contentLowercase:"# 中文题目\n在matlab中，有一个非常有用的函数 reshape，它可以将一个矩阵重塑为另一个大小不同的新矩阵，但保留其原始数据。\n\n给出一个由二维数组表示的矩阵，以及两个正整数r和c，分别表示想要的重构的矩阵的行数和列数。\n\n重构后的矩阵需要将原始矩阵的所有元素以相同的行遍历顺序填充。\n\n如果具有给定参数的reshape操作是可行且合理的，则输出新的重塑矩阵；否则，输出原始矩阵。\n\n示例 1:\n\n\n输入: \nnums = \n[[1,2],\n [3,4]]\nr = 1, c = 4\n输出: \n[[1,2,3,4]]\n解释:\n行遍历nums的结果是 [1,2,3,4]。新的矩阵是 1 * 4 矩阵, 用之前的元素值一行一行填充新矩阵。\n\n\n示例 2:\n\n\n输入: \nnums = \n[[1,2],\n [3,4]]\nr = 2, c = 4\n输出: \n[[1,2],\n [3,4]]\n解释:\n没有办法将 2 * 2 矩阵转化为 2 * 4 矩阵。 所以输出原矩阵。\n\n\n注意：\n\n 1. 给定矩阵的宽和高范围在 [1, 100]。\n 2. 给定的 r 和 c 都是正数。\n\n# 通过代码\nclass solution {\n    public int[][] matrixreshape(int[][] nums, int r, int c) {\n        int[][] arr=new int[r][c];\n        int a=nums.length;\n        int b=nums[0].length;\n        if (a*b==r*c){\n            int[] array = arrays.stream(nums).flatmaptoint(x -> arrays.stream(x)).toarray();\n            int count=0;\n            for (int i = 0; i < r; i++) {\n                for (int j = 0; j < c; j++) {\n                    arr[i][j]=array[count++];\n                }\n            }\n            return arr;\n        }else {\n            return nums;\n        }\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n# 官方题解\n# 方法一 使用队列 [通过]\n算法\n\n最简单的方法是通过以行方式读取元素来提取给定矩阵的所有元素。在此实现中，我们使用队列来放置提取的元素。然后，我们可以取出以串行顺序形成的队列元素，并再次按行逐行排列所得到的所需矩阵中的元素。\n\n如果原始矩阵中的元素数量不等于所得矩阵中的元素数量，则不可能形成所得矩阵。\n\npublic class solution {\n    public int[][] matrixreshape(int[][] nums, int r, int c) {\n        int[][] res = new int[r][c];\n        if (nums.length == 0 || r * c != nums.length * nums[0].length)\n            return nums;\n        int count = 0;\n        queue < integer > queue = new linkedlist < > ();\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = 0; j < nums[0].length; j++) {\n                queue.add(nums[i][j]);\n            }\n        }\n        for (int i = 0; i < r; i++) {\n            for (int j = 0; j < c; j++) {\n                res[i][j] = queue.remove();\n            }\n        }\n        return res;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n复杂度分析\n\n * 时间复杂度：o(m∗n)o(m*n)o(m∗n)。我们遍历 m∗nm * nm∗n 元素两次。这里，mmm 和 nnn 分别表示给定矩阵的行数和列数。\n   \n   \n * 空间复杂度：o(m∗n)o(m*n)o(m∗n)。形成的队列大小为 m∗nm*nm∗n 。\n   \n   \n\n\n\n\n# 方法二 不用额外空间 [通过]\n算法\n\n我们不必像在暴力方法中那样不必要地使用队列，而是可以在逐行顺序迭代给定矩阵的同时，直接将数字放在结果矩阵中。在将数字放入结果数组时，我们固定一个特定的行，并继续增加列数，直到我们到达ccc指示的所需列的末尾。此时，我们通过递增来更新行索引，并将列索引重置为从0开始。因此，我们可以节省队列消耗的空间，以便存储只需要复制到新数组中的数据。\n\npublic class solution {\n    public int[][] matrixreshape(int[][] nums, int r, int c) {\n        int[][] res = new int[r][c];\n        if (nums.length == 0 || r * c != nums.length * nums[0].length)\n            return nums;\n        int rows = 0, cols = 0;\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = 0; j < nums[0].length; j++) {\n                res[rows][cols] = nums[i][j];\n                cols++;\n                if (cols == c) {\n                    rows++;\n                    cols = 0;\n                }\n            }\n        }\n        return res;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n复杂度分析\n\n * 时间复杂度：o(m∗n)o(m*n)o(m∗n)。我们只遍历整个矩阵 m∗nm*nm∗n。这里，mmm 和 nnn 指的是给定矩阵中的行数和列数。\n   \n   \n * 空间复杂度：o(m∗n)o(m*n)o(m∗n)。使用大小为 m∗nm*nm∗n 的结果矩阵。\n   \n   \n\n\n\n\n# 方法三 除法和取模 [通过]\n算法\n\n在上一种方法中，我们需要跟踪我们何时到达结果矩阵的列的末尾，并且需要通过每次检查当前索引来更新当前行和列号以放置提取的元素。我们可以利用数学来帮助解决，而不是在每一步都进行限制性检查。\n\n这种方法背后的想法如下。你知道二维数组是如何存储在主存中的（本质上是一维）吗？它仅在内部表示为一维阵列。元素nums[i][j]nums [i] [j]nums[i][j] numsnumsnums 数组通过使用以下形式的索引以一维数组的形式表示：$ nums [n * i + j] ，其中，其中，其中 m 是给定矩阵中的列数。以相反的顺序查看相同的内容，同时将元素放在结果矩阵中的元素中，我们可以使用是给定矩阵中的列数。以相反的顺序查看相同的内容，同时将元素放在结果矩阵中的元素中，我们可以使用是给定矩阵中的列数。以相反的顺序查看相同的内容，同时将元素放在结果矩阵中的元素中，我们可以使用 count 变量，该变量对于遍历的每个元素都会递增，就像我们将元素放在一维中一样结果数组。但是，要将变量，该变量对于遍历的每个元素都会递增，就像我们将元素放在一维中一样结果数组。但是，要将变量，该变量对于遍历的每个元素都会递增，就像我们将元素放在一维中一样结果数组。但是，要将 count 转换回列数为转换回列数为转换回列数为 c 的二维矩阵索引，我们可以获得的二维矩阵索引，我们可以获得的二维矩阵索引，我们可以获得 res [count / c] [count \\％c] 的索引，其中的索引，其中的索引，其中 count / c 是行号和是行号和是行号和 count \\％c $是列数字。因此，我们可以节省每一步所需的额外检查。\n\npublic class solution {\n    public int[][] matrixreshape(int[][] nums, int r, int c) {\n        int[][] res = new int[r][c];\n        if (nums.length == 0 || r * c != nums.length * nums[0].length)\n            return nums;\n        int count = 0;\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = 0; j < nums[0].length; j++) {\n                res[count / c][count % c] = nums[i][j];\n                count++;\n            }\n        }\n        return res;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n复杂度分析\n\n * 时间复杂度：o(m∗n)o(m*n)o(m∗n)。我们只遍历整个矩阵 m∗nm*nm∗n 。这里，mmm 和 nnn 指的是给定矩阵中的行数和列数。\n   \n   \n * 空间复杂度：o(m∗n)o(m*n)o(m∗n)。使用大小为 m∗nm*nm∗n 的矩阵存储结果。\n   \n   \n\n\n\n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2020-01-12 17:15:03accepted [https://leetcode-cn.com//submissions/detail/43194918/]10 ms11.44%46 mbjava# 统计信息\n通过次数提交次数ac比率120711910763.2%"},{title:"617-合并二叉树(Merge Two Binary Trees)",frontmatter:{title:"617-合并二叉树(Merge Two Binary Trees)",date:"2018-05-09T00:00:00.000Z",categories:["简单"],tags:["树<Tree>"]},regularPath:"/views/%E7%AE%80%E5%8D%95/0617-%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91.html",relativePath:"views/简单/0617-合并二叉树.md",key:"v-17bb9e2d",path:"/views/%E7%AE%80%E5%8D%95/0617-%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91.html",headers:[{level:2,title:"中文题目",slug:"中文题目",charIndex:2},{level:2,title:"通过代码",slug:"通过代码",charIndex:605},{level:2,title:"官方题解",slug:"官方题解",charIndex:1982},{level:2,title:"提交历史",slug:"提交历史",charIndex:4308},{level:2,title:"统计信息",slug:"统计信息",charIndex:4535}],lastUpdated:"4/11/2021, 1:15:21 PM",headersStr:"中文题目 通过代码 官方题解 提交历史 统计信息",content:"# 中文题目\n给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。\n\n你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为NULL 的节点将直接作为新二叉树的节点。\n\n示例 1:\n\n\n输入: \n\tTree 1                     Tree 2                  \n          1                         2                             \n         / \\                       / \\                            \n        3   2                     1   3                        \n       /                           \\   \\                      \n      5                             4   7                  \n输出: \n合并后的树:\n\t     3\n\t    / \\\n\t   4   5\n\t  / \\   \\ \n\t 5   4   7\n\n\n注意:合并必须从两个树的根节点开始。\n\n# 通过代码\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public TreeNode mergeTrees(TreeNode t1, TreeNode t2) {\n      if (t1==null){\n                return t2;\n            }\n            if (t2==null){\n                return t1;\n            }\n            TreeNode root=new TreeNode(t1.val+t2.val);\n\n            root.left=mergeTrees(t1.left,t2.left);\n            root.right=mergeTrees(t1.right,t2.right);\n            return root;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public TreeNode mergeTrees(TreeNode t1, TreeNode t2) {\n        if (t1 == null && t2 == null) {\n                return null;\n            }\n            int val = (t1 == null ? 0 : t1.val) + (t2 == null ? 0 : t2.val);\n            TreeNode root = new TreeNode(val);\n            root.left = mergeTrees(t1 == null ? null : t1.left, t2 == null ? null : t2.left);\n            root.right = mergeTrees(t1 == null ? null : t1.right, t2 == null ? null : t2.right);\n            return root;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n# 官方题解\n# 方法一：递归\n我们可以对这两棵树同时进行前序遍历，并将对应的节点进行合并。在遍历时，如果两棵树的当前节点均不为空，我们就将它们的值进行相加，并对它们的左孩子和右孩子进行递归合并；如果其中有一棵树为空，那么我们返回另一颗树作为结果；如果两棵树均为空，此时返回任意一棵树均可（因为都是空）。\n\n<,,,,,,,,,,,,,,>\n\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\npublic class Solution {\n    public TreeNode mergeTrees(TreeNode t1, TreeNode t2) {\n        if (t1 == null)\n            return t2;\n        if (t2 == null)\n            return t1;\n        t1.val += t2.val;\n        t1.left = mergeTrees(t1.left, t2.left);\n        t1.right = mergeTrees(t1.right, t2.right);\n        return t1;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n复杂度分析\n\n * 时间复杂度：O(N)O(N)O(N)，其中 NNN 是两棵树中节点个数的较小值。\n   \n   \n * 空间复杂度：O(N)O(N)O(N)，在最坏情况下，会递归 NNN 层，需要 O(N)O(N)O(N) 的栈空间。\n   \n   \n\n# 方法二：迭代\n我们也可以用迭代的方法解决这个问题。\n\n我们首先把两棵树的根节点入栈，栈中的每个元素都会存放两个根节点，并且栈顶的元素表示当前需要处理的节点。在迭代的每一步中，我们取出栈顶的元素并把它移出栈，并将它们的值相加。随后我们分别考虑这两个节点的左孩子和右孩子，如果两个节点都有左孩子，那么就将左孩子入栈；如果只有一个节点有左孩子，那么将其作为第一个节点的左孩子；如果都没有左孩子，那么不用做任何事情。对于右孩子同理。\n\n最后我们返回第一棵树的根节点作为答案。\n\n<,,,,,,,,,,,,,,>\n\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\npublic class Solution {\n    public TreeNode mergeTrees(TreeNode t1, TreeNode t2) {\n        if (t1 == null)\n            return t2;\n        Stack < TreeNode[] > stack = new Stack < > ();\n        stack.push(new TreeNode[] {t1, t2});\n        while (!stack.isEmpty()) {\n            TreeNode[] t = stack.pop();\n            if (t[0] == null || t[1] == null) {\n                continue;\n            }\n            t[0].val += t[1].val;\n            if (t[0].left == null) {\n                t[0].left = t[1].left;\n            } else {\n                stack.push(new TreeNode[] {t[0].left, t[1].left});\n            }\n            if (t[0].right == null) {\n                t[0].right = t[1].right;\n            } else {\n                stack.push(new TreeNode[] {t[0].right, t[1].right});\n            }\n        }\n        return t1;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n复杂度分析\n\n * 时间复杂度：O(N)O(N)O(N)，其中 NNN 是两棵树中节点个数的较小值。\n   \n   \n * 空间复杂度：O(N)O(N)O(N)，在最坏情况下，栈中会存放 NNN 个节点。\n   \n   \n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-05-09 23:35:06Accepted [https://leetcode-cn.com//submissions/detail/2121753/]13 ms9.92%N/Ajava2018-05-09 23:24:08Accepted [https://leetcode-cn.com//submissions/detail/2121559/]14 ms9.92%N/Ajava# 统计信息\n通过次数提交次数AC比率309564156174.5%",contentLowercase:"# 中文题目\n给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。\n\n你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为null 的节点将直接作为新二叉树的节点。\n\n示例 1:\n\n\n输入: \n\ttree 1                     tree 2                  \n          1                         2                             \n         / \\                       / \\                            \n        3   2                     1   3                        \n       /                           \\   \\                      \n      5                             4   7                  \n输出: \n合并后的树:\n\t     3\n\t    / \\\n\t   4   5\n\t  / \\   \\ \n\t 5   4   7\n\n\n注意:合并必须从两个树的根节点开始。\n\n# 通过代码\n/**\n * definition for a binary tree node.\n * public class treenode {\n *     int val;\n *     treenode left;\n *     treenode right;\n *     treenode(int x) { val = x; }\n * }\n */\nclass solution {\n    public treenode mergetrees(treenode t1, treenode t2) {\n      if (t1==null){\n                return t2;\n            }\n            if (t2==null){\n                return t1;\n            }\n            treenode root=new treenode(t1.val+t2.val);\n\n            root.left=mergetrees(t1.left,t2.left);\n            root.right=mergetrees(t1.right,t2.right);\n            return root;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n/**\n * definition for a binary tree node.\n * public class treenode {\n *     int val;\n *     treenode left;\n *     treenode right;\n *     treenode(int x) { val = x; }\n * }\n */\nclass solution {\n    public treenode mergetrees(treenode t1, treenode t2) {\n        if (t1 == null && t2 == null) {\n                return null;\n            }\n            int val = (t1 == null ? 0 : t1.val) + (t2 == null ? 0 : t2.val);\n            treenode root = new treenode(val);\n            root.left = mergetrees(t1 == null ? null : t1.left, t2 == null ? null : t2.left);\n            root.right = mergetrees(t1 == null ? null : t1.right, t2 == null ? null : t2.right);\n            return root;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n# 官方题解\n# 方法一：递归\n我们可以对这两棵树同时进行前序遍历，并将对应的节点进行合并。在遍历时，如果两棵树的当前节点均不为空，我们就将它们的值进行相加，并对它们的左孩子和右孩子进行递归合并；如果其中有一棵树为空，那么我们返回另一颗树作为结果；如果两棵树均为空，此时返回任意一棵树均可（因为都是空）。\n\n<,,,,,,,,,,,,,,>\n\n/**\n * definition for a binary tree node.\n * public class treenode {\n *     int val;\n *     treenode left;\n *     treenode right;\n *     treenode(int x) { val = x; }\n * }\n */\npublic class solution {\n    public treenode mergetrees(treenode t1, treenode t2) {\n        if (t1 == null)\n            return t2;\n        if (t2 == null)\n            return t1;\n        t1.val += t2.val;\n        t1.left = mergetrees(t1.left, t2.left);\n        t1.right = mergetrees(t1.right, t2.right);\n        return t1;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n复杂度分析\n\n * 时间复杂度：o(n)o(n)o(n)，其中 nnn 是两棵树中节点个数的较小值。\n   \n   \n * 空间复杂度：o(n)o(n)o(n)，在最坏情况下，会递归 nnn 层，需要 o(n)o(n)o(n) 的栈空间。\n   \n   \n\n# 方法二：迭代\n我们也可以用迭代的方法解决这个问题。\n\n我们首先把两棵树的根节点入栈，栈中的每个元素都会存放两个根节点，并且栈顶的元素表示当前需要处理的节点。在迭代的每一步中，我们取出栈顶的元素并把它移出栈，并将它们的值相加。随后我们分别考虑这两个节点的左孩子和右孩子，如果两个节点都有左孩子，那么就将左孩子入栈；如果只有一个节点有左孩子，那么将其作为第一个节点的左孩子；如果都没有左孩子，那么不用做任何事情。对于右孩子同理。\n\n最后我们返回第一棵树的根节点作为答案。\n\n<,,,,,,,,,,,,,,>\n\n/**\n * definition for a binary tree node.\n * public class treenode {\n *     int val;\n *     treenode left;\n *     treenode right;\n *     treenode(int x) { val = x; }\n * }\n */\npublic class solution {\n    public treenode mergetrees(treenode t1, treenode t2) {\n        if (t1 == null)\n            return t2;\n        stack < treenode[] > stack = new stack < > ();\n        stack.push(new treenode[] {t1, t2});\n        while (!stack.isempty()) {\n            treenode[] t = stack.pop();\n            if (t[0] == null || t[1] == null) {\n                continue;\n            }\n            t[0].val += t[1].val;\n            if (t[0].left == null) {\n                t[0].left = t[1].left;\n            } else {\n                stack.push(new treenode[] {t[0].left, t[1].left});\n            }\n            if (t[0].right == null) {\n                t[0].right = t[1].right;\n            } else {\n                stack.push(new treenode[] {t[0].right, t[1].right});\n            }\n        }\n        return t1;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n复杂度分析\n\n * 时间复杂度：o(n)o(n)o(n)，其中 nnn 是两棵树中节点个数的较小值。\n   \n   \n * 空间复杂度：o(n)o(n)o(n)，在最坏情况下，栈中会存放 nnn 个节点。\n   \n   \n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-05-09 23:35:06accepted [https://leetcode-cn.com//submissions/detail/2121753/]13 ms9.92%n/ajava2018-05-09 23:24:08accepted [https://leetcode-cn.com//submissions/detail/2121559/]14 ms9.92%n/ajava# 统计信息\n通过次数提交次数ac比率309564156174.5%"},{title:"633-平方数之和(Sum of Square Numbers)",frontmatter:{title:"633-平方数之和(Sum of Square Numbers)",date:"2020-01-05T00:00:00.000Z",categories:["简单"],tags:["数学<Math>"]},regularPath:"/views/%E7%AE%80%E5%8D%95/0633-%E5%B9%B3%E6%96%B9%E6%95%B0%E4%B9%8B%E5%92%8C.html",relativePath:"views/简单/0633-平方数之和.md",key:"v-9df561a4",path:"/views/%E7%AE%80%E5%8D%95/0633-%E5%B9%B3%E6%96%B9%E6%95%B0%E4%B9%8B%E5%92%8C.html",headers:[{level:2,title:"中文题目",slug:"中文题目",charIndex:2},{level:2,title:"通过代码",slug:"通过代码",charIndex:128},{level:2,title:"官方题解",slug:"官方题解",charIndex:409},{level:2,title:"提交历史",slug:"提交历史",charIndex:2546},{level:2,title:"统计信息",slug:"统计信息",charIndex:3307},{level:2,title:"相似题目",slug:"相似题目",charIndex:3341}],lastUpdated:"4/11/2021, 1:15:21 PM",headersStr:"中文题目 通过代码 官方题解 提交历史 统计信息 相似题目",content:"# 中文题目\n给定一个非负整数c，你要判断是否存在两个整数 a 和 b，使得 a2 + b2 = c。\n\n示例1:\n\n\n输入: 5\n输出: True\n解释: 1 * 1 + 2 * 2 = 5\n\n\n\n\n示例2:\n\n\n输入: 3\n输出: False\n\n\n# 通过代码\npublic class Solution {\n    public boolean judgeSquareSum(int c) {\n        for (long a = 0; a * a <= c; a++) {\n            double b = Math.sqrt(c - a * a);\n            if (b == (int) b)\n                return true;\n        }\n        return false;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n# 官方题解\n# 方法一：二分查找\n我们可以首先枚举 a，并保证 c - a^2 >= 0，随后我们通过二分查找的方法找出是否存在 b，满足 b^2 = c - a^2。二分查找的范围为 [0, c - a^2]。\n\n<,,,,,>\n\npublic class Solution {\n    public boolean judgeSquareSum(int c) {\n        for (long a = 0; a * a <= c; a++) {\n            int b = c - (int)(a * a);\n            if (binary_search(0, b, b))\n                return true;\n        }\n        return false;\n    }\n    public boolean binary_search(long s, long e, int n) {\n        if (s > e)\n            return false;\n        long mid = s + (e - s) / 2;\n        if (mid * mid == n)\n            return true;\n        if (mid * mid > n)\n            return binary_search(s, mid - 1, n);\n        return binary_search(mid + 1, e, n);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n复杂度分析\n\n * 时间复杂度：O(clog⁡c)O(\\sqrt{c}\\log c)O(c​logc)，其中枚举 a 的时间复杂度为 O(c)O(\\sqrt{c})O(c​)，二分查找的时间复杂度为 log⁡c\\log clogc。\n   \n   \n * 空间复杂度：O(log⁡c)O(\\log c)O(logc)。代码中使用递归的方式实现二分查找，也可以优化到 O(1)O(1)O(1)。\n   \n   \n\n# 方法二：使用 sqrt 函数\n在枚举 a 之后，我们也可以直接使用 sqrt 函数直接找出 b。\n\npublic class Solution {\n    public boolean judgeSquareSum(int c) {\n        for (long a = 0; a * a <= c; a++) {\n            double b = Math.sqrt(c - a * a);\n            if (b == (int) b)\n                return true;\n        }\n        return false;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n复杂度分析\n\n * 时间复杂度：O(c)O(\\sqrt{c})O(c​)。\n   \n   \n * 空间复杂度：O(1)O(1)O(1)。\n   \n   \n\n# 方法三：费马平方和定理\n费马平方和定理告诉我们：\n\n> 一个非负整数 ccc 能够表示为两个整数的平方和，当且仅当 ccc 的所有形如 4k+34k+34k+3 的质因子的幂次均为偶数。\n\n\n证明方法可以见 这里 [http://wstein.org/edu/124/lectures/lecture21/lecture21/node2.html]。\n\n因此我们对 ccc 进行质因数分解，再判断形如 4k+34k+34k+3 的质因子的幂次是否均为偶数即可。\n\npublic class Solution {\n    public boolean judgeSquareSum(int c) {\n        for (int i = 2; i * i <= c; i++) {\n            int count = 0;\n            if (c % i == 0) {\n                while (c % i == 0) {\n                    count++;\n                    c /= i;\n                }\n                if (i % 4 == 3 && count % 2 != 0)\n                    return false;\n            }\n        }\n        return c % 4 != 3;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n复杂度分析\n\n * 时间复杂度：O(c)O(\\sqrt{c})O(c​)。\n   \n   \n * 空间复杂度：O(1)O(1)O(1)。\n   \n   \n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2020-01-05 16:32:59Accepted [https://leetcode-cn.com//submissions/detail/42352122/]6 ms31.64%33.2 MBjava2020-01-05 16:31:05Time Limit Exceeded [https://leetcode-cn.com//submissions/detail/42351865/]N/AN/AN/Ajava2020-01-05 16:29:40Time Limit Exceeded [https://leetcode-cn.com//submissions/detail/42351707/]N/AN/AN/Ajava2020-01-05 16:24:37Time Limit Exceeded [https://leetcode-cn.com//submissions/detail/42351081/]N/AN/AN/Ajava2020-01-05 16:22:02Time Limit Exceeded [https://leetcode-cn.com//submissions/detail/42350737/]N/AN/AN/Ajava2020-01-05 16:21:18Wrong Answer [https://leetcode-cn.com//submissions/detail/42350651/]N/AN/AN/Ajava2020-01-05 16:20:11Wrong Answer [https://leetcode-cn.com//submissions/detail/42350519/]N/AN/AN/Ajava# 统计信息\n通过次数提交次数AC比率123063813232.3%# 相似题目\n题目难度有效的完全平方数 [https://leetcode-cn.com/problems/valid-perfect-square/]简单",contentLowercase:"# 中文题目\n给定一个非负整数c，你要判断是否存在两个整数 a 和 b，使得 a2 + b2 = c。\n\n示例1:\n\n\n输入: 5\n输出: true\n解释: 1 * 1 + 2 * 2 = 5\n\n\n\n\n示例2:\n\n\n输入: 3\n输出: false\n\n\n# 通过代码\npublic class solution {\n    public boolean judgesquaresum(int c) {\n        for (long a = 0; a * a <= c; a++) {\n            double b = math.sqrt(c - a * a);\n            if (b == (int) b)\n                return true;\n        }\n        return false;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n# 官方题解\n# 方法一：二分查找\n我们可以首先枚举 a，并保证 c - a^2 >= 0，随后我们通过二分查找的方法找出是否存在 b，满足 b^2 = c - a^2。二分查找的范围为 [0, c - a^2]。\n\n<,,,,,>\n\npublic class solution {\n    public boolean judgesquaresum(int c) {\n        for (long a = 0; a * a <= c; a++) {\n            int b = c - (int)(a * a);\n            if (binary_search(0, b, b))\n                return true;\n        }\n        return false;\n    }\n    public boolean binary_search(long s, long e, int n) {\n        if (s > e)\n            return false;\n        long mid = s + (e - s) / 2;\n        if (mid * mid == n)\n            return true;\n        if (mid * mid > n)\n            return binary_search(s, mid - 1, n);\n        return binary_search(mid + 1, e, n);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n复杂度分析\n\n * 时间复杂度：o(clog⁡c)o(\\sqrt{c}\\log c)o(c​logc)，其中枚举 a 的时间复杂度为 o(c)o(\\sqrt{c})o(c​)，二分查找的时间复杂度为 log⁡c\\log clogc。\n   \n   \n * 空间复杂度：o(log⁡c)o(\\log c)o(logc)。代码中使用递归的方式实现二分查找，也可以优化到 o(1)o(1)o(1)。\n   \n   \n\n# 方法二：使用 sqrt 函数\n在枚举 a 之后，我们也可以直接使用 sqrt 函数直接找出 b。\n\npublic class solution {\n    public boolean judgesquaresum(int c) {\n        for (long a = 0; a * a <= c; a++) {\n            double b = math.sqrt(c - a * a);\n            if (b == (int) b)\n                return true;\n        }\n        return false;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n复杂度分析\n\n * 时间复杂度：o(c)o(\\sqrt{c})o(c​)。\n   \n   \n * 空间复杂度：o(1)o(1)o(1)。\n   \n   \n\n# 方法三：费马平方和定理\n费马平方和定理告诉我们：\n\n> 一个非负整数 ccc 能够表示为两个整数的平方和，当且仅当 ccc 的所有形如 4k+34k+34k+3 的质因子的幂次均为偶数。\n\n\n证明方法可以见 这里 [http://wstein.org/edu/124/lectures/lecture21/lecture21/node2.html]。\n\n因此我们对 ccc 进行质因数分解，再判断形如 4k+34k+34k+3 的质因子的幂次是否均为偶数即可。\n\npublic class solution {\n    public boolean judgesquaresum(int c) {\n        for (int i = 2; i * i <= c; i++) {\n            int count = 0;\n            if (c % i == 0) {\n                while (c % i == 0) {\n                    count++;\n                    c /= i;\n                }\n                if (i % 4 == 3 && count % 2 != 0)\n                    return false;\n            }\n        }\n        return c % 4 != 3;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n复杂度分析\n\n * 时间复杂度：o(c)o(\\sqrt{c})o(c​)。\n   \n   \n * 空间复杂度：o(1)o(1)o(1)。\n   \n   \n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2020-01-05 16:32:59accepted [https://leetcode-cn.com//submissions/detail/42352122/]6 ms31.64%33.2 mbjava2020-01-05 16:31:05time limit exceeded [https://leetcode-cn.com//submissions/detail/42351865/]n/an/an/ajava2020-01-05 16:29:40time limit exceeded [https://leetcode-cn.com//submissions/detail/42351707/]n/an/an/ajava2020-01-05 16:24:37time limit exceeded [https://leetcode-cn.com//submissions/detail/42351081/]n/an/an/ajava2020-01-05 16:22:02time limit exceeded [https://leetcode-cn.com//submissions/detail/42350737/]n/an/an/ajava2020-01-05 16:21:18wrong answer [https://leetcode-cn.com//submissions/detail/42350651/]n/an/an/ajava2020-01-05 16:20:11wrong answer [https://leetcode-cn.com//submissions/detail/42350519/]n/an/an/ajava# 统计信息\n通过次数提交次数ac比率123063813232.3%# 相似题目\n题目难度有效的完全平方数 [https://leetcode-cn.com/problems/valid-perfect-square/]简单"},{title:"643-子数组最大平均数 I(Maximum Average Subarray I)",frontmatter:{title:"643-子数组最大平均数 I(Maximum Average Subarray I)",date:"2020-01-05T00:00:00.000Z",categories:["简单"],tags:["数组<Array>"]},regularPath:"/views/%E7%AE%80%E5%8D%95/0643-%E5%AD%90%E6%95%B0%E7%BB%84%E6%9C%80%E5%A4%A7%E5%B9%B3%E5%9D%87%E6%95%B0%20I.html",relativePath:"views/简单/0643-子数组最大平均数 I.md",key:"v-54968448",path:"/views/%E7%AE%80%E5%8D%95/0643-%E5%AD%90%E6%95%B0%E7%BB%84%E6%9C%80%E5%A4%A7%E5%B9%B3%E5%9D%87%E6%95%B0%20I.html",headers:[{level:2,title:"中文题目",slug:"中文题目",charIndex:2},{level:2,title:"通过代码",slug:"通过代码",charIndex:202},{level:2,title:"官方题解",slug:"官方题解",charIndex:694},{level:2,title:"提交历史",slug:"提交历史",charIndex:2302},{level:2,title:"统计信息",slug:"统计信息",charIndex:2435},{level:2,title:"相似题目",slug:"相似题目",charIndex:2468}],lastUpdated:"4/11/2021, 1:15:21 PM",headersStr:"中文题目 通过代码 官方题解 提交历史 统计信息 相似题目",content:"# 中文题目\n给定 n 个整数，找出平均数最大且长度为 k 的连续子数组，并输出该最大平均数。\n\n示例 1:\n\n输入: [1,12,-5,-6,50,3], k = 4\n输出: 12.75\n解释: 最大平均数 (12-5-6+50)/4 = 51/4 = 12.75\n\n\n\n\n注意:\n\n 1. 1 <= k <= n <= 30,000。\n 2. 所给数据范围 [-10,000，10,000]。\n\n# 通过代码\nclass Solution {\n    public double findMaxAverage(int[] nums, int k) {\n        int maxTotal = 0;\n        int total;\n        for (int i = 0; i < k; i++) {\n            maxTotal += nums[i];\n        }\n        total = maxTotal;\n        for (int i = k; i < nums.length; i++) {\n            total -= nums[i - k];\n            total += nums[i];\n            maxTotal = total > maxTotal ? total : maxTotal;\n        }\n        return maxTotal * 1.0 / k;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n# 官方题解\n# 方法一：累计求和【通过】\n算法\n\n为了获得长度为 kkk 的子数组的平均值，我们需要知道这 kkk 个元素之和。使用 sumsumsum 记录数组的累加和，sum[i]sum[i]sum[i] 存储从第一个元素到第 iii 个元素之和。该数组只需要计算一次。\n\n在数组 sumsumsum 中，原数组索引从 iii 到 i+ki+ki+k 的元素之和为 sum[i]−sum[i−k]sum[i] - sum[i-k]sum[i]−sum[i−k]。按照此方法遍历数组 sumsumsum，计算每个长度为 kkk 的子数组平均值，即可获得长度为 kkk 的子数组的最大平均值。\n\n通过动画说明一个简单实例的计算过程。\n\n<,,,,,,,>\n\npublic class Solution {\n\tpublic double findMaxAverage(int[] nums, int k) {\n\t\tint[] sum = new int[nums.length];\n\t\tsum[0] = nums[0];\n\t\tfor (int i = 1; i < nums.length; i++)\n\t\tsum[i] = sum[i - 1] + nums[i];\n\t\tdouble res = sum[k - 1] * 1.0 / k;\n\t\tfor (int i = k; i < nums.length; i++) {\n\t\t\tres = Math.max(res, (sum[i] - sum[i - k]) * 1.0 / k);\n\t\t}\n\t\treturn res;\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n复杂度分析\n\n * 时间复杂度：O(n)O(n)O(n)，遍历数组 numnumnum，和遍历数组 sumsumsum 中的 n−kn-kn−k 个元素。\n   \n   \n * 空间复杂度：O(n)O(n)O(n)，使用长度为 nnn 的数组 sumsumsum 存储累加和。\n   \n   \n\n# 方法二：滑动窗口【通过】\n算法\n\n相比于创建一个累加和数组，再遍历计算最大平均值，本方法只需要遍历一次数组 numnumnum，从中找出长度为 kkk 的子数组最大和。\n\n假设我们已经索引从 iii 到 i+ki+ki+k 子数组和为 xxx。要知道索引从 i+1i+1i+1 到 i+k+1i+k+1i+k+1 子数组和，只需要从 xxx 减去 sum[i]sum[i]sum[i]，加上 sum[i+k+1]sum[i+k+1]sum[i+k+1] 即可。 根据此方法可以获得长度为 kkk 的子数组最大平均值。\n\npublic class Solution {\n    public double findMaxAverage(int[] nums, int k) {\n        double sum=0;\n        for(int i=0;i<k;i++)\n            sum+=nums[i];\n        double res=sum;\n        for(int i=k;i<nums.length;i++){\n            sum+=nums[i]-nums[i-k];\n                res=Math.max(res,sum);\n        }\n        return res/k;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n复杂度分析\n\n * 时间复杂度：O(n)O(n)O(n)，遍历长度为 nnn 的数组 numnumnum 所需时间。\n   \n   \n * 空间复杂度：O(1)O(1)O(1)，恒定的额外空间。\n   \n   \n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2020-01-05 14:54:06Accepted [https://leetcode-cn.com//submissions/detail/42340601/]3 ms99.75%41.2 MBjava# 统计信息\n通过次数提交次数AC比率98122652437.0%# 相似题目\n题目难度最大平均子段和 II [https://leetcode-cn.com/problems/maximum-average-subarray-ii/]困难",contentLowercase:"# 中文题目\n给定 n 个整数，找出平均数最大且长度为 k 的连续子数组，并输出该最大平均数。\n\n示例 1:\n\n输入: [1,12,-5,-6,50,3], k = 4\n输出: 12.75\n解释: 最大平均数 (12-5-6+50)/4 = 51/4 = 12.75\n\n\n\n\n注意:\n\n 1. 1 <= k <= n <= 30,000。\n 2. 所给数据范围 [-10,000，10,000]。\n\n# 通过代码\nclass solution {\n    public double findmaxaverage(int[] nums, int k) {\n        int maxtotal = 0;\n        int total;\n        for (int i = 0; i < k; i++) {\n            maxtotal += nums[i];\n        }\n        total = maxtotal;\n        for (int i = k; i < nums.length; i++) {\n            total -= nums[i - k];\n            total += nums[i];\n            maxtotal = total > maxtotal ? total : maxtotal;\n        }\n        return maxtotal * 1.0 / k;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n# 官方题解\n# 方法一：累计求和【通过】\n算法\n\n为了获得长度为 kkk 的子数组的平均值，我们需要知道这 kkk 个元素之和。使用 sumsumsum 记录数组的累加和，sum[i]sum[i]sum[i] 存储从第一个元素到第 iii 个元素之和。该数组只需要计算一次。\n\n在数组 sumsumsum 中，原数组索引从 iii 到 i+ki+ki+k 的元素之和为 sum[i]−sum[i−k]sum[i] - sum[i-k]sum[i]−sum[i−k]。按照此方法遍历数组 sumsumsum，计算每个长度为 kkk 的子数组平均值，即可获得长度为 kkk 的子数组的最大平均值。\n\n通过动画说明一个简单实例的计算过程。\n\n<,,,,,,,>\n\npublic class solution {\n\tpublic double findmaxaverage(int[] nums, int k) {\n\t\tint[] sum = new int[nums.length];\n\t\tsum[0] = nums[0];\n\t\tfor (int i = 1; i < nums.length; i++)\n\t\tsum[i] = sum[i - 1] + nums[i];\n\t\tdouble res = sum[k - 1] * 1.0 / k;\n\t\tfor (int i = k; i < nums.length; i++) {\n\t\t\tres = math.max(res, (sum[i] - sum[i - k]) * 1.0 / k);\n\t\t}\n\t\treturn res;\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n复杂度分析\n\n * 时间复杂度：o(n)o(n)o(n)，遍历数组 numnumnum，和遍历数组 sumsumsum 中的 n−kn-kn−k 个元素。\n   \n   \n * 空间复杂度：o(n)o(n)o(n)，使用长度为 nnn 的数组 sumsumsum 存储累加和。\n   \n   \n\n# 方法二：滑动窗口【通过】\n算法\n\n相比于创建一个累加和数组，再遍历计算最大平均值，本方法只需要遍历一次数组 numnumnum，从中找出长度为 kkk 的子数组最大和。\n\n假设我们已经索引从 iii 到 i+ki+ki+k 子数组和为 xxx。要知道索引从 i+1i+1i+1 到 i+k+1i+k+1i+k+1 子数组和，只需要从 xxx 减去 sum[i]sum[i]sum[i]，加上 sum[i+k+1]sum[i+k+1]sum[i+k+1] 即可。 根据此方法可以获得长度为 kkk 的子数组最大平均值。\n\npublic class solution {\n    public double findmaxaverage(int[] nums, int k) {\n        double sum=0;\n        for(int i=0;i<k;i++)\n            sum+=nums[i];\n        double res=sum;\n        for(int i=k;i<nums.length;i++){\n            sum+=nums[i]-nums[i-k];\n                res=math.max(res,sum);\n        }\n        return res/k;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n复杂度分析\n\n * 时间复杂度：o(n)o(n)o(n)，遍历长度为 nnn 的数组 numnumnum 所需时间。\n   \n   \n * 空间复杂度：o(1)o(1)o(1)，恒定的额外空间。\n   \n   \n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2020-01-05 14:54:06accepted [https://leetcode-cn.com//submissions/detail/42340601/]3 ms99.75%41.2 mbjava# 统计信息\n通过次数提交次数ac比率98122652437.0%# 相似题目\n题目难度最大平均子段和 ii [https://leetcode-cn.com/problems/maximum-average-subarray-ii/]困难"},{title:"448-找到所有数组中消失的数字(Find All Numbers Disappeared in an Array)",frontmatter:{title:"448-找到所有数组中消失的数字(Find All Numbers Disappeared in an Array)",date:"2020-01-09T00:00:00.000Z",categories:["简单"],tags:["数组<Array>"]},regularPath:"/views/%E7%AE%80%E5%8D%95/0448-%E6%89%BE%E5%88%B0%E6%89%80%E6%9C%89%E6%95%B0%E7%BB%84%E4%B8%AD%E6%B6%88%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97.html",relativePath:"views/简单/0448-找到所有数组中消失的数字.md",key:"v-78bc8af7",path:"/views/%E7%AE%80%E5%8D%95/0448-%E6%89%BE%E5%88%B0%E6%89%80%E6%9C%89%E6%95%B0%E7%BB%84%E4%B8%AD%E6%B6%88%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97.html",headers:[{level:2,title:"中文题目",slug:"中文题目",charIndex:2},{level:2,title:"通过代码",slug:"通过代码",charIndex:201},{level:2,title:"官方题解",slug:"官方题解",charIndex:757},{level:2,title:"提交历史",slug:"提交历史",charIndex:5861},{level:2,title:"统计信息",slug:"统计信息",charIndex:5995},{level:2,title:"相似题目",slug:"相似题目",charIndex:6029}],lastUpdated:"4/11/2021, 1:15:21 PM",headersStr:"中文题目 通过代码 官方题解 提交历史 统计信息 相似题目",content:'# 中文题目\n给定一个范围在 1 ≤ a[i] ≤ n (n = 数组大小 ) 的 整型数组，数组中的元素一些出现了两次，另一些只出现一次。\n\n找到所有在 [1, n] 范围之间没有出现在数组中的数字。\n\n您能在不使用额外空间且时间复杂度为O(n)的情况下完成这个任务吗? 你可以假定返回的数组不算在额外空间内。\n\n示例:\n\n\n输入:\n[4,3,2,7,8,2,3,1]\n\n输出:\n[5,6]\n\n\n# 通过代码\nclass Solution {\n    public List<Integer> findDisappearedNumbers(int[] nums) {\n        for (int i = 0; i < nums.length; i++) {\n            int index = Math.abs(nums[i]) - 1;\n            if (nums[index] > 0) {\n                nums[index] = -1 * Math.abs(nums[index]);\n            }\n        }\n\n        List<Integer> res = new ArrayList<>();\n        for (int i = 0; i < nums.length; i++) {\n            if (nums[i] > 0) {\n                res.add(i + 1);\n            }\n        }\n        return res;\n    }\n\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n# 官方题解\n# 方法一：使用哈希表\n我们假设数组大小为 N，它应该包含从 1 到 N 的数字。但是有些数字丢失了，我们要做的是记录我们在数组中遇到的数字。然后从 1⋯N1\\cdots N1⋯N 检查哈希表中没有出现的数字。我们用一个简单的例子来帮助理解。\n\n算法：\n\n * 我们用一个哈希表 hash 来记录我们在数组中遇到的数字。我们也可以用集合 set 来记录，因为我们并不关心数字出现的次数。\n * 然后遍历给定数组的元素，插入到哈希表中，即使哈希表中已经存在某元素，再次插入了也会覆盖\n * 现在我们知道了数组中存在那些数字，只需从 1⋯N1\\cdots N1⋯N 范围中找到缺失的数字。\n * 从 1⋯N1\\cdots N1⋯N 检查哈希表中是否存在，若不存在则添加到存放答案的数组中。\n\nclass Solution(object):\n    def findDisappearedNumbers(self, nums):\n        """\n        :type nums: List[int]\n        :rtype: List[int]\n        """\n        \n        # Hash table for keeping track of the numbers in the array\n        # Note that we can also use a set here since we are not \n        # really concerned with the frequency of numbers.\n        hash_table = {}\n        \n        # Add each of the numbers to the hash table\n        for num in nums:\n            hash_table[num] = 1\n        \n        # Response array that would contain the missing numbers\n        result = []    \n        \n        # Iterate over the numbers from 1 to N and add all those\n        # that don\'t appear in the hash table. \n        for num in range(1, len(nums) + 1):\n            if num not in hash_table:\n                result.append(num)\n                \n        return result       \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\nclass Solution {\n    public List<Integer> findDisappearedNumbers(int[] nums) {\n        \n        // Hash table for keeping track of the numbers in the array\n        // Note that we can also use a set here since we are not \n        // really concerned with the frequency of numbers.\n        HashMap<Integer, Boolean> hashTable = new HashMap<Integer, Boolean>();\n        \n        // Add each of the numbers to the hash table\n        for (int i = 0; i < nums.length; i++) {\n            hashTable.put(nums[i], true);\n        }\n        \n        // Response array that would contain the missing numbers\n        List<Integer> result = new LinkedList<Integer>();\n        \n        // Iterate over the numbers from 1 to N and add all those\n        // that don\'t appear in the hash table. \n        for (int i = 1; i <= nums.length; i++) {\n            if (!hashTable.containsKey(i)) {\n                result.add(i);\n            }\n        }\n        \n        return result;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n复杂度分析\n\n * 时间复杂度：O(N)O(N)O(N)。\n * 空间复杂度：O(N)O(N)O(N)。\n\n# 方法二：原地修改\n * 我们需要知道数组中存在的数字，由于数组的元素取值范围是 [1, N]，所以我们可以不使用额外的空间去解决它。\n * 我们可以在输入数组本身以某种方式标记已访问过的数字，然后再找到缺失的数字。\n\n算法：\n\n * 遍历输入数组的每个元素一次。\n * 我们将把 |nums[i]|-1 索引位置的元素标记为负数。即 nums[∣nums[i]∣−1]×−1nums[|nums[i] |- 1] \\times -1nums[∣nums[i]∣−1]×−1 。\n * 然后遍历数组，若当前数组元素 nums[i] 为负数，说明我们在数组中存在数字 i+1。\n * 可以通过以下图片示例来帮助理解。\n\nclass Solution(object):\n    def findDisappearedNumbers(self, nums):\n        """\n        :type nums: List[int]\n        :rtype: List[int]\n        """\n        \n        # Iterate over each of the elements in the original array\n        for i in range(len(nums)):\n            \n            # Treat the value as the new index\n            new_index = abs(nums[i]) - 1\n            \n            # Check the magnitude of value at this new index\n            # If the magnitude is positive, make it negative \n            # thus indicating that the number nums[i] has \n            # appeared or has been visited.\n            if nums[new_index] > 0:\n                nums[new_index] *= -1\n        \n        # Response array that would contain the missing numbers\n        result = []    \n        \n        # Iterate over the numbers from 1 to N and add all those\n        # that have positive magnitude in the array \n        for i in range(1, len(nums) + 1):\n            if nums[i - 1] > 0:\n                result.append(i)\n                \n        return result    \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\nclass Solution {\n    public List<Integer> findDisappearedNumbers(int[] nums) {\n        \n        // Iterate over each of the elements in the original array\n        for (int i = 0; i < nums.length; i++) {\n            \n            // Treat the value as the new index\n            int newIndex = Math.abs(nums[i]) - 1;\n            \n            // Check the magnitude of value at this new index\n            // If the magnitude is positive, make it negative \n            // thus indicating that the number nums[i] has \n            // appeared or has been visited.\n            if (nums[newIndex] > 0) {\n                nums[newIndex] *= -1;\n            }\n        }\n        \n        // Response array that would contain the missing numbers\n        List<Integer> result = new LinkedList<Integer>();\n        \n        // Iterate over the numbers from 1 to N and add all those\n        // that have positive magnitude in the array\n        for (int i = 1; i <= nums.length; i++) {\n            \n            if (nums[i - 1] > 0) {\n                result.add(i);\n            }\n        }\n        \n        return result;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n复杂度分析\n\n * 时间复杂度：O(N)O(N)O(N)。\n * 空间复杂度：O(1)O(1)O(1)，因为我们在原地修改数组，没有使用额外的空间。\n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2020-01-09 22:46:38Accepted [https://leetcode-cn.com//submissions/detail/42919312/]12 ms24.96%48.5 MBjava# 统计信息\n通过次数提交次数AC比率233344212455.4%# 相似题目\n题目难度缺失的第一个正数 [https://leetcode-cn.com/problems/first-missing-positive/]困难数组中重复的数据 [https://leetcode-cn.com/problems/find-all-duplicates-in-an-array/]中等',contentLowercase:'# 中文题目\n给定一个范围在 1 ≤ a[i] ≤ n (n = 数组大小 ) 的 整型数组，数组中的元素一些出现了两次，另一些只出现一次。\n\n找到所有在 [1, n] 范围之间没有出现在数组中的数字。\n\n您能在不使用额外空间且时间复杂度为o(n)的情况下完成这个任务吗? 你可以假定返回的数组不算在额外空间内。\n\n示例:\n\n\n输入:\n[4,3,2,7,8,2,3,1]\n\n输出:\n[5,6]\n\n\n# 通过代码\nclass solution {\n    public list<integer> finddisappearednumbers(int[] nums) {\n        for (int i = 0; i < nums.length; i++) {\n            int index = math.abs(nums[i]) - 1;\n            if (nums[index] > 0) {\n                nums[index] = -1 * math.abs(nums[index]);\n            }\n        }\n\n        list<integer> res = new arraylist<>();\n        for (int i = 0; i < nums.length; i++) {\n            if (nums[i] > 0) {\n                res.add(i + 1);\n            }\n        }\n        return res;\n    }\n\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n# 官方题解\n# 方法一：使用哈希表\n我们假设数组大小为 n，它应该包含从 1 到 n 的数字。但是有些数字丢失了，我们要做的是记录我们在数组中遇到的数字。然后从 1⋯n1\\cdots n1⋯n 检查哈希表中没有出现的数字。我们用一个简单的例子来帮助理解。\n\n算法：\n\n * 我们用一个哈希表 hash 来记录我们在数组中遇到的数字。我们也可以用集合 set 来记录，因为我们并不关心数字出现的次数。\n * 然后遍历给定数组的元素，插入到哈希表中，即使哈希表中已经存在某元素，再次插入了也会覆盖\n * 现在我们知道了数组中存在那些数字，只需从 1⋯n1\\cdots n1⋯n 范围中找到缺失的数字。\n * 从 1⋯n1\\cdots n1⋯n 检查哈希表中是否存在，若不存在则添加到存放答案的数组中。\n\nclass solution(object):\n    def finddisappearednumbers(self, nums):\n        """\n        :type nums: list[int]\n        :rtype: list[int]\n        """\n        \n        # hash table for keeping track of the numbers in the array\n        # note that we can also use a set here since we are not \n        # really concerned with the frequency of numbers.\n        hash_table = {}\n        \n        # add each of the numbers to the hash table\n        for num in nums:\n            hash_table[num] = 1\n        \n        # response array that would contain the missing numbers\n        result = []    \n        \n        # iterate over the numbers from 1 to n and add all those\n        # that don\'t appear in the hash table. \n        for num in range(1, len(nums) + 1):\n            if num not in hash_table:\n                result.append(num)\n                \n        return result       \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\nclass solution {\n    public list<integer> finddisappearednumbers(int[] nums) {\n        \n        // hash table for keeping track of the numbers in the array\n        // note that we can also use a set here since we are not \n        // really concerned with the frequency of numbers.\n        hashmap<integer, boolean> hashtable = new hashmap<integer, boolean>();\n        \n        // add each of the numbers to the hash table\n        for (int i = 0; i < nums.length; i++) {\n            hashtable.put(nums[i], true);\n        }\n        \n        // response array that would contain the missing numbers\n        list<integer> result = new linkedlist<integer>();\n        \n        // iterate over the numbers from 1 to n and add all those\n        // that don\'t appear in the hash table. \n        for (int i = 1; i <= nums.length; i++) {\n            if (!hashtable.containskey(i)) {\n                result.add(i);\n            }\n        }\n        \n        return result;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n复杂度分析\n\n * 时间复杂度：o(n)o(n)o(n)。\n * 空间复杂度：o(n)o(n)o(n)。\n\n# 方法二：原地修改\n * 我们需要知道数组中存在的数字，由于数组的元素取值范围是 [1, n]，所以我们可以不使用额外的空间去解决它。\n * 我们可以在输入数组本身以某种方式标记已访问过的数字，然后再找到缺失的数字。\n\n算法：\n\n * 遍历输入数组的每个元素一次。\n * 我们将把 |nums[i]|-1 索引位置的元素标记为负数。即 nums[∣nums[i]∣−1]×−1nums[|nums[i] |- 1] \\times -1nums[∣nums[i]∣−1]×−1 。\n * 然后遍历数组，若当前数组元素 nums[i] 为负数，说明我们在数组中存在数字 i+1。\n * 可以通过以下图片示例来帮助理解。\n\nclass solution(object):\n    def finddisappearednumbers(self, nums):\n        """\n        :type nums: list[int]\n        :rtype: list[int]\n        """\n        \n        # iterate over each of the elements in the original array\n        for i in range(len(nums)):\n            \n            # treat the value as the new index\n            new_index = abs(nums[i]) - 1\n            \n            # check the magnitude of value at this new index\n            # if the magnitude is positive, make it negative \n            # thus indicating that the number nums[i] has \n            # appeared or has been visited.\n            if nums[new_index] > 0:\n                nums[new_index] *= -1\n        \n        # response array that would contain the missing numbers\n        result = []    \n        \n        # iterate over the numbers from 1 to n and add all those\n        # that have positive magnitude in the array \n        for i in range(1, len(nums) + 1):\n            if nums[i - 1] > 0:\n                result.append(i)\n                \n        return result    \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\nclass solution {\n    public list<integer> finddisappearednumbers(int[] nums) {\n        \n        // iterate over each of the elements in the original array\n        for (int i = 0; i < nums.length; i++) {\n            \n            // treat the value as the new index\n            int newindex = math.abs(nums[i]) - 1;\n            \n            // check the magnitude of value at this new index\n            // if the magnitude is positive, make it negative \n            // thus indicating that the number nums[i] has \n            // appeared or has been visited.\n            if (nums[newindex] > 0) {\n                nums[newindex] *= -1;\n            }\n        }\n        \n        // response array that would contain the missing numbers\n        list<integer> result = new linkedlist<integer>();\n        \n        // iterate over the numbers from 1 to n and add all those\n        // that have positive magnitude in the array\n        for (int i = 1; i <= nums.length; i++) {\n            \n            if (nums[i - 1] > 0) {\n                result.add(i);\n            }\n        }\n        \n        return result;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n复杂度分析\n\n * 时间复杂度：o(n)o(n)o(n)。\n * 空间复杂度：o(1)o(1)o(1)，因为我们在原地修改数组，没有使用额外的空间。\n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2020-01-09 22:46:38accepted [https://leetcode-cn.com//submissions/detail/42919312/]12 ms24.96%48.5 mbjava# 统计信息\n通过次数提交次数ac比率233344212455.4%# 相似题目\n题目难度缺失的第一个正数 [https://leetcode-cn.com/problems/first-missing-positive/]困难数组中重复的数据 [https://leetcode-cn.com/problems/find-all-duplicates-in-an-array/]中等'},{title:"637-二叉树的层平均值(Average of Levels in Binary Tree)",frontmatter:{title:"637-二叉树的层平均值(Average of Levels in Binary Tree)",date:"2018-05-11T00:00:00.000Z",categories:["简单"],tags:["树<Tree>"]},regularPath:"/views/%E7%AE%80%E5%8D%95/0637-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%B9%B3%E5%9D%87%E5%80%BC.html",relativePath:"views/简单/0637-二叉树的层平均值.md",key:"v-6384368a",path:"/views/%E7%AE%80%E5%8D%95/0637-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%B9%B3%E5%9D%87%E5%80%BC.html",headers:[{level:2,title:"中文题目",slug:"中文题目",charIndex:2},{level:2,title:"通过代码",slug:"通过代码",charIndex:198},{level:2,title:"官方题解",slug:"官方题解",charIndex:1302},{level:2,title:"提交历史",slug:"提交历史",charIndex:4094},{level:2,title:"统计信息",slug:"统计信息",charIndex:4221},{level:2,title:"相似题目",slug:"相似题目",charIndex:4255}],lastUpdated:"4/11/2021, 1:15:21 PM",headersStr:"中文题目 通过代码 官方题解 提交历史 统计信息 相似题目",content:"# 中文题目\n给定一个非空二叉树, 返回一个由每层节点平均值组成的数组.\n\n示例 1:\n\n输入:\n    3\n   / \\\n  9  20\n    /  \\\n   15   7\n输出: [3, 14.5, 11]\n解释:\n第0层的平均值是 3,  第1层是 14.5, 第2层是 11. 因此返回 [3, 14.5, 11].\n\n\n注意：\n\n 1. 节点值的范围在32位有符号整数范围内。\n\n# 通过代码\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public List<Double> averageOfLevels(TreeNode root) {\n        if (null==root){\n                return null;\n            }\n            LinkedList<TreeNode> queue=new LinkedList<>();\n            queue.addLast(root);\n            LinkedList<Double> list=new LinkedList<>();\n            while (!queue.isEmpty()){\n                int size=queue.size();\n                long total=0L;\n                for (int i = 0; i <size ; i++) {\n                    TreeNode node=queue.removeFirst();\n                    if (node.left!=null)\n                        queue.addLast(node.left);\n                    if (node.right!=null)\n                        queue.addLast(node.right);\n                    total+=node.val;\n                }\n                list.addLast(1.0*total/size);\n            }\n            return list;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n# 官方题解\n# 方法一：深度优先搜索\n我们可以使用深度优先搜索遍历整颗二叉树。我们使用两个数组 sum 存放树中每一层的节点数值之和，以及 count 存放树中每一层的节点数量之和。在遍历时，我们需要额外记录当前节点所在的高度，并根据高度 h 更新数组元素 sum[h] 和 count[h]。在遍历结束之后，res = sum / cnt 即为答案。\n\n<,,,,,,,>\n\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\npublic class Solution {\n    public List < Double > averageOfLevels(TreeNode root) {\n        List < Integer > count = new ArrayList < > ();\n        List < Double > res = new ArrayList < > ();\n        average(root, 0, res, count);\n        for (int i = 0; i < res.size(); i++)\n            res.set(i, res.get(i) / count.get(i));\n        return res;\n    }\n    public void average(TreeNode t, int i, List < Double > sum, List < Integer > count) {\n        if (t == null)\n            return;\n        if (i < sum.size()) {\n            sum.set(i, sum.get(i) + t.val);\n            count.set(i, count.get(i) + 1);\n        } else {\n            sum.add(1.0 * t.val);\n            count.add(1);\n        }\n        average(t.left, i + 1, sum, count);\n        average(t.right, i + 1, sum, count);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n复杂度分析\n\n * 时间复杂度：O(N)O(N)O(N)，其中 NNN 是树中的节点个数。\n   \n   \n * 空间复杂度：O(H)O(H)O(H)，其中 HHH 是树的高度，即为深度优先搜索中使用递归占用的栈空间。\n   \n   \n\n# 方法二：广度优先搜索\n我们同样也可以使用广度优先搜索遍历整颗二叉树。首先我们将根节点放入队列 queue 中，随后对于 queue 中的每一个节点，我们将它的子节点放入临时队列 temp 中。在 queue 中的所有节点都处理完毕后，temp 中即存放了所有在 queue 对应的层数的下一层中的节点。在将子节点放入 temp 的过程中，我们也可以顺便计算出 queue 中节点的数值之和，以此得到平均值。最后我们将 temp 赋值给 queue，继续进行下一轮的广度优先搜索，直到某一轮 temp 为空。\n\n<,,,,,,,,,,,,,,,>\n\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\npublic class Solution {\n    public List < Double > averageOfLevels(TreeNode root) {\n        List < Double > res = new ArrayList < > ();\n        Queue < TreeNode > queue = new LinkedList < > ();\n        queue.add(root);\n        while (!queue.isEmpty()) {\n            long sum = 0, count = 0;\n            Queue < TreeNode > temp = new LinkedList < > ();\n            while (!queue.isEmpty()) {\n                TreeNode n = queue.remove();\n                sum += n.val;\n                count++;\n                if (n.left != null)\n                    temp.add(n.left);\n                if (n.right != null)\n                    temp.add(n.right);\n            }\n            queue = temp;\n            res.add(sum * 1.0 / count);\n        }\n        return res;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n复杂度分析\n\n * 时间复杂度：O(N)O(N)O(N)，其中 NNN 是树中的节点个数。\n   \n   \n * 空间复杂度：O(M)O(M)O(M)，其中 MMM 是树中每一层节点个数的最大值，即为广度优先搜索中使用队列存储同一层节点需要的空间。\n   \n   \n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-05-11 23:36:31Accepted [https://leetcode-cn.com//submissions/detail/2189347/]8 ms6.38%N/Ajava# 统计信息\n通过次数提交次数AC比率119591922062.2%# 相似题目\n题目难度二叉树的层次遍历 [https://leetcode-cn.com/problems/binary-tree-level-order-traversal/]中等二叉树的层次遍历 II [https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/]简单",contentLowercase:"# 中文题目\n给定一个非空二叉树, 返回一个由每层节点平均值组成的数组.\n\n示例 1:\n\n输入:\n    3\n   / \\\n  9  20\n    /  \\\n   15   7\n输出: [3, 14.5, 11]\n解释:\n第0层的平均值是 3,  第1层是 14.5, 第2层是 11. 因此返回 [3, 14.5, 11].\n\n\n注意：\n\n 1. 节点值的范围在32位有符号整数范围内。\n\n# 通过代码\n/**\n * definition for a binary tree node.\n * public class treenode {\n *     int val;\n *     treenode left;\n *     treenode right;\n *     treenode(int x) { val = x; }\n * }\n */\nclass solution {\n    public list<double> averageoflevels(treenode root) {\n        if (null==root){\n                return null;\n            }\n            linkedlist<treenode> queue=new linkedlist<>();\n            queue.addlast(root);\n            linkedlist<double> list=new linkedlist<>();\n            while (!queue.isempty()){\n                int size=queue.size();\n                long total=0l;\n                for (int i = 0; i <size ; i++) {\n                    treenode node=queue.removefirst();\n                    if (node.left!=null)\n                        queue.addlast(node.left);\n                    if (node.right!=null)\n                        queue.addlast(node.right);\n                    total+=node.val;\n                }\n                list.addlast(1.0*total/size);\n            }\n            return list;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n# 官方题解\n# 方法一：深度优先搜索\n我们可以使用深度优先搜索遍历整颗二叉树。我们使用两个数组 sum 存放树中每一层的节点数值之和，以及 count 存放树中每一层的节点数量之和。在遍历时，我们需要额外记录当前节点所在的高度，并根据高度 h 更新数组元素 sum[h] 和 count[h]。在遍历结束之后，res = sum / cnt 即为答案。\n\n<,,,,,,,>\n\n/**\n * definition for a binary tree node.\n * public class treenode {\n *     int val;\n *     treenode left;\n *     treenode right;\n *     treenode(int x) { val = x; }\n * }\n */\npublic class solution {\n    public list < double > averageoflevels(treenode root) {\n        list < integer > count = new arraylist < > ();\n        list < double > res = new arraylist < > ();\n        average(root, 0, res, count);\n        for (int i = 0; i < res.size(); i++)\n            res.set(i, res.get(i) / count.get(i));\n        return res;\n    }\n    public void average(treenode t, int i, list < double > sum, list < integer > count) {\n        if (t == null)\n            return;\n        if (i < sum.size()) {\n            sum.set(i, sum.get(i) + t.val);\n            count.set(i, count.get(i) + 1);\n        } else {\n            sum.add(1.0 * t.val);\n            count.add(1);\n        }\n        average(t.left, i + 1, sum, count);\n        average(t.right, i + 1, sum, count);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n复杂度分析\n\n * 时间复杂度：o(n)o(n)o(n)，其中 nnn 是树中的节点个数。\n   \n   \n * 空间复杂度：o(h)o(h)o(h)，其中 hhh 是树的高度，即为深度优先搜索中使用递归占用的栈空间。\n   \n   \n\n# 方法二：广度优先搜索\n我们同样也可以使用广度优先搜索遍历整颗二叉树。首先我们将根节点放入队列 queue 中，随后对于 queue 中的每一个节点，我们将它的子节点放入临时队列 temp 中。在 queue 中的所有节点都处理完毕后，temp 中即存放了所有在 queue 对应的层数的下一层中的节点。在将子节点放入 temp 的过程中，我们也可以顺便计算出 queue 中节点的数值之和，以此得到平均值。最后我们将 temp 赋值给 queue，继续进行下一轮的广度优先搜索，直到某一轮 temp 为空。\n\n<,,,,,,,,,,,,,,,>\n\n/**\n * definition for a binary tree node.\n * public class treenode {\n *     int val;\n *     treenode left;\n *     treenode right;\n *     treenode(int x) { val = x; }\n * }\n */\npublic class solution {\n    public list < double > averageoflevels(treenode root) {\n        list < double > res = new arraylist < > ();\n        queue < treenode > queue = new linkedlist < > ();\n        queue.add(root);\n        while (!queue.isempty()) {\n            long sum = 0, count = 0;\n            queue < treenode > temp = new linkedlist < > ();\n            while (!queue.isempty()) {\n                treenode n = queue.remove();\n                sum += n.val;\n                count++;\n                if (n.left != null)\n                    temp.add(n.left);\n                if (n.right != null)\n                    temp.add(n.right);\n            }\n            queue = temp;\n            res.add(sum * 1.0 / count);\n        }\n        return res;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n复杂度分析\n\n * 时间复杂度：o(n)o(n)o(n)，其中 nnn 是树中的节点个数。\n   \n   \n * 空间复杂度：o(m)o(m)o(m)，其中 mmm 是树中每一层节点个数的最大值，即为广度优先搜索中使用队列存储同一层节点需要的空间。\n   \n   \n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-05-11 23:36:31accepted [https://leetcode-cn.com//submissions/detail/2189347/]8 ms6.38%n/ajava# 统计信息\n通过次数提交次数ac比率119591922062.2%# 相似题目\n题目难度二叉树的层次遍历 [https://leetcode-cn.com/problems/binary-tree-level-order-traversal/]中等二叉树的层次遍历 ii [https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/]简单"},{title:"724-寻找数组的中心索引(Find Pivot Index)",frontmatter:{title:"724-寻找数组的中心索引(Find Pivot Index)",date:"2020-01-03T00:00:00.000Z",categories:["简单"],tags:["数组<Array>"]},regularPath:"/views/%E7%AE%80%E5%8D%95/0724-%E5%AF%BB%E6%89%BE%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E5%BF%83%E7%B4%A2%E5%BC%95.html",relativePath:"views/简单/0724-寻找数组的中心索引.md",key:"v-21d82b43",path:"/views/%E7%AE%80%E5%8D%95/0724-%E5%AF%BB%E6%89%BE%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E5%BF%83%E7%B4%A2%E5%BC%95.html",headers:[{level:2,title:"中文题目",slug:"中文题目",charIndex:2},{level:2,title:"通过代码",slug:"通过代码",charIndex:422},{level:2,title:"官方题解",slug:"官方题解",charIndex:1543},{level:2,title:"提交历史",slug:"提交历史",charIndex:2393},{level:2,title:"统计信息",slug:"统计信息",charIndex:2732},{level:2,title:"相似题目",slug:"相似题目",charIndex:2766}],lastUpdated:"4/11/2021, 1:15:21 PM",headersStr:"中文题目 通过代码 官方题解 提交历史 统计信息 相似题目",content:"# 中文题目\n给定一个整数类型的数组nums，请编写一个能够返回数组“中心索引”的方法。\n\n我们是这样定义数组中心索引的：数组中心索引的左侧所有元素相加的和等于右侧所有元素相加的和。\n\n如果数组不存在中心索引，那么我们应该返回 -1。如果数组有多个中心索引，那么我们应该返回最靠近左边的那一个。\n\n示例 1:\n\n\n输入: \nnums = [1, 7, 3, 6, 5, 6]\n输出: 3\n解释: \n索引3 (nums[3] = 6) 的左侧数之和(1 + 7 + 3 = 11)，与右侧数之和(5 + 6 = 11)相等。\n同时, 3 也是第一个符合要求的中心索引。\n\n\n示例 2:\n\n\n输入: \nnums = [1, 2, 3]\n输出: -1\n解释: \n数组中不存在满足此条件的中心索引。\n\n说明:\n\n * nums 的长度范围为[0, 10000]。\n * 任何一个nums[i] 将会是一个范围在[-1000, 1000]的整数。\n\n# 通过代码\nclass Solution {\n    public int pivotIndex(int[] nums) {\n        long total = Arrays.stream(nums).summaryStatistics().getSum();\n        long leftTotal = 0;\n        long rightTotal;\n        for (int i = 0; i < nums.length; i++) {\n            rightTotal = total - (leftTotal + nums[i]);\n            if (leftTotal == rightTotal) {\n                return i;\n            }\n            leftTotal += nums[i];\n        }\n        return -1;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\nclass Solution {\n    public int pivotIndex(int[] nums) {\n        int[] newNums=new int[nums.length+1];\n        for (int i = 0; i < nums.length; i++) {\n            newNums[i+1]=nums[i];\n        }\n        long total = Arrays.stream(newNums).summaryStatistics().getSum();\n        long leftTotal = 0;\n        long rightTotal;\n        for (int i = 1; i < newNums.length; i++) {\n            leftTotal += newNums[i - 1];\n            rightTotal = total - (leftTotal + newNums[i]);\n            if (leftTotal == rightTotal) {\n                return i-1;\n            }\n        }\n        return -1;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n# 官方题解\n# 方法：前缀和\n算法：\n\n * S 是数组的和，当索引 i 是中心索引时，位于 i 左边数组元素的和 leftsum 满足 S - nums[i] - leftsum。\n * 我们只需要判断当前索引 i 是否满足 leftsum==S-nums[i]-leftsum 并动态计算 leftsum 的值。\n\nclass Solution(object):\n    def pivotIndex(self, nums):\n        S = sum(nums)\n        leftsum = 0\n        for i, x in enumerate(nums):\n            if leftsum == (S - leftsum - x):\n                return i\n            leftsum += x\n        return -1\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\nclass Solution {\n    public int pivotIndex(int[] nums) {\n        int sum = 0, leftsum = 0;\n        for (int x: nums) sum += x;\n        for (int i = 0; i < nums.length; ++i) {\n            if (leftsum == sum - leftsum - nums[i]) return i;\n            leftsum += nums[i];\n        }\n        return -1;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n复杂度分析\n\n * 时间复杂度：O(N)O(N)O(N)，其中 NNN 是 nums 的长度。\n * 空间复杂度：O(1)O(1)O(1)，使用了 S 和 leftsum 。\n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2020-01-03 22:08:20Accepted [https://leetcode-cn.com//submissions/detail/42192239/]11 ms28.48%41.5 MBjava2020-01-03 22:02:29Accepted [https://leetcode-cn.com//submissions/detail/42191670/]13 ms28.05%41.9 MBjava2020-01-03 21:43:17Wrong Answer [https://leetcode-cn.com//submissions/detail/42189649/]N/AN/AN/Ajava# 统计信息\n通过次数提交次数AC比率252027027435.9%# 相似题目\n题目难度和为K的子数组 [https://leetcode-cn.com/problems/subarray-sum-equals-k/]中等",contentLowercase:"# 中文题目\n给定一个整数类型的数组nums，请编写一个能够返回数组“中心索引”的方法。\n\n我们是这样定义数组中心索引的：数组中心索引的左侧所有元素相加的和等于右侧所有元素相加的和。\n\n如果数组不存在中心索引，那么我们应该返回 -1。如果数组有多个中心索引，那么我们应该返回最靠近左边的那一个。\n\n示例 1:\n\n\n输入: \nnums = [1, 7, 3, 6, 5, 6]\n输出: 3\n解释: \n索引3 (nums[3] = 6) 的左侧数之和(1 + 7 + 3 = 11)，与右侧数之和(5 + 6 = 11)相等。\n同时, 3 也是第一个符合要求的中心索引。\n\n\n示例 2:\n\n\n输入: \nnums = [1, 2, 3]\n输出: -1\n解释: \n数组中不存在满足此条件的中心索引。\n\n说明:\n\n * nums 的长度范围为[0, 10000]。\n * 任何一个nums[i] 将会是一个范围在[-1000, 1000]的整数。\n\n# 通过代码\nclass solution {\n    public int pivotindex(int[] nums) {\n        long total = arrays.stream(nums).summarystatistics().getsum();\n        long lefttotal = 0;\n        long righttotal;\n        for (int i = 0; i < nums.length; i++) {\n            righttotal = total - (lefttotal + nums[i]);\n            if (lefttotal == righttotal) {\n                return i;\n            }\n            lefttotal += nums[i];\n        }\n        return -1;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\nclass solution {\n    public int pivotindex(int[] nums) {\n        int[] newnums=new int[nums.length+1];\n        for (int i = 0; i < nums.length; i++) {\n            newnums[i+1]=nums[i];\n        }\n        long total = arrays.stream(newnums).summarystatistics().getsum();\n        long lefttotal = 0;\n        long righttotal;\n        for (int i = 1; i < newnums.length; i++) {\n            lefttotal += newnums[i - 1];\n            righttotal = total - (lefttotal + newnums[i]);\n            if (lefttotal == righttotal) {\n                return i-1;\n            }\n        }\n        return -1;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n# 官方题解\n# 方法：前缀和\n算法：\n\n * s 是数组的和，当索引 i 是中心索引时，位于 i 左边数组元素的和 leftsum 满足 s - nums[i] - leftsum。\n * 我们只需要判断当前索引 i 是否满足 leftsum==s-nums[i]-leftsum 并动态计算 leftsum 的值。\n\nclass solution(object):\n    def pivotindex(self, nums):\n        s = sum(nums)\n        leftsum = 0\n        for i, x in enumerate(nums):\n            if leftsum == (s - leftsum - x):\n                return i\n            leftsum += x\n        return -1\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\nclass solution {\n    public int pivotindex(int[] nums) {\n        int sum = 0, leftsum = 0;\n        for (int x: nums) sum += x;\n        for (int i = 0; i < nums.length; ++i) {\n            if (leftsum == sum - leftsum - nums[i]) return i;\n            leftsum += nums[i];\n        }\n        return -1;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n复杂度分析\n\n * 时间复杂度：o(n)o(n)o(n)，其中 nnn 是 nums 的长度。\n * 空间复杂度：o(1)o(1)o(1)，使用了 s 和 leftsum 。\n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2020-01-03 22:08:20accepted [https://leetcode-cn.com//submissions/detail/42192239/]11 ms28.48%41.5 mbjava2020-01-03 22:02:29accepted [https://leetcode-cn.com//submissions/detail/42191670/]13 ms28.05%41.9 mbjava2020-01-03 21:43:17wrong answer [https://leetcode-cn.com//submissions/detail/42189649/]n/an/an/ajava# 统计信息\n通过次数提交次数ac比率252027027435.9%# 相似题目\n题目难度和为k的子数组 [https://leetcode-cn.com/problems/subarray-sum-equals-k/]中等"},{title:"728-自除数(Self Dividing Numbers)",frontmatter:{title:"728-自除数(Self Dividing Numbers)",date:"2018-12-16T00:00:00.000Z",categories:["简单"],tags:["数学<Math>"]},regularPath:"/views/%E7%AE%80%E5%8D%95/0728-%E8%87%AA%E9%99%A4%E6%95%B0.html",relativePath:"views/简单/0728-自除数.md",key:"v-2fc6e32b",path:"/views/%E7%AE%80%E5%8D%95/0728-%E8%87%AA%E9%99%A4%E6%95%B0.html",headers:[{level:2,title:"中文题目",slug:"中文题目",charIndex:2},{level:2,title:"通过代码",slug:"通过代码",charIndex:287},{level:2,title:"官方题解",slug:"官方题解",charIndex:1200},{level:2,title:"提交历史",slug:"提交历史",charIndex:3150},{level:2,title:"统计信息",slug:"统计信息",charIndex:3283},{level:2,title:"相似题目",slug:"相似题目",charIndex:3317}],lastUpdated:"4/11/2021, 1:15:21 PM",headersStr:"中文题目 通过代码 官方题解 提交历史 统计信息 相似题目",content:"# 中文题目\n自除数是指可以被它包含的每一位数除尽的数。\n\n例如，128 是一个自除数，因为128 % 1 == 0，128 % 2 == 0，128 % 8 == 0。\n\n还有，自除数不允许包含 0 。\n\n给定上边界和下边界数字，输出一个列表，列表的元素是边界（含边界）内所有的自除数。\n\n示例 1：\n\n\n输入： \n上边界left = 1, 下边界right = 22\n输出： [1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 15, 22]\n\n\n注意：\n\n * 每个输入参数的边界满足1 <= left <= right <= 10000。\n\n# 通过代码\nclass Solution {\n    public List<Integer> selfDividingNumbers(int left, int right) {\n        LinkedList<Integer> res=new LinkedList<Integer>();\n            for (int i = left; i <=right ; i++) {\n                int temp=i;\n                if (i<9){\n                    res.addLast(i);\n                }\n                else {\n                    boolean flag=true;\n                    while (temp > 0){\n                        int a=temp%10;\n                        if (a==0||i%a!=0){\n                            flag=false;\n                            break;\n                        }else {\n                            temp /= 10;\n                        }\n                    }\n                    if (flag){\n                        res.addLast(i);\n                    }\n                }\n            }\n            return res;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n# 官方题解\n# 方法一：暴力法\n算法：\n\n * 对于给定范围内的每个数，我们将直接判断该数是否为自除数。\n * 根据定义，我们先判断数字是否非零，若数字非零再判断是否能够被该数除尽。例如，对于 128，我们要判断 d != 0 && 128 % d == 0，且 d = 1, 2, 8。\n * 解决这个问题的一个简单方法是将数字转换成一个字符数组（python 中的字符串），然后在检查 n%d==0 时转换回整数执行模运算。\n * 我们还可以不断地把数字除以 10，取整数的最后一个数字。在代码中为注释的部分。\n\nclass Solution(object):\n    def selfDividingNumbers(self, left, right):\n        def self_dividing(n):\n            for d in str(n):\n                if d == '0' or n % int(d) > 0:\n                    return False\n            return True\n        \"\"\"\n        Alternate implementation of self_dividing:\n        def self_dividing(n):\n            x = n\n            while x > 0:\n                x, d = divmod(x, 10)\n                if d == 0 or n % d > 0:\n                    return False\n            return True\n        \"\"\"\n        ans = []\n        for n in range(left, right + 1):\n            if self_dividing(n):\n                ans.append(n)\n        return ans #Equals filter(self_dividing, range(left, right+1))\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\nclass Solution {\n    public List<Integer> selfDividingNumbers(int left, int right) {\n        List<Integer> ans = new ArrayList();\n        for (int n = left; n <= right; ++n) {\n            if (selfDividing(n)) ans.add(n);\n        }\n        return ans;\n    }\n    public boolean selfDividing(int n) {\n        for (char c: String.valueOf(n).toCharArray()) {\n            if (c == '0' || (n % (c - '0') > 0))\n                return false;\n        }\n        return true;\n    }\n    /*\n    Alternate implementation of selfDividing:\n    public boolean selfDividing(int n) {\n        int x = n;\n        while (x > 0) {\n            int d = x % 10;\n            x /= 10;\n            if (d == 0 || (n % d) > 0) return false;\n        }\n        return true;\n    */\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n复杂度分析\n\n * 时间复杂度：O(D)O(D)O(D)。DDD 是在区间 [L,R][L, R][L,R] 里的整数数。\n * 空间复杂度：O(D)O(D)O(D)，使用了一个数组来存放结果。\n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-12-16 23:46:32Accepted [https://leetcode-cn.com//submissions/detail/10534428/]5 ms31.37%23.4 MBjava# 统计信息\n通过次数提交次数AC比率164792291271.9%# 相似题目\n题目难度完美数 [https://leetcode-cn.com/problems/perfect-number/]简单",contentLowercase:"# 中文题目\n自除数是指可以被它包含的每一位数除尽的数。\n\n例如，128 是一个自除数，因为128 % 1 == 0，128 % 2 == 0，128 % 8 == 0。\n\n还有，自除数不允许包含 0 。\n\n给定上边界和下边界数字，输出一个列表，列表的元素是边界（含边界）内所有的自除数。\n\n示例 1：\n\n\n输入： \n上边界left = 1, 下边界right = 22\n输出： [1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 15, 22]\n\n\n注意：\n\n * 每个输入参数的边界满足1 <= left <= right <= 10000。\n\n# 通过代码\nclass solution {\n    public list<integer> selfdividingnumbers(int left, int right) {\n        linkedlist<integer> res=new linkedlist<integer>();\n            for (int i = left; i <=right ; i++) {\n                int temp=i;\n                if (i<9){\n                    res.addlast(i);\n                }\n                else {\n                    boolean flag=true;\n                    while (temp > 0){\n                        int a=temp%10;\n                        if (a==0||i%a!=0){\n                            flag=false;\n                            break;\n                        }else {\n                            temp /= 10;\n                        }\n                    }\n                    if (flag){\n                        res.addlast(i);\n                    }\n                }\n            }\n            return res;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n# 官方题解\n# 方法一：暴力法\n算法：\n\n * 对于给定范围内的每个数，我们将直接判断该数是否为自除数。\n * 根据定义，我们先判断数字是否非零，若数字非零再判断是否能够被该数除尽。例如，对于 128，我们要判断 d != 0 && 128 % d == 0，且 d = 1, 2, 8。\n * 解决这个问题的一个简单方法是将数字转换成一个字符数组（python 中的字符串），然后在检查 n%d==0 时转换回整数执行模运算。\n * 我们还可以不断地把数字除以 10，取整数的最后一个数字。在代码中为注释的部分。\n\nclass solution(object):\n    def selfdividingnumbers(self, left, right):\n        def self_dividing(n):\n            for d in str(n):\n                if d == '0' or n % int(d) > 0:\n                    return false\n            return true\n        \"\"\"\n        alternate implementation of self_dividing:\n        def self_dividing(n):\n            x = n\n            while x > 0:\n                x, d = divmod(x, 10)\n                if d == 0 or n % d > 0:\n                    return false\n            return true\n        \"\"\"\n        ans = []\n        for n in range(left, right + 1):\n            if self_dividing(n):\n                ans.append(n)\n        return ans #equals filter(self_dividing, range(left, right+1))\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\nclass solution {\n    public list<integer> selfdividingnumbers(int left, int right) {\n        list<integer> ans = new arraylist();\n        for (int n = left; n <= right; ++n) {\n            if (selfdividing(n)) ans.add(n);\n        }\n        return ans;\n    }\n    public boolean selfdividing(int n) {\n        for (char c: string.valueof(n).tochararray()) {\n            if (c == '0' || (n % (c - '0') > 0))\n                return false;\n        }\n        return true;\n    }\n    /*\n    alternate implementation of selfdividing:\n    public boolean selfdividing(int n) {\n        int x = n;\n        while (x > 0) {\n            int d = x % 10;\n            x /= 10;\n            if (d == 0 || (n % d) > 0) return false;\n        }\n        return true;\n    */\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n复杂度分析\n\n * 时间复杂度：o(d)o(d)o(d)。ddd 是在区间 [l,r][l, r][l,r] 里的整数数。\n * 空间复杂度：o(d)o(d)o(d)，使用了一个数组来存放结果。\n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-12-16 23:46:32accepted [https://leetcode-cn.com//submissions/detail/10534428/]5 ms31.37%23.4 mbjava# 统计信息\n通过次数提交次数ac比率164792291271.9%# 相似题目\n题目难度完美数 [https://leetcode-cn.com/problems/perfect-number/]简单"},{title:"704-二分查找(Binary Search)",frontmatter:{title:"704-二分查找(Binary Search)",date:"2021-05-23T00:00:00.000Z",categories:["简单"],tags:["二分查找<Binary Search>"]},regularPath:"/views/%E7%AE%80%E5%8D%95/0704-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.html",relativePath:"views/简单/0704-二分查找.md",key:"v-22e5cd39",path:"/views/%E7%AE%80%E5%8D%95/0704-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.html",headers:[{level:2,title:"中文题目",slug:"中文题目",charIndex:2},{level:2,title:"通过代码",slug:"通过代码",charIndex:337},{level:2,title:"官方题解",slug:"官方题解",charIndex:944},{level:2,title:"提交历史",slug:"提交历史",charIndex:2677},{level:2,title:"统计信息",slug:"统计信息",charIndex:2818},{level:2,title:"相似题目",slug:"相似题目",charIndex:2854}],headersStr:"中文题目 通过代码 官方题解 提交历史 统计信息 相似题目",content:"# 中文题目\n给定一个n个元素有序的（升序）整型数组nums 和一个目标值target ，写一个函数搜索nums中的 target，如果目标值存在返回下标，否则返回 -1。\n\n\n示例 1:\n\n输入: nums = [-1,0,3,5,9,12], target = 9\n输出: 4\n解释: 9 出现在 nums 中并且下标为 4\n\n\n示例 2:\n\n输入: nums = [-1,0,3,5,9,12], target = 2\n输出: -1\n解释: 2 不存在 nums 中因此返回 -1\n\n\n\n\n提示：\n\n 1. 你可以假设 nums中的所有元素是不重复的。\n 2. n将在[1, 10000]之间。\n 3. nums的每个元素都将在[-9999, 9999]之间。\n\n# 通过代码\n    class Solution {\n        public int search(int[] nums, int target) {\n            int left = 0, right = nums.length - 1, mid;\n            while (left <= right) {\n                mid = left + (right - left) / 2;\n                if (nums[mid] == target) {\n                    return mid;\n                }\n                if (nums[mid] < target) {\n                    left = mid + 1;\n                }\n                if (nums[mid] > target) {\n                    right = mid - 1;\n                }\n            }\n            return -1;\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n# 官方题解\n# 方法：二分查找\n二分查找是一种基于比较目标值和数组中间元素的教科书式算法。\n\n * 如果目标值等于中间元素，则找到目标值。\n * 如果目标值较小，继续在左侧搜索。\n * 如果目标值较大，则继续在右侧搜索。\n\n{:width=400} {:align=center}\n\n算法：\n\n * 初始化指针 left = 0, right = n - 1。\n * 当 left <= right： * 比较中间元素 nums[pivot] 和目标值 target 。 * 如果 target = nums[pivot]，返回 pivot。\n       * 如果 target < nums[pivot]，则在左侧继续搜索 right = pivot - 1。\n       * 如果 target > nums[pivot]，则在右侧继续搜索 left = pivot + 1。\n      \n      \n   \n   \n\n{:width=400} {:align=center}\n\n{:width=400} {:align=center}\n\nclass Solution:\n    def search(self, nums: List[int], target: int) -> int:\n        left, right = 0, len(nums) - 1\n        while left <= right:\n            pivot = left + (right - left) // 2\n            if nums[pivot] == target:\n                return pivot\n            if target < nums[pivot]:\n                right = pivot - 1\n            else:\n                left = pivot + 1\n        return -1\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\nclass Solution {\n  public int search(int[] nums, int target) {\n    int pivot, left = 0, right = nums.length - 1;\n    while (left <= right) {\n      pivot = left + (right - left) / 2;\n      if (nums[pivot] == target) return pivot;\n      if (target < nums[pivot]) right = pivot - 1;\n      else left = pivot + 1;\n    }\n    return -1;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\nclass Solution {\n  public:\n  int search(vector<int>& nums, int target) {\n    int pivot, left = 0, right = nums.size() - 1;\n    while (left <= right) {\n      pivot = left + (right - left) / 2;\n      if (nums[pivot] == target) return pivot;\n      if (target < nums[pivot]) right = pivot - 1;\n      else left = pivot + 1;\n    }\n    return -1;\n  }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n复杂度分析\n\n * 时间复杂度：O(log⁡N)\\mathcal{O}(\\log N)O(logN)。\n * 空间复杂度：O(1)\\mathcal{O}(1)O(1)。\n\n# 提交历史\n提交时间提交结果标记状态我的注释执行时间战胜比例内存消耗语言2021-05-23 18:39:50Accepted [https://leetcode-cn.com/submissions/detail/180143498/]0 ms100.0%39.5 MBjava# 统计信息\n通过次数提交次数AC比率12541022247256.4%# 相似题目\n题目难度搜索长度未知的有序数组 [https://leetcode-cn.com/problems/search-in-a-sorted-array-of-unknown-size/]中等",contentLowercase:"# 中文题目\n给定一个n个元素有序的（升序）整型数组nums 和一个目标值target ，写一个函数搜索nums中的 target，如果目标值存在返回下标，否则返回 -1。\n\n\n示例 1:\n\n输入: nums = [-1,0,3,5,9,12], target = 9\n输出: 4\n解释: 9 出现在 nums 中并且下标为 4\n\n\n示例 2:\n\n输入: nums = [-1,0,3,5,9,12], target = 2\n输出: -1\n解释: 2 不存在 nums 中因此返回 -1\n\n\n\n\n提示：\n\n 1. 你可以假设 nums中的所有元素是不重复的。\n 2. n将在[1, 10000]之间。\n 3. nums的每个元素都将在[-9999, 9999]之间。\n\n# 通过代码\n    class solution {\n        public int search(int[] nums, int target) {\n            int left = 0, right = nums.length - 1, mid;\n            while (left <= right) {\n                mid = left + (right - left) / 2;\n                if (nums[mid] == target) {\n                    return mid;\n                }\n                if (nums[mid] < target) {\n                    left = mid + 1;\n                }\n                if (nums[mid] > target) {\n                    right = mid - 1;\n                }\n            }\n            return -1;\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n# 官方题解\n# 方法：二分查找\n二分查找是一种基于比较目标值和数组中间元素的教科书式算法。\n\n * 如果目标值等于中间元素，则找到目标值。\n * 如果目标值较小，继续在左侧搜索。\n * 如果目标值较大，则继续在右侧搜索。\n\n{:width=400} {:align=center}\n\n算法：\n\n * 初始化指针 left = 0, right = n - 1。\n * 当 left <= right： * 比较中间元素 nums[pivot] 和目标值 target 。 * 如果 target = nums[pivot]，返回 pivot。\n       * 如果 target < nums[pivot]，则在左侧继续搜索 right = pivot - 1。\n       * 如果 target > nums[pivot]，则在右侧继续搜索 left = pivot + 1。\n      \n      \n   \n   \n\n{:width=400} {:align=center}\n\n{:width=400} {:align=center}\n\nclass solution:\n    def search(self, nums: list[int], target: int) -> int:\n        left, right = 0, len(nums) - 1\n        while left <= right:\n            pivot = left + (right - left) // 2\n            if nums[pivot] == target:\n                return pivot\n            if target < nums[pivot]:\n                right = pivot - 1\n            else:\n                left = pivot + 1\n        return -1\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\nclass solution {\n  public int search(int[] nums, int target) {\n    int pivot, left = 0, right = nums.length - 1;\n    while (left <= right) {\n      pivot = left + (right - left) / 2;\n      if (nums[pivot] == target) return pivot;\n      if (target < nums[pivot]) right = pivot - 1;\n      else left = pivot + 1;\n    }\n    return -1;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\nclass solution {\n  public:\n  int search(vector<int>& nums, int target) {\n    int pivot, left = 0, right = nums.size() - 1;\n    while (left <= right) {\n      pivot = left + (right - left) / 2;\n      if (nums[pivot] == target) return pivot;\n      if (target < nums[pivot]) right = pivot - 1;\n      else left = pivot + 1;\n    }\n    return -1;\n  }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n复杂度分析\n\n * 时间复杂度：o(log⁡n)\\mathcal{o}(\\log n)o(logn)。\n * 空间复杂度：o(1)\\mathcal{o}(1)o(1)。\n\n# 提交历史\n提交时间提交结果标记状态我的注释执行时间战胜比例内存消耗语言2021-05-23 18:39:50accepted [https://leetcode-cn.com/submissions/detail/180143498/]0 ms100.0%39.5 mbjava# 统计信息\n通过次数提交次数ac比率12541022247256.4%# 相似题目\n题目难度搜索长度未知的有序数组 [https://leetcode-cn.com/problems/search-in-a-sorted-array-of-unknown-size/]中等"},{title:"746-使用最小花费爬楼梯(Min Cost Climbing Stairs)",frontmatter:{title:"746-使用最小花费爬楼梯(Min Cost Climbing Stairs)",date:"2018-05-07T00:00:00.000Z",categories:["简单"],tags:["数组<Array>","动态规划<Dynamic Programming>"]},regularPath:"/views/%E7%AE%80%E5%8D%95/0746-%E4%BD%BF%E7%94%A8%E6%9C%80%E5%B0%8F%E8%8A%B1%E8%B4%B9%E7%88%AC%E6%A5%BC%E6%A2%AF.html",relativePath:"views/简单/0746-使用最小花费爬楼梯.md",key:"v-4f4bf9f6",path:"/views/%E7%AE%80%E5%8D%95/0746-%E4%BD%BF%E7%94%A8%E6%9C%80%E5%B0%8F%E8%8A%B1%E8%B4%B9%E7%88%AC%E6%A5%BC%E6%A2%AF.html",headers:[{level:2,title:"中文题目",slug:"中文题目",charIndex:2},{level:2,title:"通过代码",slug:"通过代码",charIndex:423},{level:2,title:"官方题解",slug:"官方题解",charIndex:1203},{level:2,title:"提交历史",slug:"提交历史",charIndex:2058},{level:2,title:"统计信息",slug:"统计信息",charIndex:2684},{level:2,title:"相似题目",slug:"相似题目",charIndex:2718}],lastUpdated:"4/11/2021, 1:15:21 PM",headersStr:"中文题目 通过代码 官方题解 提交历史 统计信息 相似题目",content:"# 中文题目\n数组的每个索引做为一个阶梯，第i个阶梯对应着一个非负数的体力花费值cost[i](索引从0开始)。\n\n每当你爬上一个阶梯你都要花费对应的体力花费值，然后你可以选择继续爬一个阶梯或者爬两个阶梯。\n\n您需要找到达到楼层顶部的最低花费。在开始时，你可以选择从索引为 0 或 1 的元素作为初始阶梯。\n\n示例 1:\n\n\n输入: cost = [10, 15, 20]\n输出: 15\n解释: 最低花费是从cost[1]开始，然后走两步即可到阶梯顶，一共花费15。\n\n\n示例 2:\n\n\n输入: cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]\n输出: 6\n解释: 最低花费方式是从cost[0]开始，逐个经过那些1，跳过cost[3]，一共花费6。\n\n\n注意：\n\n 1. cost的长度将会在[2, 1000]。\n 2. 每一个cost[i] 将会是一个Integer类型，范围为[0, 999]。\n\n# 通过代码\nclass Solution {\n   public int minCostClimbingStairs(int[] cost) {\n            for(int i = 2; i < cost.length; i++)\n            {\n                cost[i] = cost[i] + Math.min(cost[i-2], cost[i-1]);\n            }\n\n            return Math.min(cost[cost.length-1], cost[cost.length - 2]);\n        }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\nclass Solution {\n    public int minCostClimbingStairs(int[] cost) {\n         int[] mincost=new int[cost.length+1];\n            mincost[0]=cost[0];\n            mincost[1]=cost[1];\n            for (int i = 2; i <=cost.length ; i++) {\n                int costNow=(i==cost.length)?0:cost[i];\n                mincost[i]=Math.min(mincost[i-1]+costNow,mincost[i-2]+costNow);\n            }\n            return mincost[cost.length];\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n# 官方题解\n# 方法：动态规划\n计算花费 f[i] 有一个清楚的递归关系：f[i] = cost[i] + min(f[i+1], f[i+2])。我们可以使用动态规划来实现。\n\n算法：\n\n * 当我们要计算 f[i] 时，要先计算出 f[i+1] 和 f[i+2]。所以我们应该从后往前计算 f。\n * 在第 i 步，让 f1，f2 为 f[i+1]，f[i+2] 的旧值，并将其更新为f[i]，f[i+1] 的新值。当我们从后遍历 i 时，我们会保持这些更新。在最后答案是 min(f1, f2)。\n\nclass Solution(object):\n    def minCostClimbingStairs(self, cost):\n        f1 = f2 = 0\n        for x in reversed(cost):\n            f1, f2 = x + min(f1, f2), f1\n        return min(f1, f2)\n\n\n1\n2\n3\n4\n5\n6\nclass Solution {\n    public int minCostClimbingStairs(int[] cost) {\n        int f1 = 0, f2 = 0;\n        for (int i = cost.length - 1; i >= 0; --i) {\n            int f0 = cost[i] + Math.min(f1, f2);\n            f2 = f1;\n            f1 = f0;\n        }\n        return Math.min(f1, f2);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n复杂度分析\n\n * 时间复杂度：O(N)O(N)O(N)。NNN 指的是 cost 的长度\n * 空间复杂度：O(1)O(1)O(1)，只使用了 f1, f2。\n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-05-07 23:29:10Accepted [https://leetcode-cn.com//submissions/detail/2059396/]13 ms15.71%N/Ajava2018-05-07 23:13:39Accepted [https://leetcode-cn.com//submissions/detail/2058887/]19 ms15.71%N/Ajava2018-05-07 23:12:38Wrong Answer [https://leetcode-cn.com//submissions/detail/2058858/]N/AN/AN/Ajava2018-05-07 23:09:01Wrong Answer [https://leetcode-cn.com//submissions/detail/2058733/]N/AN/AN/Ajava2018-05-07 23:07:07Wrong Answer [https://leetcode-cn.com//submissions/detail/2058662/]N/AN/AN/Ajava2018-05-07 23:05:06Runtime Error [https://leetcode-cn.com//submissions/detail/2058594/]N/AN/AN/Ajava# 统计信息\n通过次数提交次数AC比率208614521346.1%# 相似题目\n题目难度爬楼梯 [https://leetcode-cn.com/problems/climbing-stairs/]简单",contentLowercase:"# 中文题目\n数组的每个索引做为一个阶梯，第i个阶梯对应着一个非负数的体力花费值cost[i](索引从0开始)。\n\n每当你爬上一个阶梯你都要花费对应的体力花费值，然后你可以选择继续爬一个阶梯或者爬两个阶梯。\n\n您需要找到达到楼层顶部的最低花费。在开始时，你可以选择从索引为 0 或 1 的元素作为初始阶梯。\n\n示例 1:\n\n\n输入: cost = [10, 15, 20]\n输出: 15\n解释: 最低花费是从cost[1]开始，然后走两步即可到阶梯顶，一共花费15。\n\n\n示例 2:\n\n\n输入: cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]\n输出: 6\n解释: 最低花费方式是从cost[0]开始，逐个经过那些1，跳过cost[3]，一共花费6。\n\n\n注意：\n\n 1. cost的长度将会在[2, 1000]。\n 2. 每一个cost[i] 将会是一个integer类型，范围为[0, 999]。\n\n# 通过代码\nclass solution {\n   public int mincostclimbingstairs(int[] cost) {\n            for(int i = 2; i < cost.length; i++)\n            {\n                cost[i] = cost[i] + math.min(cost[i-2], cost[i-1]);\n            }\n\n            return math.min(cost[cost.length-1], cost[cost.length - 2]);\n        }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\nclass solution {\n    public int mincostclimbingstairs(int[] cost) {\n         int[] mincost=new int[cost.length+1];\n            mincost[0]=cost[0];\n            mincost[1]=cost[1];\n            for (int i = 2; i <=cost.length ; i++) {\n                int costnow=(i==cost.length)?0:cost[i];\n                mincost[i]=math.min(mincost[i-1]+costnow,mincost[i-2]+costnow);\n            }\n            return mincost[cost.length];\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n# 官方题解\n# 方法：动态规划\n计算花费 f[i] 有一个清楚的递归关系：f[i] = cost[i] + min(f[i+1], f[i+2])。我们可以使用动态规划来实现。\n\n算法：\n\n * 当我们要计算 f[i] 时，要先计算出 f[i+1] 和 f[i+2]。所以我们应该从后往前计算 f。\n * 在第 i 步，让 f1，f2 为 f[i+1]，f[i+2] 的旧值，并将其更新为f[i]，f[i+1] 的新值。当我们从后遍历 i 时，我们会保持这些更新。在最后答案是 min(f1, f2)。\n\nclass solution(object):\n    def mincostclimbingstairs(self, cost):\n        f1 = f2 = 0\n        for x in reversed(cost):\n            f1, f2 = x + min(f1, f2), f1\n        return min(f1, f2)\n\n\n1\n2\n3\n4\n5\n6\nclass solution {\n    public int mincostclimbingstairs(int[] cost) {\n        int f1 = 0, f2 = 0;\n        for (int i = cost.length - 1; i >= 0; --i) {\n            int f0 = cost[i] + math.min(f1, f2);\n            f2 = f1;\n            f1 = f0;\n        }\n        return math.min(f1, f2);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n复杂度分析\n\n * 时间复杂度：o(n)o(n)o(n)。nnn 指的是 cost 的长度\n * 空间复杂度：o(1)o(1)o(1)，只使用了 f1, f2。\n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-05-07 23:29:10accepted [https://leetcode-cn.com//submissions/detail/2059396/]13 ms15.71%n/ajava2018-05-07 23:13:39accepted [https://leetcode-cn.com//submissions/detail/2058887/]19 ms15.71%n/ajava2018-05-07 23:12:38wrong answer [https://leetcode-cn.com//submissions/detail/2058858/]n/an/an/ajava2018-05-07 23:09:01wrong answer [https://leetcode-cn.com//submissions/detail/2058733/]n/an/an/ajava2018-05-07 23:07:07wrong answer [https://leetcode-cn.com//submissions/detail/2058662/]n/an/an/ajava2018-05-07 23:05:06runtime error [https://leetcode-cn.com//submissions/detail/2058594/]n/an/an/ajava# 统计信息\n通过次数提交次数ac比率208614521346.1%# 相似题目\n题目难度爬楼梯 [https://leetcode-cn.com/problems/climbing-stairs/]简单"},{title:"496-下一个更大元素 I(Next Greater Element I)",frontmatter:{title:"496-下一个更大元素 I(Next Greater Element I)",date:"2021-04-28T00:00:00.000Z",categories:["简单"],tags:["栈<Stack>"]},regularPath:"/views/%E7%AE%80%E5%8D%95/0496-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0%20I.html",relativePath:"views/简单/0496-下一个更大元素 I.md",key:"v-c9f395f0",path:"/views/%E7%AE%80%E5%8D%95/0496-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0%20I.html",headers:[{level:2,title:"中文题目",slug:"中文题目",charIndex:2},{level:2,title:"通过代码",slug:"通过代码",charIndex:650},{level:2,title:"我的笔记",slug:"我的笔记",charIndex:2225},{level:2,title:"官方题解",slug:"官方题解",charIndex:2239},{level:2,title:"提交历史",slug:"提交历史",charIndex:5241},{level:2,title:"统计信息",slug:"统计信息",charIndex:5482},{level:2,title:"相似题目",slug:"相似题目",charIndex:5517}],headersStr:"中文题目 通过代码 我的笔记 官方题解 提交历史 统计信息 相似题目",content:"# 中文题目\n给你两个 没有重复元素 的数组nums1 和nums2，其中nums1是nums2的子集。\n\n请你找出 nums1中每个元素在nums2中的下一个比其大的值。\n\nnums1中数字x的下一个更大元素是指x在nums2中对应位置的右边的第一个比x大的元素。如果不存在，对应位置输出 -1 。\n\n\n\n示例 1:\n\n\n输入: nums1 = [4,1,2], nums2 = [1,3,4,2].\n输出: [-1,3,-1]\n解释:\n    对于 num1 中的数字 4 ，你无法在第二个数组中找到下一个更大的数字，因此输出 -1 。\n    对于 num1 中的数字 1 ，第二个数组中数字1右边的下一个较大数字是 3 。\n    对于 num1 中的数字 2 ，第二个数组中没有下一个更大的数字，因此输出 -1 。\n\n示例 2:\n\n\n输入: nums1 = [2,4], nums2 = [1,2,3,4].\n输出: [3,-1]\n解释:\n    对于 num1 中的数字 2 ，第二个数组中的下一个较大数字是 3 。\n    对于 num1 中的数字 4 ，第二个数组中没有下一个更大的数字，因此输出 -1 。\n\n\n\n\n提示：\n\n * 1 \n * 0 4\n * nums1和nums2中所有整数 互不相同\n * nums1 中的所有整数同样出现在 nums2 中\n\n\n\n进阶：你可以设计一个时间复杂度为 O(nums1.length + nums2.length) 的解决方案吗？\n\n# 通过代码\n    class Solution {\n        public int[] nextGreaterElement(int[] nums1, int[] nums2) {\n            Map<Integer,Integer> map=new HashMap<>(nums2.length);\n            for (int i = 0; i < nums2.length; i++) {\n                for (Integer key:map.keySet()) {\n                    if (nums2[i]>key && map.get(key)==-1){\n                        map.put(key,nums2[i]);\n                    }\n                }\n                map.put(nums2[i],-1);\n            }\n            int[] res=new int[nums1.length];\n            for (int i = 0; i < nums1.length; i++) {\n                res[i]=map.get(nums1[i]);\n            }\n            return res;\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n    class Solution {\n        public int[] nextGreaterElement(int[] nums1, int[] nums2) {\n            Stack<Integer> stack=new Stack<>();\n            for (int i = nums2.length-1; i >=0 ; i--) {\n                stack.push(nums2[i]);\n            }\n            Map<Integer,Integer> map=new HashMap<>(nums2.length);\n            while (!stack.isEmpty()){\n                Integer i = stack.pop();\n                for (Integer key:map.keySet()) {\n                    if (i>key && map.get(key)==-1){\n                        map.put(key,i);\n                    }\n                }\n                map.put(i,-1);\n            }\n            int[] res=new int[nums1.length];\n            for (int i = 0; i < nums1.length; i++) {\n                res[i]=map.get(nums1[i]);\n            }\n            return res;\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n# 我的笔记\n采用单调栈\n\n# 官方题解\n# 方法一：暴力解法\n题目中的关键信息：两个数组各自 没有重复元素。模拟题目的意思：对于每一个 nums1[i] 中的元素，先在 nums2 中找到它，然后向右遍历找到第 1 个大于 nums1[i] 的元素。\n\n参考代码 1：\n\nimport java.util.Arrays;\n\npublic class Solution {\n\n    public int[] nextGreaterElement(int[] nums1, int[] nums2) {\n        int len1 = nums1.length;\n        int len2 = nums2.length;\n\n        int[] res = new int[len1];\n        if (len1 < 1) {\n            return res;\n        }\n\n        for (int i = 0; i < len1; i++) {\n            int curVal = nums1[i];\n            int j = 0;\n            while (j < len2 && nums2[j] != curVal) {\n                j++;\n            }\n\n            // 此时 nums[j] = nums[i]\n            j++;\n            while (j < len2 && nums2[j] < curVal) {\n                j++;\n            }\n\n            if (j == len2) {\n                res[i] = -1;\n                continue;\n            }\n            res[i] = nums2[j];\n        }\n        return res;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n复杂度分析：\n\n * 时间复杂度：O(NM)O(NM)O(NM)，这里 NNN 是数组 nums1 的长度， MMM 是数组 nums2 的长度，对于 NNN 个 nums1 中的元素，最差情况下需要遍历完 nums2 中的每个元素，因此时间复杂度为 O(NM)O(NM)O(NM)；\n * 空间复杂度： * 如果不计算保存结果的空间，空间复杂度为 O(1)O(1)O(1)；\n    * 如果计算保存结果的空间，空间复杂度为 O(N)O(N)O(N)。\n   \n   \n\n「暴力解法」时间复杂度高 ，空间复杂度低，优化「暴力解法」的思路是「空间换时间」。事实上，找右边第 1 个大于比自己大的数，这是一个典型的「栈」的应用（也叫「单调栈」），将每一个元素进栈一次、出栈一次，这样的过程中就可以找到找右边第 1 个大于比自己大的数。\n\n\n\n\n# 方法二：栈（单调栈）\n根据题意，数组 nums1 视为询问。我们可以：\n\n * 先对 nums2 中的每一个元素，求出它的右边第一个更大的元素；\n * 将上一步的对应关系放入哈希表（HashMap）中；\n * 再遍历数组 nums1，根据哈希表找出答案。\n\n下面我们解释如何得到 nums2 的每个元素右边第 1 个比它大的元素，这里以 nums2 = [2, 3, 5, 1, 0, 7, 3] 为例进行说明，我们从左到右遍历数组 nums2 中的元素。\n\n友情提示：只需要看文字和图例的前几句话，找到解决问题的一帮规律，这样可以节约阅读时间。\n\n<,,,,,,,,>\n\n归纳重点：\n\n * 可以发现，我们维护的栈恰好保证了单调性：栈中的元素从栈顶到栈底是单调不降的。当我们遇到一个新的元素 nums2[i] 时，我们判断栈顶元素是否小于 nums2[i]，如果是，那么栈顶元素的下一个更大元素即为 nums2[i]，我们将栈顶元素出栈。重复这一操作，直到栈为空或者栈顶元素大于 nums2[i]。此时我们将 nums2[i] 入栈，保持栈的单调性，并对接下来的 nums2[i + 1], nums2[i + 2] ... 执行同样的操作。\n\n参考代码 2：\n\nimport java.util.ArrayDeque;\nimport java.util.Arrays;\nimport java.util.Deque;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Stack;\n\npublic class Solution {\n\n    public int[] nextGreaterElement(int[] nums1, int[] nums2) {\n        int len1 = nums1.length;\n        int len2 = nums2.length;\n\n        Deque<Integer> stack = new ArrayDeque<>();\n        Map<Integer, Integer> map = new HashMap<>();\n        // 先处理 nums2，把对应关系存入哈希表\n        for (int i = 0; i < len2; i++) {\n            while (!stack.isEmpty() && stack.peekLast() < nums2[i]) {\n                map.put(stack.removeLast(), nums2[i]);\n            }\n            stack.addLast(nums2[i]);\n        }\n\n        // 遍历 nums1 得到结果集\n        int[] res = new int[len1];\n        for (int i = 0; i < len1; i++) {\n            res[i] = map.getOrDefault(nums1[i], -1);\n        }\n        return res;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n复杂度分析：\n\n * 时间复杂度：O(N+M)O(N + M)O(N+M)，分别遍历数组 nums1 和数组 nums2 各一次即可，对于 nums2 中的每个元素，进栈一次，出栈一次；\n * 空间复杂度：O(N)O(N)O(N)。我们在遍历 nums2 时，需要使用栈，以及哈希映射用来临时存储答案。\n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2021-04-28 22:09:16Accepted [https://leetcode-cn.com//submissions/detail/173007801/]88 ms100.0%38.7 MBjava2021-04-28 21:53:20Accepted [https://leetcode-cn.com//submissions/detail/173001659/]79 ms100.0%38.7 MBjava# 统计信息\n通过次数提交次数AC比率7663911311967.8%# 相似题目\n题目难度下一个更大元素 II [https://leetcode-cn.com/problems/next-greater-element-ii/]中等下一个更大元素 III [https://leetcode-cn.com/problems/next-greater-element-iii/]中等每日温度 [https://leetcode-cn.com/problems/daily-temperatures/]中等",contentLowercase:"# 中文题目\n给你两个 没有重复元素 的数组nums1 和nums2，其中nums1是nums2的子集。\n\n请你找出 nums1中每个元素在nums2中的下一个比其大的值。\n\nnums1中数字x的下一个更大元素是指x在nums2中对应位置的右边的第一个比x大的元素。如果不存在，对应位置输出 -1 。\n\n\n\n示例 1:\n\n\n输入: nums1 = [4,1,2], nums2 = [1,3,4,2].\n输出: [-1,3,-1]\n解释:\n    对于 num1 中的数字 4 ，你无法在第二个数组中找到下一个更大的数字，因此输出 -1 。\n    对于 num1 中的数字 1 ，第二个数组中数字1右边的下一个较大数字是 3 。\n    对于 num1 中的数字 2 ，第二个数组中没有下一个更大的数字，因此输出 -1 。\n\n示例 2:\n\n\n输入: nums1 = [2,4], nums2 = [1,2,3,4].\n输出: [3,-1]\n解释:\n    对于 num1 中的数字 2 ，第二个数组中的下一个较大数字是 3 。\n    对于 num1 中的数字 4 ，第二个数组中没有下一个更大的数字，因此输出 -1 。\n\n\n\n\n提示：\n\n * 1 \n * 0 4\n * nums1和nums2中所有整数 互不相同\n * nums1 中的所有整数同样出现在 nums2 中\n\n\n\n进阶：你可以设计一个时间复杂度为 o(nums1.length + nums2.length) 的解决方案吗？\n\n# 通过代码\n    class solution {\n        public int[] nextgreaterelement(int[] nums1, int[] nums2) {\n            map<integer,integer> map=new hashmap<>(nums2.length);\n            for (int i = 0; i < nums2.length; i++) {\n                for (integer key:map.keyset()) {\n                    if (nums2[i]>key && map.get(key)==-1){\n                        map.put(key,nums2[i]);\n                    }\n                }\n                map.put(nums2[i],-1);\n            }\n            int[] res=new int[nums1.length];\n            for (int i = 0; i < nums1.length; i++) {\n                res[i]=map.get(nums1[i]);\n            }\n            return res;\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n    class solution {\n        public int[] nextgreaterelement(int[] nums1, int[] nums2) {\n            stack<integer> stack=new stack<>();\n            for (int i = nums2.length-1; i >=0 ; i--) {\n                stack.push(nums2[i]);\n            }\n            map<integer,integer> map=new hashmap<>(nums2.length);\n            while (!stack.isempty()){\n                integer i = stack.pop();\n                for (integer key:map.keyset()) {\n                    if (i>key && map.get(key)==-1){\n                        map.put(key,i);\n                    }\n                }\n                map.put(i,-1);\n            }\n            int[] res=new int[nums1.length];\n            for (int i = 0; i < nums1.length; i++) {\n                res[i]=map.get(nums1[i]);\n            }\n            return res;\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n# 我的笔记\n采用单调栈\n\n# 官方题解\n# 方法一：暴力解法\n题目中的关键信息：两个数组各自 没有重复元素。模拟题目的意思：对于每一个 nums1[i] 中的元素，先在 nums2 中找到它，然后向右遍历找到第 1 个大于 nums1[i] 的元素。\n\n参考代码 1：\n\nimport java.util.arrays;\n\npublic class solution {\n\n    public int[] nextgreaterelement(int[] nums1, int[] nums2) {\n        int len1 = nums1.length;\n        int len2 = nums2.length;\n\n        int[] res = new int[len1];\n        if (len1 < 1) {\n            return res;\n        }\n\n        for (int i = 0; i < len1; i++) {\n            int curval = nums1[i];\n            int j = 0;\n            while (j < len2 && nums2[j] != curval) {\n                j++;\n            }\n\n            // 此时 nums[j] = nums[i]\n            j++;\n            while (j < len2 && nums2[j] < curval) {\n                j++;\n            }\n\n            if (j == len2) {\n                res[i] = -1;\n                continue;\n            }\n            res[i] = nums2[j];\n        }\n        return res;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n复杂度分析：\n\n * 时间复杂度：o(nm)o(nm)o(nm)，这里 nnn 是数组 nums1 的长度， mmm 是数组 nums2 的长度，对于 nnn 个 nums1 中的元素，最差情况下需要遍历完 nums2 中的每个元素，因此时间复杂度为 o(nm)o(nm)o(nm)；\n * 空间复杂度： * 如果不计算保存结果的空间，空间复杂度为 o(1)o(1)o(1)；\n    * 如果计算保存结果的空间，空间复杂度为 o(n)o(n)o(n)。\n   \n   \n\n「暴力解法」时间复杂度高 ，空间复杂度低，优化「暴力解法」的思路是「空间换时间」。事实上，找右边第 1 个大于比自己大的数，这是一个典型的「栈」的应用（也叫「单调栈」），将每一个元素进栈一次、出栈一次，这样的过程中就可以找到找右边第 1 个大于比自己大的数。\n\n\n\n\n# 方法二：栈（单调栈）\n根据题意，数组 nums1 视为询问。我们可以：\n\n * 先对 nums2 中的每一个元素，求出它的右边第一个更大的元素；\n * 将上一步的对应关系放入哈希表（hashmap）中；\n * 再遍历数组 nums1，根据哈希表找出答案。\n\n下面我们解释如何得到 nums2 的每个元素右边第 1 个比它大的元素，这里以 nums2 = [2, 3, 5, 1, 0, 7, 3] 为例进行说明，我们从左到右遍历数组 nums2 中的元素。\n\n友情提示：只需要看文字和图例的前几句话，找到解决问题的一帮规律，这样可以节约阅读时间。\n\n<,,,,,,,,>\n\n归纳重点：\n\n * 可以发现，我们维护的栈恰好保证了单调性：栈中的元素从栈顶到栈底是单调不降的。当我们遇到一个新的元素 nums2[i] 时，我们判断栈顶元素是否小于 nums2[i]，如果是，那么栈顶元素的下一个更大元素即为 nums2[i]，我们将栈顶元素出栈。重复这一操作，直到栈为空或者栈顶元素大于 nums2[i]。此时我们将 nums2[i] 入栈，保持栈的单调性，并对接下来的 nums2[i + 1], nums2[i + 2] ... 执行同样的操作。\n\n参考代码 2：\n\nimport java.util.arraydeque;\nimport java.util.arrays;\nimport java.util.deque;\nimport java.util.hashmap;\nimport java.util.map;\nimport java.util.stack;\n\npublic class solution {\n\n    public int[] nextgreaterelement(int[] nums1, int[] nums2) {\n        int len1 = nums1.length;\n        int len2 = nums2.length;\n\n        deque<integer> stack = new arraydeque<>();\n        map<integer, integer> map = new hashmap<>();\n        // 先处理 nums2，把对应关系存入哈希表\n        for (int i = 0; i < len2; i++) {\n            while (!stack.isempty() && stack.peeklast() < nums2[i]) {\n                map.put(stack.removelast(), nums2[i]);\n            }\n            stack.addlast(nums2[i]);\n        }\n\n        // 遍历 nums1 得到结果集\n        int[] res = new int[len1];\n        for (int i = 0; i < len1; i++) {\n            res[i] = map.getordefault(nums1[i], -1);\n        }\n        return res;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n复杂度分析：\n\n * 时间复杂度：o(n+m)o(n + m)o(n+m)，分别遍历数组 nums1 和数组 nums2 各一次即可，对于 nums2 中的每个元素，进栈一次，出栈一次；\n * 空间复杂度：o(n)o(n)o(n)。我们在遍历 nums2 时，需要使用栈，以及哈希映射用来临时存储答案。\n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2021-04-28 22:09:16accepted [https://leetcode-cn.com//submissions/detail/173007801/]88 ms100.0%38.7 mbjava2021-04-28 21:53:20accepted [https://leetcode-cn.com//submissions/detail/173001659/]79 ms100.0%38.7 mbjava# 统计信息\n通过次数提交次数ac比率7663911311967.8%# 相似题目\n题目难度下一个更大元素 ii [https://leetcode-cn.com/problems/next-greater-element-ii/]中等下一个更大元素 iii [https://leetcode-cn.com/problems/next-greater-element-iii/]中等每日温度 [https://leetcode-cn.com/problems/daily-temperatures/]中等"},{title:"832-翻转图像(Flipping an Image)",frontmatter:{title:"832-翻转图像(Flipping an Image)",date:"2020-01-16T00:00:00.000Z",categories:["简单"],tags:["数组<Array>"]},regularPath:"/views/%E7%AE%80%E5%8D%95/0832-%E7%BF%BB%E8%BD%AC%E5%9B%BE%E5%83%8F.html",relativePath:"views/简单/0832-翻转图像.md",key:"v-6a8c0a12",path:"/views/%E7%AE%80%E5%8D%95/0832-%E7%BF%BB%E8%BD%AC%E5%9B%BE%E5%83%8F.html",headers:[{level:2,title:"中文题目",slug:"中文题目",charIndex:2},{level:2,title:"通过代码",slug:"通过代码",charIndex:586},{level:2,title:"我的题解",slug:"我的题解",charIndex:1128},{level:2,title:"官方题解",slug:"官方题解",charIndex:1325},{level:2,title:"提交历史",slug:"提交历史",charIndex:2360},{level:2,title:"统计信息",slug:"统计信息",charIndex:2493}],lastUpdated:"4/11/2021, 1:15:21 PM",headersStr:"中文题目 通过代码 我的题解 官方题解 提交历史 统计信息",content:'# 中文题目\n给定一个二进制矩阵A，我们想先水平翻转图像，然后反转图像并返回结果。\n\n水平翻转图片就是将图片的每一行都进行翻转，即逆序。例如，水平翻转[1, 1, 0]的结果是[0, 1, 1]。\n\n反转图片的意思是图片中的0全部被1替换，1全部被0替换。例如，反转[0, 1, 1]的结果是[1, 0, 0]。\n\n示例 1:\n\n\n输入: [[1,1,0],[1,0,1],[0,0,0]]\n输出: [[1,0,0],[0,1,0],[1,1,1]]\n解释: 首先翻转每一行: [[0,1,1],[1,0,1],[0,0,0]]；\n     然后反转图片: [[1,0,0],[0,1,0],[1,1,1]]\n\n\n示例 2:\n\n\n输入: [[1,1,0,0],[1,0,0,1],[0,1,1,1],[1,0,1,0]]\n输出: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]\n解释: 首先翻转每一行: [[0,0,1,1],[1,0,0,1],[1,1,1,0],[0,1,0,1]]；\n     然后反转图片: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]\n\n\n说明:\n\n * 1 <= A.length = A[0].length <= 20\n * 0 <= A[i][j] <= 1\n\n# 通过代码\nclass Solution {\n    public int[][] flipAndInvertImage(int[][] A) {\n        for (int i = 0; i < A.length; i++) {\n            int x=0;\n            int y=A[i].length-1;\n            while (x<y){\n                int temp=A[i][x];\n                A[i][x]=A[i][y];\n                A[i][y]=temp;\n                x++;\n                y--;\n            }\n            for (int j = 0; j < A[i].length; j++) {\n                A[i][j]=(A[i][j]==1?0:1);\n            }\n        }\n        return A;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n# 我的题解\n可以采用下面这种方式遍历二维数组\n\nint[][] arr={{1,1,0,0},{0,1,1,1},{0,0,0,1}};\nArrays.asList(new Main().flipAndInvertImage(arr)).stream().flatMapToInt(x->Arrays.stream(x)).forEach(System.out::print);\n\n\n1\n2\n# 官方题解\n# 方法一：模拟\n我们可以不使用额外的（非常数）空间来完成翻转和反转操作。对于 A[i][j]，我们将它和 A[i][c - j - 1] 进行交换（即翻转），其中 c 是数组 A 的列数。在交换的同时，我们可以将这两个数进行反转。\n\nclass Solution {\n    public int[][] flipAndInvertImage(int[][] A) {\n        int C = A[0].length;\n        for (int[] row: A)\n            for (int i = 0; i < (C + 1) / 2; ++i) {\n                int tmp = row[i] ^ 1;\n                row[i] = row[C - 1 - i] ^ 1;\n                row[C - 1 - i] = tmp;\n            }\n\n        return A;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\nclass Solution(object):\n    def flipAndInvertImage(self, A):\n        for row in A:\n            for i in xrange((len(row) + 1) / 2):\n                """\n                In Python, the shortcut row[~i] = row[-i-1] = row[len(row) - 1 - i]\n                helps us find the i-th value of the row, counting from the right.\n                """\n                row[i], row[~i] = row[~i] ^ 1, row[i] ^ 1\n        return A\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n复杂度分析\n\n * 时间复杂度：O(M∗N)O(M*N)O(M∗N)，其中 MMM 和 NNN 分别为数组 A 的行数和列数。\n   \n   \n * 空间复杂度：O(1)O(1)O(1)。\n   \n   \n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2020-01-16 22:05:39Accepted [https://leetcode-cn.com//submissions/detail/43740411/]1 ms72.85%36.6 MBjava# 统计信息\n通过次数提交次数AC比率265073587573.9%',contentLowercase:'# 中文题目\n给定一个二进制矩阵a，我们想先水平翻转图像，然后反转图像并返回结果。\n\n水平翻转图片就是将图片的每一行都进行翻转，即逆序。例如，水平翻转[1, 1, 0]的结果是[0, 1, 1]。\n\n反转图片的意思是图片中的0全部被1替换，1全部被0替换。例如，反转[0, 1, 1]的结果是[1, 0, 0]。\n\n示例 1:\n\n\n输入: [[1,1,0],[1,0,1],[0,0,0]]\n输出: [[1,0,0],[0,1,0],[1,1,1]]\n解释: 首先翻转每一行: [[0,1,1],[1,0,1],[0,0,0]]；\n     然后反转图片: [[1,0,0],[0,1,0],[1,1,1]]\n\n\n示例 2:\n\n\n输入: [[1,1,0,0],[1,0,0,1],[0,1,1,1],[1,0,1,0]]\n输出: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]\n解释: 首先翻转每一行: [[0,0,1,1],[1,0,0,1],[1,1,1,0],[0,1,0,1]]；\n     然后反转图片: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]\n\n\n说明:\n\n * 1 <= a.length = a[0].length <= 20\n * 0 <= a[i][j] <= 1\n\n# 通过代码\nclass solution {\n    public int[][] flipandinvertimage(int[][] a) {\n        for (int i = 0; i < a.length; i++) {\n            int x=0;\n            int y=a[i].length-1;\n            while (x<y){\n                int temp=a[i][x];\n                a[i][x]=a[i][y];\n                a[i][y]=temp;\n                x++;\n                y--;\n            }\n            for (int j = 0; j < a[i].length; j++) {\n                a[i][j]=(a[i][j]==1?0:1);\n            }\n        }\n        return a;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n# 我的题解\n可以采用下面这种方式遍历二维数组\n\nint[][] arr={{1,1,0,0},{0,1,1,1},{0,0,0,1}};\narrays.aslist(new main().flipandinvertimage(arr)).stream().flatmaptoint(x->arrays.stream(x)).foreach(system.out::print);\n\n\n1\n2\n# 官方题解\n# 方法一：模拟\n我们可以不使用额外的（非常数）空间来完成翻转和反转操作。对于 a[i][j]，我们将它和 a[i][c - j - 1] 进行交换（即翻转），其中 c 是数组 a 的列数。在交换的同时，我们可以将这两个数进行反转。\n\nclass solution {\n    public int[][] flipandinvertimage(int[][] a) {\n        int c = a[0].length;\n        for (int[] row: a)\n            for (int i = 0; i < (c + 1) / 2; ++i) {\n                int tmp = row[i] ^ 1;\n                row[i] = row[c - 1 - i] ^ 1;\n                row[c - 1 - i] = tmp;\n            }\n\n        return a;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\nclass solution(object):\n    def flipandinvertimage(self, a):\n        for row in a:\n            for i in xrange((len(row) + 1) / 2):\n                """\n                in python, the shortcut row[~i] = row[-i-1] = row[len(row) - 1 - i]\n                helps us find the i-th value of the row, counting from the right.\n                """\n                row[i], row[~i] = row[~i] ^ 1, row[i] ^ 1\n        return a\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n复杂度分析\n\n * 时间复杂度：o(m∗n)o(m*n)o(m∗n)，其中 mmm 和 nnn 分别为数组 a 的行数和列数。\n   \n   \n * 空间复杂度：o(1)o(1)o(1)。\n   \n   \n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2020-01-16 22:05:39accepted [https://leetcode-cn.com//submissions/detail/43740411/]1 ms72.85%36.6 mbjava# 统计信息\n通过次数提交次数ac比率265073587573.9%'},{title:"771-宝石与石头(Jewels and Stones)",frontmatter:{title:"771-宝石与石头(Jewels and Stones)",date:"2019-06-23T00:00:00.000Z",categories:["简单"],tags:["哈希表<Hash Table>"]},regularPath:"/views/%E7%AE%80%E5%8D%95/0771-%E5%AE%9D%E7%9F%B3%E4%B8%8E%E7%9F%B3%E5%A4%B4.html",relativePath:"views/简单/0771-宝石与石头.md",key:"v-2d78303e",path:"/views/%E7%AE%80%E5%8D%95/0771-%E5%AE%9D%E7%9F%B3%E4%B8%8E%E7%9F%B3%E5%A4%B4.html",headers:[{level:2,title:"中文题目",slug:"中文题目",charIndex:2},{level:2,title:"通过代码",slug:"通过代码",charIndex:248},{level:2,title:"官方题解",slug:"官方题解",charIndex:3598},{level:2,title:"提交历史",slug:"提交历史",charIndex:5218},{level:2,title:"统计信息",slug:"统计信息",charIndex:5763}],lastUpdated:"4/11/2021, 1:15:21 PM",headersStr:"中文题目 通过代码 官方题解 提交历史 统计信息",content:'# 中文题目\n给定字符串J代表石头中宝石的类型，和字符串S代表你拥有的石头。S中每个字符代表了一种你拥有的石头的类型，你想知道你拥有的石头中有多少是宝石。\n\nJ中的字母不重复，J和S中的所有字符都是字母。字母区分大小写，因此"a"和"A"是不同类型的石头。\n\n示例 1:\n\n输入: J = "aA", S = "aAAbbbb"\n输出: 3\n\n\n示例 2:\n\n输入: J = "z", S = "ZZ"\n输出: 0\n\n\n注意:\n\n * S和J最多含有50个字母。\n * J中的字符不重复。\n\n# 通过代码\nclass Solution {\n        // public int numJewelsInStones(String J, String S) {\n        //     HashSet<Character> jSet=new HashSet<Character>();\n        //     for (int i = 0; i < J.length(); i++) {\n        //         jSet.add(J.charAt(i));\n        //     }\n        //     int total=0;\n        //     for (int i = 0; i < S.length(); i++) {\n        //         if (jSet.contains(S.charAt(i))){\n        //             total++;\n        //         }\n        //     }\n        //     return total;\n        // }\n    public int numJewelsInStones(String J, String S) {\n            int num = 0;\n            if (J == null || J.equals("")) {\n                return num;\n            }\n            if (S == null || S.equals("")) {\n                return num;\n            }\n\n            for (int i = 0; i < J.length(); i++) {\n                for (int j = 0; j < S.length(); j++) {\n                    if (J.charAt(i) == S.charAt(j)) {\n                        num++;\n                    }\n                }\n            }\n            return num;\n        }\n    }\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\nclass Solution {\n        public int numJewelsInStones(String J, String S) {\n            HashSet<Character> jSet=new HashSet<Character>();\n            for (int i = 0; i < J.length(); i++) {\n                jSet.add(J.charAt(i));\n            }\n            int total=0;\n            for (int i = 0; i < S.length(); i++) {\n                if (jSet.contains(S.charAt(i))){\n                    total++;\n                }\n            }\n            return total;\n        }\n    }\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\nclass Solution {\n        public int numJewelsInStones(String J, String S) {\n            HashSet<Character> jSet=new HashSet<Character>();\n            for (int i = 0; i < J.length(); i++) {\n                jSet.add(J.charAt(i));\n            }\n            int total=0;\n            for (int i = 0; i < S.length(); i++) {\n                if (jSet.contains(S.charAt(i))){\n                    total++;\n                }\n            }\n            return total;\n        }\n    }\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\nclass Solution {\n        public int numJewelsInStones(String J, String S) {\n            int num = 0;\n            if (J == null || J.equals("")) {\n                return num;\n            }\n            if (S == null || S.equals("")) {\n                return num;\n            }\n\n            for (int i = 0; i < J.length(); i++) {\n                for (int j = 0; j < S.length(); j++) {\n                    if (J.charAt(i) == S.charAt(j)) {\n                        num++;\n                    }\n                }\n            }\n            return num;\n        }\n    }\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\nclass Solution {\n    public int numJewelsInStones(String J, String S) {\n        int num = 0;\n            if (J == null || J.equals("")) {\n                return num;\n            }\n            if (S == null || S.equals("")) {\n                return num;\n            }\n\n            for (int i = 0; i < J.length(); i++) {\n                for (int j = 0; j < S.length(); j++) {\n                    if (J.charAt(i) == S.charAt(j)) {\n                        num++;\n                    }\n                }\n            }\n            return num;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n# 官方题解\n# 方法一： 暴力法 【通过】\n思路和算法\n\n遍历每块石头，检查是不是宝石。检查步骤用简单的线性搜索来实现。\n\nclass Solution {\n    public int numJewelsInStones(String J, String S) {\n        int ans = 0;\n        for (char s: S.toCharArray()) // For each stone...\n            for (char j: J.toCharArray()) // For each jewel...\n                if (j == s) {  // If the stone is a jewel...\n                    ans++;\n                    break; // Stop searching whether this stone \'s\' is a jewel\n                }\n        return ans;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\nclass Solution(object):\n    def numJewelsInStones(self, J, S):\n        return sum(s in J for s in S)\n\n\n1\n2\n3\n复杂度分析\n\n * 时间复杂度：O(J.length∗S.length))O(J.length * S.length))O(J.length∗S.length))。\n   \n   \n * 空间复杂度：在 Python 实现中，空间复杂度为 O(1)O(1)O(1)。在 Java 实现中，空间复杂度为 O(J.length∗S.length))O(J.length * S.length))O(J.length∗S.length))。\n   \n   \n\n# 方法二： 哈希集合 【通过】\n思路和算法\n\n遍历每块石头，检查是不是宝石。检查步骤用 哈希集合 来高效完成。\n\nclass Solution {\n    public int numJewelsInStones(String J, String S) {\n        Set<Character> Jset = new HashSet();\n        for (char j: J.toCharArray())\n            Jset.add(j);\n\n        int ans = 0;\n        for (char s: S.toCharArray())\n            if (Jset.contains(s))\n                ans++;\n        return ans;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\nclass Solution(object):\n    def numJewelsInStones(self, J, S):\n        Jset = set(J)\n        return sum(s in Jset for s in S)\n\n\n1\n2\n3\n4\n复杂度分析\n\n * 时间复杂度：O(J.length+S.length))O(J.length + S.length))O(J.length+S.length))。O(J.length}) 这部分来自于创建 J，O(S.length)O(S.length)O(S.length) 这部分来自于搜索 S。\n   \n   \n * 空间复杂度：O(J.length)O(J.length)O(J.length)。\n   \n   \n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2019-06-23 18:44:58Accepted [https://leetcode-cn.com//submissions/detail/21235403/]6 ms7.98%35.2 MBjava2019-06-23 18:43:40Accepted [https://leetcode-cn.com//submissions/detail/21235326/]4 ms11.4%34.8 MBjava2019-06-23 18:42:51Accepted [https://leetcode-cn.com//submissions/detail/21235284/]5 ms8.6%34.9 MBjava2019-06-23 18:36:13Accepted [https://leetcode-cn.com//submissions/detail/21234887/]3 ms22.05%35.2 MBjava2018-12-15 17:07:23Accepted [https://leetcode-cn.com//submissions/detail/10497091/]10 ms5.47%18.8 MBjava# 统计信息\n通过次数提交次数AC比率670178223681.5%',contentLowercase:'# 中文题目\n给定字符串j代表石头中宝石的类型，和字符串s代表你拥有的石头。s中每个字符代表了一种你拥有的石头的类型，你想知道你拥有的石头中有多少是宝石。\n\nj中的字母不重复，j和s中的所有字符都是字母。字母区分大小写，因此"a"和"a"是不同类型的石头。\n\n示例 1:\n\n输入: j = "aa", s = "aaabbbb"\n输出: 3\n\n\n示例 2:\n\n输入: j = "z", s = "zz"\n输出: 0\n\n\n注意:\n\n * s和j最多含有50个字母。\n * j中的字符不重复。\n\n# 通过代码\nclass solution {\n        // public int numjewelsinstones(string j, string s) {\n        //     hashset<character> jset=new hashset<character>();\n        //     for (int i = 0; i < j.length(); i++) {\n        //         jset.add(j.charat(i));\n        //     }\n        //     int total=0;\n        //     for (int i = 0; i < s.length(); i++) {\n        //         if (jset.contains(s.charat(i))){\n        //             total++;\n        //         }\n        //     }\n        //     return total;\n        // }\n    public int numjewelsinstones(string j, string s) {\n            int num = 0;\n            if (j == null || j.equals("")) {\n                return num;\n            }\n            if (s == null || s.equals("")) {\n                return num;\n            }\n\n            for (int i = 0; i < j.length(); i++) {\n                for (int j = 0; j < s.length(); j++) {\n                    if (j.charat(i) == s.charat(j)) {\n                        num++;\n                    }\n                }\n            }\n            return num;\n        }\n    }\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\nclass solution {\n        public int numjewelsinstones(string j, string s) {\n            hashset<character> jset=new hashset<character>();\n            for (int i = 0; i < j.length(); i++) {\n                jset.add(j.charat(i));\n            }\n            int total=0;\n            for (int i = 0; i < s.length(); i++) {\n                if (jset.contains(s.charat(i))){\n                    total++;\n                }\n            }\n            return total;\n        }\n    }\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\nclass solution {\n        public int numjewelsinstones(string j, string s) {\n            hashset<character> jset=new hashset<character>();\n            for (int i = 0; i < j.length(); i++) {\n                jset.add(j.charat(i));\n            }\n            int total=0;\n            for (int i = 0; i < s.length(); i++) {\n                if (jset.contains(s.charat(i))){\n                    total++;\n                }\n            }\n            return total;\n        }\n    }\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\nclass solution {\n        public int numjewelsinstones(string j, string s) {\n            int num = 0;\n            if (j == null || j.equals("")) {\n                return num;\n            }\n            if (s == null || s.equals("")) {\n                return num;\n            }\n\n            for (int i = 0; i < j.length(); i++) {\n                for (int j = 0; j < s.length(); j++) {\n                    if (j.charat(i) == s.charat(j)) {\n                        num++;\n                    }\n                }\n            }\n            return num;\n        }\n    }\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\nclass solution {\n    public int numjewelsinstones(string j, string s) {\n        int num = 0;\n            if (j == null || j.equals("")) {\n                return num;\n            }\n            if (s == null || s.equals("")) {\n                return num;\n            }\n\n            for (int i = 0; i < j.length(); i++) {\n                for (int j = 0; j < s.length(); j++) {\n                    if (j.charat(i) == s.charat(j)) {\n                        num++;\n                    }\n                }\n            }\n            return num;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n# 官方题解\n# 方法一： 暴力法 【通过】\n思路和算法\n\n遍历每块石头，检查是不是宝石。检查步骤用简单的线性搜索来实现。\n\nclass solution {\n    public int numjewelsinstones(string j, string s) {\n        int ans = 0;\n        for (char s: s.tochararray()) // for each stone...\n            for (char j: j.tochararray()) // for each jewel...\n                if (j == s) {  // if the stone is a jewel...\n                    ans++;\n                    break; // stop searching whether this stone \'s\' is a jewel\n                }\n        return ans;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\nclass solution(object):\n    def numjewelsinstones(self, j, s):\n        return sum(s in j for s in s)\n\n\n1\n2\n3\n复杂度分析\n\n * 时间复杂度：o(j.length∗s.length))o(j.length * s.length))o(j.length∗s.length))。\n   \n   \n * 空间复杂度：在 python 实现中，空间复杂度为 o(1)o(1)o(1)。在 java 实现中，空间复杂度为 o(j.length∗s.length))o(j.length * s.length))o(j.length∗s.length))。\n   \n   \n\n# 方法二： 哈希集合 【通过】\n思路和算法\n\n遍历每块石头，检查是不是宝石。检查步骤用 哈希集合 来高效完成。\n\nclass solution {\n    public int numjewelsinstones(string j, string s) {\n        set<character> jset = new hashset();\n        for (char j: j.tochararray())\n            jset.add(j);\n\n        int ans = 0;\n        for (char s: s.tochararray())\n            if (jset.contains(s))\n                ans++;\n        return ans;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\nclass solution(object):\n    def numjewelsinstones(self, j, s):\n        jset = set(j)\n        return sum(s in jset for s in s)\n\n\n1\n2\n3\n4\n复杂度分析\n\n * 时间复杂度：o(j.length+s.length))o(j.length + s.length))o(j.length+s.length))。o(j.length}) 这部分来自于创建 j，o(s.length)o(s.length)o(s.length) 这部分来自于搜索 s。\n   \n   \n * 空间复杂度：o(j.length)o(j.length)o(j.length)。\n   \n   \n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2019-06-23 18:44:58accepted [https://leetcode-cn.com//submissions/detail/21235403/]6 ms7.98%35.2 mbjava2019-06-23 18:43:40accepted [https://leetcode-cn.com//submissions/detail/21235326/]4 ms11.4%34.8 mbjava2019-06-23 18:42:51accepted [https://leetcode-cn.com//submissions/detail/21235284/]5 ms8.6%34.9 mbjava2019-06-23 18:36:13accepted [https://leetcode-cn.com//submissions/detail/21234887/]3 ms22.05%35.2 mbjava2018-12-15 17:07:23accepted [https://leetcode-cn.com//submissions/detail/10497091/]10 ms5.47%18.8 mbjava# 统计信息\n通过次数提交次数ac比率670178223681.5%'},{title:"682-棒球比赛(Baseball Game)",frontmatter:{title:"682-棒球比赛(Baseball Game)",date:"2021-05-06T00:00:00.000Z",categories:["简单"],tags:["栈<Stack>"]},regularPath:"/views/%E7%AE%80%E5%8D%95/0682-%E6%A3%92%E7%90%83%E6%AF%94%E8%B5%9B.html",relativePath:"views/简单/0682-棒球比赛.md",key:"v-e1b467a8",path:"/views/%E7%AE%80%E5%8D%95/0682-%E6%A3%92%E7%90%83%E6%AF%94%E8%B5%9B.html",headers:[{level:2,title:"中文题目",slug:"中文题目",charIndex:2},{level:2,title:"通过代码",slug:"通过代码",charIndex:1175},{level:2,title:"官方题解",slug:"官方题解",charIndex:2168},{level:2,title:"提交历史",slug:"提交历史",charIndex:3539},{level:2,title:"统计信息",slug:"统计信息",charIndex:3673}],headersStr:"中文题目 通过代码 官方题解 提交历史 统计信息",content:'# 中文题目\n你现在是一场采用特殊赛制棒球比赛的记录员。这场比赛由若干回合组成，过去几回合的得分可能会影响以后几回合的得分。\n\n比赛开始时，记录是空白的。你会得到一个记录操作的字符串列表 ops，其中 ops[i] 是你需要记录的第 i 项操作，ops 遵循下述规则：\n\n 1. 整数 x - 表示本回合新获得分数 x\n 2. "+" - 表示本回合新获得的得分是前两次得分的总和。题目数据保证记录此操作时前面总是存在两个有效的分数。\n 3. "D" - 表示本回合新获得的得分是前一次得分的两倍。题目数据保证记录此操作时前面总是存在一个有效的分数。\n 4. "C" - 表示前一次得分无效，将其从记录中移除。题目数据保证记录此操作时前面总是存在一个有效的分数。\n\n请你返回记录中所有得分的总和。\n\n\n\n示例 1：\n\n\n输入：ops = ["5","2","C","D","+"]\n输出：30\n解释：\n"5" - 记录加 5 ，记录现在是 [5]\n"2" - 记录加 2 ，记录现在是 [5, 2]\n"C" - 使前一次得分的记录无效并将其移除，记录现在是 [5].\n"D" - 记录加 2 * 5 = 10 ，记录现在是 [5, 10].\n"+" - 记录加 5 + 10 = 15 ，记录现在是 [5, 10, 15].\n所有得分的总和 5 + 10 + 15 = 30\n\n\n示例 2：\n\n\n输入：ops = ["5","-2","4","C","D","9","+","+"]\n输出：27\n解释：\n"5" - 记录加 5 ，记录现在是 [5]\n"-2" - 记录加 -2 ，记录现在是 [5, -2]\n"4" - 记录加 4 ，记录现在是 [5, -2, 4]\n"C" - 使前一次得分的记录无效并将其移除，记录现在是 [5, -2]\n"D" - 记录加 2 * -2 = -4 ，记录现在是 [5, -2, -4]\n"9" - 记录加 9 ，记录现在是 [5, -2, -4, 9]\n"+" - 记录加 -4 + 9 = 5 ，记录现在是 [5, -2, -4, 9, 5]\n"+" - 记录加 9 + 5 = 14 ，记录现在是 [5, -2, -4, 9, 5, 14]\n所有得分的总和 5 + -2 + -4 + 9 + 5 + 14 = 27\n\n\n示例 3：\n\n\n输入：ops = ["1"]\n输出：1\n\n\n\n\n提示：\n\n * 1 \n * ops[i] 为 "C"、"D"、"+"，或者一个表示整数的字符串。整数范围是 [-3 * 104, 3 * 104]\n * 对于 "+" 操作，题目数据保证记录此操作时前面总是存在两个有效的分数\n * 对于 "C" 和 "D" 操作，题目数据保证记录此操作时前面总是存在一个有效的分数\n\n# 通过代码\n    class Solution {\n        public int calPoints(String[] ops) {\n            Stack<Integer> stack=new Stack<>();\n            int temp1,temp2;\n            for (int i = 0; i < ops.length; i++) {\n                if ("C".equals(ops[i])){\n                    stack.pop();\n                }else if ("D".equals(ops[i])){\n                    temp1=stack.peek();\n                    stack.push(temp1*2);\n                }else if ("+".equals(ops[i])){\n                    temp1=stack.peek();\n                    stack.pop();\n                    temp2=stack.peek();\n                    stack.push(temp1);\n                    stack.push(temp1+temp2);\n                }else {\n                    stack.push(Integer.parseInt(ops[i]));\n                }\n            }\n            int result=0;\n            while (!stack.isEmpty()){\n                result+=stack.pop();\n            }\n            return result;\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n# 官方题解\n# 方法：栈\n思路与算法\n\n让我们在处理数据时保持栈上每个有效回合的值。栈是理想的，因为我们只处理涉及最后或倒数第二轮的操作。\n\nclass Solution {\n    public int calPoints(String[] ops) {\n        Stack<Integer> stack = new Stack();\n\n        for(String op : ops) {\n            if (op.equals("+")) {\n                int top = stack.pop();\n                int newtop = top + stack.peek();\n                stack.push(top);\n                stack.push(newtop);\n            } else if (op.equals("C")) {\n                stack.pop();\n            } else if (op.equals("D")) {\n                stack.push(2 * stack.peek());\n            } else {\n                stack.push(Integer.valueOf(op));\n            }\n        }\n\n        int ans = 0;\n        for(int score : stack) ans += score;\n        return ans;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\nclass Solution(object):\n    def calPoints(self, ops):\n        stack = []\n        for op in ops:\n            if op == \'+\':\n                stack.append(stack[-1] + stack[-2])\n            elif op == \'C\':\n                stack.pop()\n            elif op == \'D\':\n                stack.append(2 * stack[-1])\n            else:\n                stack.append(int(op))\n\n        return sum(stack)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n复杂度分析\n\n * 复杂度分析：O(N)O(N)O(N)，其中 NNN 是 ops 的长度。我们解析给定数组中的每个元素，然后每个元素执行 O(1)O(1)O(1) 的工作。\n   \n   \n * 空间复杂度：O(N)O(N)O(N)，用于存储 stack 的空间。\n   \n   \n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2021-05-06 21:38:35Accepted [https://leetcode-cn.com//submissions/detail/174915488/]4 ms100.0%37.9 MBjava# 统计信息\n通过次数提交次数AC比率409235911269.2%',contentLowercase:'# 中文题目\n你现在是一场采用特殊赛制棒球比赛的记录员。这场比赛由若干回合组成，过去几回合的得分可能会影响以后几回合的得分。\n\n比赛开始时，记录是空白的。你会得到一个记录操作的字符串列表 ops，其中 ops[i] 是你需要记录的第 i 项操作，ops 遵循下述规则：\n\n 1. 整数 x - 表示本回合新获得分数 x\n 2. "+" - 表示本回合新获得的得分是前两次得分的总和。题目数据保证记录此操作时前面总是存在两个有效的分数。\n 3. "d" - 表示本回合新获得的得分是前一次得分的两倍。题目数据保证记录此操作时前面总是存在一个有效的分数。\n 4. "c" - 表示前一次得分无效，将其从记录中移除。题目数据保证记录此操作时前面总是存在一个有效的分数。\n\n请你返回记录中所有得分的总和。\n\n\n\n示例 1：\n\n\n输入：ops = ["5","2","c","d","+"]\n输出：30\n解释：\n"5" - 记录加 5 ，记录现在是 [5]\n"2" - 记录加 2 ，记录现在是 [5, 2]\n"c" - 使前一次得分的记录无效并将其移除，记录现在是 [5].\n"d" - 记录加 2 * 5 = 10 ，记录现在是 [5, 10].\n"+" - 记录加 5 + 10 = 15 ，记录现在是 [5, 10, 15].\n所有得分的总和 5 + 10 + 15 = 30\n\n\n示例 2：\n\n\n输入：ops = ["5","-2","4","c","d","9","+","+"]\n输出：27\n解释：\n"5" - 记录加 5 ，记录现在是 [5]\n"-2" - 记录加 -2 ，记录现在是 [5, -2]\n"4" - 记录加 4 ，记录现在是 [5, -2, 4]\n"c" - 使前一次得分的记录无效并将其移除，记录现在是 [5, -2]\n"d" - 记录加 2 * -2 = -4 ，记录现在是 [5, -2, -4]\n"9" - 记录加 9 ，记录现在是 [5, -2, -4, 9]\n"+" - 记录加 -4 + 9 = 5 ，记录现在是 [5, -2, -4, 9, 5]\n"+" - 记录加 9 + 5 = 14 ，记录现在是 [5, -2, -4, 9, 5, 14]\n所有得分的总和 5 + -2 + -4 + 9 + 5 + 14 = 27\n\n\n示例 3：\n\n\n输入：ops = ["1"]\n输出：1\n\n\n\n\n提示：\n\n * 1 \n * ops[i] 为 "c"、"d"、"+"，或者一个表示整数的字符串。整数范围是 [-3 * 104, 3 * 104]\n * 对于 "+" 操作，题目数据保证记录此操作时前面总是存在两个有效的分数\n * 对于 "c" 和 "d" 操作，题目数据保证记录此操作时前面总是存在一个有效的分数\n\n# 通过代码\n    class solution {\n        public int calpoints(string[] ops) {\n            stack<integer> stack=new stack<>();\n            int temp1,temp2;\n            for (int i = 0; i < ops.length; i++) {\n                if ("c".equals(ops[i])){\n                    stack.pop();\n                }else if ("d".equals(ops[i])){\n                    temp1=stack.peek();\n                    stack.push(temp1*2);\n                }else if ("+".equals(ops[i])){\n                    temp1=stack.peek();\n                    stack.pop();\n                    temp2=stack.peek();\n                    stack.push(temp1);\n                    stack.push(temp1+temp2);\n                }else {\n                    stack.push(integer.parseint(ops[i]));\n                }\n            }\n            int result=0;\n            while (!stack.isempty()){\n                result+=stack.pop();\n            }\n            return result;\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n# 官方题解\n# 方法：栈\n思路与算法\n\n让我们在处理数据时保持栈上每个有效回合的值。栈是理想的，因为我们只处理涉及最后或倒数第二轮的操作。\n\nclass solution {\n    public int calpoints(string[] ops) {\n        stack<integer> stack = new stack();\n\n        for(string op : ops) {\n            if (op.equals("+")) {\n                int top = stack.pop();\n                int newtop = top + stack.peek();\n                stack.push(top);\n                stack.push(newtop);\n            } else if (op.equals("c")) {\n                stack.pop();\n            } else if (op.equals("d")) {\n                stack.push(2 * stack.peek());\n            } else {\n                stack.push(integer.valueof(op));\n            }\n        }\n\n        int ans = 0;\n        for(int score : stack) ans += score;\n        return ans;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\nclass solution(object):\n    def calpoints(self, ops):\n        stack = []\n        for op in ops:\n            if op == \'+\':\n                stack.append(stack[-1] + stack[-2])\n            elif op == \'c\':\n                stack.pop()\n            elif op == \'d\':\n                stack.append(2 * stack[-1])\n            else:\n                stack.append(int(op))\n\n        return sum(stack)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n复杂度分析\n\n * 复杂度分析：o(n)o(n)o(n)，其中 nnn 是 ops 的长度。我们解析给定数组中的每个元素，然后每个元素执行 o(1)o(1)o(1) 的工作。\n   \n   \n * 空间复杂度：o(n)o(n)o(n)，用于存储 stack 的空间。\n   \n   \n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2021-05-06 21:38:35accepted [https://leetcode-cn.com//submissions/detail/174915488/]4 ms100.0%37.9 mbjava# 统计信息\n通过次数提交次数ac比率409235911269.2%'},{title:"852-山脉数组的峰顶索引(Peak Index in a Mountain Array)",frontmatter:{title:"852-山脉数组的峰顶索引(Peak Index in a Mountain Array)",date:"2018-12-18T00:00:00.000Z",categories:["简单"],tags:["二分查找<Binary Search>"]},regularPath:"/views/%E7%AE%80%E5%8D%95/0852-%E5%B1%B1%E8%84%89%E6%95%B0%E7%BB%84%E7%9A%84%E5%B3%B0%E9%A1%B6%E7%B4%A2%E5%BC%95.html",relativePath:"views/简单/0852-山脉数组的峰顶索引.md",key:"v-0b39ac5e",path:"/views/%E7%AE%80%E5%8D%95/0852-%E5%B1%B1%E8%84%89%E6%95%B0%E7%BB%84%E7%9A%84%E5%B3%B0%E9%A1%B6%E7%B4%A2%E5%BC%95.html",headers:[{level:2,title:"中文题目",slug:"中文题目",charIndex:2},{level:2,title:"通过代码",slug:"通过代码",charIndex:359},{level:2,title:"官方题解",slug:"官方题解",charIndex:1010},{level:2,title:"提交历史",slug:"提交历史",charIndex:2551},{level:2,title:"统计信息",slug:"统计信息",charIndex:2791},{level:2,title:"相似题目",slug:"相似题目",charIndex:2825}],lastUpdated:"4/11/2021, 1:15:21 PM",headersStr:"中文题目 通过代码 官方题解 提交历史 统计信息 相似题目",content:"# 中文题目\n我们把符合下列属性的数组A称作山脉：\n\n * A.length >= 3\n * 存在 0 < i < A.length - 1 使得A[0] < A[1] < ... A[i-1] < A[i] > A[i+1] > ... > A[A.length - 1]\n\n给定一个确定为山脉的数组，返回任何满足A[0] < A[1] < ... A[i-1] < A[i] > A[i+1] > ... > A[A.length - 1]的 i的值。\n\n\n\n示例 1：\n\n输入：[0,1,0]\n输出：1\n\n\n示例 2：\n\n输入：[0,2,1,0]\n输出：1\n\n\n\n提示：\n\n 1. 3 <= A.length <= 10000\n 2. 0 <= A[i] <= 10^6\n 3. A 是如上定义的山脉\n\n\n\n# 通过代码\nclass Solution {\n    public int peakIndexInMountainArray(int[] A) {\n        int posa = 0;\n            int posb = 0;\n            for (int i = 0; i < A.length-1; i++) {\n                if (A[i]>A[i+1]){\n                    posa=i;\n                    break;\n                }\n            }\n            for (int i = A.length-1; i > 0; i--) {\n                if (A[i]>A[i-1]){\n                    posb=i;\n                    break;\n                }\n            }\n            if (posa==posb){\n                return posa;\n            }else {\n                return 0;\n            }\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n# 官方题解\n# 方法一：线性扫描\n思路和算法\n\n从左往右扫描直到山的高度不再增长为止，停止增长点就是峰顶。\n\nclass Solution {\n    public int peakIndexInMountainArray(int[] A) {\n        int i = 0;\n        while (A[i] < A[i+1]) i++;\n        return i;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\nclass Solution(object):\n    def peakIndexInMountainArray(self, A):\n        for i in xrange(len(A)):\n            if A[i] > A[i+1]:\n                return i\n\n\n1\n2\n3\n4\n5\n复杂度分析\n\n * 时间复杂度：O(N)O(N)O(N)，其中 NNN 是 A 的长度。\n   \n   \n * 空间复杂度：O(1)O(1)O(1)。\n   \n   \n\n# 方法二：二分查找\n思路和算法\n\n将山脉数组中所有满足 A[i] < A[i+1] 的 i 点标记为 True，不满足的点标记为 False。则一个山脉数组可以标记为：[True, True, True, ..., True, False, False, ..., False]。例如山脉数组 [1, 2, 3, 4, 1] 可以标记为 True, True, True, False。\n\n在山脉数组上使用二分查找，找出满足 A[i] < A[i+1] 的最大 i。更多关于 二分查找 的知识，请访问 Leetcode 探索 [https://leetcode-cn.com/explore/learn/card/binary-search/]。\n\nclass Solution {\n    public int peakIndexInMountainArray(int[] A) {\n        int lo = 0, hi = A.length - 1;\n        while (lo < hi) {\n            int mi = lo + (hi - lo) / 2;\n            if (A[mi] < A[mi + 1])\n                lo = mi + 1;\n            else\n                hi = mi;\n        }\n        return lo;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\nclass Solution(object):\n    def peakIndexInMountainArray(self, A):\n        lo, hi = 0, len(A) - 1\n        while lo < hi:\n            mi = (lo + hi) / 2\n            if A[mi] < A[mi + 1]:\n                lo = mi + 1\n            else:\n                hi = mi\n        return lo\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n复杂度分析\n\n * 时间复杂度：O(log⁡N)O(\\log N)O(logN)，其中 NNN 是 A 的长度。\n   \n   \n * 空间复杂度：O(1)O(1)O(1)。\n   \n   \n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-12-18 22:40:35Accepted [https://leetcode-cn.com//submissions/detail/10614597/]4 ms39.13%29.6 MBjava2018-12-18 22:39:54Time Limit Exceeded [https://leetcode-cn.com//submissions/detail/10614559/]N/AN/AN/Ajava# 统计信息\n通过次数提交次数AC比率186362704968.9%# 相似题目\n题目难度寻找峰值 [https://leetcode-cn.com/problems/find-peak-element/]中等",contentLowercase:"# 中文题目\n我们把符合下列属性的数组a称作山脉：\n\n * a.length >= 3\n * 存在 0 < i < a.length - 1 使得a[0] < a[1] < ... a[i-1] < a[i] > a[i+1] > ... > a[a.length - 1]\n\n给定一个确定为山脉的数组，返回任何满足a[0] < a[1] < ... a[i-1] < a[i] > a[i+1] > ... > a[a.length - 1]的 i的值。\n\n\n\n示例 1：\n\n输入：[0,1,0]\n输出：1\n\n\n示例 2：\n\n输入：[0,2,1,0]\n输出：1\n\n\n\n提示：\n\n 1. 3 <= a.length <= 10000\n 2. 0 <= a[i] <= 10^6\n 3. a 是如上定义的山脉\n\n\n\n# 通过代码\nclass solution {\n    public int peakindexinmountainarray(int[] a) {\n        int posa = 0;\n            int posb = 0;\n            for (int i = 0; i < a.length-1; i++) {\n                if (a[i]>a[i+1]){\n                    posa=i;\n                    break;\n                }\n            }\n            for (int i = a.length-1; i > 0; i--) {\n                if (a[i]>a[i-1]){\n                    posb=i;\n                    break;\n                }\n            }\n            if (posa==posb){\n                return posa;\n            }else {\n                return 0;\n            }\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n# 官方题解\n# 方法一：线性扫描\n思路和算法\n\n从左往右扫描直到山的高度不再增长为止，停止增长点就是峰顶。\n\nclass solution {\n    public int peakindexinmountainarray(int[] a) {\n        int i = 0;\n        while (a[i] < a[i+1]) i++;\n        return i;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\nclass solution(object):\n    def peakindexinmountainarray(self, a):\n        for i in xrange(len(a)):\n            if a[i] > a[i+1]:\n                return i\n\n\n1\n2\n3\n4\n5\n复杂度分析\n\n * 时间复杂度：o(n)o(n)o(n)，其中 nnn 是 a 的长度。\n   \n   \n * 空间复杂度：o(1)o(1)o(1)。\n   \n   \n\n# 方法二：二分查找\n思路和算法\n\n将山脉数组中所有满足 a[i] < a[i+1] 的 i 点标记为 true，不满足的点标记为 false。则一个山脉数组可以标记为：[true, true, true, ..., true, false, false, ..., false]。例如山脉数组 [1, 2, 3, 4, 1] 可以标记为 true, true, true, false。\n\n在山脉数组上使用二分查找，找出满足 a[i] < a[i+1] 的最大 i。更多关于 二分查找 的知识，请访问 leetcode 探索 [https://leetcode-cn.com/explore/learn/card/binary-search/]。\n\nclass solution {\n    public int peakindexinmountainarray(int[] a) {\n        int lo = 0, hi = a.length - 1;\n        while (lo < hi) {\n            int mi = lo + (hi - lo) / 2;\n            if (a[mi] < a[mi + 1])\n                lo = mi + 1;\n            else\n                hi = mi;\n        }\n        return lo;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\nclass solution(object):\n    def peakindexinmountainarray(self, a):\n        lo, hi = 0, len(a) - 1\n        while lo < hi:\n            mi = (lo + hi) / 2\n            if a[mi] < a[mi + 1]:\n                lo = mi + 1\n            else:\n                hi = mi\n        return lo\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n复杂度分析\n\n * 时间复杂度：o(log⁡n)o(\\log n)o(logn)，其中 nnn 是 a 的长度。\n   \n   \n * 空间复杂度：o(1)o(1)o(1)。\n   \n   \n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-12-18 22:40:35accepted [https://leetcode-cn.com//submissions/detail/10614597/]4 ms39.13%29.6 mbjava2018-12-18 22:39:54time limit exceeded [https://leetcode-cn.com//submissions/detail/10614559/]n/an/an/ajava# 统计信息\n通过次数提交次数ac比率186362704968.9%# 相似题目\n题目难度寻找峰值 [https://leetcode-cn.com/problems/find-peak-element/]中等"},{title:"929-独特的电子邮件地址(Unique Email Addresses)",frontmatter:{title:"929-独特的电子邮件地址(Unique Email Addresses)",date:"2018-12-16T00:00:00.000Z",categories:["简单"],tags:["字符串<String>"]},regularPath:"/views/%E7%AE%80%E5%8D%95/0929-%E7%8B%AC%E7%89%B9%E7%9A%84%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6%E5%9C%B0%E5%9D%80.html",relativePath:"views/简单/0929-独特的电子邮件地址.md",key:"v-536bbb82",path:"/views/%E7%AE%80%E5%8D%95/0929-%E7%8B%AC%E7%89%B9%E7%9A%84%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6%E5%9C%B0%E5%9D%80.html",headers:[{level:2,title:"中文题目",slug:"中文题目",charIndex:2},{level:2,title:"通过代码",slug:"通过代码",charIndex:730},{level:2,title:"官方题解",slug:"官方题解",charIndex:1530},{level:2,title:"提交历史",slug:"提交历史",charIndex:2874},{level:2,title:"统计信息",slug:"统计信息",charIndex:3006}],lastUpdated:"4/11/2021, 1:15:21 PM",headersStr:"中文题目 通过代码 官方题解 提交历史 统计信息",content:"# 中文题目\n每封电子邮件都由一个本地名称和一个域名组成，以 @ 符号分隔。\n\n例如，在alice@leetcode.com中，alice是本地名称，而leetcode.com是域名。\n\n除了小写字母，这些电子邮件还可能包含 '.' 或 '+'。\n\n如果在电子邮件地址的本地名称部分中的某些字符之间添加句点（'.'），则发往那里的邮件将会转发到本地名称中没有点的同一地址。例如，\"alice.z@leetcode.com” 和 “alicez@leetcode.com”会转发到同一电子邮件地址。 （请注意，此规则不适用于域名。）\n\n如果在本地名称中添加加号（'+'），则会忽略第一个加号后面的所有内容。这允许过滤某些电子邮件，例如 m.y+name@email.com 将转发到 my@email.com。 （同样，此规则不适用于域名。）\n\n可以同时使用这两个规则。\n\n给定电子邮件列表 emails，我们会向列表中的每个地址发送一封电子邮件。实际收到邮件的不同地址有多少？\n\n\n\n示例：\n\n输入：[\"test.email+alex@leetcode.com\",\"test.e.mail+bob.cathy@leetcode.com\",\"testemail+david@lee.tcode.com\"]\n输出：2\n解释：实际收到邮件的是 \"testemail@leetcode.com\" 和 \"testemail@lee.tcode.com\"。\n\n\n\n\n提示：\n\n * 1 <= emails[i].length <= 100\n * 1 <= emails.length <= 100\n * 每封 emails[i] 都包含有且仅有一个 '@' 字符。\n\n# 通过代码\nclass Solution {\n    public int numUniqueEmails(String[] emails) {\n        if (emails == null || emails.length==0){\n                return 0;\n            }\n            HashSet<String> set=new HashSet<String>();\n            for (int i = 0; i < emails.length; i++) {\n                String str=emails[i].substring(0,emails[i].indexOf('@'));\n                int pos=str.indexOf('+');\n                if (pos!=-1){\n                    str=emails[i].substring(0,pos);\n                }\n                if (str.indexOf('.')!=-1){\n                    str=str.replaceAll(\"\\\\.\",\"\");\n                }\n                str+=emails[i].substring(emails[i].indexOf('@'));\n                set.add(str);\n            }\n            return set.size();\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n# 官方题解\n# 方法一：规范化表示\n对于每个电子邮件地址，我们求出它的规范化表示（即根据 '.' 和 '+' 的规则进行处理后得到的，本地名称中仅包含小写字母的电子邮件地址）。我们对每一个地址依次进行如下的操作：\n\n * 将电子邮件地址根据 '@' 分成本地名称和域名两部分，其中域名部分包含 '@'，且不需要进行额外的处理；\n   \n   \n * 如果本地名称中有 '+'，那么移除 '+' 以及它后面出现的所有字符；\n   \n   \n * 移除本地名称中的所有 '.'；\n   \n   \n * 处理完成的本地名称和域名进行连接，得到电子邮件地址的规范化表示。\n   \n   \n\n在得到了所有电子邮件地址的规范化表示后，我们将它们放入集合（set）中，就可以获知不同地址的数目。\n\nclass Solution {\n    public int numUniqueEmails(String[] emails) {\n        Set<String> seen = new HashSet();\n        for (String email: emails) {\n            int i = email.indexOf('@');\n            String local = email.substring(0, i);\n            String rest = email.substring(i);\n            if (local.contains(\"+\")) {\n                local = local.substring(0, local.indexOf('+'));\n            }\n            local = local.replaceAll(\".\", \"\");\n            seen.add(local + rest);\n        }\n\n        return seen.size();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\nclass Solution(object):\n    def numUniqueEmails(self, emails):\n        seen = set()\n        for email in emails:\n            local, domain = email.split('@')\n            if '+' in local:\n                local = local[:local.index('+')]\n            seen.add(local.replace('.','') + '@' + domain)\n        return len(seen)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n复杂度分析\n\n * 时间复杂度：O(C)O(C)O(C)，其中 CCC 是电子邮件地址的数目。\n   \n   \n * 空间复杂度：O(C)O(C)O(C)。\n   \n   \n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-12-16 23:28:05Accepted [https://leetcode-cn.com//submissions/detail/10534027/]75 ms5.1%35.4 MBjava# 统计信息\n通过次数提交次数AC比率136202132763.9%",contentLowercase:"# 中文题目\n每封电子邮件都由一个本地名称和一个域名组成，以 @ 符号分隔。\n\n例如，在alice@leetcode.com中，alice是本地名称，而leetcode.com是域名。\n\n除了小写字母，这些电子邮件还可能包含 '.' 或 '+'。\n\n如果在电子邮件地址的本地名称部分中的某些字符之间添加句点（'.'），则发往那里的邮件将会转发到本地名称中没有点的同一地址。例如，\"alice.z@leetcode.com” 和 “alicez@leetcode.com”会转发到同一电子邮件地址。 （请注意，此规则不适用于域名。）\n\n如果在本地名称中添加加号（'+'），则会忽略第一个加号后面的所有内容。这允许过滤某些电子邮件，例如 m.y+name@email.com 将转发到 my@email.com。 （同样，此规则不适用于域名。）\n\n可以同时使用这两个规则。\n\n给定电子邮件列表 emails，我们会向列表中的每个地址发送一封电子邮件。实际收到邮件的不同地址有多少？\n\n\n\n示例：\n\n输入：[\"test.email+alex@leetcode.com\",\"test.e.mail+bob.cathy@leetcode.com\",\"testemail+david@lee.tcode.com\"]\n输出：2\n解释：实际收到邮件的是 \"testemail@leetcode.com\" 和 \"testemail@lee.tcode.com\"。\n\n\n\n\n提示：\n\n * 1 <= emails[i].length <= 100\n * 1 <= emails.length <= 100\n * 每封 emails[i] 都包含有且仅有一个 '@' 字符。\n\n# 通过代码\nclass solution {\n    public int numuniqueemails(string[] emails) {\n        if (emails == null || emails.length==0){\n                return 0;\n            }\n            hashset<string> set=new hashset<string>();\n            for (int i = 0; i < emails.length; i++) {\n                string str=emails[i].substring(0,emails[i].indexof('@'));\n                int pos=str.indexof('+');\n                if (pos!=-1){\n                    str=emails[i].substring(0,pos);\n                }\n                if (str.indexof('.')!=-1){\n                    str=str.replaceall(\"\\\\.\",\"\");\n                }\n                str+=emails[i].substring(emails[i].indexof('@'));\n                set.add(str);\n            }\n            return set.size();\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n# 官方题解\n# 方法一：规范化表示\n对于每个电子邮件地址，我们求出它的规范化表示（即根据 '.' 和 '+' 的规则进行处理后得到的，本地名称中仅包含小写字母的电子邮件地址）。我们对每一个地址依次进行如下的操作：\n\n * 将电子邮件地址根据 '@' 分成本地名称和域名两部分，其中域名部分包含 '@'，且不需要进行额外的处理；\n   \n   \n * 如果本地名称中有 '+'，那么移除 '+' 以及它后面出现的所有字符；\n   \n   \n * 移除本地名称中的所有 '.'；\n   \n   \n * 处理完成的本地名称和域名进行连接，得到电子邮件地址的规范化表示。\n   \n   \n\n在得到了所有电子邮件地址的规范化表示后，我们将它们放入集合（set）中，就可以获知不同地址的数目。\n\nclass solution {\n    public int numuniqueemails(string[] emails) {\n        set<string> seen = new hashset();\n        for (string email: emails) {\n            int i = email.indexof('@');\n            string local = email.substring(0, i);\n            string rest = email.substring(i);\n            if (local.contains(\"+\")) {\n                local = local.substring(0, local.indexof('+'));\n            }\n            local = local.replaceall(\".\", \"\");\n            seen.add(local + rest);\n        }\n\n        return seen.size();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\nclass solution(object):\n    def numuniqueemails(self, emails):\n        seen = set()\n        for email in emails:\n            local, domain = email.split('@')\n            if '+' in local:\n                local = local[:local.index('+')]\n            seen.add(local.replace('.','') + '@' + domain)\n        return len(seen)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n复杂度分析\n\n * 时间复杂度：o(c)o(c)o(c)，其中 ccc 是电子邮件地址的数目。\n   \n   \n * 空间复杂度：o(c)o(c)o(c)。\n   \n   \n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2018-12-16 23:28:05accepted [https://leetcode-cn.com//submissions/detail/10534027/]75 ms5.1%35.4 mbjava# 统计信息\n通过次数提交次数ac比率136202132763.9%"},{title:"941-有效的山脉数组(Valid Mountain Array)",frontmatter:{title:"941-有效的山脉数组(Valid Mountain Array)",date:"2020-01-03T00:00:00.000Z",categories:["简单"],tags:["数组<Array>"]},regularPath:"/views/%E7%AE%80%E5%8D%95/0941-%E6%9C%89%E6%95%88%E7%9A%84%E5%B1%B1%E8%84%89%E6%95%B0%E7%BB%84.html",relativePath:"views/简单/0941-有效的山脉数组.md",key:"v-75e2436c",path:"/views/%E7%AE%80%E5%8D%95/0941-%E6%9C%89%E6%95%88%E7%9A%84%E5%B1%B1%E8%84%89%E6%95%B0%E7%BB%84.html",headers:[{level:2,title:"中文题目",slug:"中文题目",charIndex:2},{level:2,title:"通过代码",slug:"通过代码",charIndex:373},{level:2,title:"官方题解",slug:"官方题解",charIndex:934},{level:2,title:"提交历史",slug:"提交历史",charIndex:2094},{level:2,title:"统计信息",slug:"统计信息",charIndex:2327}],lastUpdated:"4/11/2021, 1:15:21 PM",headersStr:"中文题目 通过代码 官方题解 提交历史 统计信息",content:"# 中文题目\n给定一个整数数组A，如果它是有效的山脉数组就返回true，否则返回 false。\n\n让我们回顾一下，如果 A 满足下述条件，那么它是一个山脉数组：\n\n * A.length >= 3\n * 在0 < i < A.length - 1条件下，存在i使得： * A[0] < A[1] < ... A[i-1] < A[i] \n    * A[i] > A[i+1] > ... > A[B.length - 1]\n   \n   \n\n\n\n示例 1：\n\n输入：[2,1]\n输出：false\n\n\n示例 2：\n\n输入：[3,5,5]\n输出：false\n\n\n示例 3：\n\n输入：[0,3,2,1]\n输出：true\n\n\n\n提示：\n\n 1. 0 <= A.length <= 10000\n 2. 0 <= A[i] <= 10000\n\n\n\n\n\n# 通过代码\nclass Solution {\n    public boolean validMountainArray(int[] A) {\n        if (A.length < 3) {\n            return false;\n        }\n        int tempPos = 0;\n        for (int i = 1; i < A.length; i++) {\n            if (A[i] <= A[i - 1]) {\n                tempPos = i-1;\n                break;\n            }\n        }\n        for (int i = A.length - 1; i > tempPos; i--) {\n            if (A[i] >= A[i - 1]) {\n                return false;\n            }\n        }\n        return tempPos==0?false:true;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n# 官方题解\n# 方法一：线性扫描\n我们从数组的最左侧开始扫描，直到找到第一个不满足 A[i] < A[i + 1] 的 i，那么 i 就是这个数组的最高点。如果 i = 0 或者不存在这样的 i（即整个数组都是单调递增的），那么就返回 false。否则从 i 开始继续扫描，判断接下来的的位置 j 是否都满足 A[j] > A[j + 1]，若都满足就返回 true，否则返回 false。\n\nclass Solution {\n    public boolean validMountainArray(int[] A) {\n        int N = A.length;\n        int i = 0;\n\n        // walk up\n        while (i+1 < N && A[i] < A[i+1])\n            i++;\n\n        // peak can't be first or last\n        if (i == 0 || i == N-1)\n            return false;\n\n        // walk down\n        while (i+1 < N && A[i] > A[i+1])\n            i++;\n\n        return i == N-1;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\nclass Solution(object):\n    def validMountainArray(self, A):\n        N = len(A)\n        i = 0\n\n        # walk up\n        while i+1 < N and A[i] < A[i+1]:\n            i += 1\n\n        # peak can't be first or last\n        if i == 0 or i == N-1:\n            return False\n\n        # walk down\n        while i+1 < N and A[i] > A[i+1]:\n            i += 1\n\n        return i == N-1\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n复杂度分析\n\n * 时间复杂度：O(N)O(N)O(N)，其中 NNN 是数组 A 的长度。\n   \n   \n * 空间复杂度：O(1)O(1)O(1)。\n   \n   \n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2020-01-03 23:04:19Accepted [https://leetcode-cn.com//submissions/detail/42197052/]1 ms100.0%40.1 MBjava2020-01-03 22:48:10Wrong Answer [https://leetcode-cn.com//submissions/detail/42195774/]N/AN/AN/Ajava# 统计信息\n通过次数提交次数AC比率66091905834.7%",contentLowercase:"# 中文题目\n给定一个整数数组a，如果它是有效的山脉数组就返回true，否则返回 false。\n\n让我们回顾一下，如果 a 满足下述条件，那么它是一个山脉数组：\n\n * a.length >= 3\n * 在0 < i < a.length - 1条件下，存在i使得： * a[0] < a[1] < ... a[i-1] < a[i] \n    * a[i] > a[i+1] > ... > a[b.length - 1]\n   \n   \n\n\n\n示例 1：\n\n输入：[2,1]\n输出：false\n\n\n示例 2：\n\n输入：[3,5,5]\n输出：false\n\n\n示例 3：\n\n输入：[0,3,2,1]\n输出：true\n\n\n\n提示：\n\n 1. 0 <= a.length <= 10000\n 2. 0 <= a[i] <= 10000\n\n\n\n\n\n# 通过代码\nclass solution {\n    public boolean validmountainarray(int[] a) {\n        if (a.length < 3) {\n            return false;\n        }\n        int temppos = 0;\n        for (int i = 1; i < a.length; i++) {\n            if (a[i] <= a[i - 1]) {\n                temppos = i-1;\n                break;\n            }\n        }\n        for (int i = a.length - 1; i > temppos; i--) {\n            if (a[i] >= a[i - 1]) {\n                return false;\n            }\n        }\n        return temppos==0?false:true;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n# 官方题解\n# 方法一：线性扫描\n我们从数组的最左侧开始扫描，直到找到第一个不满足 a[i] < a[i + 1] 的 i，那么 i 就是这个数组的最高点。如果 i = 0 或者不存在这样的 i（即整个数组都是单调递增的），那么就返回 false。否则从 i 开始继续扫描，判断接下来的的位置 j 是否都满足 a[j] > a[j + 1]，若都满足就返回 true，否则返回 false。\n\nclass solution {\n    public boolean validmountainarray(int[] a) {\n        int n = a.length;\n        int i = 0;\n\n        // walk up\n        while (i+1 < n && a[i] < a[i+1])\n            i++;\n\n        // peak can't be first or last\n        if (i == 0 || i == n-1)\n            return false;\n\n        // walk down\n        while (i+1 < n && a[i] > a[i+1])\n            i++;\n\n        return i == n-1;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\nclass solution(object):\n    def validmountainarray(self, a):\n        n = len(a)\n        i = 0\n\n        # walk up\n        while i+1 < n and a[i] < a[i+1]:\n            i += 1\n\n        # peak can't be first or last\n        if i == 0 or i == n-1:\n            return false\n\n        # walk down\n        while i+1 < n and a[i] > a[i+1]:\n            i += 1\n\n        return i == n-1\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n复杂度分析\n\n * 时间复杂度：o(n)o(n)o(n)，其中 nnn 是数组 a 的长度。\n   \n   \n * 空间复杂度：o(1)o(1)o(1)。\n   \n   \n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2020-01-03 23:04:19accepted [https://leetcode-cn.com//submissions/detail/42197052/]1 ms100.0%40.1 mbjava2020-01-03 22:48:10wrong answer [https://leetcode-cn.com//submissions/detail/42195774/]n/an/an/ajava# 统计信息\n通过次数提交次数ac比率66091905834.7%"},{title:"1051-高度检查器(Height Checker)",frontmatter:{title:"1051-高度检查器(Height Checker)",date:"2020-02-10T00:00:00.000Z",categories:["简单"],tags:["数组<Array>"]},regularPath:"/views/%E7%AE%80%E5%8D%95/1051-%E9%AB%98%E5%BA%A6%E6%A3%80%E6%9F%A5%E5%99%A8.html",relativePath:"views/简单/1051-高度检查器.md",key:"v-6d5a9f28",path:"/views/%E7%AE%80%E5%8D%95/1051-%E9%AB%98%E5%BA%A6%E6%A3%80%E6%9F%A5%E5%99%A8.html",headers:[{level:2,title:"中文题目",slug:"中文题目",charIndex:2},{level:2,title:"通过代码",slug:"通过代码",charIndex:181},{level:2,title:"我的笔记",slug:"我的笔记",charIndex:659},{level:2,title:"高赞题解",slug:"高赞题解",charIndex:724},{level:3,title:"分析:",slug:"分析",charIndex:731},{level:3,title:"我们真的需要排序吗？",slug:"我们真的需要排序吗？",charIndex:826},{level:3,title:"计数算法:",slug:"计数算法",charIndex:1019},{level:3,title:"复杂度分析:",slug:"复杂度分析",charIndex:1450},{level:3,title:"运行结果:",slug:"运行结果",charIndex:1630},{level:2,title:"提交历史",slug:"提交历史",charIndex:1724},{level:2,title:"统计信息",slug:"统计信息",charIndex:1958}],lastUpdated:"4/11/2021, 1:15:21 PM",headersStr:"中文题目 通过代码 我的笔记 高赞题解 分析: 我们真的需要排序吗？ 计数算法: 复杂度分析: 运行结果: 提交历史 统计信息",content:"# 中文题目\n学校在拍年度纪念照时，一般要求学生按照 非递减 的高度顺序排列。\n\n请你返回能让所有学生以 非递减 高度排列的最小必要移动人数。\n\n\n\n示例：\n\n输入：heights = [1,1,4,2,1,3]\n输出：3\n\n\n\n提示：\n\n 1. 1 <= heights.length <= 100\n 2. 1 <= heights[i] <= 100\n\n# 通过代码\nclass Solution {\n    // 类似采用桶排序\n    public int heightChecker(int[] heights) {\n        int[] arr=new int[101];\n        for (int i : heights) {\n            arr[i]++;\n        }\n\n        int total=0;\n        for (int i = 1,j=0;j < heights.length; i++) {\n\n            while (arr[i]--\x3e0){\n                if (heights[j++]!=i){\n                    total++;\n                }\n            }\n        }\n        return total;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n# 我的笔记\n类似采用桶排序，现将相同的元素放到一个桶中，将桶中的元素逐个取出去和heights进行比较，不同的则需要进行交换\n\n# 高赞题解\n# 分析:\n非递减 排序也就是升序排列，最直观的一种解法就是排序后对比计数每个位置的不同数量。\n但是涉及到比较排序，时间复杂度最低也有 O(NlogN)O(NlogN)O(NlogN)。\n\n# 我们真的需要排序吗？\n首先我们其实并不关心排序后得到的结果，我们想知道的只是在该位置上，与最小的值是否一致 题目中已经明确了值的范围 1 <= heights[i] <= 100\n这是一个在固定范围内的输入，比如输入： [1,1,4,2,1,3]\n输入中有 3 个 1,1 个 2，1 个 3 和 1 个 4，3 个 1 肯定会在前面，依次类推\n所以，我们需要的仅仅只是计数而已\n\n# 计数算法:\nclass Solution {\n    public int heightChecker(int[] heights) {\n        int[] arr = new int[101];\n        for (int height : heights) {\n            arr[height]++;\n        }\n        int count = 0;\n        for (int i = 1, j = 0; i < arr.length; i++) {\n            while (arr[i]-- > 0) {\n                if (heights[j++] != i) count++;\n            }\n        }\n        return count;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n# 复杂度分析:\n时间复杂度：O(n)O(n)O(n) ，计数过程为 O(n)O(n)O(n)，比较过程外层循环次数固定为 100，里层循环一共也只会执行 nnn 次，O(100+n)O(100+n)O(100+n)，即 O(n)O(n)O(n)\n空间复杂度：O(1)O(1)O(1) ，其中一个固定长度的计数数组与一个统计变量，与输入 NNN 的大小无关\n\n# 运行结果:\n执行用时 : 1 ms, 在所有 Java 提交中击败了 100.00% 的用户\n内存消耗 : 34.3 MB, 在所有 Java 提交中击败了 100.00% 的用户\n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2020-02-10 20:55:14Accepted [https://leetcode-cn.com//submissions/detail/46615857/]0 ms100.0%40.4 MBjava2020-02-10 20:54:37Runtime Error [https://leetcode-cn.com//submissions/detail/46615743/]N/AN/AN/Ajava# 统计信息\n通过次数提交次数AC比率111981546172.4%",contentLowercase:"# 中文题目\n学校在拍年度纪念照时，一般要求学生按照 非递减 的高度顺序排列。\n\n请你返回能让所有学生以 非递减 高度排列的最小必要移动人数。\n\n\n\n示例：\n\n输入：heights = [1,1,4,2,1,3]\n输出：3\n\n\n\n提示：\n\n 1. 1 <= heights.length <= 100\n 2. 1 <= heights[i] <= 100\n\n# 通过代码\nclass solution {\n    // 类似采用桶排序\n    public int heightchecker(int[] heights) {\n        int[] arr=new int[101];\n        for (int i : heights) {\n            arr[i]++;\n        }\n\n        int total=0;\n        for (int i = 1,j=0;j < heights.length; i++) {\n\n            while (arr[i]--\x3e0){\n                if (heights[j++]!=i){\n                    total++;\n                }\n            }\n        }\n        return total;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n# 我的笔记\n类似采用桶排序，现将相同的元素放到一个桶中，将桶中的元素逐个取出去和heights进行比较，不同的则需要进行交换\n\n# 高赞题解\n# 分析:\n非递减 排序也就是升序排列，最直观的一种解法就是排序后对比计数每个位置的不同数量。\n但是涉及到比较排序，时间复杂度最低也有 o(nlogn)o(nlogn)o(nlogn)。\n\n# 我们真的需要排序吗？\n首先我们其实并不关心排序后得到的结果，我们想知道的只是在该位置上，与最小的值是否一致 题目中已经明确了值的范围 1 <= heights[i] <= 100\n这是一个在固定范围内的输入，比如输入： [1,1,4,2,1,3]\n输入中有 3 个 1,1 个 2，1 个 3 和 1 个 4，3 个 1 肯定会在前面，依次类推\n所以，我们需要的仅仅只是计数而已\n\n# 计数算法:\nclass solution {\n    public int heightchecker(int[] heights) {\n        int[] arr = new int[101];\n        for (int height : heights) {\n            arr[height]++;\n        }\n        int count = 0;\n        for (int i = 1, j = 0; i < arr.length; i++) {\n            while (arr[i]-- > 0) {\n                if (heights[j++] != i) count++;\n            }\n        }\n        return count;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n# 复杂度分析:\n时间复杂度：o(n)o(n)o(n) ，计数过程为 o(n)o(n)o(n)，比较过程外层循环次数固定为 100，里层循环一共也只会执行 nnn 次，o(100+n)o(100+n)o(100+n)，即 o(n)o(n)o(n)\n空间复杂度：o(1)o(1)o(1) ，其中一个固定长度的计数数组与一个统计变量，与输入 nnn 的大小无关\n\n# 运行结果:\n执行用时 : 1 ms, 在所有 java 提交中击败了 100.00% 的用户\n内存消耗 : 34.3 mb, 在所有 java 提交中击败了 100.00% 的用户\n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2020-02-10 20:55:14accepted [https://leetcode-cn.com//submissions/detail/46615857/]0 ms100.0%40.4 mbjava2020-02-10 20:54:37runtime error [https://leetcode-cn.com//submissions/detail/46615743/]n/an/an/ajava# 统计信息\n通过次数提交次数ac比率111981546172.4%"},{title:"876-链表的中间结点(Middle of the Linked List)",frontmatter:{title:"876-链表的中间结点(Middle of the Linked List)",date:"2021-05-06T00:00:00.000Z",categories:["简单"],tags:["链表<Linked List>"]},regularPath:"/views/%E7%AE%80%E5%8D%95/0876-%E9%93%BE%E8%A1%A8%E7%9A%84%E4%B8%AD%E9%97%B4%E7%BB%93%E7%82%B9.html",relativePath:"views/简单/0876-链表的中间结点.md",key:"v-638027b4",path:"/views/%E7%AE%80%E5%8D%95/0876-%E9%93%BE%E8%A1%A8%E7%9A%84%E4%B8%AD%E9%97%B4%E7%BB%93%E7%82%B9.html",headers:[{level:2,title:"中文题目",slug:"中文题目",charIndex:2},{level:2,title:"通过代码",slug:"通过代码",charIndex:397},{level:2,title:"高赞题解",slug:"高赞题解",charIndex:1004},{level:2,title:"提交历史",slug:"提交历史",charIndex:6611},{level:2,title:"统计信息",slug:"统计信息",charIndex:6745}],headersStr:"中文题目 通过代码 高赞题解 提交历史 统计信息",content:"# 中文题目\n给定一个头结点为 head的非空单链表，返回链表的中间结点。\n\n如果有两个中间结点，则返回第二个中间结点。\n\n\n\n示例 1：\n\n\n输入：[1,2,3,4,5]\n输出：此列表中的结点 3 (序列化形式：[3,4,5])\n返回的结点值为 3 。 (测评系统对该结点序列化表述是 [3,4,5])。\n注意，我们返回了一个 ListNode 类型的对象 ans，这样：\nans.val = 3, ans.next.val = 4, ans.next.next.val = 5, 以及 ans.next.next.next = NULL.\n\n\n示例 2：\n\n\n输入：[1,2,3,4,5,6]\n输出：此列表中的结点 4 (序列化形式：[4,5,6])\n由于该列表有两个中间结点，值分别为 3 和 4，我们返回第二个结点。\n\n\n\n\n提示：\n\n * 给定链表的结点数介于1和100之间。\n\n# 通过代码\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public ListNode middleNode(ListNode head) {\n        ListNode fast=head;\n        ListNode slow=head;\n        while (true){\n            if (fast.next==null){\n                return slow;\n            }\n            if (fast.next.next==null) {\n                return slow.next;\n            }\n            slow=slow.next;\n            fast=fast.next.next;\n        }\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n# 高赞题解\n朴素解法：这道题最朴素的做法是，先遍历一次，计算链表的长度，进而计算链表中间结点的下标（注意偶数结点的时候，得到的是中间的第二个结点），然后再遍历一次，来到所要求结点的位置。\n\n缺点：\n\n * 必须先遍历完整个链表，然后才可以「干正事」，再遍历到一半，找到中间结点；\n * 在链表的长度很长的时候，这种方法之前的等待会很久。\n\n快慢指针：比较经典的做法是：\n\n * 使用两个指针变量，刚开始都位于链表的第 1 个结点，一个永远一次只走 1 步，一个永远一次只走 2 步，一个在前，一个在后，同时走。这样当快指针走完的时候，慢指针就来到了链表的中间位置。\n\n思想是：快慢指针的前进方向相同，且它们步伐的「差」是恒定的，根据这种确定性去解决链表中的一些问题。使用这种思想还可以解决链表的以下问题：\n\n * 「力扣」第 19 题： 倒数第 k 个结点 [https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/]，快指针先走几步，不是靠猜的，要在纸上画图模拟一下，就清楚了；\n * 「力扣」第 141 题：环形链表 [https://leetcode-cn.com/problems/linked-list-cycle/]，在环中的时候可以想象，A 同学开始有存款 100 元，每天赚 1 元，B 同学开始有存款 50 元，每天赚 2 元，B 同学一定会在某一天和 A 同学的存款一样；\n * 「力扣」第 142 题：环形链表 II [https://leetcode-cn.com/problems/linked-list-cycle-ii/]；\n * 「力扣」第 161 题：相交链表 [https://leetcode-cn.com/problems/intersection-of-two-linked-lists/]，起点不同，构造相同长度让它们相遇，同样是利用了同步走这个等量关系。\n\n解决这些问题的共同特点就是使用两个指针变量同步移动。解决链表的问题常见的技巧还有：\n\n * 1、使用递归函数，避免复杂的更改指针变量指向操作，使得求解问题变得简单。 * 「力扣」第 206 题：反转链表 [https://leetcode-cn.com/problems/reverse-linked-list]；\n    * 「力扣」第 24 题：两两交换链表中的节点 [https://leetcode-cn.com/problems/swap-nodes-in-pairs]；\n    * 「力扣」第 25 题：K 个一组翻转链表 [https://leetcode-cn.com/problems/reverse-nodes-in-k-group]；\n    * 「力扣」第 328 题：奇偶链表 [https://leetcode-cn.com/problems/odd-even-linked-list]；\n    * 「力扣」第 203 题：移除链表元素 [https://leetcode-cn.com/problems/remove-linked-list-elements/]；\n    * 「力扣」第 21 题：合并两个有序链表 [https://leetcode-cn.com/problems/merge-two-sorted-lists/]。\n   \n   \n * 2、设置「虚拟头结点」，避免对链表第 1 个结点做单独讨论，这个思想在数组里我们见过，叫「哨兵」； * 「力扣」第 2 题：两数相加 [https://leetcode-cn.com/problems/add-two-numbers]；\n    * 「力扣」第 82 题：删除排序链表中的重复元素 II [https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/]。\n   \n   \n * 3、使用「快慢指针」，本题就是。确切地说，叫「同步指针」可能更好一些；\n * 4、为链表编写测试函数，进行调试（在下面的参考代码中有），主要是： * 从数组得到一个链表；\n    * 根据当前结点打印当前结点以及后面的结点。 这两个方法可以非常方便地帮助我们调试关于链表的程序。\n   \n   \n\n大家还可以在「力扣」的新手场：「探索」 [https://leetcode-cn.com/explore/learn/card/linked-list/] 板块里，学习链表的相关知识和问题。「力扣」上的链表问题，和我们在教科书里学习的链表是有一点点不一样的，「力扣」的链表是以结点类 ListNode 为中心进行编程。而一般教科书上则是将 ListNode 作为链表的内部类进行编程，差别就是这些。其它处理链表问题的技巧是完全一样的。\n\n打草稿很重要：链表问题在「力扣」上是相对较少，并且题目类型和解题技巧相对固定的问题，相信通过刷题和总结，我们是可以把链表问题全部掌握的。\n\n并且思考链表问题的第 1 步，和「回溯算法」一样，绝大多数时候在草稿纸上写写画画就能得到解决链表问题的办法，特别是在链表中做一些更改指针变量指向操作的问题。\n\n注意：这里要注意一个细节：题目要求：「两个中间结点的时候，返回第二个中间结点」。此时可以在草稿纸上写写画画，就拿自己的左右手的两根指头同步移动，可以得出：快指针可以前进的条件是：当前快指针和当前快指针的下一个结点都非空。\n\n在有些问题，例如「力扣」第 148 题：排序链表 [https://leetcode-cn.com/problems/sort-list/]，是需要来到链表的第一个中间结点，然后切断链表，这时代码就得做小的调整。具体是怎么写的，不能靠猜，依然是要在纸上模拟一下这个「快慢指针同步走」的过程，就很清楚了（不过第 148 题的本来意思不是让我们从中间二分递归去做）。\n\n结论：如果题目要求「在两个中间结点的时候，返回第一个中间结点」，此时快指针可以前进的条件是：当前快指针的下一个结点和当前快指针的下下一个结点都非空。\n\n注意体会以上二者的不同之处。\n\n\n\n说明：图例中使用了 Python 语言的写法，例如 while fast 在 fast 变量不是空结点的时候，返回 True，写成 while fast is not None 是语义更清晰的写法，但由于约定，且这种写法非常常见，我们就简写了。\n\n参考代码 1：\n\nclass ListNode {\n    int val;\n    ListNode next;\n\n    ListNode(int x) {\n        val = x;\n    }\n\n    public ListNode(int[] nums) {\n        if (nums == null || nums.length == 0) {\n            throw new IllegalArgumentException(\"arr can not be empty\");\n        }\n        this.val = nums[0];\n        ListNode curr = this;\n        for (int i = 1; i < nums.length; i++) {\n            curr.next = new ListNode(nums[i]);\n            curr = curr.next;\n        }\n    }\n\n    @Override\n    public String toString() {\n        StringBuilder s = new StringBuilder();\n        ListNode cur = this;\n        while (cur != null) {\n            s.append(cur.val);\n            s.append(\" -> \");\n            cur = cur.next;\n        }\n        s.append(\"NULL\");\n        return s.toString();\n    }\n}\n\npublic class Solution {\n\n    public ListNode middleNode(ListNode head) {\n        if (head == null) {\n            return null;\n        }\n        ListNode slow = head;\n        ListNode fast = head;\n\n        while (fast != null && fast.next != null) {\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        return slow;\n    }\n\n    public static void main(String[] args) {\n        int[] arr = new int[]{1, 2, 3, 4, 5, 6};\n        // int[] arr = new int[]{1, 2, 3, 4, 5};\n        ListNode head = new ListNode(arr);\n        Solution solution = new Solution();\n        ListNode res = solution.middleNode(head);\n        System.out.println(res);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\n\nclass Solution:\n    def middleNode(self, head: ListNode) -> ListNode:\n        if head is None:\n            return None\n\n        slow = head\n        fast = head\n\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        return slow\n\n\ndef create_linked_list(nums):\n    if len(nums) == 0:\n        return None\n    head = ListNode(nums[0])\n    cur = head\n    for i in range(1, len(nums)):\n        cur.next = ListNode(nums[i])\n        cur = cur.next\n    return head\n\n\ndef print_linked_list(list_node):\n    if list_node is None:\n        return\n\n    cur = list_node\n    while cur:\n        print(cur.val, '->', end=' ')\n        cur = cur.next\n    print('null')\n\n\nif __name__ == '__main__':\n    # nums = [1, 2, 3, 4, 5, 6, 7]\n    nums = [1, 2, 3, 4, 5, 6, 7, 8]\n    head = create_linked_list(nums)\n    solution = Solution()\n    result = solution.middleNode(head)\n    print('结果：')\n    print_linked_list(result)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n复杂度分析：\n\n * 时间复杂度：O(N)O(N)O(N)，NNN 是链表的长度，快指针变量需要遍历完整个链表，因此最多走 NNN 步；\n * 空间复杂度：O(1)O(1)O(1)。\n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2021-05-06 21:14:01Accepted [https://leetcode-cn.com//submissions/detail/174905654/]0 ms100.0%35.6 MBjava# 统计信息\n通过次数提交次数AC比率10454514931470.0%",contentLowercase:"# 中文题目\n给定一个头结点为 head的非空单链表，返回链表的中间结点。\n\n如果有两个中间结点，则返回第二个中间结点。\n\n\n\n示例 1：\n\n\n输入：[1,2,3,4,5]\n输出：此列表中的结点 3 (序列化形式：[3,4,5])\n返回的结点值为 3 。 (测评系统对该结点序列化表述是 [3,4,5])。\n注意，我们返回了一个 listnode 类型的对象 ans，这样：\nans.val = 3, ans.next.val = 4, ans.next.next.val = 5, 以及 ans.next.next.next = null.\n\n\n示例 2：\n\n\n输入：[1,2,3,4,5,6]\n输出：此列表中的结点 4 (序列化形式：[4,5,6])\n由于该列表有两个中间结点，值分别为 3 和 4，我们返回第二个结点。\n\n\n\n\n提示：\n\n * 给定链表的结点数介于1和100之间。\n\n# 通过代码\n/**\n * definition for singly-linked list.\n * public class listnode {\n *     int val;\n *     listnode next;\n *     listnode(int x) { val = x; }\n * }\n */\nclass solution {\n    public listnode middlenode(listnode head) {\n        listnode fast=head;\n        listnode slow=head;\n        while (true){\n            if (fast.next==null){\n                return slow;\n            }\n            if (fast.next.next==null) {\n                return slow.next;\n            }\n            slow=slow.next;\n            fast=fast.next.next;\n        }\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n# 高赞题解\n朴素解法：这道题最朴素的做法是，先遍历一次，计算链表的长度，进而计算链表中间结点的下标（注意偶数结点的时候，得到的是中间的第二个结点），然后再遍历一次，来到所要求结点的位置。\n\n缺点：\n\n * 必须先遍历完整个链表，然后才可以「干正事」，再遍历到一半，找到中间结点；\n * 在链表的长度很长的时候，这种方法之前的等待会很久。\n\n快慢指针：比较经典的做法是：\n\n * 使用两个指针变量，刚开始都位于链表的第 1 个结点，一个永远一次只走 1 步，一个永远一次只走 2 步，一个在前，一个在后，同时走。这样当快指针走完的时候，慢指针就来到了链表的中间位置。\n\n思想是：快慢指针的前进方向相同，且它们步伐的「差」是恒定的，根据这种确定性去解决链表中的一些问题。使用这种思想还可以解决链表的以下问题：\n\n * 「力扣」第 19 题： 倒数第 k 个结点 [https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/]，快指针先走几步，不是靠猜的，要在纸上画图模拟一下，就清楚了；\n * 「力扣」第 141 题：环形链表 [https://leetcode-cn.com/problems/linked-list-cycle/]，在环中的时候可以想象，a 同学开始有存款 100 元，每天赚 1 元，b 同学开始有存款 50 元，每天赚 2 元，b 同学一定会在某一天和 a 同学的存款一样；\n * 「力扣」第 142 题：环形链表 ii [https://leetcode-cn.com/problems/linked-list-cycle-ii/]；\n * 「力扣」第 161 题：相交链表 [https://leetcode-cn.com/problems/intersection-of-two-linked-lists/]，起点不同，构造相同长度让它们相遇，同样是利用了同步走这个等量关系。\n\n解决这些问题的共同特点就是使用两个指针变量同步移动。解决链表的问题常见的技巧还有：\n\n * 1、使用递归函数，避免复杂的更改指针变量指向操作，使得求解问题变得简单。 * 「力扣」第 206 题：反转链表 [https://leetcode-cn.com/problems/reverse-linked-list]；\n    * 「力扣」第 24 题：两两交换链表中的节点 [https://leetcode-cn.com/problems/swap-nodes-in-pairs]；\n    * 「力扣」第 25 题：k 个一组翻转链表 [https://leetcode-cn.com/problems/reverse-nodes-in-k-group]；\n    * 「力扣」第 328 题：奇偶链表 [https://leetcode-cn.com/problems/odd-even-linked-list]；\n    * 「力扣」第 203 题：移除链表元素 [https://leetcode-cn.com/problems/remove-linked-list-elements/]；\n    * 「力扣」第 21 题：合并两个有序链表 [https://leetcode-cn.com/problems/merge-two-sorted-lists/]。\n   \n   \n * 2、设置「虚拟头结点」，避免对链表第 1 个结点做单独讨论，这个思想在数组里我们见过，叫「哨兵」； * 「力扣」第 2 题：两数相加 [https://leetcode-cn.com/problems/add-two-numbers]；\n    * 「力扣」第 82 题：删除排序链表中的重复元素 ii [https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/]。\n   \n   \n * 3、使用「快慢指针」，本题就是。确切地说，叫「同步指针」可能更好一些；\n * 4、为链表编写测试函数，进行调试（在下面的参考代码中有），主要是： * 从数组得到一个链表；\n    * 根据当前结点打印当前结点以及后面的结点。 这两个方法可以非常方便地帮助我们调试关于链表的程序。\n   \n   \n\n大家还可以在「力扣」的新手场：「探索」 [https://leetcode-cn.com/explore/learn/card/linked-list/] 板块里，学习链表的相关知识和问题。「力扣」上的链表问题，和我们在教科书里学习的链表是有一点点不一样的，「力扣」的链表是以结点类 listnode 为中心进行编程。而一般教科书上则是将 listnode 作为链表的内部类进行编程，差别就是这些。其它处理链表问题的技巧是完全一样的。\n\n打草稿很重要：链表问题在「力扣」上是相对较少，并且题目类型和解题技巧相对固定的问题，相信通过刷题和总结，我们是可以把链表问题全部掌握的。\n\n并且思考链表问题的第 1 步，和「回溯算法」一样，绝大多数时候在草稿纸上写写画画就能得到解决链表问题的办法，特别是在链表中做一些更改指针变量指向操作的问题。\n\n注意：这里要注意一个细节：题目要求：「两个中间结点的时候，返回第二个中间结点」。此时可以在草稿纸上写写画画，就拿自己的左右手的两根指头同步移动，可以得出：快指针可以前进的条件是：当前快指针和当前快指针的下一个结点都非空。\n\n在有些问题，例如「力扣」第 148 题：排序链表 [https://leetcode-cn.com/problems/sort-list/]，是需要来到链表的第一个中间结点，然后切断链表，这时代码就得做小的调整。具体是怎么写的，不能靠猜，依然是要在纸上模拟一下这个「快慢指针同步走」的过程，就很清楚了（不过第 148 题的本来意思不是让我们从中间二分递归去做）。\n\n结论：如果题目要求「在两个中间结点的时候，返回第一个中间结点」，此时快指针可以前进的条件是：当前快指针的下一个结点和当前快指针的下下一个结点都非空。\n\n注意体会以上二者的不同之处。\n\n\n\n说明：图例中使用了 python 语言的写法，例如 while fast 在 fast 变量不是空结点的时候，返回 true，写成 while fast is not none 是语义更清晰的写法，但由于约定，且这种写法非常常见，我们就简写了。\n\n参考代码 1：\n\nclass listnode {\n    int val;\n    listnode next;\n\n    listnode(int x) {\n        val = x;\n    }\n\n    public listnode(int[] nums) {\n        if (nums == null || nums.length == 0) {\n            throw new illegalargumentexception(\"arr can not be empty\");\n        }\n        this.val = nums[0];\n        listnode curr = this;\n        for (int i = 1; i < nums.length; i++) {\n            curr.next = new listnode(nums[i]);\n            curr = curr.next;\n        }\n    }\n\n    @override\n    public string tostring() {\n        stringbuilder s = new stringbuilder();\n        listnode cur = this;\n        while (cur != null) {\n            s.append(cur.val);\n            s.append(\" -> \");\n            cur = cur.next;\n        }\n        s.append(\"null\");\n        return s.tostring();\n    }\n}\n\npublic class solution {\n\n    public listnode middlenode(listnode head) {\n        if (head == null) {\n            return null;\n        }\n        listnode slow = head;\n        listnode fast = head;\n\n        while (fast != null && fast.next != null) {\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        return slow;\n    }\n\n    public static void main(string[] args) {\n        int[] arr = new int[]{1, 2, 3, 4, 5, 6};\n        // int[] arr = new int[]{1, 2, 3, 4, 5};\n        listnode head = new listnode(arr);\n        solution solution = new solution();\n        listnode res = solution.middlenode(head);\n        system.out.println(res);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\nclass listnode:\n    def __init__(self, x):\n        self.val = x\n        self.next = none\n\n\nclass solution:\n    def middlenode(self, head: listnode) -> listnode:\n        if head is none:\n            return none\n\n        slow = head\n        fast = head\n\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        return slow\n\n\ndef create_linked_list(nums):\n    if len(nums) == 0:\n        return none\n    head = listnode(nums[0])\n    cur = head\n    for i in range(1, len(nums)):\n        cur.next = listnode(nums[i])\n        cur = cur.next\n    return head\n\n\ndef print_linked_list(list_node):\n    if list_node is none:\n        return\n\n    cur = list_node\n    while cur:\n        print(cur.val, '->', end=' ')\n        cur = cur.next\n    print('null')\n\n\nif __name__ == '__main__':\n    # nums = [1, 2, 3, 4, 5, 6, 7]\n    nums = [1, 2, 3, 4, 5, 6, 7, 8]\n    head = create_linked_list(nums)\n    solution = solution()\n    result = solution.middlenode(head)\n    print('结果：')\n    print_linked_list(result)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n复杂度分析：\n\n * 时间复杂度：o(n)o(n)o(n)，nnn 是链表的长度，快指针变量需要遍历完整个链表，因此最多走 nnn 步；\n * 空间复杂度：o(1)o(1)o(1)。\n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2021-05-06 21:14:01accepted [https://leetcode-cn.com//submissions/detail/174905654/]0 ms100.0%35.6 mbjava# 统计信息\n通过次数提交次数ac比率10454514931470.0%"},{title:"1033-移动石子直到连续(Moving Stones Until Consecutive)",frontmatter:{title:"1033-移动石子直到连续(Moving Stones Until Consecutive)",date:"2020-01-01T00:00:00.000Z",categories:["简单"],tags:["脑筋急转弯<Brainteaser>"]},regularPath:"/views/%E7%AE%80%E5%8D%95/1033-%E7%A7%BB%E5%8A%A8%E7%9F%B3%E5%AD%90%E7%9B%B4%E5%88%B0%E8%BF%9E%E7%BB%AD.html",relativePath:"views/简单/1033-移动石子直到连续.md",key:"v-d3e8a800",path:"/views/%E7%AE%80%E5%8D%95/1033-%E7%A7%BB%E5%8A%A8%E7%9F%B3%E5%AD%90%E7%9B%B4%E5%88%B0%E8%BF%9E%E7%BB%AD.html",headers:[{level:2,title:"中文题目",slug:"中文题目",charIndex:2},{level:2,title:"通过代码",slug:"通过代码",charIndex:508},{level:2,title:"高赞题解",slug:"高赞题解",charIndex:2795},{level:2,title:"提交历史",slug:"提交历史",charIndex:3142},{level:2,title:"统计信息",slug:"统计信息",charIndex:3379}],lastUpdated:"4/11/2021, 6:09:39 PM",headersStr:"中文题目 通过代码 高赞题解 提交历史 统计信息",content:"# 中文题目\n三枚石子放置在数轴上，位置分别为 a，b，c。\n\n每一回合，你可以从两端之一拿起一枚石子（位置最大或最小），并将其放入两端之间的任一空闲位置。形式上，假设这三枚石子当前分别位于位置 x, y, z 且 x < y < z。那么就可以从位置 x 或者是位置 z 拿起一枚石子，并将该石子移动到某一整数位置 k 处，其中 x < k < z 且 k != y。\n\n当你无法进行任何移动时，即，这些石子的位置连续时，游戏结束。\n\n要使游戏结束，你可以执行的最小和最大移动次数分别是多少？ 以长度为 2 的数组形式返回答案：answer = [minimum_moves, maximum_moves]\n\n\n\n示例 1：\n\n\n输入：a = 1, b = 2, c = 5\n输出：[1, 2]\n解释：将石子从 5 移动到 4 再移动到 3，或者我们可以直接将石子移动到 3。\n\n\n示例 2：\n\n\n输入：a = 4, b = 3, c = 2\n输出：[0, 0]\n解释：我们无法进行任何移动。\n\n\n\n\n提示：\n\n 1. 1 \n 2. 1 \n 3. 1 \n 4. a != b, b != c, c != a\n\n# 通过代码\nclass Solution {\n    public int[] numMovesStones(int a, int b, int c) {\n        int[] res = new int[2];\n        int[] arr = {a, b, c};\n        Arrays.sort(arr);\n\n        if(arr[1]!=arr[0]+1 || arr[2]!=arr[1]+1) {\n            //只要不是（1，2，5）（1，3，5）这种可以一步就移到的，像（1，4，7）两边都需要往中间移一下就需要2步\n            if(arr[1]==arr[0]+1 || arr[1]==arr[0]+2 || arr[2]==arr[1]+1 || arr[2]==arr[1]+2) {\n                res[0] = 1;\n            } else {\n                res[0] = 2;\n            }\n        }\n        res[1] = arr[2]-arr[0]-2 ;\n        return res;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\nclass Solution {\n    public int[] numMovesStones(int a, int b, int c) {\n        int[] res = new int[2];\n        int[] array = {a, b, c};\n        Arrays.sort(array);\n\n        //两数相差大于1，（1、4、7）就直接挪到中间数旁边，需要一次；两数挨着，就不动\n        res[0] = (array[1] - array[0] == 1 ? 0 : 1) + (array[2] - array[1] == 1 ? 0 : 1);\n        //两数相差等于2，（1、3、5）就直接把另一个数挪中间\n        res[0] = (array[1] - array[0] == 2 || array[2] - array[1] == 2) ? 1 : res[0];\n        //最大值就是两边距离\n        res[1] = array[2] - array[0] - 2;\n\n        return res;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\nclass Solution {\n    public int[] numMovesStones(int a, int b, int c) {\n        int[] res = new int[2];\n        int[] arr = {a, b, c};\n        Arrays.sort(arr);\n\n        if(arr[1]!=arr[0]+1 || arr[2]!=arr[1]+1) {\n            //只要不是（1，2，5）（1，3，5）这种可以一步就移到的，像（1，4，7）两边都需要往中间移一下就需要2步\n            if(arr[1]==arr[0]+1 || arr[1]==arr[0]+2 || arr[2]==arr[1]+1 || arr[2]==arr[1]+2) {\n                res[0] = 1;\n            } else {\n                res[0] = 2;\n            }\n        }\n        res[1] = arr[2]-arr[0]-2 ;\n        return res;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\nclass Solution {\n    public int[] numMovesStones(int a, int b, int c) {\n        int[] res = new int[2];\n        int[] array = {a, b, c};\n        Arrays.sort(array);\n\n        //两数相差大于1，（1、4、7）就直接挪到中间数旁边，需要一次；两数挨着，就不动\n        res[0] = (array[1] - array[0] == 1 ? 0 : 1) + (array[2] - array[1] == 1 ? 0 : 1);\n        //两数相差等于2，（1、3、5）就直接把另一个数挪中间\n        res[0] = (array[1] - array[0] == 2 || array[2] - array[1] == 2) ? 1 : res[0];\n        //最大值就是两边距离\n        res[1] = array[2] - array[0] - 2;\n\n        return res;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n# 高赞题解\n分情况讨论即可。\n\nclass Solution {\npublic:\n    vector<int> numMovesStones(int a, int b, int c) {\n        int x=min(min(a,b),c);\n        int z=max(max(a,b),c);\n        int y=a+b+c-x-z;\n        if(y-x==1 && z-y==1) return {0,0};\n        if(y-x<=2 || z-y<=2) return {1,z-y+y-x-2};\n        else return {2,z-y+y-x-2};\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2020-01-01 21:53:53Accepted [https://leetcode-cn.com//submissions/detail/41946354/]1 ms100.0%33.6 MBjava2020-01-01 21:45:29Accepted [https://leetcode-cn.com//submissions/detail/41945608/]1 ms100.0%33.6 MBjava# 统计信息\n通过次数提交次数AC比率95762482538.6%",contentLowercase:"# 中文题目\n三枚石子放置在数轴上，位置分别为 a，b，c。\n\n每一回合，你可以从两端之一拿起一枚石子（位置最大或最小），并将其放入两端之间的任一空闲位置。形式上，假设这三枚石子当前分别位于位置 x, y, z 且 x < y < z。那么就可以从位置 x 或者是位置 z 拿起一枚石子，并将该石子移动到某一整数位置 k 处，其中 x < k < z 且 k != y。\n\n当你无法进行任何移动时，即，这些石子的位置连续时，游戏结束。\n\n要使游戏结束，你可以执行的最小和最大移动次数分别是多少？ 以长度为 2 的数组形式返回答案：answer = [minimum_moves, maximum_moves]\n\n\n\n示例 1：\n\n\n输入：a = 1, b = 2, c = 5\n输出：[1, 2]\n解释：将石子从 5 移动到 4 再移动到 3，或者我们可以直接将石子移动到 3。\n\n\n示例 2：\n\n\n输入：a = 4, b = 3, c = 2\n输出：[0, 0]\n解释：我们无法进行任何移动。\n\n\n\n\n提示：\n\n 1. 1 \n 2. 1 \n 3. 1 \n 4. a != b, b != c, c != a\n\n# 通过代码\nclass solution {\n    public int[] nummovesstones(int a, int b, int c) {\n        int[] res = new int[2];\n        int[] arr = {a, b, c};\n        arrays.sort(arr);\n\n        if(arr[1]!=arr[0]+1 || arr[2]!=arr[1]+1) {\n            //只要不是（1，2，5）（1，3，5）这种可以一步就移到的，像（1，4，7）两边都需要往中间移一下就需要2步\n            if(arr[1]==arr[0]+1 || arr[1]==arr[0]+2 || arr[2]==arr[1]+1 || arr[2]==arr[1]+2) {\n                res[0] = 1;\n            } else {\n                res[0] = 2;\n            }\n        }\n        res[1] = arr[2]-arr[0]-2 ;\n        return res;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\nclass solution {\n    public int[] nummovesstones(int a, int b, int c) {\n        int[] res = new int[2];\n        int[] array = {a, b, c};\n        arrays.sort(array);\n\n        //两数相差大于1，（1、4、7）就直接挪到中间数旁边，需要一次；两数挨着，就不动\n        res[0] = (array[1] - array[0] == 1 ? 0 : 1) + (array[2] - array[1] == 1 ? 0 : 1);\n        //两数相差等于2，（1、3、5）就直接把另一个数挪中间\n        res[0] = (array[1] - array[0] == 2 || array[2] - array[1] == 2) ? 1 : res[0];\n        //最大值就是两边距离\n        res[1] = array[2] - array[0] - 2;\n\n        return res;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\nclass solution {\n    public int[] nummovesstones(int a, int b, int c) {\n        int[] res = new int[2];\n        int[] arr = {a, b, c};\n        arrays.sort(arr);\n\n        if(arr[1]!=arr[0]+1 || arr[2]!=arr[1]+1) {\n            //只要不是（1，2，5）（1，3，5）这种可以一步就移到的，像（1，4，7）两边都需要往中间移一下就需要2步\n            if(arr[1]==arr[0]+1 || arr[1]==arr[0]+2 || arr[2]==arr[1]+1 || arr[2]==arr[1]+2) {\n                res[0] = 1;\n            } else {\n                res[0] = 2;\n            }\n        }\n        res[1] = arr[2]-arr[0]-2 ;\n        return res;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\nclass solution {\n    public int[] nummovesstones(int a, int b, int c) {\n        int[] res = new int[2];\n        int[] array = {a, b, c};\n        arrays.sort(array);\n\n        //两数相差大于1，（1、4、7）就直接挪到中间数旁边，需要一次；两数挨着，就不动\n        res[0] = (array[1] - array[0] == 1 ? 0 : 1) + (array[2] - array[1] == 1 ? 0 : 1);\n        //两数相差等于2，（1、3、5）就直接把另一个数挪中间\n        res[0] = (array[1] - array[0] == 2 || array[2] - array[1] == 2) ? 1 : res[0];\n        //最大值就是两边距离\n        res[1] = array[2] - array[0] - 2;\n\n        return res;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n# 高赞题解\n分情况讨论即可。\n\nclass solution {\npublic:\n    vector<int> nummovesstones(int a, int b, int c) {\n        int x=min(min(a,b),c);\n        int z=max(max(a,b),c);\n        int y=a+b+c-x-z;\n        if(y-x==1 && z-y==1) return {0,0};\n        if(y-x<=2 || z-y<=2) return {1,z-y+y-x-2};\n        else return {2,z-y+y-x-2};\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2020-01-01 21:53:53accepted [https://leetcode-cn.com//submissions/detail/41946354/]1 ms100.0%33.6 mbjava2020-01-01 21:45:29accepted [https://leetcode-cn.com//submissions/detail/41945608/]1 ms100.0%33.6 mbjava# 统计信息\n通过次数提交次数ac比率95762482538.6%"},{title:"844-比较含退格的字符串(Backspace String Compare)",frontmatter:{title:"844-比较含退格的字符串(Backspace String Compare)",date:"2021-05-10T00:00:00.000Z",categories:["简单"],tags:["栈<Stack>","双指针<Two Pointers>"]},regularPath:"/views/%E7%AE%80%E5%8D%95/0844-%E6%AF%94%E8%BE%83%E5%90%AB%E9%80%80%E6%A0%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2.html",relativePath:"views/简单/0844-比较含退格的字符串.md",key:"v-5bdc57ee",path:"/views/%E7%AE%80%E5%8D%95/0844-%E6%AF%94%E8%BE%83%E5%90%AB%E9%80%80%E6%A0%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2.html",headers:[{level:2,title:"中文题目",slug:"中文题目",charIndex:2},{level:2,title:"通过代码",slug:"通过代码",charIndex:448},{level:2,title:"高赞题解",slug:"高赞题解",charIndex:2970},{level:3,title:"🧠 解题思路",slug:"🧠-解题思路",charIndex:2982},{level:3,title:"🎨 图解演示",slug:"🎨-图解演示",charIndex:3613},{level:3,title:"🍭 示例代码",slug:"🍭-示例代码",charIndex:3638},{level:3,title:"转身挥手",slug:"转身挥手",charIndex:9738},{level:2,title:"提交历史",slug:"提交历史",charIndex:9824},{level:2,title:"统计信息",slug:"统计信息",charIndex:10682}],headersStr:"中文题目 通过代码 高赞题解 🧠 解题思路 🎨 图解演示 🍭 示例代码 转身挥手 提交历史 统计信息",content:"# 中文题目\n给定 S 和 T 两个字符串，当它们分别被输入到空白的文本编辑器后，判断二者是否相等，并返回结果。 # 代表退格字符。\n\n注意：如果对空文本输入退格字符，文本继续为空。\n\n\n\n示例 1：\n\n\n输入：S = \"ab#c\", T = \"ad#c\"\n输出：true\n解释：S 和 T 都会变成 “ac”。\n\n\n示例 2：\n\n\n输入：S = \"ab##\", T = \"c#d#\"\n输出：true\n解释：S 和 T 都会变成 “”。\n\n\n示例 3：\n\n\n输入：S = \"a##c\", T = \"#a#c\"\n输出：true\n解释：S 和 T 都会变成 “c”。\n\n\n示例 4：\n\n\n输入：S = \"a#c\", T = \"b\"\n输出：false\n解释：S 会变成 “c”，但 T 仍然是 “b”。\n\n\n\n提示：\n\n * 1 \n * 1 \n * S 和 T 只含有小写字母以及字符 '#'。\n\n\n\n进阶：\n\n * 你可以用 O(N) 的时间复杂度和 O(1) 的空间复杂度解决该问题吗？\n\n\n\n# 通过代码\n    class Solution {\n        public boolean backspaceCompare(String s, String t) {\n            char[] sChar = s.toCharArray();\n            char[] tChar = t.toCharArray();\n            String str1=getChar(sChar);\n            String str2=getChar(tChar);\n            return str1.equals(str2);\n        }\n\n        private String getChar(char[] sChar) {\n            int i= sChar.length-1,j=sChar.length-1;\n            while (i>0){\n                while (i>0 && sChar[i]!='#'){\n                    i--;\n                }\n                if (j>=i){\n                    j=i-1;\n                }\n                while (sChar[i]=='#'){\n                    if (j<0)\n                        break;\n                    if (sChar[j]!='#') {\n                        sChar[j] = '0';\n                        break;\n                    }\n                    else j--;\n                }\n                i--;\n                j--;\n            }\n            String str=\"\";\n            for (int k = 0; k < sChar.length; k++) {\n                if (sChar[k]!='0' && sChar[k]!='#'){\n                    str+=sChar[k];\n                }\n            }\n            return str;\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n    class Solution {\n        public boolean backspaceCompare(String s, String t) {\n            Stack<Character> stack1=new Stack<>();\n            Stack<Character> stack2=new Stack<>();\n            for (int i = 0; i < s.length(); i++) {\n                if (s.charAt(i)=='#'){\n                    if (!stack1.isEmpty()) {\n                        stack1.pop();\n                    }\n                }else {\n                    stack1.push(s.charAt(i));\n                }\n            }\n            for (int i = 0; i < t.length(); i++) {\n                if (t.charAt(i)=='#'){\n                    if (!stack2.isEmpty()) {\n                        stack2.pop();\n                    }\n                }else {\n                    stack2.push(t.charAt(i));\n                }\n            }\n            StringBuilder str1=new StringBuilder();\n            StringBuilder str2=new StringBuilder();\n            while (!stack1.isEmpty()){\n                str1.append(stack1.pop());\n            }\n            while (!stack2.isEmpty()){\n                str2.append(stack2.pop());\n            }\n            return str1.toString().equals(str2.toString());\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n# 高赞题解\n\n\n\n\n\n# 🧠 解题思路\n相信大家看到该题的第一反应应该是使用栈，或者直接删除字符串来解决，但是这样做的话，空间复杂度为： n+mn+mn+m。\n\n这无疑不是更优解，下面，我将介绍一种常量级空间复杂度的解法：双指针，并且比官方解思路更简单清晰！\n\n由于 # 号只会消除左边的一个字符，所以对右边的字符无影响，所以我们选择从后往前遍历 SSS，TTT 字符串。\n\n思路解析：\n\n 1. 准备两个指针 iii, jjj 分别指向 SSS，TTT 的末位字符，再准备两个变量 skipSskipSskipS，skipTskipTskipT 来分别存放 SSS，TTT 字符串中的 # 数量。\n 2. 从后往前遍历 SSS，所遇情况有三，如下所示： 2.1 若当前字符是 #，则 skipSskipSskipS 自增 111； 2.2 若当前字符不是 #，且 skipSskipSskipS 不为 000，则 skipSskipSskipS 自减 111； 2.3 若当前字符不是 #，且 skipSskipSskipS 为 000，则代表当前字符不会被消除，我们可以用来和 TTT 中的当前字符作比较。\n\n若对比过程出现 SSS, TTT 当前字符不匹配，则遍历结束，返回 falsefalsefalse，若 SSS，TTT 都遍历结束，且都能一一匹配，则返回 truetruetrue。\n\n文字描述一般在不懂逻辑的时候都比较不容易理解，所以请结合图解来加快理解。\n\n\n\n\n# 🎨 图解演示\n<,,,,,,,,>\n\n\n\n\n# 🍭 示例代码\nvar backspaceCompare = function(S, T) {\n    let i = S.length - 1,\n        j = T.length - 1,\n        skipS = 0,\n        skipT = 0;\n    // 大循环\n    while(i >= 0 || j >= 0){\n        // S 循环\n        while(i >= 0){\n            if(S[i] === '#'){\n                skipS++;\n                i--;\n            }else if(skipS > 0){\n                skipS--;\n                i--;\n            }else break;\n        }\n        // T 循环\n        while(j >= 0){\n            if(T[j] === '#'){\n                skipT++;\n                j--;\n            }else if(skipT > 0){\n                skipT--;\n                j--;\n            }else break;\n        }\n        if(S[i] !== T[j]) return false;\n        i--;\n        j--;\n    }\n    return true;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\nclass Solution {\npublic:\n    bool backspaceCompare(string S, string T) {\n        int i = S.length() - 1, j = T.length() - 1;\n        int skipS = 0, skipT = 0;\n\n        while (i >= 0 || j >= 0) {\n            while (i >= 0) {\n                if (S[i] == '#') {\n                    skipS++, i--;\n                } else if (skipS > 0) {\n                    skipS--, i--;\n                } else {\n                    break;\n                }\n            }\n            while (j >= 0) {\n                if (T[j] == '#') {\n                    skipT++, j--;\n                } else if (skipT > 0) {\n                    skipT--, j--;\n                } else {\n                    break;\n                }\n            }\n            if (i >= 0 && j >= 0) {\n                if (S[i] != T[j]) {\n                    return false;\n                }\n            } else {\n                if (i >= 0 || j >= 0) {\n                    return false;\n                }\n            }\n            i--, j--;\n        }\n        return true;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\nclass Solution {\n    public boolean backspaceCompare(String S, String T) {\n        int i = S.length() - 1, j = T.length() - 1;\n        int skipS = 0, skipT = 0;\n\n        while (i >= 0 || j >= 0) {\n            while (i >= 0) {\n                if (S.charAt(i) == '#') {\n                    skipS++;\n                    i--;\n                } else if (skipS > 0) {\n                    skipS--;\n                    i--;\n                } else {\n                    break;\n                }\n            }\n            while (j >= 0) {\n                if (T.charAt(j) == '#') {\n                    skipT++;\n                    j--;\n                } else if (skipT > 0) {\n                    skipT--;\n                    j--;\n                } else {\n                    break;\n                }\n            }\n            if (i >= 0 && j >= 0) {\n                if (S.charAt(i) != T.charAt(j)) {\n                    return false;\n                }\n            } else {\n                if (i >= 0 || j >= 0) {\n                    return false;\n                }\n            }\n            i--;\n            j--;\n        }\n        return true;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\nfunc backspaceCompare(s, t string) bool {\n    skipS, skipT := 0, 0\n    i, j := len(s)-1, len(t)-1\n    for i >= 0 || j >= 0 {\n        for i >= 0 {\n            if s[i] == '#' {\n                skipS++\n                i--\n            } else if skipS > 0 {\n                skipS--\n                i--\n            } else {\n                break\n            }\n        }\n        for j >= 0 {\n            if t[j] == '#' {\n                skipT++\n                j--\n            } else if skipT > 0 {\n                skipT--\n                j--\n            } else {\n                break\n            }\n        }\n        if i >= 0 && j >= 0 {\n            if s[i] != t[j] {\n                return false\n            }\n        } else if i >= 0 || j >= 0 {\n            return false\n        }\n        i--\n        j--\n    }\n    return true\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\nclass Solution:\n    def backspaceCompare(self, S: str, T: str) -> bool:\n        i, j = len(S) - 1, len(T) - 1\n        skipS = skipT = 0\n\n        while i >= 0 or j >= 0:\n            while i >= 0:\n                if S[i] == \"#\":\n                    skipS += 1\n                    i -= 1\n                elif skipS > 0:\n                    skipS -= 1\n                    i -= 1\n                else:\n                    break\n            while j >= 0:\n                if T[j] == \"#\":\n                    skipT += 1\n                    j -= 1\n                elif skipT > 0:\n                    skipT -= 1\n                    j -= 1\n                else:\n                    break\n            if i >= 0 and j >= 0:\n                if S[i] != T[j]:\n                    return False\n            elif i >= 0 or j >= 0:\n                return False\n            i -= 1\n            j -= 1\n        \n        return True\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\nbool backspaceCompare(char* S, char* T) {\n    int i = strlen(S) - 1, j = strlen(T) - 1;\n    int skipS = 0, skipT = 0;\n\n    while (i >= 0 || j >= 0) {\n        while (i >= 0) {\n            if (S[i] == '#') {\n                skipS++, i--;\n            } else if (skipS > 0) {\n                skipS--, i--;\n            } else {\n                break;\n            }\n        }\n        while (j >= 0) {\n            if (T[j] == '#') {\n                skipT++, j--;\n            } else if (skipT > 0) {\n                skipT--, j--;\n            } else {\n                break;\n            }\n        }\n        if (i >= 0 && j >= 0) {\n            if (S[i] != T[j]) {\n                return false;\n            }\n        } else {\n            if (i >= 0 || j >= 0) {\n                return false;\n            }\n        }\n        i--, j--;\n    }\n    return true;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n\n\n# 转身挥手\n嘿，少年，做图不易，留下个赞或评论再走吧！谢啦~ 💐\n\n差点忘了，祝你牛年大吉 🐮 ，AC 和 Offer 📑 多多益善~\n\n⛲⛲⛲ 期待下次再见~\n\n# 提交历史\n提交时间提交结果标记状态我的注释执行时间战胜比例内存消耗语言2021-05-10 21:17:02Accepted [https://leetcode-cn.com/submissions/detail/176207832/]BLUE双指针7 ms100.0%36.8 MBjava2021-05-10 21:08:39Wrong Answer [https://leetcode-cn.com/submissions/detail/176204183/]N/AN/AN/Ajava2021-05-10 21:07:07Wrong Answer [https://leetcode-cn.com/submissions/detail/176203581/]N/AN/AN/Ajava2021-05-10 21:06:40Wrong Answer [https://leetcode-cn.com/submissions/detail/176203390/]N/AN/AN/Ajava2021-05-10 21:03:57Runtime Error [https://leetcode-cn.com/submissions/detail/176202304/]N/AN/AN/Ajava2021-05-10 21:02:46Runtime Error [https://leetcode-cn.com/submissions/detail/176201842/]N/AN/AN/Ajava2021-05-10 20:09:20Accepted [https://leetcode-cn.com/submissions/detail/176179142/]RED栈3 ms100.0%36.8 MBjava2021-05-10 20:06:15Wrong Answer [https://leetcode-cn.com/submissions/detail/176177985/]N/AN/AN/Ajava# 统计信息\n通过次数提交次数AC比率7133813715452.0%",contentLowercase:"# 中文题目\n给定 s 和 t 两个字符串，当它们分别被输入到空白的文本编辑器后，判断二者是否相等，并返回结果。 # 代表退格字符。\n\n注意：如果对空文本输入退格字符，文本继续为空。\n\n\n\n示例 1：\n\n\n输入：s = \"ab#c\", t = \"ad#c\"\n输出：true\n解释：s 和 t 都会变成 “ac”。\n\n\n示例 2：\n\n\n输入：s = \"ab##\", t = \"c#d#\"\n输出：true\n解释：s 和 t 都会变成 “”。\n\n\n示例 3：\n\n\n输入：s = \"a##c\", t = \"#a#c\"\n输出：true\n解释：s 和 t 都会变成 “c”。\n\n\n示例 4：\n\n\n输入：s = \"a#c\", t = \"b\"\n输出：false\n解释：s 会变成 “c”，但 t 仍然是 “b”。\n\n\n\n提示：\n\n * 1 \n * 1 \n * s 和 t 只含有小写字母以及字符 '#'。\n\n\n\n进阶：\n\n * 你可以用 o(n) 的时间复杂度和 o(1) 的空间复杂度解决该问题吗？\n\n\n\n# 通过代码\n    class solution {\n        public boolean backspacecompare(string s, string t) {\n            char[] schar = s.tochararray();\n            char[] tchar = t.tochararray();\n            string str1=getchar(schar);\n            string str2=getchar(tchar);\n            return str1.equals(str2);\n        }\n\n        private string getchar(char[] schar) {\n            int i= schar.length-1,j=schar.length-1;\n            while (i>0){\n                while (i>0 && schar[i]!='#'){\n                    i--;\n                }\n                if (j>=i){\n                    j=i-1;\n                }\n                while (schar[i]=='#'){\n                    if (j<0)\n                        break;\n                    if (schar[j]!='#') {\n                        schar[j] = '0';\n                        break;\n                    }\n                    else j--;\n                }\n                i--;\n                j--;\n            }\n            string str=\"\";\n            for (int k = 0; k < schar.length; k++) {\n                if (schar[k]!='0' && schar[k]!='#'){\n                    str+=schar[k];\n                }\n            }\n            return str;\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n    class solution {\n        public boolean backspacecompare(string s, string t) {\n            stack<character> stack1=new stack<>();\n            stack<character> stack2=new stack<>();\n            for (int i = 0; i < s.length(); i++) {\n                if (s.charat(i)=='#'){\n                    if (!stack1.isempty()) {\n                        stack1.pop();\n                    }\n                }else {\n                    stack1.push(s.charat(i));\n                }\n            }\n            for (int i = 0; i < t.length(); i++) {\n                if (t.charat(i)=='#'){\n                    if (!stack2.isempty()) {\n                        stack2.pop();\n                    }\n                }else {\n                    stack2.push(t.charat(i));\n                }\n            }\n            stringbuilder str1=new stringbuilder();\n            stringbuilder str2=new stringbuilder();\n            while (!stack1.isempty()){\n                str1.append(stack1.pop());\n            }\n            while (!stack2.isempty()){\n                str2.append(stack2.pop());\n            }\n            return str1.tostring().equals(str2.tostring());\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n# 高赞题解\n\n\n\n\n\n# 🧠 解题思路\n相信大家看到该题的第一反应应该是使用栈，或者直接删除字符串来解决，但是这样做的话，空间复杂度为： n+mn+mn+m。\n\n这无疑不是更优解，下面，我将介绍一种常量级空间复杂度的解法：双指针，并且比官方解思路更简单清晰！\n\n由于 # 号只会消除左边的一个字符，所以对右边的字符无影响，所以我们选择从后往前遍历 sss，ttt 字符串。\n\n思路解析：\n\n 1. 准备两个指针 iii, jjj 分别指向 sss，ttt 的末位字符，再准备两个变量 skipsskipsskips，skiptskiptskipt 来分别存放 sss，ttt 字符串中的 # 数量。\n 2. 从后往前遍历 sss，所遇情况有三，如下所示： 2.1 若当前字符是 #，则 skipsskipsskips 自增 111； 2.2 若当前字符不是 #，且 skipsskipsskips 不为 000，则 skipsskipsskips 自减 111； 2.3 若当前字符不是 #，且 skipsskipsskips 为 000，则代表当前字符不会被消除，我们可以用来和 ttt 中的当前字符作比较。\n\n若对比过程出现 sss, ttt 当前字符不匹配，则遍历结束，返回 falsefalsefalse，若 sss，ttt 都遍历结束，且都能一一匹配，则返回 truetruetrue。\n\n文字描述一般在不懂逻辑的时候都比较不容易理解，所以请结合图解来加快理解。\n\n\n\n\n# 🎨 图解演示\n<,,,,,,,,>\n\n\n\n\n# 🍭 示例代码\nvar backspacecompare = function(s, t) {\n    let i = s.length - 1,\n        j = t.length - 1,\n        skips = 0,\n        skipt = 0;\n    // 大循环\n    while(i >= 0 || j >= 0){\n        // s 循环\n        while(i >= 0){\n            if(s[i] === '#'){\n                skips++;\n                i--;\n            }else if(skips > 0){\n                skips--;\n                i--;\n            }else break;\n        }\n        // t 循环\n        while(j >= 0){\n            if(t[j] === '#'){\n                skipt++;\n                j--;\n            }else if(skipt > 0){\n                skipt--;\n                j--;\n            }else break;\n        }\n        if(s[i] !== t[j]) return false;\n        i--;\n        j--;\n    }\n    return true;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\nclass solution {\npublic:\n    bool backspacecompare(string s, string t) {\n        int i = s.length() - 1, j = t.length() - 1;\n        int skips = 0, skipt = 0;\n\n        while (i >= 0 || j >= 0) {\n            while (i >= 0) {\n                if (s[i] == '#') {\n                    skips++, i--;\n                } else if (skips > 0) {\n                    skips--, i--;\n                } else {\n                    break;\n                }\n            }\n            while (j >= 0) {\n                if (t[j] == '#') {\n                    skipt++, j--;\n                } else if (skipt > 0) {\n                    skipt--, j--;\n                } else {\n                    break;\n                }\n            }\n            if (i >= 0 && j >= 0) {\n                if (s[i] != t[j]) {\n                    return false;\n                }\n            } else {\n                if (i >= 0 || j >= 0) {\n                    return false;\n                }\n            }\n            i--, j--;\n        }\n        return true;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\nclass solution {\n    public boolean backspacecompare(string s, string t) {\n        int i = s.length() - 1, j = t.length() - 1;\n        int skips = 0, skipt = 0;\n\n        while (i >= 0 || j >= 0) {\n            while (i >= 0) {\n                if (s.charat(i) == '#') {\n                    skips++;\n                    i--;\n                } else if (skips > 0) {\n                    skips--;\n                    i--;\n                } else {\n                    break;\n                }\n            }\n            while (j >= 0) {\n                if (t.charat(j) == '#') {\n                    skipt++;\n                    j--;\n                } else if (skipt > 0) {\n                    skipt--;\n                    j--;\n                } else {\n                    break;\n                }\n            }\n            if (i >= 0 && j >= 0) {\n                if (s.charat(i) != t.charat(j)) {\n                    return false;\n                }\n            } else {\n                if (i >= 0 || j >= 0) {\n                    return false;\n                }\n            }\n            i--;\n            j--;\n        }\n        return true;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\nfunc backspacecompare(s, t string) bool {\n    skips, skipt := 0, 0\n    i, j := len(s)-1, len(t)-1\n    for i >= 0 || j >= 0 {\n        for i >= 0 {\n            if s[i] == '#' {\n                skips++\n                i--\n            } else if skips > 0 {\n                skips--\n                i--\n            } else {\n                break\n            }\n        }\n        for j >= 0 {\n            if t[j] == '#' {\n                skipt++\n                j--\n            } else if skipt > 0 {\n                skipt--\n                j--\n            } else {\n                break\n            }\n        }\n        if i >= 0 && j >= 0 {\n            if s[i] != t[j] {\n                return false\n            }\n        } else if i >= 0 || j >= 0 {\n            return false\n        }\n        i--\n        j--\n    }\n    return true\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\nclass solution:\n    def backspacecompare(self, s: str, t: str) -> bool:\n        i, j = len(s) - 1, len(t) - 1\n        skips = skipt = 0\n\n        while i >= 0 or j >= 0:\n            while i >= 0:\n                if s[i] == \"#\":\n                    skips += 1\n                    i -= 1\n                elif skips > 0:\n                    skips -= 1\n                    i -= 1\n                else:\n                    break\n            while j >= 0:\n                if t[j] == \"#\":\n                    skipt += 1\n                    j -= 1\n                elif skipt > 0:\n                    skipt -= 1\n                    j -= 1\n                else:\n                    break\n            if i >= 0 and j >= 0:\n                if s[i] != t[j]:\n                    return false\n            elif i >= 0 or j >= 0:\n                return false\n            i -= 1\n            j -= 1\n        \n        return true\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\nbool backspacecompare(char* s, char* t) {\n    int i = strlen(s) - 1, j = strlen(t) - 1;\n    int skips = 0, skipt = 0;\n\n    while (i >= 0 || j >= 0) {\n        while (i >= 0) {\n            if (s[i] == '#') {\n                skips++, i--;\n            } else if (skips > 0) {\n                skips--, i--;\n            } else {\n                break;\n            }\n        }\n        while (j >= 0) {\n            if (t[j] == '#') {\n                skipt++, j--;\n            } else if (skipt > 0) {\n                skipt--, j--;\n            } else {\n                break;\n            }\n        }\n        if (i >= 0 && j >= 0) {\n            if (s[i] != t[j]) {\n                return false;\n            }\n        } else {\n            if (i >= 0 || j >= 0) {\n                return false;\n            }\n        }\n        i--, j--;\n    }\n    return true;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n\n\n# 转身挥手\n嘿，少年，做图不易，留下个赞或评论再走吧！谢啦~ 💐\n\n差点忘了，祝你牛年大吉 🐮 ，ac 和 offer 📑 多多益善~\n\n⛲⛲⛲ 期待下次再见~\n\n# 提交历史\n提交时间提交结果标记状态我的注释执行时间战胜比例内存消耗语言2021-05-10 21:17:02accepted [https://leetcode-cn.com/submissions/detail/176207832/]blue双指针7 ms100.0%36.8 mbjava2021-05-10 21:08:39wrong answer [https://leetcode-cn.com/submissions/detail/176204183/]n/an/an/ajava2021-05-10 21:07:07wrong answer [https://leetcode-cn.com/submissions/detail/176203581/]n/an/an/ajava2021-05-10 21:06:40wrong answer [https://leetcode-cn.com/submissions/detail/176203390/]n/an/an/ajava2021-05-10 21:03:57runtime error [https://leetcode-cn.com/submissions/detail/176202304/]n/an/an/ajava2021-05-10 21:02:46runtime error [https://leetcode-cn.com/submissions/detail/176201842/]n/an/an/ajava2021-05-10 20:09:20accepted [https://leetcode-cn.com/submissions/detail/176179142/]red栈3 ms100.0%36.8 mbjava2021-05-10 20:06:15wrong answer [https://leetcode-cn.com/submissions/detail/176177985/]n/an/an/ajava# 统计信息\n通过次数提交次数ac比率7133813715452.0%"},{title:"1266-访问所有点的最小时间(Minimum Time Visiting All Points)",frontmatter:{title:"1266-访问所有点的最小时间(Minimum Time Visiting All Points)",date:"2020-01-12T00:00:00.000Z",categories:["简单"],tags:["几何<Geometry>","数组<Array>"]},regularPath:"/views/%E7%AE%80%E5%8D%95/1266-%E8%AE%BF%E9%97%AE%E6%89%80%E6%9C%89%E7%82%B9%E7%9A%84%E6%9C%80%E5%B0%8F%E6%97%B6%E9%97%B4.html",relativePath:"views/简单/1266-访问所有点的最小时间.md",key:"v-493516c6",path:"/views/%E7%AE%80%E5%8D%95/1266-%E8%AE%BF%E9%97%AE%E6%89%80%E6%9C%89%E7%82%B9%E7%9A%84%E6%9C%80%E5%B0%8F%E6%97%B6%E9%97%B4.html",headers:[{level:2,title:"中文题目",slug:"中文题目",charIndex:2},{level:2,title:"通过代码",slug:"通过代码",charIndex:590},{level:2,title:"高赞题解",slug:"高赞题解",charIndex:1259},{level:2,title:"提交历史",slug:"提交历史",charIndex:2665},{level:2,title:"统计信息",slug:"统计信息",charIndex:2898}],lastUpdated:"4/11/2021, 6:09:39 PM",headersStr:"中文题目 通过代码 高赞题解 提交历史 统计信息",content:"# 中文题目\n平面上有n个点，点的位置用整数坐标表示 points[i] = [xi, yi] 。请你计算访问所有这些点需要的 最小时间（以秒为单位）。\n\n你需要按照下面的规则在平面上移动：\n\n * 每一秒内，你可以： * 沿水平方向移动一个单位长度，或者\n    * 沿竖直方向移动一个单位长度，或者\n    * 跨过对角线移动 sqrt(2) 个单位长度（可以看作在一秒内向水平和竖直方向各移动一个单位长度）。\n   \n   \n * 必须按照数组中出现的顺序来访问这些点。\n * 在访问某个点时，可以经过该点后面出现的点，但经过的那些点不算作有效访问。\n\n\n\n示例 1：\n\n\n\n\n输入：points = [[1,1],[3,4],[-1,0]]\n输出：7\n解释：一条最佳的访问路径是： [1,1] -> [2,2] -> [3,3] -> [3,4] -> [2,3] -> [1,2] -> [0,1] -> [-1,0]   \n从 [1,1] 到 [3,4] 需要 3 秒 \n从 [3,4] 到 [-1,0] 需要 4 秒\n一共需要 7 秒\n\n示例 2：\n\n\n输入：points = [[3,2],[-2,2]]\n输出：5\n\n\n\n\n提示：\n\n * points.length == n\n * 1 \n * points[i].length == 2\n * -1000\n\n# 通过代码\nclass Solution {\n    public int minTimeToVisitAllPoints(int[][] points) {\n        int total=0;\n        for (int i = 1; i < points.length; i++) {\n            total+=Math.max(Math.abs(points[i][0]-points[i-1][0]),\n                    Math.abs(points[i][1]-points[i-1][1]));\n        }\n        return total;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\nclass Solution {\n    public int minTimeToVisitAllPoints(int[][] points) {\n        int total=0;\n        for (int i = 1; i < points.length; i++) {\n            total+=Math.max(Math.abs(points[i][0]-points[i-1][0]),\n                    Math.abs(points[i][1]-points[i-1][1]));\n        }\n        return total;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n# 高赞题解\n# 方法一：切比雪夫距离\n对于平面上的两个点 x = (x0, x1) 和 y = (y0, y1)，设它们横坐标距离之差为 dx = |x0 - y0|，纵坐标距离之差为 dy = |x1 - y1|，对于以下三种情况，我们可以分别计算出从 x 移动到 y 的最少次数：\n\n * dx < dy：沿对角线移动 dx 次，再竖直移动 dy - dx 次，总计 dx + (dy - dx) = dy 次；\n   \n   \n * dx == dy：沿对角线移动 dx 次；\n   \n   \n * dx > dy：沿对角线移动 dy 次，再水平移动 dx - dy 次，总计 dy + (dx - dy) = dx 次。\n   \n   \n\n可以发现，对于任意一种情况，从 x 移动到 y 的最少次数为 dx 和 dy 中的较大值 max(dx, dy)，这也被称作 x 和 y 之间的 切比雪夫距离 [https://baike.baidu.com/item/%E5%88%87%E6%AF%94%E9%9B%AA%E5%A4%AB%E8%B7%9D%E7%A6%BB]。\n\n由于题目要求，需要按照数组中出现的顺序来访问这些点。因此我们遍历整个数组，对于数组中的相邻两个点，计算出它们的切比雪夫距离，所有的距离之和即为答案。\n\nclass Solution {\npublic:\n    int minTimeToVisitAllPoints(vector<vector<int>>& points) {\n        int x0 = points[0][0], x1 = points[0][1];\n        int ans = 0;\n        for (int i = 1; i < points.size(); ++i) {\n            int y0 = points[i][0], y1 = points[i][1];\n            ans += max(abs(x0 - y0), abs(x1 - y1));\n            x0 = y0;\n            x1 = y1;\n        }\n        return ans;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\nclass Solution:\n    def minTimeToVisitAllPoints(self, points: List[List[int]]) -> int:\n        x0, x1 = points[0]\n        ans = 0\n        for i in range(1, len(points)):\n            y0, y1 = points[i]\n            ans += max(abs(x0 - y0), abs(x1 - y1))\n            x0, x1 = points[i]\n        return ans\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n复杂度分析\n\n * 时间复杂度：O(N)O(N)O(N)，其中 NNN 是数组的长度。\n   \n   \n * 空间复杂度：O(1)O(1)O(1)。\n   \n   \n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2020-01-12 18:32:06Accepted [https://leetcode-cn.com//submissions/detail/43201721/]1 ms100.0%40.9 MBjava2020-01-12 18:27:02Wrong Answer [https://leetcode-cn.com//submissions/detail/43201316/]N/AN/AN/Ajava# 统计信息\n通过次数提交次数AC比率265403236182.0%",contentLowercase:"# 中文题目\n平面上有n个点，点的位置用整数坐标表示 points[i] = [xi, yi] 。请你计算访问所有这些点需要的 最小时间（以秒为单位）。\n\n你需要按照下面的规则在平面上移动：\n\n * 每一秒内，你可以： * 沿水平方向移动一个单位长度，或者\n    * 沿竖直方向移动一个单位长度，或者\n    * 跨过对角线移动 sqrt(2) 个单位长度（可以看作在一秒内向水平和竖直方向各移动一个单位长度）。\n   \n   \n * 必须按照数组中出现的顺序来访问这些点。\n * 在访问某个点时，可以经过该点后面出现的点，但经过的那些点不算作有效访问。\n\n\n\n示例 1：\n\n\n\n\n输入：points = [[1,1],[3,4],[-1,0]]\n输出：7\n解释：一条最佳的访问路径是： [1,1] -> [2,2] -> [3,3] -> [3,4] -> [2,3] -> [1,2] -> [0,1] -> [-1,0]   \n从 [1,1] 到 [3,4] 需要 3 秒 \n从 [3,4] 到 [-1,0] 需要 4 秒\n一共需要 7 秒\n\n示例 2：\n\n\n输入：points = [[3,2],[-2,2]]\n输出：5\n\n\n\n\n提示：\n\n * points.length == n\n * 1 \n * points[i].length == 2\n * -1000\n\n# 通过代码\nclass solution {\n    public int mintimetovisitallpoints(int[][] points) {\n        int total=0;\n        for (int i = 1; i < points.length; i++) {\n            total+=math.max(math.abs(points[i][0]-points[i-1][0]),\n                    math.abs(points[i][1]-points[i-1][1]));\n        }\n        return total;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\nclass solution {\n    public int mintimetovisitallpoints(int[][] points) {\n        int total=0;\n        for (int i = 1; i < points.length; i++) {\n            total+=math.max(math.abs(points[i][0]-points[i-1][0]),\n                    math.abs(points[i][1]-points[i-1][1]));\n        }\n        return total;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n# 高赞题解\n# 方法一：切比雪夫距离\n对于平面上的两个点 x = (x0, x1) 和 y = (y0, y1)，设它们横坐标距离之差为 dx = |x0 - y0|，纵坐标距离之差为 dy = |x1 - y1|，对于以下三种情况，我们可以分别计算出从 x 移动到 y 的最少次数：\n\n * dx < dy：沿对角线移动 dx 次，再竖直移动 dy - dx 次，总计 dx + (dy - dx) = dy 次；\n   \n   \n * dx == dy：沿对角线移动 dx 次；\n   \n   \n * dx > dy：沿对角线移动 dy 次，再水平移动 dx - dy 次，总计 dy + (dx - dy) = dx 次。\n   \n   \n\n可以发现，对于任意一种情况，从 x 移动到 y 的最少次数为 dx 和 dy 中的较大值 max(dx, dy)，这也被称作 x 和 y 之间的 切比雪夫距离 [https://baike.baidu.com/item/%e5%88%87%e6%af%94%e9%9b%aa%e5%a4%ab%e8%b7%9d%e7%a6%bb]。\n\n由于题目要求，需要按照数组中出现的顺序来访问这些点。因此我们遍历整个数组，对于数组中的相邻两个点，计算出它们的切比雪夫距离，所有的距离之和即为答案。\n\nclass solution {\npublic:\n    int mintimetovisitallpoints(vector<vector<int>>& points) {\n        int x0 = points[0][0], x1 = points[0][1];\n        int ans = 0;\n        for (int i = 1; i < points.size(); ++i) {\n            int y0 = points[i][0], y1 = points[i][1];\n            ans += max(abs(x0 - y0), abs(x1 - y1));\n            x0 = y0;\n            x1 = y1;\n        }\n        return ans;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\nclass solution:\n    def mintimetovisitallpoints(self, points: list[list[int]]) -> int:\n        x0, x1 = points[0]\n        ans = 0\n        for i in range(1, len(points)):\n            y0, y1 = points[i]\n            ans += max(abs(x0 - y0), abs(x1 - y1))\n            x0, x1 = points[i]\n        return ans\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n复杂度分析\n\n * 时间复杂度：o(n)o(n)o(n)，其中 nnn 是数组的长度。\n   \n   \n * 空间复杂度：o(1)o(1)o(1)。\n   \n   \n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2020-01-12 18:32:06accepted [https://leetcode-cn.com//submissions/detail/43201721/]1 ms100.0%40.9 mbjava2020-01-12 18:27:02wrong answer [https://leetcode-cn.com//submissions/detail/43201316/]n/an/an/ajava# 统计信息\n通过次数提交次数ac比率265403236182.0%"},{title:"1252-奇数值单元格的数目(Cells with Odd Values in a Matrix)",frontmatter:{title:"1252-奇数值单元格的数目(Cells with Odd Values in a Matrix)",date:"2020-01-16T00:00:00.000Z",categories:["简单"],tags:["数组<Array>"]},regularPath:"/views/%E7%AE%80%E5%8D%95/1252-%E5%A5%87%E6%95%B0%E5%80%BC%E5%8D%95%E5%85%83%E6%A0%BC%E7%9A%84%E6%95%B0%E7%9B%AE.html",relativePath:"views/简单/1252-奇数值单元格的数目.md",key:"v-2bbe7c80",path:"/views/%E7%AE%80%E5%8D%95/1252-%E5%A5%87%E6%95%B0%E5%80%BC%E5%8D%95%E5%85%83%E6%A0%BC%E7%9A%84%E6%95%B0%E7%9B%AE.html",headers:[{level:2,title:"中文题目",slug:"中文题目",charIndex:2},{level:2,title:"通过代码",slug:"通过代码",charIndex:636},{level:2,title:"我的笔记",slug:"我的笔记",charIndex:1729},{level:2,title:"高赞题解",slug:"高赞题解",charIndex:1794},{level:2,title:"提交历史",slug:"提交历史",charIndex:3928},{level:2,title:"统计信息",slug:"统计信息",charIndex:4061}],lastUpdated:"4/11/2021, 6:09:39 PM",headersStr:"中文题目 通过代码 我的笔记 高赞题解 提交历史 统计信息",content:"# 中文题目\n给你一个 m x n 的矩阵，最开始的时候，每个单元格中的值都是 0。\n\n另有一个二维索引数组indices，indices[i] = [ri, ci] 指向矩阵中的某个位置，其中 ri 和 ci 分别表示指定的行和列（从 0 开始编号）。\n\n对 indices[i] 所指向的每个位置，应同时执行下述增量操作：\n\n 1. ri 行上的所有单元格，加 1 。\n 2. ci 列上的所有单元格，加 1 。\n\n给你 m、n 和 indices 。请你在执行完所有indices指定的增量操作后，返回矩阵中 奇数值单元格 的数目。\n\n\n\n示例 1：\n\n\n\n\n输入：m = 2, n = 3, indices = [[0,1],[1,1]]\n输出：6\n解释：最开始的矩阵是 [[0,0,0],[0,0,0]]。\n第一次增量操作后得到 [[1,2,1],[0,1,0]]。\n最后的矩阵是 [[1,3,1],[1,3,1]]，里面有 6 个奇数。\n\n\n示例 2：\n\n\n\n\n输入：m = 2, n = 2, indices = [[1,1],[0,0]]\n输出：0\n解释：最后的矩阵是 [[2,2],[2,2]]，里面没有奇数。\n\n\n\n\n提示：\n\n * 1 \n * 1 \n * 0 i < m\n * 0 i < n\n\n\n\n进阶：你可以设计一个时间复杂度为 O(n + m + indices.length) 且仅用 O(n + m) 额外空间的算法来解决此问题吗？\n\n# 通过代码\nclass Solution {\n    public int oddCells(int n, int m, int[][] indices) {\n        int[] x=new int[n];\n        int[] y=new int[m];\n        int total=0;\n        for (int i = 0; i < indices.length; i++) {\n            x[indices[i][0]]++;\n            y[indices[i][1]]++;\n        }\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                if( (x[i]+y[j])%2 !=0){\n                    total++;\n                }\n            }\n        }\n        return total;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\nclass Solution {\n    public int oddCells(int n, int m, int[][] indices) {\n        int[] x=new int[n];\n        int[] y=new int[m];\n        int total=0;\n        for (int i = 0; i < indices.length; i++) {\n            x[indices[i][0]]++;\n            y[indices[i][1]]++;\n        }\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                if( (x[i]+y[j])%2 !=0){\n                    total++;\n                }\n            }\n        }\n        return total;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n# 我的笔记\n构造两个分别以n和m为长度数组，来统计了那些行和列进行了加一操作，最后的数组中的每个数字就是对应行和列的数字之和\n\n# 高赞题解\n方法一：模拟\n\n我们可以使用一个 n * m 的矩阵来存放操作的结果，对于 indices 中的每一对 [ri, ci]，将矩阵第 ri 行的所有数增加 1，第 ci 列的所有数增加 1。\n\n在所有操作模拟完毕后，我们遍历矩阵，得到奇数的数目。\n\nclass Solution:\n    def oddCells(self, n: int, m: int, indices: List[List[int]]) -> int:\n        matrix = [[0] * m for _ in range(n)]\n        for x, y in indices:\n            for i in range(n):\n                matrix[i][y] += 1\n            for j in range(m):\n                matrix[x][j] += 1\n        return sum(elem % 2 == 1 for line in matrix for elem in line)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n复杂度分析\n\n * 时间复杂度：O(L(M+N)+MN)O(L(M + N) + MN)O(L(M+N)+MN)，其中 LLL 是 indices 数组的长度。\n   \n   \n * 空间复杂度：O(MN)O(MN)O(MN)。\n   \n   \n\n方法二：模拟 + 空间优化\n\n由于每次操作只会将一行和一列的数增加 1，因此我们可以使用一个行数组 rows 和列数组 cols 分别记录每一行和每一列被增加的次数。对于 indices 中的每一对 [ri, ci]，我们将 rows[ri] 和 cols[ci] 的值分别增加 1。\n\n在所有操作模拟完毕后，矩阵中位于 (x, y) 位置的数即为 rows[x] + cols[y]。我们遍历矩阵，得到奇数的数目。\n\nclass Solution:\n    def oddCells(self, n: int, m: int, indices: List[List[int]]) -> int:\n        rows = [0] * n\n        cols = [0] * m\n        for x, y in indices:\n            rows[x] += 1\n            cols[y] += 1\n        return sum((rows[x] + cols[y]) % 2 == 1 for x in range(n) for y in range(m))\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n复杂度分析\n\n * 时间复杂度：O(L+MN)O(L + MN)O(L+MN)，其中 LLL 是 indices 数组的长度。\n   \n   \n * 空间复杂度：O(M+N)O(M + N)O(M+N)。\n   \n   \n\n方法三：计数\n\n我们可以继续对方法二进行优化。可以发现，矩阵中位于 (x, y) 位置的数为奇数，当且仅当 rows[x] 和 cols[y] 中恰好有一个为奇数。因此对于 rows[x] 为偶数，那么在第 x 行有 count_odd(cols) 个位置的数为奇数；对于 rows[x] 为奇数，那么在第 x 行有 m - count_odd(cols) 个位置的数为偶数，其中 count_odd(cols) 表示数组 cols 中奇数的个数。将所有的行 x 进行求和，可以得到奇数的数目为 count_odd(rows) * (m - count_odd(cols)) + (n - count_odd(rows)) * count_odd(cols)。\n\nclass Solution:\n    def oddCells(self, n: int, m: int, indices: List[List[int]]) -> int:\n        rows = [0] * n\n        cols = [0] * m\n        for x, y in indices:\n            rows[x] += 1\n            cols[y] += 1\n\n        odd_rows = sum(x % 2 == 1 for x in rows)\n        odd_cols = sum(y % 2 == 1 for y in cols)\n        return odd_rows * (m - odd_cols) + (n - odd_rows) * odd_cols\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n复杂度分析\n\n * 时间复杂度：O(L+M+N)O(L + M + N)O(L+M+N)，其中 LLL 是 indices 数组的长度。\n   \n   \n * 空间复杂度：O(M+N)O(M + N)O(M+N)。\n   \n   \n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2020-01-16 21:47:33Accepted [https://leetcode-cn.com//submissions/detail/43738366/]1 ms100.0%36.4 MBjava# 统计信息\n通过次数提交次数AC比率162502155275.4%",contentLowercase:"# 中文题目\n给你一个 m x n 的矩阵，最开始的时候，每个单元格中的值都是 0。\n\n另有一个二维索引数组indices，indices[i] = [ri, ci] 指向矩阵中的某个位置，其中 ri 和 ci 分别表示指定的行和列（从 0 开始编号）。\n\n对 indices[i] 所指向的每个位置，应同时执行下述增量操作：\n\n 1. ri 行上的所有单元格，加 1 。\n 2. ci 列上的所有单元格，加 1 。\n\n给你 m、n 和 indices 。请你在执行完所有indices指定的增量操作后，返回矩阵中 奇数值单元格 的数目。\n\n\n\n示例 1：\n\n\n\n\n输入：m = 2, n = 3, indices = [[0,1],[1,1]]\n输出：6\n解释：最开始的矩阵是 [[0,0,0],[0,0,0]]。\n第一次增量操作后得到 [[1,2,1],[0,1,0]]。\n最后的矩阵是 [[1,3,1],[1,3,1]]，里面有 6 个奇数。\n\n\n示例 2：\n\n\n\n\n输入：m = 2, n = 2, indices = [[1,1],[0,0]]\n输出：0\n解释：最后的矩阵是 [[2,2],[2,2]]，里面没有奇数。\n\n\n\n\n提示：\n\n * 1 \n * 1 \n * 0 i < m\n * 0 i < n\n\n\n\n进阶：你可以设计一个时间复杂度为 o(n + m + indices.length) 且仅用 o(n + m) 额外空间的算法来解决此问题吗？\n\n# 通过代码\nclass solution {\n    public int oddcells(int n, int m, int[][] indices) {\n        int[] x=new int[n];\n        int[] y=new int[m];\n        int total=0;\n        for (int i = 0; i < indices.length; i++) {\n            x[indices[i][0]]++;\n            y[indices[i][1]]++;\n        }\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                if( (x[i]+y[j])%2 !=0){\n                    total++;\n                }\n            }\n        }\n        return total;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\nclass solution {\n    public int oddcells(int n, int m, int[][] indices) {\n        int[] x=new int[n];\n        int[] y=new int[m];\n        int total=0;\n        for (int i = 0; i < indices.length; i++) {\n            x[indices[i][0]]++;\n            y[indices[i][1]]++;\n        }\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                if( (x[i]+y[j])%2 !=0){\n                    total++;\n                }\n            }\n        }\n        return total;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n# 我的笔记\n构造两个分别以n和m为长度数组，来统计了那些行和列进行了加一操作，最后的数组中的每个数字就是对应行和列的数字之和\n\n# 高赞题解\n方法一：模拟\n\n我们可以使用一个 n * m 的矩阵来存放操作的结果，对于 indices 中的每一对 [ri, ci]，将矩阵第 ri 行的所有数增加 1，第 ci 列的所有数增加 1。\n\n在所有操作模拟完毕后，我们遍历矩阵，得到奇数的数目。\n\nclass solution:\n    def oddcells(self, n: int, m: int, indices: list[list[int]]) -> int:\n        matrix = [[0] * m for _ in range(n)]\n        for x, y in indices:\n            for i in range(n):\n                matrix[i][y] += 1\n            for j in range(m):\n                matrix[x][j] += 1\n        return sum(elem % 2 == 1 for line in matrix for elem in line)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n复杂度分析\n\n * 时间复杂度：o(l(m+n)+mn)o(l(m + n) + mn)o(l(m+n)+mn)，其中 lll 是 indices 数组的长度。\n   \n   \n * 空间复杂度：o(mn)o(mn)o(mn)。\n   \n   \n\n方法二：模拟 + 空间优化\n\n由于每次操作只会将一行和一列的数增加 1，因此我们可以使用一个行数组 rows 和列数组 cols 分别记录每一行和每一列被增加的次数。对于 indices 中的每一对 [ri, ci]，我们将 rows[ri] 和 cols[ci] 的值分别增加 1。\n\n在所有操作模拟完毕后，矩阵中位于 (x, y) 位置的数即为 rows[x] + cols[y]。我们遍历矩阵，得到奇数的数目。\n\nclass solution:\n    def oddcells(self, n: int, m: int, indices: list[list[int]]) -> int:\n        rows = [0] * n\n        cols = [0] * m\n        for x, y in indices:\n            rows[x] += 1\n            cols[y] += 1\n        return sum((rows[x] + cols[y]) % 2 == 1 for x in range(n) for y in range(m))\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n复杂度分析\n\n * 时间复杂度：o(l+mn)o(l + mn)o(l+mn)，其中 lll 是 indices 数组的长度。\n   \n   \n * 空间复杂度：o(m+n)o(m + n)o(m+n)。\n   \n   \n\n方法三：计数\n\n我们可以继续对方法二进行优化。可以发现，矩阵中位于 (x, y) 位置的数为奇数，当且仅当 rows[x] 和 cols[y] 中恰好有一个为奇数。因此对于 rows[x] 为偶数，那么在第 x 行有 count_odd(cols) 个位置的数为奇数；对于 rows[x] 为奇数，那么在第 x 行有 m - count_odd(cols) 个位置的数为偶数，其中 count_odd(cols) 表示数组 cols 中奇数的个数。将所有的行 x 进行求和，可以得到奇数的数目为 count_odd(rows) * (m - count_odd(cols)) + (n - count_odd(rows)) * count_odd(cols)。\n\nclass solution:\n    def oddcells(self, n: int, m: int, indices: list[list[int]]) -> int:\n        rows = [0] * n\n        cols = [0] * m\n        for x, y in indices:\n            rows[x] += 1\n            cols[y] += 1\n\n        odd_rows = sum(x % 2 == 1 for x in rows)\n        odd_cols = sum(y % 2 == 1 for y in cols)\n        return odd_rows * (m - odd_cols) + (n - odd_rows) * odd_cols\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n复杂度分析\n\n * 时间复杂度：o(l+m+n)o(l + m + n)o(l+m+n)，其中 lll 是 indices 数组的长度。\n   \n   \n * 空间复杂度：o(m+n)o(m + n)o(m+n)。\n   \n   \n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2020-01-16 21:47:33accepted [https://leetcode-cn.com//submissions/detail/43738366/]1 ms100.0%36.4 mbjava# 统计信息\n通过次数提交次数ac比率162502155275.4%"},{title:"1295-统计位数为偶数的数字(Find Numbers with Even Number of Digits)",frontmatter:{title:"1295-统计位数为偶数的数字(Find Numbers with Even Number of Digits)",date:"2020-01-12T00:00:00.000Z",categories:["简单"],tags:["数组<Array>"]},regularPath:"/views/%E7%AE%80%E5%8D%95/1295-%E7%BB%9F%E8%AE%A1%E4%BD%8D%E6%95%B0%E4%B8%BA%E5%81%B6%E6%95%B0%E7%9A%84%E6%95%B0%E5%AD%97.html",relativePath:"views/简单/1295-统计位数为偶数的数字.md",key:"v-71aae79a",path:"/views/%E7%AE%80%E5%8D%95/1295-%E7%BB%9F%E8%AE%A1%E4%BD%8D%E6%95%B0%E4%B8%BA%E5%81%B6%E6%95%B0%E7%9A%84%E6%95%B0%E5%AD%97.html",headers:[{level:2,title:"中文题目",slug:"中文题目",charIndex:2},{level:2,title:"通过代码",slug:"通过代码",charIndex:340},{level:2,title:"高赞题解",slug:"高赞题解",charIndex:1843},{level:3,title:"解题思路",slug:"解题思路",charIndex:1850},{level:3,title:"代码",slug:"代码",charIndex:342},{level:2,title:"提交历史",slug:"提交历史",charIndex:2154},{level:2,title:"统计信息",slug:"统计信息",charIndex:2392}],lastUpdated:"4/11/2021, 6:09:39 PM",headersStr:"中文题目 通过代码 高赞题解 解题思路 代码 提交历史 统计信息",content:"# 中文题目\n给你一个整数数组nums，请你返回其中位数为偶数的数字的个数。\n\n\n\n示例 1：\n\n输入：nums = [12,345,2,6,7896]\n输出：2\n解释：\n12 是 2 位数字（位数为偶数） \n345 是 3 位数字（位数为奇数）  \n2 是 1 位数字（位数为奇数） \n6 是 1 位数字 位数为奇数） \n7896 是 4 位数字（位数为偶数）  \n因此只有 12 和 7896 是位数为偶数的数字\n\n\n示例 2：\n\n输入：nums = [555,901,482,1771]\n输出：1 \n解释： \n只有 1771 是位数为偶数的数字。\n\n\n\n\n提示：\n\n * 1 <= nums.length <= 500\n * 1 <= nums[i] <= 10^5\n\n# 通过代码\nclass Solution {\n    public int findNumbers(int[] nums) {\n        int total = (int) Arrays.stream(nums).parallel().filter(x -> {\n            int count = 0;\n            while (x > 0) {\n                x /= 10;\n                count++;\n            }\n            return count % 2 == 0 ? true : false;\n        }).count();\n        return total;   \n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\nclass Solution {\n    public int findNumbers(int[] nums) {\n        int total = (int) Arrays.stream(nums).filter(x -> {\n            int count = 0;\n            while (x > 0) {\n                x /= 10;\n                count++;\n            }\n            return count % 2 == 0 ? true : false;\n        }).count();\n        return total;    \n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\nclass Solution {\n    public int findNumbers(int[] nums) {\n        int total = (int) Arrays.stream(nums).parallel().filter(x -> {\n            int count = 0;\n            while (x > 0) {\n                x /= 10;\n                count++;\n            }\n            return count % 2 == 0 ? true : false;\n        }).count();\n        return total;   \n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\nclass Solution {\n    public int findNumbers(int[] nums) {\n        int total = (int) Arrays.stream(nums).filter(x -> {\n            int count = 0;\n            while (x > 0) {\n                x /= 10;\n                count++;\n            }\n            return count % 2 == 0 ? true : false;\n        }).count();\n        return total;    \n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n# 高赞题解\n# 解题思路\n将int转为String，调用.length，然后%2==0即为偶数\n\n# 代码\nclass Solution {\n    public int findNumbers(int[] nums) {\n        int res=0;\n        for(int i:nums){\n            if(String.valueOf(i).length()%2==0){\n                res++;\n            }\n        }\n\n        return res;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2020-01-12 17:57:37Accepted [https://leetcode-cn.com//submissions/detail/43198954/]15 ms100.0%37.9 MBjava2020-01-12 17:56:53Accepted [https://leetcode-cn.com//submissions/detail/43198895/]8 ms100.0%38.1 MBjava# 统计信息\n通过次数提交次数AC比率429855298481.1%",contentLowercase:"# 中文题目\n给你一个整数数组nums，请你返回其中位数为偶数的数字的个数。\n\n\n\n示例 1：\n\n输入：nums = [12,345,2,6,7896]\n输出：2\n解释：\n12 是 2 位数字（位数为偶数） \n345 是 3 位数字（位数为奇数）  \n2 是 1 位数字（位数为奇数） \n6 是 1 位数字 位数为奇数） \n7896 是 4 位数字（位数为偶数）  \n因此只有 12 和 7896 是位数为偶数的数字\n\n\n示例 2：\n\n输入：nums = [555,901,482,1771]\n输出：1 \n解释： \n只有 1771 是位数为偶数的数字。\n\n\n\n\n提示：\n\n * 1 <= nums.length <= 500\n * 1 <= nums[i] <= 10^5\n\n# 通过代码\nclass solution {\n    public int findnumbers(int[] nums) {\n        int total = (int) arrays.stream(nums).parallel().filter(x -> {\n            int count = 0;\n            while (x > 0) {\n                x /= 10;\n                count++;\n            }\n            return count % 2 == 0 ? true : false;\n        }).count();\n        return total;   \n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\nclass solution {\n    public int findnumbers(int[] nums) {\n        int total = (int) arrays.stream(nums).filter(x -> {\n            int count = 0;\n            while (x > 0) {\n                x /= 10;\n                count++;\n            }\n            return count % 2 == 0 ? true : false;\n        }).count();\n        return total;    \n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\nclass solution {\n    public int findnumbers(int[] nums) {\n        int total = (int) arrays.stream(nums).parallel().filter(x -> {\n            int count = 0;\n            while (x > 0) {\n                x /= 10;\n                count++;\n            }\n            return count % 2 == 0 ? true : false;\n        }).count();\n        return total;   \n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\nclass solution {\n    public int findnumbers(int[] nums) {\n        int total = (int) arrays.stream(nums).filter(x -> {\n            int count = 0;\n            while (x > 0) {\n                x /= 10;\n                count++;\n            }\n            return count % 2 == 0 ? true : false;\n        }).count();\n        return total;    \n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n# 高赞题解\n# 解题思路\n将int转为string，调用.length，然后%2==0即为偶数\n\n# 代码\nclass solution {\n    public int findnumbers(int[] nums) {\n        int res=0;\n        for(int i:nums){\n            if(string.valueof(i).length()%2==0){\n                res++;\n            }\n        }\n\n        return res;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2020-01-12 17:57:37accepted [https://leetcode-cn.com//submissions/detail/43198954/]15 ms100.0%37.9 mbjava2020-01-12 17:56:53accepted [https://leetcode-cn.com//submissions/detail/43198895/]8 ms100.0%38.1 mbjava# 统计信息\n通过次数提交次数ac比率429855298481.1%"},{title:"1304-和为零的N个唯一整数(Find N Unique Integers Sum up to Zero)",frontmatter:{title:"1304-和为零的N个唯一整数(Find N Unique Integers Sum up to Zero)",date:"2020-01-15T00:00:00.000Z",categories:["简单"],tags:["数组<Array>"]},regularPath:"/views/%E7%AE%80%E5%8D%95/1304-%E5%92%8C%E4%B8%BA%E9%9B%B6%E7%9A%84N%E4%B8%AA%E5%94%AF%E4%B8%80%E6%95%B4%E6%95%B0.html",relativePath:"views/简单/1304-和为零的N个唯一整数.md",key:"v-a8e7c0ea",path:"/views/%E7%AE%80%E5%8D%95/1304-%E5%92%8C%E4%B8%BA%E9%9B%B6%E7%9A%84N%E4%B8%AA%E5%94%AF%E4%B8%80%E6%95%B4%E6%95%B0.html",headers:[{level:2,title:"中文题目",slug:"中文题目",charIndex:2},{level:2,title:"通过代码",slug:"通过代码",charIndex:223},{level:2,title:"高赞题解",slug:"高赞题解",charIndex:894},{level:2,title:"提交历史",slug:"提交历史",charIndex:1165},{level:2,title:"统计信息",slug:"统计信息",charIndex:1298}],lastUpdated:"4/11/2021, 6:09:39 PM",headersStr:"中文题目 通过代码 高赞题解 提交历史 统计信息",content:"# 中文题目\n给你一个整数n，请你返回 任意一个由 n个 各不相同的整数组成的数组，并且这 n 个数相加和为 0 。\n\n\n\n示例 1：\n\n输入：n = 5\n输出：[-7,-1,1,3,4]\n解释：这些数组也是正确的 [-5,-1,1,2,3]，[-3,-1,2,-2,4]。\n\n\n示例 2：\n\n输入：n = 3\n输出：[-1,0,1]\n\n\n示例 3：\n\n输入：n = 1\n输出：[0]\n\n\n\n\n提示：\n\n * 1 <= n <= 1000\n\n# 通过代码\nclass Solution {\n    public int[] sumZero(int n) {\n        int start = -1 * n / 2;\n        int[] arr = new int[n];\n        for (int i = 0; i < n; i++) {\n            if (n % 2 == 0 && start == 0) {\n                start++;\n            }\n            arr[i] = start++;\n        }\n        return arr;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\nclass Solution {\n    public int[] sumZero(int n) {\n        int start = -1 * n / 2;\n        int[] arr = new int[n];\n        for (int i = 0; i < n; i++) {\n            if (n % 2 == 0 && start == 0) {\n                start++;\n            }\n            arr[i] = start++;\n        }\n        return arr;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n# 高赞题解\nshow the code\n\n    public int[] sumZero(int n) {\n        int[] ans = new int[n];\n        int index = 0;\n        for (int i = 1; i <= n / 2; i++) {\n            ans[index++] = -i;\n            ans[index++] = i;\n        }\n        return ans;\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2020-01-15 22:47:55Accepted [https://leetcode-cn.com//submissions/detail/43617330/]0 ms100.0%33.8 MBjava# 统计信息\n通过次数提交次数AC比率188262560073.5%",contentLowercase:"# 中文题目\n给你一个整数n，请你返回 任意一个由 n个 各不相同的整数组成的数组，并且这 n 个数相加和为 0 。\n\n\n\n示例 1：\n\n输入：n = 5\n输出：[-7,-1,1,3,4]\n解释：这些数组也是正确的 [-5,-1,1,2,3]，[-3,-1,2,-2,4]。\n\n\n示例 2：\n\n输入：n = 3\n输出：[-1,0,1]\n\n\n示例 3：\n\n输入：n = 1\n输出：[0]\n\n\n\n\n提示：\n\n * 1 <= n <= 1000\n\n# 通过代码\nclass solution {\n    public int[] sumzero(int n) {\n        int start = -1 * n / 2;\n        int[] arr = new int[n];\n        for (int i = 0; i < n; i++) {\n            if (n % 2 == 0 && start == 0) {\n                start++;\n            }\n            arr[i] = start++;\n        }\n        return arr;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\nclass solution {\n    public int[] sumzero(int n) {\n        int start = -1 * n / 2;\n        int[] arr = new int[n];\n        for (int i = 0; i < n; i++) {\n            if (n % 2 == 0 && start == 0) {\n                start++;\n            }\n            arr[i] = start++;\n        }\n        return arr;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n# 高赞题解\nshow the code\n\n    public int[] sumzero(int n) {\n        int[] ans = new int[n];\n        int index = 0;\n        for (int i = 1; i <= n / 2; i++) {\n            ans[index++] = -i;\n            ans[index++] = i;\n        }\n        return ans;\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2020-01-15 22:47:55accepted [https://leetcode-cn.com//submissions/detail/43617330/]0 ms100.0%33.8 mbjava# 统计信息\n通过次数提交次数ac比率188262560073.5%"},{title:"1299-将每个元素替换为右侧最大元素(Replace Elements with Greatest Element on Right Side)",frontmatter:{title:"1299-将每个元素替换为右侧最大元素(Replace Elements with Greatest Element on Right Side)",date:"2020-01-16T00:00:00.000Z",categories:["简单"],tags:["数组<Array>"]},regularPath:"/views/%E7%AE%80%E5%8D%95/1299-%E5%B0%86%E6%AF%8F%E4%B8%AA%E5%85%83%E7%B4%A0%E6%9B%BF%E6%8D%A2%E4%B8%BA%E5%8F%B3%E4%BE%A7%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0.html",relativePath:"views/简单/1299-将每个元素替换为右侧最大元素.md",key:"v-0aece9fa",path:"/views/%E7%AE%80%E5%8D%95/1299-%E5%B0%86%E6%AF%8F%E4%B8%AA%E5%85%83%E7%B4%A0%E6%9B%BF%E6%8D%A2%E4%B8%BA%E5%8F%B3%E4%BE%A7%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0.html",headers:[{level:2,title:"中文题目",slug:"中文题目",charIndex:2},{level:2,title:"通过代码",slug:"通过代码",charIndex:421},{level:2,title:"高赞题解",slug:"高赞题解",charIndex:1090},{level:2,title:"提交历史",slug:"提交历史",charIndex:1556},{level:2,title:"统计信息",slug:"统计信息",charIndex:1689}],lastUpdated:"4/11/2021, 6:09:39 PM",headersStr:"中文题目 通过代码 高赞题解 提交历史 统计信息",content:"# 中文题目\n给你一个数组arr，请你将每个元素用它右边最大的元素替换，如果是最后一个元素，用-1 替换。\n\n完成所有替换操作后，请你返回这个数组。\n\n\n\n示例 1：\n\n\n输入：arr = [17,18,5,4,6,1]\n输出：[18,6,6,6,1,-1]\n解释：\n- 下标 0 的元素 --\x3e 右侧最大元素是下标 1 的元素 (18)\n- 下标 1 的元素 --\x3e 右侧最大元素是下标 4 的元素 (6)\n- 下标 2 的元素 --\x3e 右侧最大元素是下标 4 的元素 (6)\n- 下标 3 的元素 --\x3e 右侧最大元素是下标 4 的元素 (6)\n- 下标 4 的元素 --\x3e 右侧最大元素是下标 5 的元素 (1)\n- 下标 5 的元素 --\x3e 右侧没有其他元素，替换为 -1\n\n\n示例 2：\n\n\n输入：arr = [400]\n输出：[-1]\n解释：下标 0 的元素右侧没有其他元素。\n\n\n\n\n提示：\n\n * 1 4\n * 1 5\n\n# 通过代码\nclass Solution {\n    public int[] replaceElements(int[] arr) {\n        int max=arr[arr.length-1];\n        arr[arr.length-1]=-1;\n        for (int i = arr.length-2; i >=0 ; i--) {\n            int temp=arr[i];\n            arr[i]=max;\n            max = temp>max?temp:max;\n        }\n        return arr;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\nclass Solution {\n    public int[] replaceElements(int[] arr) {\n        int max=arr[arr.length-1];\n        arr[arr.length-1]=-1;\n        for (int i = arr.length-2; i >=0 ; i--) {\n            int temp=arr[i];\n            arr[i]=max;\n            max = temp>max?temp:max;\n        }\n        return arr;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n# 高赞题解\n\n\n从右往左遍历，先记录右边最大值 rightMax 为最后一个值，向左每次更新 rightMax，使用变量 t 先记住当前 arr[i] 就可以了。\n\nclass Solution {\n    public int[] replaceElements(int[] arr) {\n        int rightMax = arr[arr.length - 1];\n        arr[arr.length - 1] = -1;\n        for (int i = arr.length - 2; i >= 0; i--) {\n            int t = arr[i];\n            arr[i] = rightMax;\n            if (t > rightMax)\n                rightMax = t;\n        }\n        return arr;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2020-01-16 22:12:29Accepted [https://leetcode-cn.com//submissions/detail/43741175/]1 ms100.0%39.5 MBjava# 统计信息\n通过次数提交次数AC比率268013430678.1%",contentLowercase:"# 中文题目\n给你一个数组arr，请你将每个元素用它右边最大的元素替换，如果是最后一个元素，用-1 替换。\n\n完成所有替换操作后，请你返回这个数组。\n\n\n\n示例 1：\n\n\n输入：arr = [17,18,5,4,6,1]\n输出：[18,6,6,6,1,-1]\n解释：\n- 下标 0 的元素 --\x3e 右侧最大元素是下标 1 的元素 (18)\n- 下标 1 的元素 --\x3e 右侧最大元素是下标 4 的元素 (6)\n- 下标 2 的元素 --\x3e 右侧最大元素是下标 4 的元素 (6)\n- 下标 3 的元素 --\x3e 右侧最大元素是下标 4 的元素 (6)\n- 下标 4 的元素 --\x3e 右侧最大元素是下标 5 的元素 (1)\n- 下标 5 的元素 --\x3e 右侧没有其他元素，替换为 -1\n\n\n示例 2：\n\n\n输入：arr = [400]\n输出：[-1]\n解释：下标 0 的元素右侧没有其他元素。\n\n\n\n\n提示：\n\n * 1 4\n * 1 5\n\n# 通过代码\nclass solution {\n    public int[] replaceelements(int[] arr) {\n        int max=arr[arr.length-1];\n        arr[arr.length-1]=-1;\n        for (int i = arr.length-2; i >=0 ; i--) {\n            int temp=arr[i];\n            arr[i]=max;\n            max = temp>max?temp:max;\n        }\n        return arr;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\nclass solution {\n    public int[] replaceelements(int[] arr) {\n        int max=arr[arr.length-1];\n        arr[arr.length-1]=-1;\n        for (int i = arr.length-2; i >=0 ; i--) {\n            int temp=arr[i];\n            arr[i]=max;\n            max = temp>max?temp:max;\n        }\n        return arr;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n# 高赞题解\n\n\n从右往左遍历，先记录右边最大值 rightmax 为最后一个值，向左每次更新 rightmax，使用变量 t 先记住当前 arr[i] 就可以了。\n\nclass solution {\n    public int[] replaceelements(int[] arr) {\n        int rightmax = arr[arr.length - 1];\n        arr[arr.length - 1] = -1;\n        for (int i = arr.length - 2; i >= 0; i--) {\n            int t = arr[i];\n            arr[i] = rightmax;\n            if (t > rightmax)\n                rightmax = t;\n        }\n        return arr;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2020-01-16 22:12:29accepted [https://leetcode-cn.com//submissions/detail/43741175/]1 ms100.0%39.5 mbjava# 统计信息\n通过次数提交次数ac比率268013430678.1%"},{title:"1313-解压缩编码列表(Decompress Run-Length Encoded List)",frontmatter:{title:"1313-解压缩编码列表(Decompress Run-Length Encoded List)",date:"2020-01-12T00:00:00.000Z",categories:["简单"],tags:["数组<Array>"]},regularPath:"/views/%E7%AE%80%E5%8D%95/1313-%E8%A7%A3%E5%8E%8B%E7%BC%A9%E7%BC%96%E7%A0%81%E5%88%97%E8%A1%A8.html",relativePath:"views/简单/1313-解压缩编码列表.md",key:"v-c077fb86",path:"/views/%E7%AE%80%E5%8D%95/1313-%E8%A7%A3%E5%8E%8B%E7%BC%A9%E7%BC%96%E7%A0%81%E5%88%97%E8%A1%A8.html",headers:[{level:2,title:"中文题目",slug:"中文题目",charIndex:2},{level:2,title:"通过代码",slug:"通过代码",charIndex:411},{level:2,title:"高赞题解",slug:"高赞题解",charIndex:1152},{level:2,title:"分开两列表法",slug:"分开两列表法",charIndex:1159},{level:2,title:"使用两个for循环法",slug:"使用两个for循环法",charIndex:1558},{level:2,title:"花样sum法",slug:"花样sum法",charIndex:1997},{level:2,title:"提交历史",slug:"提交历史",charIndex:2468},{level:2,title:"统计信息",slug:"统计信息",charIndex:2602}],lastUpdated:"4/11/2021, 6:09:39 PM",headersStr:"中文题目 通过代码 高赞题解 分开两列表法 使用两个for循环法 花样sum法 提交历史 统计信息",content:"# 中文题目\n给你一个以行程长度编码压缩的整数列表nums。\n\n考虑每对相邻的两个元素 [freq, val] = [nums[2*i], nums[2*i+1]]（其中i >= 0），每一对都表示解压后子列表中有 freq个值为val的元素，你需要从左到右连接所有子列表以生成解压后的列表。\n\n请你返回解压后的列表。\n\n\n\n示例 1：\n\n\n输入：nums = [1,2,3,4]\n输出：[2,4,4,4]\n解释：第一对 [1,2] 代表着 2 的出现频次为 1，所以生成数组 [2]。\n第二对 [3,4] 代表着 4 的出现频次为 3，所以生成数组 [4,4,4]。\n最后将它们串联到一起 [2] + [4,4,4] = [2,4,4,4]。\n\n示例 2：\n\n\n输入：nums = [1,1,2,3]\n输出：[1,3,3]\n\n\n\n\n提示：\n\n * 2 \n * nums.length % 2 == 0\n * 1 \n\n# 通过代码\nclass Solution {\n    public int[] decompressRLElist(int[] nums) {\n        List<Integer> list = new ArrayList<>();\n        for (int i = 0; i < nums.length - 1; i += 2) {\n            for (int j = 0; j < nums[i]; j++) {\n                list.add(nums[i + 1]);\n            }\n        }\n        return list.stream().mapToInt(x -> x).toArray();\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\nclass Solution {\n    public int[] decompressRLElist(int[] nums) {\n        List<Integer> list = new ArrayList<>();\n        for (int i = 0; i < nums.length - 1; i += 2) {\n            for (int j = 0; j < nums[i]; j++) {\n                list.add(nums[i + 1]);\n            }\n        }\n        return list.stream().mapToInt(x -> x).toArray();\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n# 高赞题解\n# 分开两列表法\n * 最推荐这个做法\n * 思路是，将奇数和偶数位置的数分开成两个列表\n * nums[::2] 是反复次数，nums[1::2]是要出现的数\n * 包装在一起，提取出每个数和其对应的出现次数\n * for i,j in zip(nums[1::2],nums[::2])\n * 显示这个数，并且反复相应的次数\n * [i for i,j in zip(nums[1::2],nums[::2]) for _ in range(j)]\n * 完整代码如下\n\nclass Solution:\n    def decompressRLElist(self, nums: List[int]) -> List[int]:\n        return [i for i,j in zip(nums[1::2],nums[::2]) for _ in range(j)]\n\n\n1\n2\n3\n# 使用两个for循环法\n * 这个方法，我们先从简单开始构建。\n * 先考虑使用列表生成式写出一个原列表\n * [i for i in nums]\n * 接着考虑保留那些奇数位置的\n * [nums[i] for i in range(len(nums)) if i % 2 == 1]\n * 最后考虑让这些奇数位置的数反复偶数位置的次数\n * [nums[i] for i in range(len(nums)) for j in range(nums[i-1]) if i % 2 == 1]\n * 完整代码如下\n\nclass Solution:\n    def decompressRLElist(self, nums: List[int]) -> List[int]:\n        return [nums[i] for i in range(len(nums)) for j in range(nums[i-1]) if i % 2 == 1]\n\n\n1\n2\n3\n# 花样sum法\n * 参考评论区的代码\n * 首先像第一种解法一样提取每个数和它的出现次数\n * for i,j in zip(nums[1::2],nums[::2])\n * 然后将每个出现的数和它的重复次数组成一个列表（其实是列表生成式）\n * ([b] * a for a, b in zip(nums[::2], nums[1::2]))\n * 将这个列表生成式（生成出来的列表类似于[[1,1,1],[2,2,2]]）与一个空列表求和，可以将原二级嵌套列表展开\n * 即sum(([b] * a for a, b in zip(nums[::2], nums[1::2])), [])\n * 完整代码如下：\n\nclass Solution:\n    def decompressRLElist(self, nums: List[int]) -> List[int]:\n        return sum(([b] * a for a, b in zip(nums[::2], nums[1::2])), [])\n\n\n1\n2\n3\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2020-01-12 17:43:31Accepted [https://leetcode-cn.com//submissions/detail/43197720/]11 ms100.0%36.6 MBjava# 统计信息\n通过次数提交次数AC比率312193765482.9%",contentLowercase:"# 中文题目\n给你一个以行程长度编码压缩的整数列表nums。\n\n考虑每对相邻的两个元素 [freq, val] = [nums[2*i], nums[2*i+1]]（其中i >= 0），每一对都表示解压后子列表中有 freq个值为val的元素，你需要从左到右连接所有子列表以生成解压后的列表。\n\n请你返回解压后的列表。\n\n\n\n示例 1：\n\n\n输入：nums = [1,2,3,4]\n输出：[2,4,4,4]\n解释：第一对 [1,2] 代表着 2 的出现频次为 1，所以生成数组 [2]。\n第二对 [3,4] 代表着 4 的出现频次为 3，所以生成数组 [4,4,4]。\n最后将它们串联到一起 [2] + [4,4,4] = [2,4,4,4]。\n\n示例 2：\n\n\n输入：nums = [1,1,2,3]\n输出：[1,3,3]\n\n\n\n\n提示：\n\n * 2 \n * nums.length % 2 == 0\n * 1 \n\n# 通过代码\nclass solution {\n    public int[] decompressrlelist(int[] nums) {\n        list<integer> list = new arraylist<>();\n        for (int i = 0; i < nums.length - 1; i += 2) {\n            for (int j = 0; j < nums[i]; j++) {\n                list.add(nums[i + 1]);\n            }\n        }\n        return list.stream().maptoint(x -> x).toarray();\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\nclass solution {\n    public int[] decompressrlelist(int[] nums) {\n        list<integer> list = new arraylist<>();\n        for (int i = 0; i < nums.length - 1; i += 2) {\n            for (int j = 0; j < nums[i]; j++) {\n                list.add(nums[i + 1]);\n            }\n        }\n        return list.stream().maptoint(x -> x).toarray();\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n# 高赞题解\n# 分开两列表法\n * 最推荐这个做法\n * 思路是，将奇数和偶数位置的数分开成两个列表\n * nums[::2] 是反复次数，nums[1::2]是要出现的数\n * 包装在一起，提取出每个数和其对应的出现次数\n * for i,j in zip(nums[1::2],nums[::2])\n * 显示这个数，并且反复相应的次数\n * [i for i,j in zip(nums[1::2],nums[::2]) for _ in range(j)]\n * 完整代码如下\n\nclass solution:\n    def decompressrlelist(self, nums: list[int]) -> list[int]:\n        return [i for i,j in zip(nums[1::2],nums[::2]) for _ in range(j)]\n\n\n1\n2\n3\n# 使用两个for循环法\n * 这个方法，我们先从简单开始构建。\n * 先考虑使用列表生成式写出一个原列表\n * [i for i in nums]\n * 接着考虑保留那些奇数位置的\n * [nums[i] for i in range(len(nums)) if i % 2 == 1]\n * 最后考虑让这些奇数位置的数反复偶数位置的次数\n * [nums[i] for i in range(len(nums)) for j in range(nums[i-1]) if i % 2 == 1]\n * 完整代码如下\n\nclass solution:\n    def decompressrlelist(self, nums: list[int]) -> list[int]:\n        return [nums[i] for i in range(len(nums)) for j in range(nums[i-1]) if i % 2 == 1]\n\n\n1\n2\n3\n# 花样sum法\n * 参考评论区的代码\n * 首先像第一种解法一样提取每个数和它的出现次数\n * for i,j in zip(nums[1::2],nums[::2])\n * 然后将每个出现的数和它的重复次数组成一个列表（其实是列表生成式）\n * ([b] * a for a, b in zip(nums[::2], nums[1::2]))\n * 将这个列表生成式（生成出来的列表类似于[[1,1,1],[2,2,2]]）与一个空列表求和，可以将原二级嵌套列表展开\n * 即sum(([b] * a for a, b in zip(nums[::2], nums[1::2])), [])\n * 完整代码如下：\n\nclass solution:\n    def decompressrlelist(self, nums: list[int]) -> list[int]:\n        return sum(([b] * a for a, b in zip(nums[::2], nums[1::2])), [])\n\n\n1\n2\n3\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2020-01-12 17:43:31accepted [https://leetcode-cn.com//submissions/detail/43197720/]11 ms100.0%36.6 mbjava# 统计信息\n通过次数提交次数ac比率312193765482.9%"},{title:"1365-有多少小于当前数字的数字(How Many Numbers Are Smaller Than the Current Number)",frontmatter:{title:"1365-有多少小于当前数字的数字(How Many Numbers Are Smaller Than the Current Number)",date:"2020-04-01T00:00:00.000Z",categories:["简单"],tags:["数组<Array>","哈希表<Hash Table>"]},regularPath:"/views/%E7%AE%80%E5%8D%95/1365-%E6%9C%89%E5%A4%9A%E5%B0%91%E5%B0%8F%E4%BA%8E%E5%BD%93%E5%89%8D%E6%95%B0%E5%AD%97%E7%9A%84%E6%95%B0%E5%AD%97.html",relativePath:"views/简单/1365-有多少小于当前数字的数字.md",key:"v-3f33cfdc",path:"/views/%E7%AE%80%E5%8D%95/1365-%E6%9C%89%E5%A4%9A%E5%B0%91%E5%B0%8F%E4%BA%8E%E5%BD%93%E5%89%8D%E6%95%B0%E5%AD%97%E7%9A%84%E6%95%B0%E5%AD%97.html",headers:[{level:2,title:"中文题目",slug:"中文题目",charIndex:2},{level:2,title:"通过代码",slug:"通过代码",charIndex:487},{level:2,title:"高赞题解",slug:"高赞题解",charIndex:1412},{level:2,title:"提交历史",slug:"提交历史",charIndex:9628},{level:2,title:"统计信息",slug:"统计信息",charIndex:10067}],lastUpdated:"4/11/2021, 1:15:21 PM",headersStr:"中文题目 通过代码 高赞题解 提交历史 统计信息",content:"# 中文题目\n给你一个数组nums，对于其中每个元素nums[i]，请你统计数组中比它小的所有数字的数目。\n\n换而言之，对于每个nums[i]你必须计算出有效的j的数量，其中 j 满足j != i 且 nums[j] < nums[i]。\n\n以数组形式返回答案。\n\n\n\n示例 1：\n\n输入：nums = [8,1,2,2,3]\n输出：[4,0,1,1,3]\n解释： \n对于 nums[0]=8 存在四个比它小的数字：（1，2，2 和 3）。 \n对于 nums[1]=1 不存在比它小的数字。\n对于 nums[2]=2 存在一个比它小的数字：（1）。 \n对于 nums[3]=2 存在一个比它小的数字：（1）。 \n对于 nums[4]=3 存在三个比它小的数字：（1，2 和 2）。\n\n\n示例 2：\n\n输入：nums = [6,5,4,8]\n输出：[2,1,0,3]\n\n\n示例 3：\n\n输入：nums = [7,7,7,7]\n输出：[0,0,0,0]\n\n\n\n\n提示：\n\n * 2 <= nums.length <= 500\n * 0 <= nums[i] <= 100\n\n# 通过代码\nclass Solution {\n    public int[] smallerNumbersThanCurrent(int[] nums) {\n        int[] arr=new int[100+1];\n        for (int i = 0; i < nums.length; i++) {\n            arr[nums[i]]++;\n        }\n        for (int i = 1; i < arr.length; i++) {\n            arr[i]=arr[i-1]+arr[i];\n        }\n        for (int i = 0; i < nums.length; i++) {\n            nums[i]=nums[i]==0?0:arr[nums[i]-1];\n        }\n        return nums;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\nclass Solution {\n    public int[] smallerNumbersThanCurrent(int[] nums) {\n        int[] arr=new int[100+1];\n        for (int i = 0; i < nums.length; i++) {\n            arr[nums[i]]++;\n        }\n        for (int i = 1; i < arr.length; i++) {\n            arr[i]=arr[i-1]+arr[i];\n        }\n        for (int i = 0; i < nums.length; i++) {\n            nums[i]=nums[i]==0?0:arr[nums[i]-1];\n        }\n        return nums;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n# 高赞题解\n# 方法一：暴力\n比较容易想到的一个方法是，对于数组中的每一个元素，我们都遍历数组一次，统计小于当前元素的数的数目。\n\nclass Solution {\npublic:\n    vector<int> smallerNumbersThanCurrent(vector<int>& nums) {\n        vector<int> ret;\n        int n = nums.size();\n        for (int i = 0; i < n; i++) {\n            int cnt = 0;\n            for (int j = 0; j < n; j++) {\n                if (nums[j] < nums[i]) {\n                    cnt++;\n                }\n            }\n            ret.push_back(cnt);\n        }\n        return ret;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\nclass Solution {\n    public int[] smallerNumbersThanCurrent(int[] nums) {\n        int n = nums.length;\n        int[] ret = new int[n];\n        for (int i = 0; i < n; i++) {\n            int cnt = 0;\n            for (int j = 0; j < n; j++) {\n                if (nums[j] < nums[i]) {\n                    cnt++;\n                }\n            }\n            ret[i] = cnt;\n        }\n        return ret;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\nfunc smallerNumbersThanCurrent(nums []int) (ans []int) {\n    for _, v := range nums {\n        cnt := 0\n        for _, w := range nums {\n            if w < v {\n                cnt++\n            }\n        }\n        ans = append(ans, cnt)\n    }\n    return\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\nint* smallerNumbersThanCurrent(int* nums, int numsSize, int* returnSize) {\n    int* ret = malloc(sizeof(int) * numsSize);\n    *returnSize = numsSize;\n    for (int i = 0; i < numsSize; i++) {\n        int cnt = 0;\n        for (int j = 0; j < numsSize; j++) {\n            if (nums[j] < nums[i]) {\n                cnt++;\n            }\n        }\n        ret[i] = cnt;\n    }\n    return ret;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\nvar smallerNumbersThanCurrent = function(nums) {\n    const n = nums.length;\n    const ret = [];\n    for (let i = 0; i < n; ++i) {\n        let cnt = 0;\n        for (let j = 0; j < n; ++j) {\n            if (nums[j] < nums[i]) {\n                cnt++;\n            }\n        }\n        ret[i] = cnt;\n    }\n    return ret;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n复杂度分析\n\n * 时间复杂度：O(N2)O(N^2)O(N2)，其中 NNN 为数组的长度。\n * 空间复杂度：O(1)O(1)O(1)。注意我们不计算答案数组的空间占用。\n\n# 方法二：排序\n我们也可以将数组排序，并记录每一个数在原数组中的位置。对于排序后的数组中的每一个数，我们找出其左侧第一个小于它的数，这样就能够知道数组中小于该数的数量。\n\nclass Solution {\npublic:\n    vector<int> smallerNumbersThanCurrent(vector<int>& nums) {\n        vector<pair<int, int>> data;\n        int n = nums.size();\n        for (int i = 0; i < n; i++) {\n            data.emplace_back(nums[i], i);\n        }\n        sort(data.begin(), data.end());\n\n        vector<int> ret(n, 0);\n        int prev = -1;\n        for (int i = 0; i < n; i++) {\n            if (prev == -1 || data[i].first != data[i - 1].first) {\n                prev = i;\n            }\n            ret[data[i].second] = prev;\n        }\n        return ret;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\nclass Solution {\n    public int[] smallerNumbersThanCurrent(int[] nums) {\n        int n = nums.length;\n        int[][] data = new int[n][2];\n        for (int i = 0; i < n; i++) {\n            data[i][0] = nums[i];\n            data[i][1] = i;\n        }\n        Arrays.sort(data, new Comparator<int[]>() {\n            public int compare(int[] data1, int[] data2) {\n                return data1[0] - data2[0];\n            }\n        });\n\n        int[] ret = new int[n];\n        int prev = -1;\n        for (int i = 0; i < n; i++) {\n            if (prev == -1 || data[i][0] != data[i - 1][0]) {\n                prev = i;\n            }\n            ret[data[i][1]] = prev;\n        }\n        return ret;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\ntype pair struct{ v, pos int }\n\nfunc smallerNumbersThanCurrent(nums []int) []int {\n    n := len(nums)\n    data := make([]pair, n)\n    for i, v := range nums {\n        data[i] = pair{v, i}\n    }\n    sort.Slice(data, func(i, j int) bool { return data[i].v < data[j].v })\n    ans := make([]int, n)\n    prev := -1\n    for i, d := range data {\n        if prev == -1 || d.v != data[i-1].v {\n            prev = i\n        }\n        ans[d.pos] = prev\n    }\n    return ans\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\nint cmp(const void* a, const void* b) {\n    return ((*(int**)a)[0] - (*(int**)b)[0]);\n}\n\nint* smallerNumbersThanCurrent(int* nums, int numsSize, int* returnSize) {\n    int* data[numsSize];\n    for (int i = 0; i < numsSize; i++) {\n        data[i] = malloc(sizeof(int) * 2);\n        data[i][0] = nums[i], data[i][1] = i;\n    }\n    qsort(data, numsSize, sizeof(int*), cmp);\n\n    int* ret = malloc(sizeof(int) * numsSize);\n    *returnSize = numsSize;\n    int prev = -1;\n    for (int i = 0; i < numsSize; i++) {\n        if (prev == -1 || data[i][0] != data[i - 1][0]) {\n            prev = i;\n        }\n        ret[data[i][1]] = prev;\n    }\n    return ret;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\nvar smallerNumbersThanCurrent = function(nums) {\n    const n = nums.length;\n    const data = new Array(n).fill(0).map(v => new Array(2).fill(0));\n    for (let i = 0; i < n; ++i) {\n        data[i][0] = nums[i];\n        data[i][1] = i;\n    }\n    data.sort((a, b) => a[0] - b[0]);\n\n    const ret = new Array(n);\n    let prev = -1;\n    for (let i = 0; i < n; ++i) {\n        if (prev == -1 || data[i][0] !== data[i - 1][0]) {\n            prev = i;\n        }\n        ret[data[i][1]] = prev;\n    }\n    return ret;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n复杂度分析\n\n * 时间复杂度：O(Nlog⁡N)O(N\\log N)O(NlogN)，其中 NNN 为数组的长度。排序需要 O(Nlog⁡N)O(N\\log N)O(NlogN) 的时间，随后需要 O(N)O(N)O(N) 时间来遍历。\n   \n   \n * 空间复杂度：O(N)O(N)O(N)。因为要额外开辟一个数组。\n   \n   \n\n# 方法三：计数排序\n注意到数组元素的值域为 [0,100][0,100][0,100]，所以可以考虑建立一个频次数组 cntcntcnt ，cnt[i]cnt[i]cnt[i] 表示数字 iii 出现的次数。那么对于数字 iii 而言，小于它的数目就为 cnt[0...i−1]cnt[0...i-1]cnt[0...i−1] 的总和。\n\nclass Solution {\npublic:\n    vector<int> smallerNumbersThanCurrent(vector<int>& nums) {\n        vector<int> cnt(101, 0);\n        int n = nums.size();\n        for (int i = 0; i < n; i++) {\n            cnt[nums[i]]++;\n        }\n        for (int i = 1; i <= 100; i++) {\n            cnt[i] += cnt[i - 1];\n        }\n        vector<int> ret;\n        for (int i = 0; i < n; i++) {\n            ret.push_back(nums[i] == 0 ? 0: cnt[nums[i]-1]);\n        }\n        return ret;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\nclass Solution {\n    public int[] smallerNumbersThanCurrent(int[] nums) {\n        int[] cnt = new int[101];\n        int n = nums.length;\n        for (int i = 0; i < n; i++) {\n            cnt[nums[i]]++;\n        }\n        for (int i = 1; i <= 100; i++) {\n            cnt[i] += cnt[i - 1];\n        }\n        int[] ret = new int[n];\n        for (int i = 0; i < n; i++) {\n            ret[i] = nums[i] == 0 ? 0 : cnt[nums[i] - 1];\n        }\n        return ret;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\nfunc smallerNumbersThanCurrent(nums []int) []int {\n    cnt := [101]int{}\n    for _, v := range nums {\n        cnt[v]++\n    }\n    for i := 0; i < 100; i++ {\n        cnt[i+1] += cnt[i]\n    }\n    ans := make([]int, len(nums))\n    for i, v := range nums {\n        if v > 0 {\n            ans[i] = cnt[v-1]\n        }\n    }\n    return ans\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\nint* smallerNumbersThanCurrent(int* nums, int numsSize, int* returnSize) {\n    int cnt[101];\n    memset(cnt, 0, sizeof(cnt));\n    for (int i = 0; i < numsSize; i++) {\n        cnt[nums[i]]++;\n    }\n    for (int i = 1; i <= 100; i++) {\n        cnt[i] += cnt[i - 1];\n    }\n\n    int* ret = malloc(sizeof(int) * numsSize);\n    *returnSize = numsSize;\n    for (int i = 0; i < numsSize; i++) {\n        ret[i] = nums[i] == 0 ? 0 : cnt[nums[i] - 1];\n    }\n    return ret;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\nvar smallerNumbersThanCurrent = function(nums) {\n    const cnt = new Array(101).fill(0);\n    const n = nums.length;\n    for (let i = 0; i < n; ++i) {\n        cnt[nums[i]] += 1;\n    }\n    for (let i = 1; i <= 100; ++i) {\n        cnt[i] += cnt[i - 1];\n    }\n    const ret = [];\n    for (let i = 0; i < n; ++i) {\n        ret.push(nums[i] ? cnt[nums[i] - 1] : 0);\n    }\n    return ret;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n复杂度分析\n\n * 时间复杂度：O(N+K)O(N + K)O(N+K)，其中 KKK 为值域大小。需要遍历两次原数组，同时遍历一次频次数组 cntcntcnt 找出前缀和。\n   \n   \n * 空间复杂度：O(K)O(K)O(K)。因为要额外开辟一个值域大小的数组。\n   \n   \n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2020-04-01 20:50:32Accepted [https://leetcode-cn.com//submissions/detail/58986981/]1 ms100.0%39.1 MBjava2020-04-01 20:50:08Accepted [https://leetcode-cn.com//submissions/detail/58986864/]1 ms100.0%39.3 MBjava2020-04-01 20:47:48Runtime Error [https://leetcode-cn.com//submissions/detail/58986185/]N/AN/AN/Ajava2020-04-01 20:47:05Runtime Error [https://leetcode-cn.com//submissions/detail/58985996/]N/AN/AN/Ajava# 统计信息\n通过次数提交次数AC比率777559411782.6%",contentLowercase:"# 中文题目\n给你一个数组nums，对于其中每个元素nums[i]，请你统计数组中比它小的所有数字的数目。\n\n换而言之，对于每个nums[i]你必须计算出有效的j的数量，其中 j 满足j != i 且 nums[j] < nums[i]。\n\n以数组形式返回答案。\n\n\n\n示例 1：\n\n输入：nums = [8,1,2,2,3]\n输出：[4,0,1,1,3]\n解释： \n对于 nums[0]=8 存在四个比它小的数字：（1，2，2 和 3）。 \n对于 nums[1]=1 不存在比它小的数字。\n对于 nums[2]=2 存在一个比它小的数字：（1）。 \n对于 nums[3]=2 存在一个比它小的数字：（1）。 \n对于 nums[4]=3 存在三个比它小的数字：（1，2 和 2）。\n\n\n示例 2：\n\n输入：nums = [6,5,4,8]\n输出：[2,1,0,3]\n\n\n示例 3：\n\n输入：nums = [7,7,7,7]\n输出：[0,0,0,0]\n\n\n\n\n提示：\n\n * 2 <= nums.length <= 500\n * 0 <= nums[i] <= 100\n\n# 通过代码\nclass solution {\n    public int[] smallernumbersthancurrent(int[] nums) {\n        int[] arr=new int[100+1];\n        for (int i = 0; i < nums.length; i++) {\n            arr[nums[i]]++;\n        }\n        for (int i = 1; i < arr.length; i++) {\n            arr[i]=arr[i-1]+arr[i];\n        }\n        for (int i = 0; i < nums.length; i++) {\n            nums[i]=nums[i]==0?0:arr[nums[i]-1];\n        }\n        return nums;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\nclass solution {\n    public int[] smallernumbersthancurrent(int[] nums) {\n        int[] arr=new int[100+1];\n        for (int i = 0; i < nums.length; i++) {\n            arr[nums[i]]++;\n        }\n        for (int i = 1; i < arr.length; i++) {\n            arr[i]=arr[i-1]+arr[i];\n        }\n        for (int i = 0; i < nums.length; i++) {\n            nums[i]=nums[i]==0?0:arr[nums[i]-1];\n        }\n        return nums;\n    }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n# 高赞题解\n# 方法一：暴力\n比较容易想到的一个方法是，对于数组中的每一个元素，我们都遍历数组一次，统计小于当前元素的数的数目。\n\nclass solution {\npublic:\n    vector<int> smallernumbersthancurrent(vector<int>& nums) {\n        vector<int> ret;\n        int n = nums.size();\n        for (int i = 0; i < n; i++) {\n            int cnt = 0;\n            for (int j = 0; j < n; j++) {\n                if (nums[j] < nums[i]) {\n                    cnt++;\n                }\n            }\n            ret.push_back(cnt);\n        }\n        return ret;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\nclass solution {\n    public int[] smallernumbersthancurrent(int[] nums) {\n        int n = nums.length;\n        int[] ret = new int[n];\n        for (int i = 0; i < n; i++) {\n            int cnt = 0;\n            for (int j = 0; j < n; j++) {\n                if (nums[j] < nums[i]) {\n                    cnt++;\n                }\n            }\n            ret[i] = cnt;\n        }\n        return ret;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\nfunc smallernumbersthancurrent(nums []int) (ans []int) {\n    for _, v := range nums {\n        cnt := 0\n        for _, w := range nums {\n            if w < v {\n                cnt++\n            }\n        }\n        ans = append(ans, cnt)\n    }\n    return\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\nint* smallernumbersthancurrent(int* nums, int numssize, int* returnsize) {\n    int* ret = malloc(sizeof(int) * numssize);\n    *returnsize = numssize;\n    for (int i = 0; i < numssize; i++) {\n        int cnt = 0;\n        for (int j = 0; j < numssize; j++) {\n            if (nums[j] < nums[i]) {\n                cnt++;\n            }\n        }\n        ret[i] = cnt;\n    }\n    return ret;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\nvar smallernumbersthancurrent = function(nums) {\n    const n = nums.length;\n    const ret = [];\n    for (let i = 0; i < n; ++i) {\n        let cnt = 0;\n        for (let j = 0; j < n; ++j) {\n            if (nums[j] < nums[i]) {\n                cnt++;\n            }\n        }\n        ret[i] = cnt;\n    }\n    return ret;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n复杂度分析\n\n * 时间复杂度：o(n2)o(n^2)o(n2)，其中 nnn 为数组的长度。\n * 空间复杂度：o(1)o(1)o(1)。注意我们不计算答案数组的空间占用。\n\n# 方法二：排序\n我们也可以将数组排序，并记录每一个数在原数组中的位置。对于排序后的数组中的每一个数，我们找出其左侧第一个小于它的数，这样就能够知道数组中小于该数的数量。\n\nclass solution {\npublic:\n    vector<int> smallernumbersthancurrent(vector<int>& nums) {\n        vector<pair<int, int>> data;\n        int n = nums.size();\n        for (int i = 0; i < n; i++) {\n            data.emplace_back(nums[i], i);\n        }\n        sort(data.begin(), data.end());\n\n        vector<int> ret(n, 0);\n        int prev = -1;\n        for (int i = 0; i < n; i++) {\n            if (prev == -1 || data[i].first != data[i - 1].first) {\n                prev = i;\n            }\n            ret[data[i].second] = prev;\n        }\n        return ret;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\nclass solution {\n    public int[] smallernumbersthancurrent(int[] nums) {\n        int n = nums.length;\n        int[][] data = new int[n][2];\n        for (int i = 0; i < n; i++) {\n            data[i][0] = nums[i];\n            data[i][1] = i;\n        }\n        arrays.sort(data, new comparator<int[]>() {\n            public int compare(int[] data1, int[] data2) {\n                return data1[0] - data2[0];\n            }\n        });\n\n        int[] ret = new int[n];\n        int prev = -1;\n        for (int i = 0; i < n; i++) {\n            if (prev == -1 || data[i][0] != data[i - 1][0]) {\n                prev = i;\n            }\n            ret[data[i][1]] = prev;\n        }\n        return ret;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\ntype pair struct{ v, pos int }\n\nfunc smallernumbersthancurrent(nums []int) []int {\n    n := len(nums)\n    data := make([]pair, n)\n    for i, v := range nums {\n        data[i] = pair{v, i}\n    }\n    sort.slice(data, func(i, j int) bool { return data[i].v < data[j].v })\n    ans := make([]int, n)\n    prev := -1\n    for i, d := range data {\n        if prev == -1 || d.v != data[i-1].v {\n            prev = i\n        }\n        ans[d.pos] = prev\n    }\n    return ans\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\nint cmp(const void* a, const void* b) {\n    return ((*(int**)a)[0] - (*(int**)b)[0]);\n}\n\nint* smallernumbersthancurrent(int* nums, int numssize, int* returnsize) {\n    int* data[numssize];\n    for (int i = 0; i < numssize; i++) {\n        data[i] = malloc(sizeof(int) * 2);\n        data[i][0] = nums[i], data[i][1] = i;\n    }\n    qsort(data, numssize, sizeof(int*), cmp);\n\n    int* ret = malloc(sizeof(int) * numssize);\n    *returnsize = numssize;\n    int prev = -1;\n    for (int i = 0; i < numssize; i++) {\n        if (prev == -1 || data[i][0] != data[i - 1][0]) {\n            prev = i;\n        }\n        ret[data[i][1]] = prev;\n    }\n    return ret;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\nvar smallernumbersthancurrent = function(nums) {\n    const n = nums.length;\n    const data = new array(n).fill(0).map(v => new array(2).fill(0));\n    for (let i = 0; i < n; ++i) {\n        data[i][0] = nums[i];\n        data[i][1] = i;\n    }\n    data.sort((a, b) => a[0] - b[0]);\n\n    const ret = new array(n);\n    let prev = -1;\n    for (let i = 0; i < n; ++i) {\n        if (prev == -1 || data[i][0] !== data[i - 1][0]) {\n            prev = i;\n        }\n        ret[data[i][1]] = prev;\n    }\n    return ret;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n复杂度分析\n\n * 时间复杂度：o(nlog⁡n)o(n\\log n)o(nlogn)，其中 nnn 为数组的长度。排序需要 o(nlog⁡n)o(n\\log n)o(nlogn) 的时间，随后需要 o(n)o(n)o(n) 时间来遍历。\n   \n   \n * 空间复杂度：o(n)o(n)o(n)。因为要额外开辟一个数组。\n   \n   \n\n# 方法三：计数排序\n注意到数组元素的值域为 [0,100][0,100][0,100]，所以可以考虑建立一个频次数组 cntcntcnt ，cnt[i]cnt[i]cnt[i] 表示数字 iii 出现的次数。那么对于数字 iii 而言，小于它的数目就为 cnt[0...i−1]cnt[0...i-1]cnt[0...i−1] 的总和。\n\nclass solution {\npublic:\n    vector<int> smallernumbersthancurrent(vector<int>& nums) {\n        vector<int> cnt(101, 0);\n        int n = nums.size();\n        for (int i = 0; i < n; i++) {\n            cnt[nums[i]]++;\n        }\n        for (int i = 1; i <= 100; i++) {\n            cnt[i] += cnt[i - 1];\n        }\n        vector<int> ret;\n        for (int i = 0; i < n; i++) {\n            ret.push_back(nums[i] == 0 ? 0: cnt[nums[i]-1]);\n        }\n        return ret;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\nclass solution {\n    public int[] smallernumbersthancurrent(int[] nums) {\n        int[] cnt = new int[101];\n        int n = nums.length;\n        for (int i = 0; i < n; i++) {\n            cnt[nums[i]]++;\n        }\n        for (int i = 1; i <= 100; i++) {\n            cnt[i] += cnt[i - 1];\n        }\n        int[] ret = new int[n];\n        for (int i = 0; i < n; i++) {\n            ret[i] = nums[i] == 0 ? 0 : cnt[nums[i] - 1];\n        }\n        return ret;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\nfunc smallernumbersthancurrent(nums []int) []int {\n    cnt := [101]int{}\n    for _, v := range nums {\n        cnt[v]++\n    }\n    for i := 0; i < 100; i++ {\n        cnt[i+1] += cnt[i]\n    }\n    ans := make([]int, len(nums))\n    for i, v := range nums {\n        if v > 0 {\n            ans[i] = cnt[v-1]\n        }\n    }\n    return ans\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\nint* smallernumbersthancurrent(int* nums, int numssize, int* returnsize) {\n    int cnt[101];\n    memset(cnt, 0, sizeof(cnt));\n    for (int i = 0; i < numssize; i++) {\n        cnt[nums[i]]++;\n    }\n    for (int i = 1; i <= 100; i++) {\n        cnt[i] += cnt[i - 1];\n    }\n\n    int* ret = malloc(sizeof(int) * numssize);\n    *returnsize = numssize;\n    for (int i = 0; i < numssize; i++) {\n        ret[i] = nums[i] == 0 ? 0 : cnt[nums[i] - 1];\n    }\n    return ret;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\nvar smallernumbersthancurrent = function(nums) {\n    const cnt = new array(101).fill(0);\n    const n = nums.length;\n    for (let i = 0; i < n; ++i) {\n        cnt[nums[i]] += 1;\n    }\n    for (let i = 1; i <= 100; ++i) {\n        cnt[i] += cnt[i - 1];\n    }\n    const ret = [];\n    for (let i = 0; i < n; ++i) {\n        ret.push(nums[i] ? cnt[nums[i] - 1] : 0);\n    }\n    return ret;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n复杂度分析\n\n * 时间复杂度：o(n+k)o(n + k)o(n+k)，其中 kkk 为值域大小。需要遍历两次原数组，同时遍历一次频次数组 cntcntcnt 找出前缀和。\n   \n   \n * 空间复杂度：o(k)o(k)o(k)。因为要额外开辟一个值域大小的数组。\n   \n   \n\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2020-04-01 20:50:32accepted [https://leetcode-cn.com//submissions/detail/58986981/]1 ms100.0%39.1 mbjava2020-04-01 20:50:08accepted [https://leetcode-cn.com//submissions/detail/58986864/]1 ms100.0%39.3 mbjava2020-04-01 20:47:48runtime error [https://leetcode-cn.com//submissions/detail/58986185/]n/an/an/ajava2020-04-01 20:47:05runtime error [https://leetcode-cn.com//submissions/detail/58985996/]n/an/an/ajava# 统计信息\n通过次数提交次数ac比率777559411782.6%"},{title:"剑指 Offer 03-数组中重复的数字(数组中重复的数字 LCOF)",frontmatter:{title:"剑指 Offer 03-数组中重复的数字(数组中重复的数字 LCOF)",date:"2021-04-08T00:00:00.000Z",categories:["简单"],tags:["数组<Array>","哈希表<Hash Table>"]},regularPath:"/views/%E7%AE%80%E5%8D%95/%E5%89%91%E6%8C%87%20Offer%2003-%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97.html",relativePath:"views/简单/剑指 Offer 03-数组中重复的数字.md",key:"v-622c1825",path:"/views/%E7%AE%80%E5%8D%95/%E5%89%91%E6%8C%87%20Offer%2003-%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97.html",headers:[{level:2,title:"中文题目",slug:"中文题目",charIndex:2},{level:2,title:"通过代码",slug:"通过代码",charIndex:188},{level:2,title:"高赞题解",slug:"高赞题解",charIndex:577},{level:2,title:"提交历史",slug:"提交历史",charIndex:1141},{level:2,title:"统计信息",slug:"统计信息",charIndex:1275}],lastUpdated:"4/11/2021, 1:15:21 PM",headersStr:"中文题目 通过代码 高赞题解 提交历史 统计信息",content:"# 中文题目\n找出数组中重复的数字。\n\n\n在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。\n\n示例 1：\n\n输入：\n[2, 3, 1, 0, 2, 5, 3]\n输出：2 或 3 \n\n\n\n\n限制：\n\n2 <= n <= 100000\n\n# 通过代码\n    class Solution {\n        public int findRepeatNumber(int[] nums) {\n            int[] arr=new int[nums.length];\n            for (int i = 0; i < nums.length; i++) {\n                arr[nums[i]]++;\n            }\n            for (int i = 0; i < arr.length; i++) {\n                if (arr[i]>=2) return i;\n            }\n            return 0;\n        }\n    }\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n# 高赞题解\n\n\n如果没有重复数字，那么正常排序后，数字i应该在下标为i的位置，所以思路是重头扫描数组，遇到下标为i的数字如果不是i的话，（假设为m),那么我们就拿与下标m的数字交换。在交换过程中，如果有重复的数字发生，那么终止返回ture\n\nclass Solution {\n    public int findRepeatNumber(int[] nums) {\n        int temp;\n        for(int i=0;i<nums.length;i++){\n            while (nums[i]!=i){\n                if(nums[i]==nums[nums[i]]){\n                    return nums[i];\n                }\n                temp=nums[i];\n                nums[i]=nums[temp];\n                nums[temp]=temp;\n            }\n        }\n        return -1;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2021-04-08 11:04:25Accepted [https://leetcode-cn.com//submissions/detail/165174970/]1 ms100.0%46.2 MBjava# 统计信息\n通过次数提交次数AC比率26594239411567.5%",contentLowercase:"# 中文题目\n找出数组中重复的数字。\n\n\n在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。\n\n示例 1：\n\n输入：\n[2, 3, 1, 0, 2, 5, 3]\n输出：2 或 3 \n\n\n\n\n限制：\n\n2 <= n <= 100000\n\n# 通过代码\n    class solution {\n        public int findrepeatnumber(int[] nums) {\n            int[] arr=new int[nums.length];\n            for (int i = 0; i < nums.length; i++) {\n                arr[nums[i]]++;\n            }\n            for (int i = 0; i < arr.length; i++) {\n                if (arr[i]>=2) return i;\n            }\n            return 0;\n        }\n    }\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n# 高赞题解\n\n\n如果没有重复数字，那么正常排序后，数字i应该在下标为i的位置，所以思路是重头扫描数组，遇到下标为i的数字如果不是i的话，（假设为m),那么我们就拿与下标m的数字交换。在交换过程中，如果有重复的数字发生，那么终止返回ture\n\nclass solution {\n    public int findrepeatnumber(int[] nums) {\n        int temp;\n        for(int i=0;i<nums.length;i++){\n            while (nums[i]!=i){\n                if(nums[i]==nums[nums[i]]){\n                    return nums[i];\n                }\n                temp=nums[i];\n                nums[i]=nums[temp];\n                nums[temp]=temp;\n            }\n        }\n        return -1;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2021-04-08 11:04:25accepted [https://leetcode-cn.com//submissions/detail/165174970/]1 ms100.0%46.2 mbjava# 统计信息\n通过次数提交次数ac比率26594239411567.5%"},{title:"剑指 Offer 05-替换空格(替换空格 LCOF)",frontmatter:{title:"剑指 Offer 05-替换空格(替换空格 LCOF)",date:"2021-04-08T00:00:00.000Z",categories:["简单"],tags:null},regularPath:"/views/%E7%AE%80%E5%8D%95/%E5%89%91%E6%8C%87%20Offer%2005-%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC.html",relativePath:"views/简单/剑指 Offer 05-替换空格.md",key:"v-1bff81f9",path:"/views/%E7%AE%80%E5%8D%95/%E5%89%91%E6%8C%87%20Offer%2005-%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC.html",headers:[{level:2,title:"中文题目",slug:"中文题目",charIndex:2},{level:2,title:"通过代码",slug:"通过代码",charIndex:125},{level:2,title:"高赞题解",slug:"高赞题解",charIndex:686},{level:2,title:"提交历史",slug:"提交历史",charIndex:3037},{level:2,title:"统计信息",slug:"统计信息",charIndex:3276}],lastUpdated:"4/11/2021, 1:15:21 PM",headersStr:"中文题目 通过代码 高赞题解 提交历史 统计信息",content:'# 中文题目\n请实现一个函数，把字符串 s 中的每个空格替换成"%20"。\n\n\n\n示例 1：\n\n输入：s = "We are happy."\n输出："We%20are%20happy."\n\n\n\n限制：\n\n0 <= s 的长度 <= 10000\n\n# 通过代码\nclass Solution {\n        public String replaceSpace(String s) {\n                        String res="";\n            for (int i = 0; i < s.length(); i++) {\n                if(s.charAt(i)==\' \'){\n                    res+="%20";\n                }else {\n                    res+=s.charAt(i);\n                }\n            }\n            return res;\n        }\n    }\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\nclass Solution {\n        public String replaceSpace(String s) {\n            String res = s.replaceAll("\\\\s", "%20");\n            return res;\n        }\n    }\n\n1\n2\n3\n4\n5\n# 高赞题解\n# 方法一：遍历添加\n在 Python 和 Java 等语言中，字符串都被设计成「不可变」的类型，即无法直接修改字符串的某一位字符，需要新建一个字符串实现。\n\n# 算法流程：\n 1. 初始化一个 list (Python) / StringBuilder (Java) ，记为 res ；\n 2. 遍历列表 s 中的每个字符 c ： * 当 c 为空格时：向 res 后添加字符串 "%20" ；\n     * 当 c 不为空格时：向 res 后添加字符 c ；\n    \n    \n 3. 将列表 res 转化为字符串并返回。\n\n# 复杂度分析：\n * 时间复杂度 O(N)O(N)O(N) ： 遍历使用 O(N)O(N)O(N) ，每轮添加（修改）字符操作使用 O(1)O(1)O(1) ；\n * 空间复杂度 O(N)O(N)O(N) ： Python 新建的 list 和 Java 新建的 StringBuilder 都使用了线性大小的额外空间。\n\n<,,,,>\n\n# 代码：\nclass Solution:\n    def replaceSpace(self, s: str) -> str:\n        res = []\n        for c in s:\n            if c == \' \': res.append("%20")\n            else: res.append(c)\n        return "".join(res)\n\n\n1\n2\n3\n4\n5\n6\n7\nclass Solution {\n    public String replaceSpace(String s) {\n        StringBuilder res = new StringBuilder();\n        for(Character c : s.toCharArray())\n        {\n            if(c == \' \') res.append("%20");\n            else res.append(c);\n        }\n        return res.toString();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n# 方法二：原地修改\n在 C++ 语言中， string 被设计成「可变」的类型（参考资料 [https://stackoverflow.com/questions/28442719/are-c-strings-mutable-unlike-java-strings]），因此可以在不新建字符串的情况下实现原地修改。\n\n由于需要将空格替换为 "%20" ，字符串的总字符数增加，因此需要扩展原字符串 s 的长度，计算公式为：新字符串长度 = 原字符串长度 + 2 * 空格个数 ，示例如下图所示。\n\n{:width=450}\n\n# \b算法流程：\n 1. 初始化：空格数量 count ，字符串 s 的长度 len ；\n 2. 统计空格数量：遍历 s ，遇空格则 count++ ；\n 3. 修改 s 长度：添加完 "%20" 后的字符串长度应为 len + 2 * count ；\n 4. 倒序遍历修改：i 指向原字符串尾部元素， j 指向新字符串尾部元素；当 i = j 时跳出（代表左方已没有空格，无需继续遍历）； * 当 s[i] 不为空格时：执行 s[j] = s[i] ；\n     * 当 s[i] 为空格时：将字符串闭区间 [j-2, j] 的元素修改为 "%20" ；由于修改了 3 个元素，因此需要 j -= 2 ；\n    \n    \n 5. 返回值：已修改的字符串 s ；\n\n<,,,,,,,,>\n\n# 复杂度分析：\n * 时间复杂度 O(N)O(N)O(N) ： 遍历统计、遍历修改皆使用 O(N)O(N)O(N) 时间。\n * 空间复杂度 O(1)O(1)O(1) ： 由于是原地扩展 s 长度，因此使用 O(1)O(1)O(1) 额外空间。\n\nclass Solution {\npublic:\n    string replaceSpace(string s) {\n        int count = 0, len = s.size();\n        // 统计空格数量\n        for (char c : s) {\n            if (c == \' \') count++;\n        }\n        // 修改 s 长度\n        s.resize(len + 2 * count);\n        // 倒序遍历修改\n        for(int i = len - 1, j = s.size() - 1; i < j; i--, j--) {\n            if (s[i] != \' \')\n                s[j] = s[i];\n            else {\n                s[j - 2] = \'%\';\n                s[j - 1] = \'2\';\n                s[j] = \'0\';\n                j -= 2;\n            }\n        }\n        return s;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2021-04-08 17:48:40Accepted [https://leetcode-cn.com//submissions/detail/165349549/]7 ms100.0%38.6 MBjava2021-04-08 17:42:06Accepted [https://leetcode-cn.com//submissions/detail/165347265/]3 ms100.0%36.8 MBjava# 统计信息\n通过次数提交次数AC比率18182023861476.2%',contentLowercase:'# 中文题目\n请实现一个函数，把字符串 s 中的每个空格替换成"%20"。\n\n\n\n示例 1：\n\n输入：s = "we are happy."\n输出："we%20are%20happy."\n\n\n\n限制：\n\n0 <= s 的长度 <= 10000\n\n# 通过代码\nclass solution {\n        public string replacespace(string s) {\n                        string res="";\n            for (int i = 0; i < s.length(); i++) {\n                if(s.charat(i)==\' \'){\n                    res+="%20";\n                }else {\n                    res+=s.charat(i);\n                }\n            }\n            return res;\n        }\n    }\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\nclass solution {\n        public string replacespace(string s) {\n            string res = s.replaceall("\\\\s", "%20");\n            return res;\n        }\n    }\n\n1\n2\n3\n4\n5\n# 高赞题解\n# 方法一：遍历添加\n在 python 和 java 等语言中，字符串都被设计成「不可变」的类型，即无法直接修改字符串的某一位字符，需要新建一个字符串实现。\n\n# 算法流程：\n 1. 初始化一个 list (python) / stringbuilder (java) ，记为 res ；\n 2. 遍历列表 s 中的每个字符 c ： * 当 c 为空格时：向 res 后添加字符串 "%20" ；\n     * 当 c 不为空格时：向 res 后添加字符 c ；\n    \n    \n 3. 将列表 res 转化为字符串并返回。\n\n# 复杂度分析：\n * 时间复杂度 o(n)o(n)o(n) ： 遍历使用 o(n)o(n)o(n) ，每轮添加（修改）字符操作使用 o(1)o(1)o(1) ；\n * 空间复杂度 o(n)o(n)o(n) ： python 新建的 list 和 java 新建的 stringbuilder 都使用了线性大小的额外空间。\n\n<,,,,>\n\n# 代码：\nclass solution:\n    def replacespace(self, s: str) -> str:\n        res = []\n        for c in s:\n            if c == \' \': res.append("%20")\n            else: res.append(c)\n        return "".join(res)\n\n\n1\n2\n3\n4\n5\n6\n7\nclass solution {\n    public string replacespace(string s) {\n        stringbuilder res = new stringbuilder();\n        for(character c : s.tochararray())\n        {\n            if(c == \' \') res.append("%20");\n            else res.append(c);\n        }\n        return res.tostring();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n# 方法二：原地修改\n在 c++ 语言中， string 被设计成「可变」的类型（参考资料 [https://stackoverflow.com/questions/28442719/are-c-strings-mutable-unlike-java-strings]），因此可以在不新建字符串的情况下实现原地修改。\n\n由于需要将空格替换为 "%20" ，字符串的总字符数增加，因此需要扩展原字符串 s 的长度，计算公式为：新字符串长度 = 原字符串长度 + 2 * 空格个数 ，示例如下图所示。\n\n{:width=450}\n\n# \b算法流程：\n 1. 初始化：空格数量 count ，字符串 s 的长度 len ；\n 2. 统计空格数量：遍历 s ，遇空格则 count++ ；\n 3. 修改 s 长度：添加完 "%20" 后的字符串长度应为 len + 2 * count ；\n 4. 倒序遍历修改：i 指向原字符串尾部元素， j 指向新字符串尾部元素；当 i = j 时跳出（代表左方已没有空格，无需继续遍历）； * 当 s[i] 不为空格时：执行 s[j] = s[i] ；\n     * 当 s[i] 为空格时：将字符串闭区间 [j-2, j] 的元素修改为 "%20" ；由于修改了 3 个元素，因此需要 j -= 2 ；\n    \n    \n 5. 返回值：已修改的字符串 s ；\n\n<,,,,,,,,>\n\n# 复杂度分析：\n * 时间复杂度 o(n)o(n)o(n) ： 遍历统计、遍历修改皆使用 o(n)o(n)o(n) 时间。\n * 空间复杂度 o(1)o(1)o(1) ： 由于是原地扩展 s 长度，因此使用 o(1)o(1)o(1) 额外空间。\n\nclass solution {\npublic:\n    string replacespace(string s) {\n        int count = 0, len = s.size();\n        // 统计空格数量\n        for (char c : s) {\n            if (c == \' \') count++;\n        }\n        // 修改 s 长度\n        s.resize(len + 2 * count);\n        // 倒序遍历修改\n        for(int i = len - 1, j = s.size() - 1; i < j; i--, j--) {\n            if (s[i] != \' \')\n                s[j] = s[i];\n            else {\n                s[j - 2] = \'%\';\n                s[j - 1] = \'2\';\n                s[j] = \'0\';\n                j -= 2;\n            }\n        }\n        return s;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2021-04-08 17:48:40accepted [https://leetcode-cn.com//submissions/detail/165349549/]7 ms100.0%38.6 mbjava2021-04-08 17:42:06accepted [https://leetcode-cn.com//submissions/detail/165347265/]3 ms100.0%36.8 mbjava# 统计信息\n通过次数提交次数ac比率18182023861476.2%'},{title:"剑指 Offer 06-从尾到头打印链表(从尾到头打印链表 LCOF)",frontmatter:{title:"剑指 Offer 06-从尾到头打印链表(从尾到头打印链表 LCOF)",date:"2021-04-08T00:00:00.000Z",categories:["简单"],tags:["链表<Linked List>"]},regularPath:"/views/%E7%AE%80%E5%8D%95/%E5%89%91%E6%8C%87%20Offer%2006-%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8.html",relativePath:"views/简单/剑指 Offer 06-从尾到头打印链表.md",key:"v-1f24f964",path:"/views/%E7%AE%80%E5%8D%95/%E5%89%91%E6%8C%87%20Offer%2006-%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8.html",headers:[{level:2,title:"中文题目",slug:"中文题目",charIndex:2},{level:2,title:"通过代码",slug:"通过代码",charIndex:111},{level:2,title:"高赞题解",slug:"高赞题解",charIndex:780},{level:3,title:"方法一：递归法",slug:"方法一：递归法",charIndex:787},{level:3,title:"方法二：辅助栈法",slug:"方法二：辅助栈法",charIndex:1991},{level:2,title:"提交历史",slug:"提交历史",charIndex:3112},{level:2,title:"统计信息",slug:"统计信息",charIndex:3246}],lastUpdated:"4/11/2021, 1:15:21 PM",headersStr:"中文题目 通过代码 高赞题解 方法一：递归法 方法二：辅助栈法 提交历史 统计信息",content:"# 中文题目\n输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。\n\n\n\n示例 1：\n\n输入：head = [1,3,2]\n输出：[2,3,1]\n\n\n\n限制：\n\n0 <= 链表长度 <= 10000\n\n# 通过代码\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\nclass Solution {\n        public int[] reversePrint(ListNode head) {\n            int num=0;\n            Stack<Integer> stack=new Stack<>();\n            while (head!=null){\n                stack.push(head.val);\n                head= head.next;\n                num++;\n            }\n            int[] arr=new int[num];\n            for (int i = 0; i < num; i++) {\n                arr[i]=stack.pop();\n            }\n            return arr;\n        }\n\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n# 高赞题解\n# 方法一：递归法\n# 解题思路：\n> 利用递归： 先走至链表末端，回溯时依次将节点值加入列表 ，这样就可以实现链表值的倒序输出。\n\n\n * Python 算法流程：\n   \n    1. 递推阶段： 每次传入 head.next ，以 head == None（即走过链表尾部节点）为递归终止条件，此时返回空列表 [] 。\n    2. 回溯阶段： 利用 Python 语言特性，递归回溯时每次返回 当前 list + 当前节点值 [head.val]，即可实现节点的倒序输出。\n   \n   \n * Java 算法流程：\n   \n    1. 递推阶段： 每次传入 head.next ，以 head == null（即走过链表尾部节点）为递归终止条件，此时直接返回。\n    2. 回溯阶段： 层层回溯时，将当前节点值加入列表，即tmp.add(head.val)。\n    3. 最终，将列表 tmp 转化为数组 res ，并返回即可。\n   \n   \n\n# 复杂度分析：\n * 时间复杂度 O(N)O(N)O(N)： 遍历链表，递归 NNN 次。\n * 空间复杂度 O(N)O(N)O(N)： 系统递归需要使用 O(N)O(N)O(N) 的栈空间。\n\n> 图解以 Python 代码为例， Java 原理一致，只是把利用返回值改为 add() 操作。\n\n\n<,,,,,,,,,>\n\n# 代码：\nclass Solution:\n    def reversePrint(self, head: ListNode) -> List[int]:\n        return self.reversePrint(head.next) + [head.val] if head else []\n\n\n1\n2\n3\nclass Solution {\n    ArrayList<Integer> tmp = new ArrayList<Integer>();\n    public int[] reversePrint(ListNode head) {\n        recur(head);\n        int[] res = new int[tmp.size()];\n        for(int i = 0; i < res.length; i++)\n            res[i] = tmp.get(i);\n        return res;\n    }\n    void recur(ListNode head) {\n        if(head == null) return;\n        recur(head.next);\n        tmp.add(head.val);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n# 方法二：辅助栈法\n# 解题思路：\n> 链表特点： 只能从前至后访问每个节点。题目要求： 倒序输出节点值。 这种 先入后出 的需求可以借助 栈 来实现。\n\n\n * 算法流程： 1. 入栈： 遍历链表，将各节点值 push 入栈。（Python​ 使用 append() 方法，​Java​借助 LinkedList 的addLast()方法）。\n    2. 出栈： 将各节点值 pop 出栈，存储于数组并返回。（Python​ 直接返回 stack 的倒序列表，Java ​新建一个数组，通过 popLast() 方法将各元素存入数组，实现倒序输出）。\n   \n   \n\n# 复杂度分析：\n * 时间复杂度 O(N)O(N)O(N)： 入栈和出栈共使用 O(N)O(N)O(N) 时间。\n * 空间复杂度 O(N)O(N)O(N)： 辅助栈 stack 和数组 res 共使用 O(N)O(N)O(N) 的额外空间。\n\n> 图解以 Java 代码为例，Python 无需将 stack 转移至 res，而是直接返回倒序数组。\n\n\n<,,,,,,,>\n\n# 代码：\nclass Solution:\n    def reversePrint(self, head: ListNode) -> List[int]:\n        stack = []\n        while head:\n            stack.append(head.val)\n            head = head.next\n        return stack[::-1]\n\n\n1\n2\n3\n4\n5\n6\n7\nclass Solution {\n    public int[] reversePrint(ListNode head) {\n        LinkedList<Integer> stack = new LinkedList<Integer>();\n        while(head != null) {\n            stack.addLast(head.val);\n            head = head.next;\n        }\n        int[] res = new int[stack.size()];\n        for(int i = 0; i < res.length; i++)\n            res[i] = stack.removeLast();\n    return res;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2021-04-08 17:57:28Accepted [https://leetcode-cn.com//submissions/detail/165352448/]2 ms100.0%39.1 MBjava# 统计信息\n通过次数提交次数AC比率19431925868475.1%",contentLowercase:"# 中文题目\n输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。\n\n\n\n示例 1：\n\n输入：head = [1,3,2]\n输出：[2,3,1]\n\n\n\n限制：\n\n0 <= 链表长度 <= 10000\n\n# 通过代码\n/**\n * definition for singly-linked list.\n * public class listnode {\n *     int val;\n *     listnode next;\n *     listnode(int x) { val = x; }\n * }\n */\nclass solution {\n        public int[] reverseprint(listnode head) {\n            int num=0;\n            stack<integer> stack=new stack<>();\n            while (head!=null){\n                stack.push(head.val);\n                head= head.next;\n                num++;\n            }\n            int[] arr=new int[num];\n            for (int i = 0; i < num; i++) {\n                arr[i]=stack.pop();\n            }\n            return arr;\n        }\n\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n# 高赞题解\n# 方法一：递归法\n# 解题思路：\n> 利用递归： 先走至链表末端，回溯时依次将节点值加入列表 ，这样就可以实现链表值的倒序输出。\n\n\n * python 算法流程：\n   \n    1. 递推阶段： 每次传入 head.next ，以 head == none（即走过链表尾部节点）为递归终止条件，此时返回空列表 [] 。\n    2. 回溯阶段： 利用 python 语言特性，递归回溯时每次返回 当前 list + 当前节点值 [head.val]，即可实现节点的倒序输出。\n   \n   \n * java 算法流程：\n   \n    1. 递推阶段： 每次传入 head.next ，以 head == null（即走过链表尾部节点）为递归终止条件，此时直接返回。\n    2. 回溯阶段： 层层回溯时，将当前节点值加入列表，即tmp.add(head.val)。\n    3. 最终，将列表 tmp 转化为数组 res ，并返回即可。\n   \n   \n\n# 复杂度分析：\n * 时间复杂度 o(n)o(n)o(n)： 遍历链表，递归 nnn 次。\n * 空间复杂度 o(n)o(n)o(n)： 系统递归需要使用 o(n)o(n)o(n) 的栈空间。\n\n> 图解以 python 代码为例， java 原理一致，只是把利用返回值改为 add() 操作。\n\n\n<,,,,,,,,,>\n\n# 代码：\nclass solution:\n    def reverseprint(self, head: listnode) -> list[int]:\n        return self.reverseprint(head.next) + [head.val] if head else []\n\n\n1\n2\n3\nclass solution {\n    arraylist<integer> tmp = new arraylist<integer>();\n    public int[] reverseprint(listnode head) {\n        recur(head);\n        int[] res = new int[tmp.size()];\n        for(int i = 0; i < res.length; i++)\n            res[i] = tmp.get(i);\n        return res;\n    }\n    void recur(listnode head) {\n        if(head == null) return;\n        recur(head.next);\n        tmp.add(head.val);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n# 方法二：辅助栈法\n# 解题思路：\n> 链表特点： 只能从前至后访问每个节点。题目要求： 倒序输出节点值。 这种 先入后出 的需求可以借助 栈 来实现。\n\n\n * 算法流程： 1. 入栈： 遍历链表，将各节点值 push 入栈。（python​ 使用 append() 方法，​java​借助 linkedlist 的addlast()方法）。\n    2. 出栈： 将各节点值 pop 出栈，存储于数组并返回。（python​ 直接返回 stack 的倒序列表，java ​新建一个数组，通过 poplast() 方法将各元素存入数组，实现倒序输出）。\n   \n   \n\n# 复杂度分析：\n * 时间复杂度 o(n)o(n)o(n)： 入栈和出栈共使用 o(n)o(n)o(n) 时间。\n * 空间复杂度 o(n)o(n)o(n)： 辅助栈 stack 和数组 res 共使用 o(n)o(n)o(n) 的额外空间。\n\n> 图解以 java 代码为例，python 无需将 stack 转移至 res，而是直接返回倒序数组。\n\n\n<,,,,,,,>\n\n# 代码：\nclass solution:\n    def reverseprint(self, head: listnode) -> list[int]:\n        stack = []\n        while head:\n            stack.append(head.val)\n            head = head.next\n        return stack[::-1]\n\n\n1\n2\n3\n4\n5\n6\n7\nclass solution {\n    public int[] reverseprint(listnode head) {\n        linkedlist<integer> stack = new linkedlist<integer>();\n        while(head != null) {\n            stack.addlast(head.val);\n            head = head.next;\n        }\n        int[] res = new int[stack.size()];\n        for(int i = 0; i < res.length; i++)\n            res[i] = stack.removelast();\n    return res;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n# 提交历史\n提交时间提交结果执行时间战胜比例内存消耗语言2021-04-08 17:57:28accepted [https://leetcode-cn.com//submissions/detail/165352448/]2 ms100.0%39.1 mbjava# 统计信息\n通过次数提交次数ac比率19431925868475.1%"},{title:"剑指 Offer 09-用两个栈实现队列(用两个栈实现队列 LCOF)",frontmatter:{title:"剑指 Offer 09-用两个栈实现队列(用两个栈实现队列 LCOF)",date:"2021-05-22T00:00:00.000Z",categories:["简单"],tags:["栈<Stack>","设计<Design>"]},regularPath:"/views/%E7%AE%80%E5%8D%95/%E5%89%91%E6%8C%87%20Offer%2009-%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97.html",relativePath:"views/简单/剑指 Offer 09-用两个栈实现队列.md",key:"v-0e65eec4",path:"/views/%E7%AE%80%E5%8D%95/%E5%89%91%E6%8C%87%20Offer%2009-%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97.html",headers:[{level:2,title:"中文题目",slug:"中文题目",charIndex:2},{level:2,title:"通过代码",slug:"通过代码",charIndex:432},{level:2,title:"高赞题解",slug:"高赞题解",charIndex:1310},{level:2,title:"提交历史",slug:"提交历史",charIndex:3043},{level:2,title:"统计信息",slug:"统计信息",charIndex:3187}],headersStr:"中文题目 通过代码 高赞题解 提交历史 统计信息",content:'# 中文题目\n用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead操作返回 -1 )\n\n\n\n示例 1：\n\n输入：\n["CQueue","appendTail","deleteHead","deleteHead"]\n[[],[3],[],[]]\n输出：[null,null,3,-1]\n\n\n示例 2：\n\n输入：\n["CQueue","deleteHead","appendTail","appendTail","deleteHead","deleteHead"]\n[[],[],[5],[2],[],[]]\n输出：[null,-1,null,null,5,2]\n\n\n提示：\n\n * 1 <= values <= 10000\n * 最多会对 appendTail、deleteHead 进行 10000 次调用\n\n# 通过代码\nclass CQueue {\n        Stack<Integer> stack1;\n        Stack<Integer> stack2;\n        public CQueue() {\n            stack1=new Stack<>();\n            stack2=new Stack<>();\n        }\n\n        public void appendTail(int value) {\n            stack1.push(value);\n        }\n\n        public int deleteHead() {\n            if (stack2.isEmpty() && stack1.isEmpty()){\n                return -1;\n            }\n            if (stack2.isEmpty() && !stack1.isEmpty()){\n                while (!stack1.isEmpty()){\n                    stack2.push(stack1.pop());\n                }\n            }\n            return stack2.pop();\n        }\n    }\n\n/**\n * Your CQueue object will be instantiated and called as such:\n * CQueue obj = new CQueue();\n * obj.appendTail(value);\n * int param_2 = obj.deleteHead();\n */\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n# 高赞题解\n# 解题思路：\n * 栈无法实现队列功能： 栈底元素（对应队首元素）无法直接删除，需要将上方所有元素出栈。\n * 双栈可实现列表倒序： 设有含三个元素的栈 A=[1,2,3]A = [1,2,3]A=[1,2,3] 和空栈 B=[]B = []B=[]。若循环执行 AAA 元素出栈并添加入栈 BBB ，直到栈 AAA 为空，则 A=[]A = []A=[] , B=[3,2,1]B = [3,2,1]B=[3,2,1] ，即 栈 BBB 元素实现栈 AAA 元素倒序 。\n * 利用栈 BBB 删除队首元素： 倒序后，BBB 执行出栈则相当于删除了 AAA 的栈底元素，即对应队首元素。\n\n{:width=500}\n\n# 函数设计：\n> 题目只要求实现 加入队尾appendTail() 和 删除队首deleteHead() 两个函数的正常工作，因此我们可以设计栈 A 用于加入队尾操作，栈 B 用于将元素倒序，从而实现删除队首元素。\n\n\n * 加入队尾 appendTail()函数： 将数字 val 加入栈 A 即可。\n * 删除队首deleteHead()函数： 有以下三种情况。 1. 当栈 B 不为空： B中仍有已完成倒序的元素，因此直接返回 B 的栈顶元素。\n    2. 否则，当 A 为空： 即两个栈都为空，无元素，因此返回 −1-1−1 。\n    3. 否则： 将栈 A 元素全部转移至栈 B 中，实现元素倒序，并返回栈 B 的栈顶元素。\n   \n   \n\n<,,,,,,,>\n\n# 复杂度分析：\n> 由于问题特殊，以下分析仅满足添加 NNN 个元素并删除 NNN 个元素，即栈初始和结束状态下都为空的情况。\n\n\n * 时间复杂度： appendTail()函数为 O(1)O(1)O(1) ；deleteHead() 函数在 NNN 次队首元素删除操作中总共需完成 NNN 个元素的倒序。\n * 空间复杂度 O(N)O(N)O(N) ： 最差情况下，栈 A 和 B 共保存 NNN 个元素。\n\n# 代码：\nclass CQueue:\n    def __init__(self):\n        self.A, self.B = [], []\n\n    def appendTail(self, value: int) -> None:\n        self.A.append(value)\n\n    def deleteHead(self) -> int:\n        if self.B: return self.B.pop()\n        if not self.A: return -1\n        while self.A:\n            self.B.append(self.A.pop())\n        return self.B.pop()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\nclass CQueue {\n    LinkedList<Integer> A, B;\n    public CQueue() {\n        A = new LinkedList<Integer>();\n        B = new LinkedList<Integer>();\n    }\n    public void appendTail(int value) {\n        A.addLast(value);\n    }\n    public int deleteHead() {\n        if(!B.isEmpty()) return B.removeLast();\n        if(A.isEmpty()) return -1;\n        while(!A.isEmpty())\n            B.addLast(A.removeLast());\n        return B.removeLast();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n# 提交历史\n提交时间提交结果标记状态我的注释执行时间战胜比例内存消耗语言2021-05-22 21:16:21Accepted [https://leetcode-cn.com/submissions/detail/179913974/]🚩64 ms100.0%46.7 MBjava# 统计信息\n通过次数提交次数AC比率17988424866072.3%',contentLowercase:'# 中文题目\n用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendtail 和 deletehead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deletehead操作返回 -1 )\n\n\n\n示例 1：\n\n输入：\n["cqueue","appendtail","deletehead","deletehead"]\n[[],[3],[],[]]\n输出：[null,null,3,-1]\n\n\n示例 2：\n\n输入：\n["cqueue","deletehead","appendtail","appendtail","deletehead","deletehead"]\n[[],[],[5],[2],[],[]]\n输出：[null,-1,null,null,5,2]\n\n\n提示：\n\n * 1 <= values <= 10000\n * 最多会对 appendtail、deletehead 进行 10000 次调用\n\n# 通过代码\nclass cqueue {\n        stack<integer> stack1;\n        stack<integer> stack2;\n        public cqueue() {\n            stack1=new stack<>();\n            stack2=new stack<>();\n        }\n\n        public void appendtail(int value) {\n            stack1.push(value);\n        }\n\n        public int deletehead() {\n            if (stack2.isempty() && stack1.isempty()){\n                return -1;\n            }\n            if (stack2.isempty() && !stack1.isempty()){\n                while (!stack1.isempty()){\n                    stack2.push(stack1.pop());\n                }\n            }\n            return stack2.pop();\n        }\n    }\n\n/**\n * your cqueue object will be instantiated and called as such:\n * cqueue obj = new cqueue();\n * obj.appendtail(value);\n * int param_2 = obj.deletehead();\n */\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n# 高赞题解\n# 解题思路：\n * 栈无法实现队列功能： 栈底元素（对应队首元素）无法直接删除，需要将上方所有元素出栈。\n * 双栈可实现列表倒序： 设有含三个元素的栈 a=[1,2,3]a = [1,2,3]a=[1,2,3] 和空栈 b=[]b = []b=[]。若循环执行 aaa 元素出栈并添加入栈 bbb ，直到栈 aaa 为空，则 a=[]a = []a=[] , b=[3,2,1]b = [3,2,1]b=[3,2,1] ，即 栈 bbb 元素实现栈 aaa 元素倒序 。\n * 利用栈 bbb 删除队首元素： 倒序后，bbb 执行出栈则相当于删除了 aaa 的栈底元素，即对应队首元素。\n\n{:width=500}\n\n# 函数设计：\n> 题目只要求实现 加入队尾appendtail() 和 删除队首deletehead() 两个函数的正常工作，因此我们可以设计栈 a 用于加入队尾操作，栈 b 用于将元素倒序，从而实现删除队首元素。\n\n\n * 加入队尾 appendtail()函数： 将数字 val 加入栈 a 即可。\n * 删除队首deletehead()函数： 有以下三种情况。 1. 当栈 b 不为空： b中仍有已完成倒序的元素，因此直接返回 b 的栈顶元素。\n    2. 否则，当 a 为空： 即两个栈都为空，无元素，因此返回 −1-1−1 。\n    3. 否则： 将栈 a 元素全部转移至栈 b 中，实现元素倒序，并返回栈 b 的栈顶元素。\n   \n   \n\n<,,,,,,,>\n\n# 复杂度分析：\n> 由于问题特殊，以下分析仅满足添加 nnn 个元素并删除 nnn 个元素，即栈初始和结束状态下都为空的情况。\n\n\n * 时间复杂度： appendtail()函数为 o(1)o(1)o(1) ；deletehead() 函数在 nnn 次队首元素删除操作中总共需完成 nnn 个元素的倒序。\n * 空间复杂度 o(n)o(n)o(n) ： 最差情况下，栈 a 和 b 共保存 nnn 个元素。\n\n# 代码：\nclass cqueue:\n    def __init__(self):\n        self.a, self.b = [], []\n\n    def appendtail(self, value: int) -> none:\n        self.a.append(value)\n\n    def deletehead(self) -> int:\n        if self.b: return self.b.pop()\n        if not self.a: return -1\n        while self.a:\n            self.b.append(self.a.pop())\n        return self.b.pop()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\nclass cqueue {\n    linkedlist<integer> a, b;\n    public cqueue() {\n        a = new linkedlist<integer>();\n        b = new linkedlist<integer>();\n    }\n    public void appendtail(int value) {\n        a.addlast(value);\n    }\n    public int deletehead() {\n        if(!b.isempty()) return b.removelast();\n        if(a.isempty()) return -1;\n        while(!a.isempty())\n            b.addlast(a.removelast());\n        return b.removelast();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n# 提交历史\n提交时间提交结果标记状态我的注释执行时间战胜比例内存消耗语言2021-05-22 21:16:21accepted [https://leetcode-cn.com/submissions/detail/179913974/]🚩64 ms100.0%46.7 mbjava# 统计信息\n通过次数提交次数ac比率17988424866072.3%'},{title:"剑指 Offer 10- I-斐波那契数列(斐波那契数列  LCOF)",frontmatter:{title:"剑指 Offer 10- I-斐波那契数列(斐波那契数列  LCOF)",date:"2021-05-22T00:00:00.000Z",categories:["简单"],tags:["递归<Recursion>"]},regularPath:"/views/%E7%AE%80%E5%8D%95/%E5%89%91%E6%8C%87%20Offer%2010-%20I-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97.html",relativePath:"views/简单/剑指 Offer 10- I-斐波那契数列.md",key:"v-559cfd35",path:"/views/%E7%AE%80%E5%8D%95/%E5%89%91%E6%8C%87%20Offer%2010-%20I-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97.html",headers:[{level:2,title:"中文题目",slug:"中文题目",charIndex:2},{level:2,title:"通过代码",slug:"通过代码",charIndex:287},{level:2,title:"高赞题解",slug:"高赞题解",charIndex:1248},{level:2,title:"提交历史",slug:"提交历史",charIndex:3675},{level:2,title:"统计信息",slug:"统计信息",charIndex:4036}],headersStr:"中文题目 通过代码 高赞题解 提交历史 统计信息",content:"# 中文题目\n写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项（即 F(N)）。斐波那契数列的定义如下：\n\n\nF(0) = 0,   F(1) = 1\nF(N) = F(N - 1) + F(N - 2), 其中 N > 1.\n\n斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。\n\n答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。\n\n\n\n示例 1：\n\n\n输入：n = 2\n输出：1\n\n\n示例 2：\n\n\n输入：n = 5\n输出：5\n\n\n\n\n提示：\n\n * 0 \n\n# 通过代码\nclass Solution {\n        public int fib(int n) {\n            if (n==0){\n                return 0;\n            }\n            if (n==1){\n                return 1;\n            }\n            int[] arr=new int[n+1];\n            arr[0]=0;\n            arr[1]=1;\n            for (int i = 2; i <=n ; i++) {\n                arr[i]=(arr[i-1]+arr[i-2])%1000000007;\n            }\n            return arr[n];\n        }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\nclass Solution {\npublic int fib(int n) {\n            if (n == 0) {\n                return 0;\n            }\n            if (n == 1) {\n                return 1;\n            }\n            double a = 0;\n            double b = 1;\n            double c = 0;\n            int num=1000000007;\n            for (int i = 2; i <= n; i++) {\n                c = (a + b)%num;\n                a = b;\n                b = c;\n            }\n            return (int) c;\n        }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n# 高赞题解\n# 解题思路：\n斐波那契数列的定义是 f(n+1)=f(n)+f(n−1)f(n + 1) = f(n) + f(n - 1)f(n+1)=f(n)+f(n−1) ，生成第 nnn 项的做法有以下几种：\n\n 1. 递归法： * 原理： 把 f(n)f(n)f(n) 问题的计算拆分成 f(n−1)f(n-1)f(n−1) 和 f(n−2)f(n-2)f(n−2) 两个子问题的计算，并递归，以 f(0)f(0)f(0) 和 f(1)f(1)f(1) 为终止条件。\n     * 缺点： 大量重复的递归计算，例如 f(n)f(n)f(n) 和 f(n−1)f(n - 1)f(n−1) 两者向下递归需要 各自计算 f(n−2)f(n - 2)f(n−2) 的值。\n    \n    \n 2. 记忆化递归法： * 原理： 在递归法的基础上，新建一个长度为 nnn 的数组，用于在递归时存储 f(0)f(0)f(0) 至 f(n)f(n)f(n) 的数字值，重复遇到某数字则直接从数组取用，避免了重复的递归计算。\n     * 缺点： 记忆化存储需要使用 O(N)O(N)O(N) 的额外空间。\n    \n    \n 3. 动态规划： * 原理： 以斐波那契数列性质 f(n+1)=f(n)+f(n−1)f(n + 1) = f(n) + f(n - 1)f(n+1)=f(n)+f(n−1) 为转移方程。\n     * 从计算效率、空间复杂度上看，动态规划是本题的最佳解法。\n    \n    \n\n> 下图帮助理解递归法的 “重复计算” 概念。\n\n\n{:width=450}\n\n# 动态规划解析：\n * 状态定义： 设 dpdpdp 为一维数组，其中 dp[i]dp[i]dp[i] 的值代表 斐波那契数列第 iii 个数字 。\n * 转移方程： dp[i+1]=dp[i]+dp[i−1]dp[i + 1] = dp[i] + dp[i - 1]dp[i+1]=dp[i]+dp[i−1] ，即对应数列定义 f(n+1)=f(n)+f(n−1)f(n + 1) = f(n) + f(n - 1)f(n+1)=f(n)+f(n−1) ；\n * 初始状态： dp[0]=0dp[0] = 0dp[0]=0, dp[1]=1dp[1] = 1dp[1]=1 ，即初始化前两个数字；\n * 返回值： dp[n]dp[n]dp[n] ，即斐波那契数列的第 nnn 个数字。\n\n# 空间复杂度优化：\n> 若新建长度为 nnn 的 dpdpdp 列表，则空间复杂度为 O(N)O(N)O(N) 。\n\n\n * 由于 dpdpdp 列表第 iii 项只与第 i−1i-1i−1 和第 i−2i-2i−2 项有关，因此只需要初始化三个整形变量 sum, a, b ，利用辅助变量 sumsumsum 使 a,ba, ba,b 两数字交替前进即可 （具体实现见代码） 。\n * 节省了 dpdpdp 列表空间，因此空间复杂度降至 O(1)O(1)O(1) 。\n\n# 循环求余法：\n> 大数越界： 随着 nnn 增大, f(n)f(n)f(n) 会超过 Int32 甚至 Int64 的取值范围，导致最终的返回值错误。\n\n\n * 求余运算规则： 设正整数 x,y,px, y, px,y,p ，求余符号为 ⊙\\odot⊙ ，则有 (x+y)⊙p=(x⊙p+y⊙p)⊙p(x + y) \\odot p = (x \\odot p + y \\odot p) \\odot p(x+y)⊙p=(x⊙p+y⊙p)⊙p 。\n * 解析： 根据以上规则，可推出 f(n)⊙p=[f(n−1)⊙p+f(n−2)⊙p]⊙pf(n) \\odot p = [f(n-1) \\odot p + f(n-2) \\odot p] \\odot pf(n)⊙p=[f(n−1)⊙p+f(n−2)⊙p]⊙p ，从而可以在循环过程中每次计算 sum=(a+b)⊙1000000007sum = (a + b) \\odot 1000000007sum=(a+b)⊙1000000007 ，此操作与最终返回前取余等价。\n\n> 图解基于 Java 代码绘制，Python 由于语言特性可以省去 sumsumsum 辅助变量和大数越界处理。\n\n\n<,,,,,,,,,,,>\n\n# 复杂度分析：\n * 时间复杂度 O(N)O(N)O(N) ： 计算 f(n)f(n)f(n) 需循环 nnn 次，每轮循环内计算操作使用 O(1)O(1)O(1) 。\n * 空间复杂度 O(1)O(1)O(1) ： 几个标志变量使用常数大小的额外空间。\n\n# 代码：\n> 由于 Python 中整形数字的大小限制 取决计算机的内存 （可理解为无限大），因此可不考虑大数越界问题。\n\n\nclass Solution:\n    def fib(self, n: int) -> int:\n        a, b = 0, 1\n        for _ in range(n):\n            a, b = b, a + b\n        return a % 1000000007\n\n\n1\n2\n3\n4\n5\n6\nclass Solution {\n    public int fib(int n) {\n        int a = 0, b = 1, sum;\n        for(int i = 0; i < n; i++){\n            sum = (a + b) % 1000000007;\n            a = b;\n            b = sum;\n        }\n        return a;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n# 提交历史\n提交时间提交结果标记状态我的注释执行时间战胜比例内存消耗语言2021-05-22 21:39:21Accepted [https://leetcode-cn.com/submissions/detail/179919882/]🚩🚩🚩数组保存0 ms100.0%35.4 MBjava2021-05-22 21:38:10Accepted [https://leetcode-cn.com/submissions/detail/179919223/]🚩三个变量0 ms100.0%35.2 MBjava2021-05-22 21:28:16Wrong Answer [https://leetcode-cn.com/submissions/detail/179916888/]N/AN/AN/Ajava# 统计信息\n通过次数提交次数AC比率16684748570534.4%",contentLowercase:"# 中文题目\n写一个函数，输入 n ，求斐波那契（fibonacci）数列的第 n 项（即 f(n)）。斐波那契数列的定义如下：\n\n\nf(0) = 0,   f(1) = 1\nf(n) = f(n - 1) + f(n - 2), 其中 n > 1.\n\n斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。\n\n答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。\n\n\n\n示例 1：\n\n\n输入：n = 2\n输出：1\n\n\n示例 2：\n\n\n输入：n = 5\n输出：5\n\n\n\n\n提示：\n\n * 0 \n\n# 通过代码\nclass solution {\n        public int fib(int n) {\n            if (n==0){\n                return 0;\n            }\n            if (n==1){\n                return 1;\n            }\n            int[] arr=new int[n+1];\n            arr[0]=0;\n            arr[1]=1;\n            for (int i = 2; i <=n ; i++) {\n                arr[i]=(arr[i-1]+arr[i-2])%1000000007;\n            }\n            return arr[n];\n        }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\nclass solution {\npublic int fib(int n) {\n            if (n == 0) {\n                return 0;\n            }\n            if (n == 1) {\n                return 1;\n            }\n            double a = 0;\n            double b = 1;\n            double c = 0;\n            int num=1000000007;\n            for (int i = 2; i <= n; i++) {\n                c = (a + b)%num;\n                a = b;\n                b = c;\n            }\n            return (int) c;\n        }\n}\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n# 高赞题解\n# 解题思路：\n斐波那契数列的定义是 f(n+1)=f(n)+f(n−1)f(n + 1) = f(n) + f(n - 1)f(n+1)=f(n)+f(n−1) ，生成第 nnn 项的做法有以下几种：\n\n 1. 递归法： * 原理： 把 f(n)f(n)f(n) 问题的计算拆分成 f(n−1)f(n-1)f(n−1) 和 f(n−2)f(n-2)f(n−2) 两个子问题的计算，并递归，以 f(0)f(0)f(0) 和 f(1)f(1)f(1) 为终止条件。\n     * 缺点： 大量重复的递归计算，例如 f(n)f(n)f(n) 和 f(n−1)f(n - 1)f(n−1) 两者向下递归需要 各自计算 f(n−2)f(n - 2)f(n−2) 的值。\n    \n    \n 2. 记忆化递归法： * 原理： 在递归法的基础上，新建一个长度为 nnn 的数组，用于在递归时存储 f(0)f(0)f(0) 至 f(n)f(n)f(n) 的数字值，重复遇到某数字则直接从数组取用，避免了重复的递归计算。\n     * 缺点： 记忆化存储需要使用 o(n)o(n)o(n) 的额外空间。\n    \n    \n 3. 动态规划： * 原理： 以斐波那契数列性质 f(n+1)=f(n)+f(n−1)f(n + 1) = f(n) + f(n - 1)f(n+1)=f(n)+f(n−1) 为转移方程。\n     * 从计算效率、空间复杂度上看，动态规划是本题的最佳解法。\n    \n    \n\n> 下图帮助理解递归法的 “重复计算” 概念。\n\n\n{:width=450}\n\n# 动态规划解析：\n * 状态定义： 设 dpdpdp 为一维数组，其中 dp[i]dp[i]dp[i] 的值代表 斐波那契数列第 iii 个数字 。\n * 转移方程： dp[i+1]=dp[i]+dp[i−1]dp[i + 1] = dp[i] + dp[i - 1]dp[i+1]=dp[i]+dp[i−1] ，即对应数列定义 f(n+1)=f(n)+f(n−1)f(n + 1) = f(n) + f(n - 1)f(n+1)=f(n)+f(n−1) ；\n * 初始状态： dp[0]=0dp[0] = 0dp[0]=0, dp[1]=1dp[1] = 1dp[1]=1 ，即初始化前两个数字；\n * 返回值： dp[n]dp[n]dp[n] ，即斐波那契数列的第 nnn 个数字。\n\n# 空间复杂度优化：\n> 若新建长度为 nnn 的 dpdpdp 列表，则空间复杂度为 o(n)o(n)o(n) 。\n\n\n * 由于 dpdpdp 列表第 iii 项只与第 i−1i-1i−1 和第 i−2i-2i−2 项有关，因此只需要初始化三个整形变量 sum, a, b ，利用辅助变量 sumsumsum 使 a,ba, ba,b 两数字交替前进即可 （具体实现见代码） 。\n * 节省了 dpdpdp 列表空间，因此空间复杂度降至 o(1)o(1)o(1) 。\n\n# 循环求余法：\n> 大数越界： 随着 nnn 增大, f(n)f(n)f(n) 会超过 int32 甚至 int64 的取值范围，导致最终的返回值错误。\n\n\n * 求余运算规则： 设正整数 x,y,px, y, px,y,p ，求余符号为 ⊙\\odot⊙ ，则有 (x+y)⊙p=(x⊙p+y⊙p)⊙p(x + y) \\odot p = (x \\odot p + y \\odot p) \\odot p(x+y)⊙p=(x⊙p+y⊙p)⊙p 。\n * 解析： 根据以上规则，可推出 f(n)⊙p=[f(n−1)⊙p+f(n−2)⊙p]⊙pf(n) \\odot p = [f(n-1) \\odot p + f(n-2) \\odot p] \\odot pf(n)⊙p=[f(n−1)⊙p+f(n−2)⊙p]⊙p ，从而可以在循环过程中每次计算 sum=(a+b)⊙1000000007sum = (a + b) \\odot 1000000007sum=(a+b)⊙1000000007 ，此操作与最终返回前取余等价。\n\n> 图解基于 java 代码绘制，python 由于语言特性可以省去 sumsumsum 辅助变量和大数越界处理。\n\n\n<,,,,,,,,,,,>\n\n# 复杂度分析：\n * 时间复杂度 o(n)o(n)o(n) ： 计算 f(n)f(n)f(n) 需循环 nnn 次，每轮循环内计算操作使用 o(1)o(1)o(1) 。\n * 空间复杂度 o(1)o(1)o(1) ： 几个标志变量使用常数大小的额外空间。\n\n# 代码：\n> 由于 python 中整形数字的大小限制 取决计算机的内存 （可理解为无限大），因此可不考虑大数越界问题。\n\n\nclass solution:\n    def fib(self, n: int) -> int:\n        a, b = 0, 1\n        for _ in range(n):\n            a, b = b, a + b\n        return a % 1000000007\n\n\n1\n2\n3\n4\n5\n6\nclass solution {\n    public int fib(int n) {\n        int a = 0, b = 1, sum;\n        for(int i = 0; i < n; i++){\n            sum = (a + b) % 1000000007;\n            a = b;\n            b = sum;\n        }\n        return a;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n# 提交历史\n提交时间提交结果标记状态我的注释执行时间战胜比例内存消耗语言2021-05-22 21:39:21accepted [https://leetcode-cn.com/submissions/detail/179919882/]🚩🚩🚩数组保存0 ms100.0%35.4 mbjava2021-05-22 21:38:10accepted [https://leetcode-cn.com/submissions/detail/179919223/]🚩三个变量0 ms100.0%35.2 mbjava2021-05-22 21:28:16wrong answer [https://leetcode-cn.com/submissions/detail/179916888/]n/an/an/ajava# 统计信息\n通过次数提交次数ac比率16684748570534.4%"},{title:"剑指 Offer 10- II-青蛙跳台阶问题(青蛙跳台阶问题  LCOF)",frontmatter:{title:"剑指 Offer 10- II-青蛙跳台阶问题(青蛙跳台阶问题  LCOF)",date:"2021-05-22T00:00:00.000Z",categories:["简单"],tags:["递归<Recursion>"]},regularPath:"/views/%E7%AE%80%E5%8D%95/%E5%89%91%E6%8C%87%20Offer%2010-%20II-%E9%9D%92%E8%9B%99%E8%B7%B3%E5%8F%B0%E9%98%B6%E9%97%AE%E9%A2%98.html",relativePath:"views/简单/剑指 Offer 10- II-青蛙跳台阶问题.md",key:"v-64944eae",path:"/views/%E7%AE%80%E5%8D%95/%E5%89%91%E6%8C%87%20Offer%2010-%20II-%E9%9D%92%E8%9B%99%E8%B7%B3%E5%8F%B0%E9%98%B6%E9%97%AE%E9%A2%98.html",headers:[{level:2,title:"中文题目",slug:"中文题目",charIndex:2},{level:2,title:"通过代码",slug:"通过代码",charIndex:273},{level:2,title:"高赞题解",slug:"高赞题解",charIndex:797},{level:2,title:"提交历史",slug:"提交历史",charIndex:3957},{level:2,title:"统计信息",slug:"统计信息",charIndex:4108}],headersStr:"中文题目 通过代码 高赞题解 提交历史 统计信息",content:"# 中文题目\n一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n级的台阶总共有多少种跳法。\n\n答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。\n\n示例 1：\n\n输入：n = 2\n输出：2\n\n\n示例 2：\n\n输入：n = 7\n输出：21\n\n\n示例 3：\n\n输入：n = 0\n输出：1\n\n提示：\n\n * 0 <= n <= 100\n\n注意：本题与主站 70 题相同：https://leetcode-cn.com/problems/climbing-stairs/\n\n\n\n# 通过代码\n    class Solution {\n        public int numWays(int n) {\n            if (n == 0) {\n                return 1;\n            }\n            if (n == 1) {\n                return 1;\n            }\n            int a = 1;\n            int b = 1;\n            int c = 0;\n            int num = 1000000007;\n            for (int i = 2; i <= n; i++) {\n                c = (a + b) % num;\n                a = b;\n                b = c;\n            }\n            return c;\n        }\n    }\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n# 高赞题解\n# 解题思路：\n> 此类求 多少种可能性 的题目一般都有 递推性质 ，即 f(n)f(n)f(n) 和 f(n−1)f(n-1)f(n−1)…f(1)f(1)f(1) 之间是有联系的。\n\n\n * 设跳上 nnn 级台阶有 f(n)f(n)f(n) 种跳法。在所有跳法中，青蛙的最后一步只有两种情况： 跳上 111 级或 222 级台阶。 1. 当为 111 级台阶： 剩 n−1n-1n−1 个台阶，此情况共有 f(n−1)f(n-1)f(n−1) 种跳法；\n    2. 当为 222 级台阶： 剩 n−2n-2n−2 个台阶，此情况共有 f(n−2)f(n-2)f(n−2) 种跳法。\n   \n   \n * f(n)f(n)f(n) 为以上两种情况之和，即 f(n)=f(n−1)+f(n−2)f(n)=f(n-1)+f(n-2)f(n)=f(n−1)+f(n−2) ，以上递推性质为斐波那契数列。本题可转化为 求斐波那契数列第 nnn 项的值 ，与 面试题10- I. 斐波那契数列 [https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/solution/mian-shi-ti-10-i-fei-bo-na-qi-shu-lie-dong-tai-gui/] 等价，唯一的不同在于起始数字不同。 * 青蛙跳台阶问题： f(0)=1f(0)=1f(0)=1 , f(1)=1f(1)=1f(1)=1 , f(2)=2f(2)=2f(2)=2 ；\n    * 斐波那契数列问题： f(0)=0f(0)=0f(0)=0 , f(1)=1f(1)=1f(1)=1 , f(2)=1f(2)=1f(2)=1 。\n   \n   \n\n{:width=500}{:align=center}\n\n> 斐波那契数列的定义是 f(n+1)=f(n)+f(n−1)f(n + 1) = f(n) + f(n - 1)f(n+1)=f(n)+f(n−1) ，生成第 nnn 项的做法有以下几种：\n\n 1. 递归法： * 原理： 把 f(n)f(n)f(n) 问题的计算拆分成 f(n−1)f(n-1)f(n−1) 和 f(n−2)f(n-2)f(n−2) 两个子问题的计算，并递归，以 f(0)f(0)f(0) 和 f(1)f(1)f(1) 为终止条件。\n     * 缺点： 大量重复的递归计算，例如 f(n)f(n)f(n) 和 f(n−1)f(n - 1)f(n−1) 两者向下递归都需要计算 f(n−2)f(n - 2)f(n−2) 的值。\n    \n    \n 2. 记忆化递归法： * 原理： 在递归法的基础上，新建一个长度为 nnn 的数组，用于在递归时存储 f(0)f(0)f(0) 至 f(n)f(n)f(n) 的数字值，重复遇到某数字时则直接从数组取用，避免了重复的递归计算。\n     * 缺点： 记忆化存储的数组需要使用 O(N)O(N)O(N) 的额外空间。\n    \n    \n 3. 动态规划： * 原理： 以斐波那契数列性质 f(n+1)=f(n)+f(n−1)f(n + 1) = f(n) + f(n - 1)f(n+1)=f(n)+f(n−1) 为转移方程。\n     * 从计算效率、空间复杂度上看，动态规划是本题的最佳解法。\n    \n    \n\n\n动态规划解析：\n\n * 状态定义： 设 dpdpdp 为一维数组，其中 dp[i]dp[i]dp[i] 的值代表 斐波那契数列第 $i$ 个数字 。\n * 转移方程： dp[i+1]=dp[i]+dp[i−1]dp[i + 1] = dp[i] + dp[i - 1]dp[i+1]=dp[i]+dp[i−1] ，即对应数列定义 f(n+1)=f(n)+f(n−1)f(n + 1) = f(n) + f(n - 1)f(n+1)=f(n)+f(n−1) ；\n * 初始状态： dp[0]=1dp[0] = 1dp[0]=1, dp[1]=1dp[1] = 1dp[1]=1 ，即初始化前两个数字；\n * 返回值： dp[n]dp[n]dp[n] ，即斐波那契数列的第 nnn 个数字。\n\n空间复杂度优化：\n\n> 若新建长度为 nnn 的 dpdpdp 列表，则空间复杂度为 O(N)O(N)O(N) 。\n\n\n * 由于 dpdpdp 列表第 iii 项只与第 i−1i-1i−1 和第 i−2i-2i−2 项有关，因此只需要初始化三个整形变量 sum, a, b ，利用辅助变量 sumsumsum 使 a,ba, ba,b 两数字交替前进即可 （具体实现见代码） 。\n * 因为节省了 dpdpdp 列表空间，因此空间复杂度降至 O(1)O(1)O(1) 。\n\n循环求余法：\n\n> 大数越界： 随着 nnn 增大, f(n)f(n)f(n) 会超过 Int32 甚至 Int64 的取值范围，导致最终的返回值错误。\n\n\n * 求余运算规则： 设正整数 x,y,px, y, px,y,p ，求余符号为 ⊙\\odot⊙ ，则有 (x+y)⊙p=(x⊙p+y⊙p)⊙p(x + y) \\odot p = (x \\odot p + y \\odot p) \\odot p(x+y)⊙p=(x⊙p+y⊙p)⊙p 。\n * 解析： 根据以上规则，可推出 f(n)⊙p=[f(n−1)⊙p+f(n−2)⊙p]⊙pf(n) \\odot p = [f(n-1) \\odot p + f(n-2) \\odot p] \\odot pf(n)⊙p=[f(n−1)⊙p+f(n−2)⊙p]⊙p ，从而可以在循环过程中每次计算 sum=a+b⊙1000000007sum = a + b \\odot 1000000007sum=a+b⊙1000000007 ，此操作与最终返回前取余等价。\n\n> 图解基于 Java 代码绘制，Python 由于语言特性可以省去 sumsumsum 辅助变量和大数越界处理。\n\n\n<,,,,,,,,,,,>\n\n复杂度分析：\n\n * 时间复杂度 O(N)O(N)O(N) ： 计算 f(n)f(n)f(n) 需循环 nnn 次，每轮循环内计算操作使用 O(1)O(1)O(1) 。\n * 空间复杂度 O(1)O(1)O(1) ： 几个标志变量使用常数大小的额外空间。\n\n# 代码：\n> 由于 Python 中整形数字的大小限制 取决计算机的内存 （可理解为无限大），因此可不考虑大数越界问题。\n\n\nclass Solution:\n    def numWays(self, n: int) -> int:\n        a, b = 1, 1\n        for _ in range(n):\n            a, b = b, a + b\n        return a % 1000000007\n\n\n1\n2\n3\n4\n5\n6\nclass Solution {\n    public int numWays(int n) {\n        int a = 1, b = 1, sum;\n        for(int i = 0; i < n; i++){\n            sum = (a + b) % 1000000007;\n            a = b;\n            b = sum;\n        }\n        return a;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n# 提交历史\n提交时间提交结果标记状态我的注释执行时间战胜比例内存消耗语言2021-05-22 21:42:51Accepted [https://leetcode-cn.com/submissions/detail/179920754/]🚩🚩🚩🚩🚩0 ms100.0%35.4 MBjava# 统计信息\n通过次数提交次数AC比率13912832059943.4%",contentLowercase:"# 中文题目\n一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n级的台阶总共有多少种跳法。\n\n答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。\n\n示例 1：\n\n输入：n = 2\n输出：2\n\n\n示例 2：\n\n输入：n = 7\n输出：21\n\n\n示例 3：\n\n输入：n = 0\n输出：1\n\n提示：\n\n * 0 <= n <= 100\n\n注意：本题与主站 70 题相同：https://leetcode-cn.com/problems/climbing-stairs/\n\n\n\n# 通过代码\n    class solution {\n        public int numways(int n) {\n            if (n == 0) {\n                return 1;\n            }\n            if (n == 1) {\n                return 1;\n            }\n            int a = 1;\n            int b = 1;\n            int c = 0;\n            int num = 1000000007;\n            for (int i = 2; i <= n; i++) {\n                c = (a + b) % num;\n                a = b;\n                b = c;\n            }\n            return c;\n        }\n    }\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n# 高赞题解\n# 解题思路：\n> 此类求 多少种可能性 的题目一般都有 递推性质 ，即 f(n)f(n)f(n) 和 f(n−1)f(n-1)f(n−1)…f(1)f(1)f(1) 之间是有联系的。\n\n\n * 设跳上 nnn 级台阶有 f(n)f(n)f(n) 种跳法。在所有跳法中，青蛙的最后一步只有两种情况： 跳上 111 级或 222 级台阶。 1. 当为 111 级台阶： 剩 n−1n-1n−1 个台阶，此情况共有 f(n−1)f(n-1)f(n−1) 种跳法；\n    2. 当为 222 级台阶： 剩 n−2n-2n−2 个台阶，此情况共有 f(n−2)f(n-2)f(n−2) 种跳法。\n   \n   \n * f(n)f(n)f(n) 为以上两种情况之和，即 f(n)=f(n−1)+f(n−2)f(n)=f(n-1)+f(n-2)f(n)=f(n−1)+f(n−2) ，以上递推性质为斐波那契数列。本题可转化为 求斐波那契数列第 nnn 项的值 ，与 面试题10- i. 斐波那契数列 [https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/solution/mian-shi-ti-10-i-fei-bo-na-qi-shu-lie-dong-tai-gui/] 等价，唯一的不同在于起始数字不同。 * 青蛙跳台阶问题： f(0)=1f(0)=1f(0)=1 , f(1)=1f(1)=1f(1)=1 , f(2)=2f(2)=2f(2)=2 ；\n    * 斐波那契数列问题： f(0)=0f(0)=0f(0)=0 , f(1)=1f(1)=1f(1)=1 , f(2)=1f(2)=1f(2)=1 。\n   \n   \n\n{:width=500}{:align=center}\n\n> 斐波那契数列的定义是 f(n+1)=f(n)+f(n−1)f(n + 1) = f(n) + f(n - 1)f(n+1)=f(n)+f(n−1) ，生成第 nnn 项的做法有以下几种：\n\n 1. 递归法： * 原理： 把 f(n)f(n)f(n) 问题的计算拆分成 f(n−1)f(n-1)f(n−1) 和 f(n−2)f(n-2)f(n−2) 两个子问题的计算，并递归，以 f(0)f(0)f(0) 和 f(1)f(1)f(1) 为终止条件。\n     * 缺点： 大量重复的递归计算，例如 f(n)f(n)f(n) 和 f(n−1)f(n - 1)f(n−1) 两者向下递归都需要计算 f(n−2)f(n - 2)f(n−2) 的值。\n    \n    \n 2. 记忆化递归法： * 原理： 在递归法的基础上，新建一个长度为 nnn 的数组，用于在递归时存储 f(0)f(0)f(0) 至 f(n)f(n)f(n) 的数字值，重复遇到某数字时则直接从数组取用，避免了重复的递归计算。\n     * 缺点： 记忆化存储的数组需要使用 o(n)o(n)o(n) 的额外空间。\n    \n    \n 3. 动态规划： * 原理： 以斐波那契数列性质 f(n+1)=f(n)+f(n−1)f(n + 1) = f(n) + f(n - 1)f(n+1)=f(n)+f(n−1) 为转移方程。\n     * 从计算效率、空间复杂度上看，动态规划是本题的最佳解法。\n    \n    \n\n\n动态规划解析：\n\n * 状态定义： 设 dpdpdp 为一维数组，其中 dp[i]dp[i]dp[i] 的值代表 斐波那契数列第 $i$ 个数字 。\n * 转移方程： dp[i+1]=dp[i]+dp[i−1]dp[i + 1] = dp[i] + dp[i - 1]dp[i+1]=dp[i]+dp[i−1] ，即对应数列定义 f(n+1)=f(n)+f(n−1)f(n + 1) = f(n) + f(n - 1)f(n+1)=f(n)+f(n−1) ；\n * 初始状态： dp[0]=1dp[0] = 1dp[0]=1, dp[1]=1dp[1] = 1dp[1]=1 ，即初始化前两个数字；\n * 返回值： dp[n]dp[n]dp[n] ，即斐波那契数列的第 nnn 个数字。\n\n空间复杂度优化：\n\n> 若新建长度为 nnn 的 dpdpdp 列表，则空间复杂度为 o(n)o(n)o(n) 。\n\n\n * 由于 dpdpdp 列表第 iii 项只与第 i−1i-1i−1 和第 i−2i-2i−2 项有关，因此只需要初始化三个整形变量 sum, a, b ，利用辅助变量 sumsumsum 使 a,ba, ba,b 两数字交替前进即可 （具体实现见代码） 。\n * 因为节省了 dpdpdp 列表空间，因此空间复杂度降至 o(1)o(1)o(1) 。\n\n循环求余法：\n\n> 大数越界： 随着 nnn 增大, f(n)f(n)f(n) 会超过 int32 甚至 int64 的取值范围，导致最终的返回值错误。\n\n\n * 求余运算规则： 设正整数 x,y,px, y, px,y,p ，求余符号为 ⊙\\odot⊙ ，则有 (x+y)⊙p=(x⊙p+y⊙p)⊙p(x + y) \\odot p = (x \\odot p + y \\odot p) \\odot p(x+y)⊙p=(x⊙p+y⊙p)⊙p 。\n * 解析： 根据以上规则，可推出 f(n)⊙p=[f(n−1)⊙p+f(n−2)⊙p]⊙pf(n) \\odot p = [f(n-1) \\odot p + f(n-2) \\odot p] \\odot pf(n)⊙p=[f(n−1)⊙p+f(n−2)⊙p]⊙p ，从而可以在循环过程中每次计算 sum=a+b⊙1000000007sum = a + b \\odot 1000000007sum=a+b⊙1000000007 ，此操作与最终返回前取余等价。\n\n> 图解基于 java 代码绘制，python 由于语言特性可以省去 sumsumsum 辅助变量和大数越界处理。\n\n\n<,,,,,,,,,,,>\n\n复杂度分析：\n\n * 时间复杂度 o(n)o(n)o(n) ： 计算 f(n)f(n)f(n) 需循环 nnn 次，每轮循环内计算操作使用 o(1)o(1)o(1) 。\n * 空间复杂度 o(1)o(1)o(1) ： 几个标志变量使用常数大小的额外空间。\n\n# 代码：\n> 由于 python 中整形数字的大小限制 取决计算机的内存 （可理解为无限大），因此可不考虑大数越界问题。\n\n\nclass solution:\n    def numways(self, n: int) -> int:\n        a, b = 1, 1\n        for _ in range(n):\n            a, b = b, a + b\n        return a % 1000000007\n\n\n1\n2\n3\n4\n5\n6\nclass solution {\n    public int numways(int n) {\n        int a = 1, b = 1, sum;\n        for(int i = 0; i < n; i++){\n            sum = (a + b) % 1000000007;\n            a = b;\n            b = sum;\n        }\n        return a;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n# 提交历史\n提交时间提交结果标记状态我的注释执行时间战胜比例内存消耗语言2021-05-22 21:42:51accepted [https://leetcode-cn.com/submissions/detail/179920754/]🚩🚩🚩🚩🚩0 ms100.0%35.4 mbjava# 统计信息\n通过次数提交次数ac比率13912832059943.4%"},{frontmatter:{layout:"Tags",title:"Tags"},regularPath:"/tag/",key:"v-b1564aac",path:"/tag/"},{frontmatter:{layout:"FrontmatterKey",title:"Categories"},regularPath:"/categories/",key:"v-ef9325c4",path:"/categories/"},{frontmatter:{layout:"TimeLines",title:"Timeline"},regularPath:"/timeline/",key:"v-6319eb4e",path:"/timeline/"},{frontmatter:{layout:"Tag",title:"链表<Linked List> tags"},regularPath:"/tags/%E9%93%BE%E8%A1%A8%3CLinked%20List%3E/",key:"v-2ea6762e",path:"/tags/链表<Linked List>/"},{frontmatter:{layout:"Tag",title:"数学<Math> tags"},regularPath:"/tags/%E6%95%B0%E5%AD%A6%3CMath%3E/",key:"v-5b7e7d96",path:"/tags/数学<Math>/"},{frontmatter:{layout:"Tag",title:"哈希表<Hash Table> tags"},regularPath:"/tags/%E5%93%88%E5%B8%8C%E8%A1%A8%3CHash%20Table%3E/",key:"v-e9650e12",path:"/tags/哈希表<Hash Table>/"},{frontmatter:{layout:"Tag",title:"双指针<Two Pointers> tags"},regularPath:"/tags/%E5%8F%8C%E6%8C%87%E9%92%88%3CTwo%20Pointers%3E/",key:"v-27dacd33",path:"/tags/双指针<Two Pointers>/"},{frontmatter:{layout:"Tag",title:"字符串<String> tags"},regularPath:"/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%3CString%3E/",key:"v-6b74076a",path:"/tags/字符串<String>/"},{frontmatter:{layout:"Tag",title:"Sliding Window tags"},regularPath:"/tags/Sliding%20Window/",key:"v-3ef1fb49",path:"/tags/Sliding Window/"},{frontmatter:{layout:"Tag",title:"回溯算法<Backtracking> tags"},regularPath:"/tags/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%3CBacktracking%3E/",key:"v-67be4016",path:"/tags/回溯算法<Backtracking>/"},{frontmatter:{layout:"Tag",title:"数组<Array> tags"},regularPath:"/tags/%E6%95%B0%E7%BB%84%3CArray%3E/",key:"v-5279a3e8",path:"/tags/数组<Array>/"},{frontmatter:{layout:"Tag",title:"二分查找<Binary Search> tags"},regularPath:"/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%3CBinary%20Search%3E/",key:"v-40d1debc",path:"/tags/二分查找<Binary Search>/"},{frontmatter:{layout:"Tag",title:"递归<Recursion> tags"},regularPath:"/tags/%E9%80%92%E5%BD%92%3CRecursion%3E/",key:"v-76883238",path:"/tags/递归<Recursion>/"},{frontmatter:{layout:"Tag",title:"动态规划<Dynamic Programming> tags"},regularPath:"/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%3CDynamic%20Programming%3E/",key:"v-7d6a3d86",path:"/tags/动态规划<Dynamic Programming>/"},{frontmatter:{layout:"Tag",title:"排序<Sort> tags"},regularPath:"/tags/%E6%8E%92%E5%BA%8F%3CSort%3E/",key:"v-ab77a8b0",path:"/tags/排序<Sort>/"},{frontmatter:{layout:"Tag",title:"位运算<Bit Manipulation> tags"},regularPath:"/tags/%E4%BD%8D%E8%BF%90%E7%AE%97%3CBit%20Manipulation%3E/",key:"v-356594fd",path:"/tags/位运算<Bit Manipulation>/"},{frontmatter:{layout:"Tag",title:"栈<Stack> tags"},regularPath:"/tags/%E6%A0%88%3CStack%3E/",key:"v-dd24ce1e",path:"/tags/栈<Stack>/"},{frontmatter:{layout:"Tag",title:"树<Tree> tags"},regularPath:"/tags/%E6%A0%91%3CTree%3E/",key:"v-28f11726",path:"/tags/树<Tree>/"},{frontmatter:{layout:"Tag",title:"深度优先搜索<Depth-first Search> tags"},regularPath:"/tags/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%3CDepth-first%20Search%3E/",key:"v-45a392fa",path:"/tags/深度优先搜索<Depth-first Search>/"},{frontmatter:{layout:"Tag",title:"广度优先搜索<Breadth-first Search> tags"},regularPath:"/tags/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%3CBreadth-first%20Search%3E/",key:"v-6aeae2cc",path:"/tags/广度优先搜索<Breadth-first Search>/"},{frontmatter:{layout:"Tag",title:"并查集<Union Find> tags"},regularPath:"/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86%3CUnion%20Find%3E/",key:"v-196d7d58",path:"/tags/并查集<Union Find>/"},{frontmatter:{layout:"Tag",title:"设计<Design> tags"},regularPath:"/tags/%E8%AE%BE%E8%AE%A1%3CDesign%3E/",key:"v-2f716bfd",path:"/tags/设计<Design>/"},{frontmatter:{layout:"Tag",title:"字典树<Trie> tags"},regularPath:"/tags/%E5%AD%97%E5%85%B8%E6%A0%91%3CTrie%3E/",key:"v-c1d120b2",path:"/tags/字典树<Trie>/"},{frontmatter:{layout:"Tag",title:"堆<Heap> tags"},regularPath:"/tags/%E5%A0%86%3CHeap%3E/",key:"v-6b196c14",path:"/tags/堆<Heap>/"},{frontmatter:{layout:"Tag",title:"分治算法<Divide and Conquer> tags"},regularPath:"/tags/%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95%3CDivide%20and%20Conquer%3E/",key:"v-56974274",path:"/tags/分治算法<Divide and Conquer>/"},{frontmatter:{layout:"Tag",title:"Ordered Map tags"},regularPath:"/tags/Ordered%20Map/",key:"v-34755e6a",path:"/tags/Ordered Map/"},{frontmatter:{layout:"Tag",title:"树状数组<Binary Indexed Tree> tags"},regularPath:"/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%3CBinary%20Indexed%20Tree%3E/",key:"v-537ba684",path:"/tags/树状数组<Binary Indexed Tree>/"},{frontmatter:{layout:"Tag",title:"线段树<Segment Tree> tags"},regularPath:"/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91%3CSegment%20Tree%3E/",key:"v-2074af06",path:"/tags/线段树<Segment Tree>/"},{frontmatter:{layout:"Tag",title:"贪心算法<Greedy> tags"},regularPath:"/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%3CGreedy%3E/",key:"v-7b83e294",path:"/tags/贪心算法<Greedy>/"},{frontmatter:{layout:"Tag",title:"脑筋急转弯<Brainteaser> tags"},regularPath:"/tags/%E8%84%91%E7%AD%8B%E6%80%A5%E8%BD%AC%E5%BC%AF%3CBrainteaser%3E/",key:"v-0914131e",path:"/tags/脑筋急转弯<Brainteaser>/"},{frontmatter:{layout:"Tag",title:"几何<Geometry> tags"},regularPath:"/tags/%E5%87%A0%E4%BD%95%3CGeometry%3E/",key:"v-24a5d056",path:"/tags/几何<Geometry>/"},{frontmatter:{layout:"Category",title:"中等 categories"},regularPath:"/categories/%E4%B8%AD%E7%AD%89/",key:"v-abbdcbc6",path:"/categories/中等/"},{frontmatter:{layout:"Category",title:"困难 categories"},regularPath:"/categories/%E5%9B%B0%E9%9A%BE/",key:"v-66f980d2",path:"/categories/困难/"},{frontmatter:{layout:"Category",title:"简单 categories"},regularPath:"/categories/%E7%AE%80%E5%8D%95/",key:"v-17686912",path:"/categories/简单/"},{frontmatter:{layout:"Layout",title:"Page 1 - 链表<Linked List> | tags"},regularPath:"/tags/%E9%93%BE%E8%A1%A8%3CLinked%20List%3E/page/2/",key:"v-003aa8b4",path:"/tags/链表<Linked List>/page/2/"},{frontmatter:{layout:"Layout",title:"Page 1 - 数学<Math> | tags"},regularPath:"/tags/%E6%95%B0%E5%AD%A6%3CMath%3E/page/2/",key:"v-3a4c7ee8",path:"/tags/数学<Math>/page/2/"},{frontmatter:{layout:"Layout",title:"Page 1 - 哈希表<Hash Table> | tags"},regularPath:"/tags/%E5%93%88%E5%B8%8C%E8%A1%A8%3CHash%20Table%3E/page/2/",key:"v-2b77e8e6",path:"/tags/哈希表<Hash Table>/page/2/"},{frontmatter:{layout:"Layout",title:"Page 2 - 哈希表<Hash Table> | tags"},regularPath:"/tags/%E5%93%88%E5%B8%8C%E8%A1%A8%3CHash%20Table%3E/page/3/",key:"v-2b77e905",path:"/tags/哈希表<Hash Table>/page/3/"},{frontmatter:{layout:"Layout",title:"Page 1 - 双指针<Two Pointers> | tags"},regularPath:"/tags/%E5%8F%8C%E6%8C%87%E9%92%88%3CTwo%20Pointers%3E/page/2/",key:"v-01ca992a",path:"/tags/双指针<Two Pointers>/page/2/"},{frontmatter:{layout:"Layout",title:"Page 2 - 双指针<Two Pointers> | tags"},regularPath:"/tags/%E5%8F%8C%E6%8C%87%E9%92%88%3CTwo%20Pointers%3E/page/3/",key:"v-01ca9949",path:"/tags/双指针<Two Pointers>/page/3/"},{frontmatter:{layout:"Layout",title:"Page 1 - 字符串<String> | tags"},regularPath:"/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%3CString%3E/page/2/",key:"v-154e81dc",path:"/tags/字符串<String>/page/2/"},{frontmatter:{layout:"Layout",title:"Page 1 - 回溯算法<Backtracking> | tags"},regularPath:"/tags/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%3CBacktracking%3E/page/2/",key:"v-0f2db0e7",path:"/tags/回溯算法<Backtracking>/page/2/"},{frontmatter:{layout:"Layout",title:"Page 1 - 数组<Array> | tags"},regularPath:"/tags/%E6%95%B0%E7%BB%84%3CArray%3E/page/2/",key:"v-11b88656",path:"/tags/数组<Array>/page/2/"},{frontmatter:{layout:"Layout",title:"Page 2 - 数组<Array> | tags"},regularPath:"/tags/%E6%95%B0%E7%BB%84%3CArray%3E/page/3/",key:"v-11b88618",path:"/tags/数组<Array>/page/3/"},{frontmatter:{layout:"Layout",title:"Page 3 - 数组<Array> | tags"},regularPath:"/tags/%E6%95%B0%E7%BB%84%3CArray%3E/page/4/",key:"v-11b885da",path:"/tags/数组<Array>/page/4/"},{frontmatter:{layout:"Layout",title:"Page 4 - 数组<Array> | tags"},regularPath:"/tags/%E6%95%B0%E7%BB%84%3CArray%3E/page/5/",key:"v-11b8859c",path:"/tags/数组<Array>/page/5/"},{frontmatter:{layout:"Layout",title:"Page 5 - 数组<Array> | tags"},regularPath:"/tags/%E6%95%B0%E7%BB%84%3CArray%3E/page/6/",key:"v-11b8855e",path:"/tags/数组<Array>/page/6/"},{frontmatter:{layout:"Layout",title:"Page 1 - 二分查找<Binary Search> | tags"},regularPath:"/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%3CBinary%20Search%3E/page/2/",key:"v-7f2128fe",path:"/tags/二分查找<Binary Search>/page/2/"},{frontmatter:{layout:"Layout",title:"Page 1 - 动态规划<Dynamic Programming> | tags"},regularPath:"/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%3CDynamic%20Programming%3E/page/2/",key:"v-deb07440",path:"/tags/动态规划<Dynamic Programming>/page/2/"},{frontmatter:{layout:"Layout",title:"Page 1 - 栈<Stack> | tags"},regularPath:"/tags/%E6%A0%88%3CStack%3E/page/2/",key:"v-90a688a8",path:"/tags/栈<Stack>/page/2/"},{frontmatter:{layout:"Layout",title:"Page 1 - 树<Tree> | tags"},regularPath:"/tags/%E6%A0%91%3CTree%3E/page/2/",key:"v-71e83cb0",path:"/tags/树<Tree>/page/2/"},{frontmatter:{layout:"Layout",title:"Page 2 - 树<Tree> | tags"},regularPath:"/tags/%E6%A0%91%3CTree%3E/page/3/",key:"v-71e83ccf",path:"/tags/树<Tree>/page/3/"},{frontmatter:{layout:"Layout",title:"Page 1 - 深度优先搜索<Depth-first Search> | tags"},regularPath:"/tags/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%3CDepth-first%20Search%3E/page/2/",key:"v-0add15da",path:"/tags/深度优先搜索<Depth-first Search>/page/2/"},{frontmatter:{layout:"Layout",title:"Page 1 - 中等 | categories"},regularPath:"/categories/%E4%B8%AD%E7%AD%89/page/2/",key:"v-51e9d100",path:"/categories/中等/page/2/"},{frontmatter:{layout:"Layout",title:"Page 2 - 中等 | categories"},regularPath:"/categories/%E4%B8%AD%E7%AD%89/page/3/",key:"v-51e9d11f",path:"/categories/中等/page/3/"},{frontmatter:{layout:"Layout",title:"Page 3 - 中等 | categories"},regularPath:"/categories/%E4%B8%AD%E7%AD%89/page/4/",key:"v-51e9d13e",path:"/categories/中等/page/4/"},{frontmatter:{layout:"Layout",title:"Page 4 - 中等 | categories"},regularPath:"/categories/%E4%B8%AD%E7%AD%89/page/5/",key:"v-51e9d15d",path:"/categories/中等/page/5/"},{frontmatter:{layout:"Layout",title:"Page 5 - 中等 | categories"},regularPath:"/categories/%E4%B8%AD%E7%AD%89/page/6/",key:"v-51e9d17c",path:"/categories/中等/page/6/"},{frontmatter:{layout:"Layout",title:"Page 6 - 中等 | categories"},regularPath:"/categories/%E4%B8%AD%E7%AD%89/page/7/",key:"v-51e9d19b",path:"/categories/中等/page/7/"},{frontmatter:{layout:"Layout",title:"Page 1 - 简单 | categories"},regularPath:"/categories/%E7%AE%80%E5%8D%95/page/2/",key:"v-59afc666",path:"/categories/简单/page/2/"},{frontmatter:{layout:"Layout",title:"Page 2 - 简单 | categories"},regularPath:"/categories/%E7%AE%80%E5%8D%95/page/3/",key:"v-59afc685",path:"/categories/简单/page/3/"},{frontmatter:{layout:"Layout",title:"Page 3 - 简单 | categories"},regularPath:"/categories/%E7%AE%80%E5%8D%95/page/4/",key:"v-59afc6a4",path:"/categories/简单/page/4/"},{frontmatter:{layout:"Layout",title:"Page 4 - 简单 | categories"},regularPath:"/categories/%E7%AE%80%E5%8D%95/page/5/",key:"v-59afc6c3",path:"/categories/简单/page/5/"},{frontmatter:{layout:"Layout",title:"Page 5 - 简单 | categories"},regularPath:"/categories/%E7%AE%80%E5%8D%95/page/6/",key:"v-59afc6e2",path:"/categories/简单/page/6/"},{frontmatter:{layout:"Layout",title:"Page 6 - 简单 | categories"},regularPath:"/categories/%E7%AE%80%E5%8D%95/page/7/",key:"v-59afc701",path:"/categories/简单/page/7/"},{frontmatter:{layout:"Layout",title:"Page 7 - 简单 | categories"},regularPath:"/categories/%E7%AE%80%E5%8D%95/page/8/",key:"v-59afc720",path:"/categories/简单/page/8/"},{frontmatter:{layout:"Layout",title:"Page 8 - 简单 | categories"},regularPath:"/categories/%E7%AE%80%E5%8D%95/page/9/",key:"v-59afc73f",path:"/categories/简单/page/9/"},{frontmatter:{layout:"Layout",title:"Page 9 - 简单 | categories"},regularPath:"/categories/%E7%AE%80%E5%8D%95/page/10/",key:"v-476dfa32",path:"/categories/简单/page/10/"},{frontmatter:{layout:"Layout",title:"Page 10 - 简单 | categories"},regularPath:"/categories/%E7%AE%80%E5%8D%95/page/11/",key:"v-476df9f4",path:"/categories/简单/page/11/"}],themeConfig:{nextLinks:!0,prevLinks:!0,type:"blog",nav:[{text:"主页",link:"/",icon:"reco-home"},{text:"时间轴",link:"/timeLine/",icon:"reco-date"},{text:"联系",icon:"reco-message",items:[{text:"GitHub",link:"https://github.com/shushu1234",icon:"reco-github"},{text:"博客",link:"https://www.liuyao.site",icon:"reco-blog"}]}],friendLink:[{title:"LiuYao-Blog",desc:"以梦为马，不一定越骑越傻，我写的不是代码，是魔法 😎",email:"liuyao9642@qq.com",link:"https://www.liuyao.site"},{title:"午后南杂",desc:"Enjoy when you can, and endure when you must.",email:"recoluan@qq.com",link:"https://www.recoluan.com"}],blogConfig:{category:{location:2,text:"分类"},tag:{location:3,text:"标签"}},logo:"/images/head.png",search:!0,searchMaxSuggestions:20,sidebar:"auto",lastUpdated:"上次更新",author:"LiuYao",startYear:"2019"},locales:{"/":{lang:"zh-cmn-Hans",path:"/"}}};var fe=t(20),ge={computed:{$recoPosts(){const{$categories:{list:n}}=this;let e=n.reduce((n,e)=>[...n,...e.pages],[]);return e=Object(fe.a)(e),Object(fe.c)(e),e},$recoPostsForTimeline(){let n=this.$recoPosts;const e={},t=[];n=Object(fe.a)(n,!0),this.pages=0==n.length?[]:n;for(let t=0,i=n.length;t<i;t++){const i=n[t],r=ve(i.frontmatter.date,"year");e[r]?e[r].push(i):e[r]=[i]}for(const n in e){const i=e[n];Object(fe.b)(i),t.unshift({year:n,data:i})}return t}}};function ve(n,e){n=function(n){var e=new Date(n).toJSON();return new Date(+new Date(e)+288e5).toISOString().replace(/T/g," ").replace(/\.[\d]{3}Z/,"").replace(/-/g,"/")}(n);const t=new Date(n),i=t.getFullYear(),r=t.getMonth()+1,s=t.getDate();return"year"==e?i:`${r}-${s}`}t(112);i.a.component("Badge",()=>Promise.all([t.e(0),t.e(79)]).then(t.bind(null,1398)));var be={name:"BackToTop",data:function(){return{visible:!1,interval:null,isMoving:!1,customStyle:{right:"1rem",bottom:"6rem",width:"2.5rem",height:"2.5rem","border-radius":".25rem","line-height":"2.5rem"},visibilityHeight:400}},mounted:function(){window.addEventListener("scroll",this.handleScroll)},beforeDestroy:function(){window.removeEventListener("scroll",this.handleScroll),this.interval&&clearInterval(this.interval)},methods:{handleScroll:function(){this.visible=window.pageYOffset>this.visibilityHeight},backToTop:function(){var n=this;if(!this.isMoving){var e=window.pageYOffset,t=0;this.isMoving=!0,this.interval=setInterval((function(){var i=Math.floor(n.easeInOutQuad(10*t,e,-e,500));i<=0?(window.scrollTo(0,0),clearInterval(n.interval),n.isMoving=!1):window.scrollTo(0,i),t++}),16.7)}},easeInOutQuad:function(n,e,t,i){return(n/=i/2)<1?t/2*n*n+e:-t/2*(--n*(n-2)-1)+e}}},xe=(t(113),Object(de.a)(be,(function(){var n=this.$createElement,e=this._self._c||n;return e("transition",{attrs:{name:"fade"}},[e("div",{directives:[{name:"show",rawName:"v-show",value:this.visible,expression:"visible"}],staticClass:"back-to-ceiling",style:this.customStyle,on:{click:this.backToTop}},[e("svg",{staticClass:"icon",attrs:{t:"1574745035067",viewBox:"0 0 1024 1024",version:"1.1",xmlns:"http://www.w3.org/2000/svg","p-id":"5404"}},[e("path",{attrs:{d:"M526.60727968 10.90185116a27.675 27.675 0 0 0-29.21455937 0c-131.36607665 82.28402758-218.69155461 228.01873535-218.69155402 394.07834331a462.20625001 462.20625001 0 0 0 5.36959153 69.94390903c1.00431239 6.55289093-0.34802892 13.13561351-3.76865779 18.80351572-32.63518765 54.11355614-51.75690182 118.55860487-51.7569018 187.94566865a371.06718723 371.06718723 0 0 0 11.50484808 91.98906777c6.53300375 25.50556257 41.68394495 28.14064038 52.69160883 4.22606766 17.37162448-37.73630017 42.14135425-72.50938081 72.80769204-103.21549295 2.18761121 3.04276886 4.15646224 6.24463696 6.40373557 9.22774369a1871.4375 1871.4375 0 0 0 140.04691725 5.34970492 1866.36093723 1866.36093723 0 0 0 140.04691723-5.34970492c2.24727335-2.98310674 4.21612437-6.18497483 6.3937923-9.2178004 30.66633723 30.70611158 55.4360664 65.4791928 72.80769147 103.21549355 11.00766384 23.91457269 46.15860503 21.27949489 52.69160879-4.22606768a371.15156223 371.15156223 0 0 0 11.514792-91.99901164c0-69.36717486-19.13165746-133.82216804-51.75690182-187.92578088-3.42062944-5.66790279-4.76302748-12.26056868-3.76865837-18.80351632a462.20625001 462.20625001 0 0 0 5.36959269-69.943909c-0.00994388-166.08943902-87.32547796-311.81420293-218.6915546-394.09823051zM605.93803103 357.87693858a93.93749974 93.93749974 0 1 1-187.89594924 6.1e-7 93.93749974 93.93749974 0 0 1 187.89594924-6.1e-7z","p-id":"5405"}}),e("path",{attrs:{d:"M429.50777625 765.63860547C429.50777625 803.39355007 466.44236686 1000.39046097 512.00932183 1000.39046097c45.56695499 0 82.4922232-197.00623328 82.5015456-234.7518555 0-37.75494459-36.9345906-68.35043303-82.4922232-68.34111062-45.57627738-0.00932239-82.52019037 30.59548842-82.51086798 68.34111062z","p-id":"5406"}})])])])}),[],!1,null,"a81d141e",null).exports),we=(t(114),Object(de.a)({},(function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("div",{attrs:{id:"loader-wrapper"}},[t("div",{staticClass:"loader-main"},n._l(4,(function(n){return t("div",{key:"out"+n})})),0),n._v(" "),n.$frontmatter.home?t("h3",{staticClass:"title"},[n._v(n._s(n.$site.title||n.$localeConfig.title))]):n._e(),n._v(" "),n.$frontmatter.home?t("p",{staticClass:"description"},[n._v(n._s(n.$site.description||n.$localeConfig.description))]):n._e()])}),[],!1,null,"4b73742e",null).exports),Ee=(t(94),{data:function(){return{changePage:""}},props:{total:{type:Number,default:10},perPage:{type:Number,default:10},currentPage:{type:Number,default:1}},computed:{pages:function(){return Math.ceil(this.total/this.perPage)},show:function(){return this.pages&&1!=this.pages},efont:function(){return!(this.pages<=7)&&this.currentPage>5},indexs:function(){var n=1,e=this.pages,t=[];for(this.pages>=7&&(this.currentPage>5&&this.currentPage<this.pages-4?(n=Number(this.currentPage)-3,e=Number(this.currentPage)+3):this.currentPage<=5?(n=1,e=7):(e=this.pages,n=this.pages-6));n<=e;)t.push(n),n++;return t}},methods:{goPrev:function(){var n=this.currentPage;this.currentPage>1&&this.emit(--n)},goNext:function(){var n=this.currentPage;n<this.pages&&this.emit(++n)},jumpPage:function(n){var e=parseInt(n);e<=this.pages&&e>0?this.emit(e):alert("请输入大于0，并且小于".concat(this.pages,"的页码！"))},emit:function(n){this.$emit("getCurrentPage",n)}}}),ye=(t(121),Object(de.a)(Ee,(function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("div",{directives:[{name:"show",rawName:"v-show",value:n.show,expression:"show"}],staticClass:"pagation"},[t("div",{staticClass:"pagation-list"},[t("span",{directives:[{name:"show",rawName:"v-show",value:n.currentPage>1,expression:"currentPage > 1"}],staticClass:"jump",attrs:{unselectable:"on"},on:{click:n.goPrev}},[n._v("Prev")]),n._v(" "),t("span",{directives:[{name:"show",rawName:"v-show",value:n.efont,expression:"efont"}],staticClass:"jump",on:{click:function(e){return n.jumpPage(1)}}},[n._v("1")]),n._v(" "),t("span",{directives:[{name:"show",rawName:"v-show",value:n.efont,expression:"efont"}],staticClass:"ellipsis"},[n._v("...")]),n._v(" "),n._l(n.indexs,(function(e){return t("span",{key:e,staticClass:"jump",class:{bgprimary:n.currentPage==e},on:{click:function(t){return n.jumpPage(e)}}},[n._v(n._s(e))])})),n._v(" "),t("span",{directives:[{name:"show",rawName:"v-show",value:n.efont&&n.currentPage<n.pages-4,expression:"efont&&currentPage<pages-4"}],staticClass:"ellipsis"},[n._v("...")]),n._v(" "),t("span",{directives:[{name:"show",rawName:"v-show",value:n.efont&&n.currentPage<n.pages-4,expression:"efont&&currentPage<pages-4"}],staticClass:"jump",on:{click:function(e){return n.jumpPage(n.pages)}}},[n._v(n._s(n.pages))]),n._v(" "),t("span",{directives:[{name:"show",rawName:"v-show",value:n.currentPage<n.pages,expression:"currentPage < pages"}],staticClass:"jump",on:{click:n.goNext}},[n._v("Next")]),n._v(" "),t("span",{staticClass:"jumppoint"},[n._v("跳转到：")]),n._v(" "),t("span",{staticClass:"jumpinp"},[t("input",{directives:[{name:"model",rawName:"v-model",value:n.changePage,expression:"changePage"}],attrs:{type:"text"},domProps:{value:n.changePage},on:{input:function(e){e.target.composing||(n.changePage=e.target.value)}}})]),n._v(" "),t("span",{staticClass:"jump gobtn",on:{click:function(e){return n.jumpPage(n.changePage)}}},[n._v("GO")])],2)])}),[],!1,null,"303bd5dc",null).exports),ke=(t(57),t(58),t(59),t(60),t(52),t(53),t(56),t(22));function Ae(n,e){var t=Object.keys(n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(n);e&&(i=i.filter((function(e){return Object.getOwnPropertyDescriptor(n,e).enumerable}))),t.push.apply(t,i)}return t}var je={name:"Valine",props:{options:{type:Object,default:function(){return{}}}},mounted:function(){this.initValine()},methods:{initValine:function(){var n=t(137),e=t(138),i=function(n){for(var e=1;e<arguments.length;e++){var t=null!=arguments[e]?arguments[e]:{};e%2?Ae(Object(t),!0).forEach((function(e){Object(ke.a)(n,e,t[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(t)):Ae(Object(t)).forEach((function(e){Object.defineProperty(n,e,Object.getOwnPropertyDescriptor(t,e))}))}return n}({el:"#valine",placeholder:"just go go",notify:!1,verify:!1,avatar:"retro",visitor:!0,recordIP:!1,path:window.location.pathname},this.options);"undefined"!=typeof window&&(this.window=window,window.AV=e),new n(i)}},watch:{$route:function(n,e){var t=this;n.path!==e.path&&setTimeout((function(){t.initValine()}),300)}}},_e=(t(139),Object(de.a)(je,(function(){var n=this.$createElement;this._self._c;return this._m(0)}),[function(){var n=this.$createElement,e=this._self._c||n;return e("div",{staticClass:"valine-wrapper"},[e("div",{attrs:{id:"valine"}})])}],!1,null,null,null).exports);
/**
  * vue-class-component v7.2.0
  * (c) 2015-present Evan You
  * @license MIT
  */
function Ne(n){return(Ne="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(n){return typeof n}:function(n){return n&&"function"==typeof Symbol&&n.constructor===Symbol&&n!==Symbol.prototype?"symbol":typeof n})(n)}function Oe(n,e,t){return e in n?Object.defineProperty(n,e,{value:t,enumerable:!0,configurable:!0,writable:!0}):n[e]=t,n}function Be(n){return function(n){if(Array.isArray(n)){for(var e=0,t=new Array(n.length);e<n.length;e++)t[e]=n[e];return t}}(n)||function(n){if(Symbol.iterator in Object(n)||"[object Arguments]"===Object.prototype.toString.call(n))return Array.from(n)}(n)||function(){throw new TypeError("Invalid attempt to spread non-iterable instance")}()}function Se(){return"undefined"!=typeof Reflect&&Reflect.defineMetadata&&Reflect.getOwnMetadataKeys}function Ie(n,e){Le(n,e),Object.getOwnPropertyNames(e.prototype).forEach((function(t){Le(n.prototype,e.prototype,t)})),Object.getOwnPropertyNames(e).forEach((function(t){Le(n,e,t)}))}function Le(n,e,t){(t?Reflect.getOwnMetadataKeys(e,t):Reflect.getOwnMetadataKeys(e)).forEach((function(i){var r=t?Reflect.getOwnMetadata(i,e,t):Reflect.getOwnMetadata(i,e);t?Reflect.defineMetadata(i,r,n,t):Reflect.defineMetadata(i,r,n)}))}var Ce={__proto__:[]}instanceof Array;function Te(n){return function(e,t,i){var r="function"==typeof e?e:e.constructor;r.__decorators__||(r.__decorators__=[]),"number"!=typeof i&&(i=void 0),r.__decorators__.push((function(e){return n(e,t,i)}))}}function De(n,e){var t=e.prototype._init;e.prototype._init=function(){var e=this,t=Object.getOwnPropertyNames(n);if(n.$options.props)for(var i in n.$options.props)n.hasOwnProperty(i)||t.push(i);t.forEach((function(t){"_"!==t.charAt(0)&&Object.defineProperty(e,t,{get:function(){return n[t]},set:function(e){n[t]=e},configurable:!0})}))};var i=new e;e.prototype._init=t;var r={};return Object.keys(i).forEach((function(n){void 0!==i[n]&&(r[n]=i[n])})),r}var qe=["data","beforeCreate","created","beforeMount","mounted","beforeDestroy","destroyed","beforeUpdate","updated","activated","deactivated","render","errorCaptured","serverPrefetch"];function Pe(n){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};e.name=e.name||n._componentTag||n.name;var t=n.prototype;Object.getOwnPropertyNames(t).forEach((function(n){if("constructor"!==n)if(qe.indexOf(n)>-1)e[n]=t[n];else{var i=Object.getOwnPropertyDescriptor(t,n);void 0!==i.value?"function"==typeof i.value?(e.methods||(e.methods={}))[n]=i.value:(e.mixins||(e.mixins=[])).push({data:function(){return Oe({},n,i.value)}}):(i.get||i.set)&&((e.computed||(e.computed={}))[n]={get:i.get,set:i.set})}})),(e.mixins||(e.mixins=[])).push({data:function(){return De(this,n)}});var r=n.__decorators__;r&&(r.forEach((function(n){return n(e)})),delete n.__decorators__);var s=Object.getPrototypeOf(n.prototype),o=s instanceof i.a?s.constructor:i.a,a=o.extend(e);return Fe(a,n,o),Se()&&Ie(a,n),a}var Me={prototype:!0,arguments:!0,callee:!0,caller:!0};function Fe(n,e,t){Object.getOwnPropertyNames(e).forEach((function(i){if(!Me[i]){var r=Object.getOwnPropertyDescriptor(n,i);if(!r||r.configurable){var s,o,a=Object.getOwnPropertyDescriptor(e,i);if(!Ce){if("cid"===i)return;var l=Object.getOwnPropertyDescriptor(t,i);if(s=a.value,o=Ne(s),null!=s&&("object"===o||"function"===o)&&l&&l.value===a.value)return}0,Object.defineProperty(n,i,a)}}}))}function ze(n){return"function"==typeof n?Pe(n):function(e){return Pe(e,n)}}ze.registerHooks=function(n){qe.push.apply(qe,Be(n))};var Re=ze;function $e(n){return Te((function(e,t){void 0===e.inject&&(e.inject={}),Array.isArray(e.inject)||(e.inject[t]=n||t)}))}var Ue="undefined"!=typeof Reflect&&void 0!==Reflect.getMetadata;function He(n,e,t){Ue&&(Array.isArray(n)||"function"==typeof n||void 0!==n.type||(n.type=Reflect.getMetadata("design:type",e,t)))}function Ve(n){return void 0===n&&(n={}),function(e,t){He(n,e,t),Te((function(e,t){(e.props||(e.props={}))[t]=n}))(e,t)}}function We(n,e){void 0===e&&(e={});var t=e.deep,i=void 0!==t&&t,r=e.immediate,s=void 0!==r&&r;return Te((function(e,t){"object"!=typeof e.watch&&(e.watch=Object.create(null));var r=e.watch;"object"!=typeof r[n]||Array.isArray(r[n])?void 0===r[n]&&(r[n]=[]):r[n]=[r[n]],r[n].push({handler:t,deep:i,immediate:s})}))}var Ke=t(86),Qe=t.n(Ke),Ge=t(37);const Ze=(n,e)=>`${n}${Object(Ge.stringify)(e,{addQueryPrefix:!0})}`,Je=(n,e)=>`${n.replace(/\/$/,"")}/${e.replace(/^\//,"")}`,Xe=n=>(n.split("#")[0]||"").split("?")[0]||"",Ye=n=>Object(Ge.parse)(n,{ignoreQueryPrefix:!0}),nt=n=>Object(Ge.stringify)(n),et=n=>Qe()(n,"YYYY-MM-DD HH:mm:ss");var tt=["style","currency","currencyDisplay","useGrouping","minimumIntegerDigits","minimumFractionDigits","maximumFractionDigits","minimumSignificantDigits","maximumSignificantDigits","localeMatcher","formatMatcher","unit"];
/*!
 * vue-i18n v8.15.3 
 * (c) 2019 kazuya kawaguchi
 * Released under the MIT License.
 */function it(n,e){"undefined"!=typeof console&&(console.warn("[vue-i18n] "+n),e&&console.warn(e.stack))}function rt(n){return null!==n&&"object"==typeof n}var st=Object.prototype.toString;function ot(n){return"[object Object]"===st.call(n)}function at(n){return null==n}function lt(){for(var n=[],e=arguments.length;e--;)n[e]=arguments[e];var t=null,i=null;return 1===n.length?rt(n[0])||Array.isArray(n[0])?i=n[0]:"string"==typeof n[0]&&(t=n[0]):2===n.length&&("string"==typeof n[0]&&(t=n[0]),(rt(n[1])||Array.isArray(n[1]))&&(i=n[1])),{locale:t,params:i}}function ut(n){return JSON.parse(JSON.stringify(n))}var ct=Object.prototype.hasOwnProperty;function dt(n,e){return ct.call(n,e)}function mt(n){for(var e=arguments,t=Object(n),i=1;i<arguments.length;i++){var r=e[i];if(null!=r){var s=void 0;for(s in r)dt(r,s)&&(rt(r[s])?t[s]=mt(t[s],r[s]):t[s]=r[s])}}return t}function pt(n,e){if(n===e)return!0;var t=rt(n),i=rt(e);if(!t||!i)return!t&&!i&&String(n)===String(e);try{var r=Array.isArray(n),s=Array.isArray(e);if(r&&s)return n.length===e.length&&n.every((function(n,t){return pt(n,e[t])}));if(r||s)return!1;var o=Object.keys(n),a=Object.keys(e);return o.length===a.length&&o.every((function(t){return pt(n[t],e[t])}))}catch(n){return!1}}var ht={beforeCreate:function(){var n=this.$options;if(n.i18n=n.i18n||(n.__i18n?{}:null),n.i18n)if(n.i18n instanceof Ut){if(n.__i18n)try{var e={};n.__i18n.forEach((function(n){e=mt(e,JSON.parse(n))})),Object.keys(e).forEach((function(t){n.i18n.mergeLocaleMessage(t,e[t])}))}catch(n){0}this._i18n=n.i18n,this._i18nWatcher=this._i18n.watchI18nData()}else if(ot(n.i18n)){if(this.$root&&this.$root.$i18n&&this.$root.$i18n instanceof Ut&&(n.i18n.root=this.$root,n.i18n.formatter=this.$root.$i18n.formatter,n.i18n.fallbackLocale=this.$root.$i18n.fallbackLocale,n.i18n.formatFallbackMessages=this.$root.$i18n.formatFallbackMessages,n.i18n.silentTranslationWarn=this.$root.$i18n.silentTranslationWarn,n.i18n.silentFallbackWarn=this.$root.$i18n.silentFallbackWarn,n.i18n.pluralizationRules=this.$root.$i18n.pluralizationRules,n.i18n.preserveDirectiveContent=this.$root.$i18n.preserveDirectiveContent),n.__i18n)try{var t={};n.__i18n.forEach((function(n){t=mt(t,JSON.parse(n))})),n.i18n.messages=t}catch(n){0}var i=n.i18n.sharedMessages;i&&ot(i)&&(n.i18n.messages=mt(n.i18n.messages,i)),this._i18n=new Ut(n.i18n),this._i18nWatcher=this._i18n.watchI18nData(),(void 0===n.i18n.sync||n.i18n.sync)&&(this._localeWatcher=this.$i18n.watchLocale())}else 0;else this.$root&&this.$root.$i18n&&this.$root.$i18n instanceof Ut?this._i18n=this.$root.$i18n:n.parent&&n.parent.$i18n&&n.parent.$i18n instanceof Ut&&(this._i18n=n.parent.$i18n)},beforeMount:function(){var n=this.$options;n.i18n=n.i18n||(n.__i18n?{}:null),n.i18n?n.i18n instanceof Ut?(this._i18n.subscribeDataChanging(this),this._subscribing=!0):ot(n.i18n)&&(this._i18n.subscribeDataChanging(this),this._subscribing=!0):this.$root&&this.$root.$i18n&&this.$root.$i18n instanceof Ut?(this._i18n.subscribeDataChanging(this),this._subscribing=!0):n.parent&&n.parent.$i18n&&n.parent.$i18n instanceof Ut&&(this._i18n.subscribeDataChanging(this),this._subscribing=!0)},beforeDestroy:function(){if(this._i18n){var n=this;this.$nextTick((function(){n._subscribing&&(n._i18n.unsubscribeDataChanging(n),delete n._subscribing),n._i18nWatcher&&(n._i18nWatcher(),n._i18n.destroyVM(),delete n._i18nWatcher),n._localeWatcher&&(n._localeWatcher(),delete n._localeWatcher),n._i18n=null}))}}},ft={name:"i18n",functional:!0,props:{tag:{type:String},path:{type:String,required:!0},locale:{type:String},places:{type:[Array,Object]}},render:function(n,e){var t=e.data,i=e.parent,r=e.props,s=e.slots,o=i.$i18n;if(o){var a=r.path,l=r.locale,u=r.places,c=s(),d=o.i(a,l,function(n){var e;for(e in n)if("default"!==e)return!1;return Boolean(e)}(c)||u?function(n,e){var t=e?function(n){0;return Array.isArray(n)?n.reduce(vt,{}):Object.assign({},n)}(e):{};if(!n)return t;var i=(n=n.filter((function(n){return n.tag||""!==n.text.trim()}))).every(bt);0;return n.reduce(i?gt:vt,t)}(c.default,u):c),m=r.tag||"span";return m?n(m,t,d):d}}};function gt(n,e){return e.data&&e.data.attrs&&e.data.attrs.place&&(n[e.data.attrs.place]=e),n}function vt(n,e,t){return n[t]=e,n}function bt(n){return Boolean(n.data&&n.data.attrs&&n.data.attrs.place)}var xt,wt={name:"i18n-n",functional:!0,props:{tag:{type:String,default:"span"},value:{type:Number,required:!0},format:{type:[String,Object]},locale:{type:String}},render:function(n,e){var t=e.props,i=e.parent,r=e.data,s=i.$i18n;if(!s)return null;var o=null,a=null;"string"==typeof t.format?o=t.format:rt(t.format)&&(t.format.key&&(o=t.format.key),a=Object.keys(t.format).reduce((function(n,e){var i;return tt.includes(e)?Object.assign({},n,((i={})[e]=t.format[e],i)):n}),null));var l=t.locale||s.locale,u=s._ntp(t.value,l,o,a),c=u.map((function(n,e){var t,i=r.scopedSlots&&r.scopedSlots[n.type];return i?i(((t={})[n.type]=n.value,t.index=e,t.parts=u,t)):n.value}));return n(t.tag,{attrs:r.attrs,class:r.class,staticClass:r.staticClass},c)}};function Et(n,e,t){At(n,t)&&jt(n,e,t)}function yt(n,e,t,i){if(At(n,t)){var r=t.context.$i18n;(function(n,e){var t=e.context;return n._locale===t.$i18n.locale})(n,t)&&pt(e.value,e.oldValue)&&pt(n._localeMessage,r.getLocaleMessage(r.locale))||jt(n,e,t)}}function kt(n,e,t,i){if(t.context){var r=t.context.$i18n||{};e.modifiers.preserve||r.preserveDirectiveContent||(n.textContent=""),n._vt=void 0,delete n._vt,n._locale=void 0,delete n._locale,n._localeMessage=void 0,delete n._localeMessage}else it("Vue instance does not exists in VNode context")}function At(n,e){var t=e.context;return t?!!t.$i18n||(it("VueI18n instance does not exists in Vue instance"),!1):(it("Vue instance does not exists in VNode context"),!1)}function jt(n,e,t){var i,r,s=function(n){var e,t,i,r;"string"==typeof n?e=n:ot(n)&&(e=n.path,t=n.locale,i=n.args,r=n.choice);return{path:e,locale:t,args:i,choice:r}}(e.value),o=s.path,a=s.locale,l=s.args,u=s.choice;if(o||a||l)if(o){var c=t.context;n._vt=n.textContent=u?(i=c.$i18n).tc.apply(i,[o,u].concat(_t(a,l))):(r=c.$i18n).t.apply(r,[o].concat(_t(a,l))),n._locale=c.$i18n.locale,n._localeMessage=c.$i18n.getLocaleMessage(c.$i18n.locale)}else it("`path` is required in v-t directive");else it("value type not supported")}function _t(n,e){var t=[];return n&&t.push(n),e&&(Array.isArray(e)||ot(e))&&t.push(e),t}function Nt(n){Nt.installed=!0;var e;(xt=n).version&&Number(xt.version.split(".")[0]);(e=xt).prototype.hasOwnProperty("$i18n")||Object.defineProperty(e.prototype,"$i18n",{get:function(){return this._i18n}}),e.prototype.$t=function(n){for(var e=[],t=arguments.length-1;t-- >0;)e[t]=arguments[t+1];var i=this.$i18n;return i._t.apply(i,[n,i.locale,i._getMessages(),this].concat(e))},e.prototype.$tc=function(n,e){for(var t=[],i=arguments.length-2;i-- >0;)t[i]=arguments[i+2];var r=this.$i18n;return r._tc.apply(r,[n,r.locale,r._getMessages(),this,e].concat(t))},e.prototype.$te=function(n,e){var t=this.$i18n;return t._te(n,t.locale,t._getMessages(),e)},e.prototype.$d=function(n){for(var e,t=[],i=arguments.length-1;i-- >0;)t[i]=arguments[i+1];return(e=this.$i18n).d.apply(e,[n].concat(t))},e.prototype.$n=function(n){for(var e,t=[],i=arguments.length-1;i-- >0;)t[i]=arguments[i+1];return(e=this.$i18n).n.apply(e,[n].concat(t))},xt.mixin(ht),xt.directive("t",{bind:Et,update:yt,unbind:kt}),xt.component(ft.name,ft),xt.component(wt.name,wt),xt.config.optionMergeStrategies.i18n=function(n,e){return void 0===e?n:e}}var Ot=function(){this._caches=Object.create(null)};Ot.prototype.interpolate=function(n,e){if(!e)return[n];var t=this._caches[n];return t||(t=function(n){var e=[],t=0,i="";for(;t<n.length;){var r=n[t++];if("{"===r){i&&e.push({type:"text",value:i}),i="";var s="";for(r=n[t++];void 0!==r&&"}"!==r;)s+=r,r=n[t++];var o="}"===r,a=Bt.test(s)?"list":o&&St.test(s)?"named":"unknown";e.push({value:s,type:a})}else"%"===r?"{"!==n[t]&&(i+=r):i+=r}return i&&e.push({type:"text",value:i}),e}(n),this._caches[n]=t),function(n,e){var t=[],i=0,r=Array.isArray(e)?"list":rt(e)?"named":"unknown";if("unknown"===r)return t;for(;i<n.length;){var s=n[i];switch(s.type){case"text":t.push(s.value);break;case"list":t.push(e[parseInt(s.value,10)]);break;case"named":"named"===r&&t.push(e[s.value]);break;case"unknown":0}i++}return t}(t,e)};var Bt=/^(?:\d)+/,St=/^(?:\w)+/;var It=[];It[0]={ws:[0],ident:[3,0],"[":[4],eof:[7]},It[1]={ws:[1],".":[2],"[":[4],eof:[7]},It[2]={ws:[2],ident:[3,0],0:[3,0],number:[3,0]},It[3]={ident:[3,0],0:[3,0],number:[3,0],ws:[1,1],".":[2,1],"[":[4,1],eof:[7,1]},It[4]={"'":[5,0],'"':[6,0],"[":[4,2],"]":[1,3],eof:8,else:[4,0]},It[5]={"'":[4,0],eof:8,else:[5,0]},It[6]={'"':[4,0],eof:8,else:[6,0]};var Lt=/^\s?(?:true|false|-?[\d.]+|'[^']*'|"[^"]*")\s?$/;function Ct(n){if(null==n)return"eof";switch(n.charCodeAt(0)){case 91:case 93:case 46:case 34:case 39:return n;case 95:case 36:case 45:return"ident";case 9:case 10:case 13:case 160:case 65279:case 8232:case 8233:return"ws"}return"ident"}function Tt(n){var e,t,i,r=n.trim();return("0"!==n.charAt(0)||!isNaN(n))&&(i=r,Lt.test(i)?(t=(e=r).charCodeAt(0))!==e.charCodeAt(e.length-1)||34!==t&&39!==t?e:e.slice(1,-1):"*"+r)}var Dt=function(){this._cache=Object.create(null)};Dt.prototype.parsePath=function(n){var e=this._cache[n];return e||(e=function(n){var e,t,i,r,s,o,a,l=[],u=-1,c=0,d=0,m=[];function p(){var e=n[u+1];if(5===c&&"'"===e||6===c&&'"'===e)return u++,i="\\"+e,m[0](),!0}for(m[1]=function(){void 0!==t&&(l.push(t),t=void 0)},m[0]=function(){void 0===t?t=i:t+=i},m[2]=function(){m[0](),d++},m[3]=function(){if(d>0)d--,c=4,m[0]();else{if(d=0,void 0===t)return!1;if(!1===(t=Tt(t)))return!1;m[1]()}};null!==c;)if(u++,"\\"!==(e=n[u])||!p()){if(r=Ct(e),8===(s=(a=It[c])[r]||a.else||8))return;if(c=s[0],(o=m[s[1]])&&(i=void 0===(i=s[2])?e:i,!1===o()))return;if(7===c)return l}}(n))&&(this._cache[n]=e),e||[]},Dt.prototype.getPathValue=function(n,e){if(!rt(n))return null;var t=this.parsePath(e);if(0===t.length)return null;for(var i=t.length,r=n,s=0;s<i;){var o=r[t[s]];if(void 0===o)return null;r=o,s++}return r};var qt,Pt=/<\/?[\w\s="/.':;#-\/]+>/,Mt=/(?:@(?:\.[a-z]+)?:(?:[\w\-_|.]+|\([\w\-_|.]+\)))/g,Ft=/^@(?:\.([a-z]+))?:/,zt=/[()]/g,Rt={upper:function(n){return n.toLocaleUpperCase()},lower:function(n){return n.toLocaleLowerCase()}},$t=new Ot,Ut=function(n){var e=this;void 0===n&&(n={}),!xt&&"undefined"!=typeof window&&window.Vue&&Nt(window.Vue);var t=n.locale||"en-US",i=n.fallbackLocale||"en-US",r=n.messages||{},s=n.dateTimeFormats||{},o=n.numberFormats||{};this._vm=null,this._formatter=n.formatter||$t,this._modifiers=n.modifiers||{},this._missing=n.missing||null,this._root=n.root||null,this._sync=void 0===n.sync||!!n.sync,this._fallbackRoot=void 0===n.fallbackRoot||!!n.fallbackRoot,this._formatFallbackMessages=void 0!==n.formatFallbackMessages&&!!n.formatFallbackMessages,this._silentTranslationWarn=void 0!==n.silentTranslationWarn&&n.silentTranslationWarn,this._silentFallbackWarn=void 0!==n.silentFallbackWarn&&!!n.silentFallbackWarn,this._dateTimeFormatters={},this._numberFormatters={},this._path=new Dt,this._dataListeners=[],this._preserveDirectiveContent=void 0!==n.preserveDirectiveContent&&!!n.preserveDirectiveContent,this.pluralizationRules=n.pluralizationRules||{},this._warnHtmlInMessage=n.warnHtmlInMessage||"off",this._exist=function(n,t){return!(!n||!t)&&(!at(e._path.getPathValue(n,t))||!!n[t])},"warn"!==this._warnHtmlInMessage&&"error"!==this._warnHtmlInMessage||Object.keys(r).forEach((function(n){e._checkLocaleMessage(n,e._warnHtmlInMessage,r[n])})),this._initVM({locale:t,fallbackLocale:i,messages:r,dateTimeFormats:s,numberFormats:o})},Ht={vm:{configurable:!0},messages:{configurable:!0},dateTimeFormats:{configurable:!0},numberFormats:{configurable:!0},availableLocales:{configurable:!0},locale:{configurable:!0},fallbackLocale:{configurable:!0},formatFallbackMessages:{configurable:!0},missing:{configurable:!0},formatter:{configurable:!0},silentTranslationWarn:{configurable:!0},silentFallbackWarn:{configurable:!0},preserveDirectiveContent:{configurable:!0},warnHtmlInMessage:{configurable:!0}};Ut.prototype._checkLocaleMessage=function(n,e,t){var i=function(n,e,t,r){if(ot(t))Object.keys(t).forEach((function(s){var o=t[s];ot(o)?(r.push(s),r.push("."),i(n,e,o,r),r.pop(),r.pop()):(r.push(s),i(n,e,o,r),r.pop())}));else if(Array.isArray(t))t.forEach((function(t,s){ot(t)?(r.push("["+s+"]"),r.push("."),i(n,e,t,r),r.pop(),r.pop()):(r.push("["+s+"]"),i(n,e,t,r),r.pop())}));else if("string"==typeof t){if(Pt.test(t)){var s="Detected HTML in message '"+t+"' of keypath '"+r.join("")+"' at '"+e+"'. Consider component interpolation with '<i18n>' to avoid XSS. See https://bit.ly/2ZqJzkp";"warn"===n?it(s):"error"===n&&function(n,e){"undefined"!=typeof console&&(console.error("[vue-i18n] "+n),e&&console.error(e.stack))}(s)}}};i(e,n,t,[])},Ut.prototype._initVM=function(n){var e=xt.config.silent;xt.config.silent=!0,this._vm=new xt({data:n}),xt.config.silent=e},Ut.prototype.destroyVM=function(){this._vm.$destroy()},Ut.prototype.subscribeDataChanging=function(n){this._dataListeners.push(n)},Ut.prototype.unsubscribeDataChanging=function(n){!function(n,e){if(n.length){var t=n.indexOf(e);if(t>-1)n.splice(t,1)}}(this._dataListeners,n)},Ut.prototype.watchI18nData=function(){var n=this;return this._vm.$watch("$data",(function(){for(var e=n._dataListeners.length;e--;)xt.nextTick((function(){n._dataListeners[e]&&n._dataListeners[e].$forceUpdate()}))}),{deep:!0})},Ut.prototype.watchLocale=function(){if(!this._sync||!this._root)return null;var n=this._vm;return this._root.$i18n.vm.$watch("locale",(function(e){n.$set(n,"locale",e),n.$forceUpdate()}),{immediate:!0})},Ht.vm.get=function(){return this._vm},Ht.messages.get=function(){return ut(this._getMessages())},Ht.dateTimeFormats.get=function(){return ut(this._getDateTimeFormats())},Ht.numberFormats.get=function(){return ut(this._getNumberFormats())},Ht.availableLocales.get=function(){return Object.keys(this.messages).sort()},Ht.locale.get=function(){return this._vm.locale},Ht.locale.set=function(n){this._vm.$set(this._vm,"locale",n)},Ht.fallbackLocale.get=function(){return this._vm.fallbackLocale},Ht.fallbackLocale.set=function(n){this._vm.$set(this._vm,"fallbackLocale",n)},Ht.formatFallbackMessages.get=function(){return this._formatFallbackMessages},Ht.formatFallbackMessages.set=function(n){this._formatFallbackMessages=n},Ht.missing.get=function(){return this._missing},Ht.missing.set=function(n){this._missing=n},Ht.formatter.get=function(){return this._formatter},Ht.formatter.set=function(n){this._formatter=n},Ht.silentTranslationWarn.get=function(){return this._silentTranslationWarn},Ht.silentTranslationWarn.set=function(n){this._silentTranslationWarn=n},Ht.silentFallbackWarn.get=function(){return this._silentFallbackWarn},Ht.silentFallbackWarn.set=function(n){this._silentFallbackWarn=n},Ht.preserveDirectiveContent.get=function(){return this._preserveDirectiveContent},Ht.preserveDirectiveContent.set=function(n){this._preserveDirectiveContent=n},Ht.warnHtmlInMessage.get=function(){return this._warnHtmlInMessage},Ht.warnHtmlInMessage.set=function(n){var e=this,t=this._warnHtmlInMessage;if(this._warnHtmlInMessage=n,t!==n&&("warn"===n||"error"===n)){var i=this._getMessages();Object.keys(i).forEach((function(n){e._checkLocaleMessage(n,e._warnHtmlInMessage,i[n])}))}},Ut.prototype._getMessages=function(){return this._vm.messages},Ut.prototype._getDateTimeFormats=function(){return this._vm.dateTimeFormats},Ut.prototype._getNumberFormats=function(){return this._vm.numberFormats},Ut.prototype._warnDefault=function(n,e,t,i,r){if(!at(t))return t;if(this._missing){var s=this._missing.apply(null,[n,e,i,r]);if("string"==typeof s)return s}else 0;if(this._formatFallbackMessages){var o=lt.apply(void 0,r);return this._render(e,"string",o.params,e)}return e},Ut.prototype._isFallbackRoot=function(n){return!n&&!at(this._root)&&this._fallbackRoot},Ut.prototype._isSilentFallbackWarn=function(n){return this._silentFallbackWarn instanceof RegExp?this._silentFallbackWarn.test(n):this._silentFallbackWarn},Ut.prototype._isSilentFallback=function(n,e){return this._isSilentFallbackWarn(e)&&(this._isFallbackRoot()||n!==this.fallbackLocale)},Ut.prototype._isSilentTranslationWarn=function(n){return this._silentTranslationWarn instanceof RegExp?this._silentTranslationWarn.test(n):this._silentTranslationWarn},Ut.prototype._interpolate=function(n,e,t,i,r,s,o){if(!e)return null;var a,l=this._path.getPathValue(e,t);if(Array.isArray(l)||ot(l))return l;if(at(l)){if(!ot(e))return null;if("string"!=typeof(a=e[t]))return null}else{if("string"!=typeof l)return null;a=l}return(a.indexOf("@:")>=0||a.indexOf("@.")>=0)&&(a=this._link(n,e,a,i,"raw",s,o)),this._render(a,r,s,t)},Ut.prototype._link=function(n,e,t,i,r,s,o){var a=t,l=a.match(Mt);for(var u in l)if(l.hasOwnProperty(u)){var c=l[u],d=c.match(Ft),m=d[0],p=d[1],h=c.replace(m,"").replace(zt,"");if(o.includes(h))return a;o.push(h);var f=this._interpolate(n,e,h,i,"raw"===r?"string":r,"raw"===r?void 0:s,o);if(this._isFallbackRoot(f)){if(!this._root)throw Error("unexpected error");var g=this._root.$i18n;f=g._translate(g._getMessages(),g.locale,g.fallbackLocale,h,i,r,s)}f=this._warnDefault(n,h,f,i,Array.isArray(s)?s:[s]),this._modifiers.hasOwnProperty(p)?f=this._modifiers[p](f):Rt.hasOwnProperty(p)&&(f=Rt[p](f)),o.pop(),a=f?a.replace(c,f):a}return a},Ut.prototype._render=function(n,e,t,i){var r=this._formatter.interpolate(n,t,i);return r||(r=$t.interpolate(n,t,i)),"string"===e?r.join(""):r},Ut.prototype._translate=function(n,e,t,i,r,s,o){var a=this._interpolate(e,n[e],i,r,s,o,[i]);return at(a)&&at(a=this._interpolate(t,n[t],i,r,s,o,[i]))?null:a},Ut.prototype._t=function(n,e,t,i){for(var r,s=[],o=arguments.length-4;o-- >0;)s[o]=arguments[o+4];if(!n)return"";var a=lt.apply(void 0,s),l=a.locale||e,u=this._translate(t,l,this.fallbackLocale,n,i,"string",a.params);if(this._isFallbackRoot(u)){if(!this._root)throw Error("unexpected error");return(r=this._root).$t.apply(r,[n].concat(s))}return this._warnDefault(l,n,u,i,s)},Ut.prototype.t=function(n){for(var e,t=[],i=arguments.length-1;i-- >0;)t[i]=arguments[i+1];return(e=this)._t.apply(e,[n,this.locale,this._getMessages(),null].concat(t))},Ut.prototype._i=function(n,e,t,i,r){var s=this._translate(t,e,this.fallbackLocale,n,i,"raw",r);if(this._isFallbackRoot(s)){if(!this._root)throw Error("unexpected error");return this._root.$i18n.i(n,e,r)}return this._warnDefault(e,n,s,i,[r])},Ut.prototype.i=function(n,e,t){return n?("string"!=typeof e&&(e=this.locale),this._i(n,e,this._getMessages(),null,t)):""},Ut.prototype._tc=function(n,e,t,i,r){for(var s,o=[],a=arguments.length-5;a-- >0;)o[a]=arguments[a+5];if(!n)return"";void 0===r&&(r=1);var l={count:r,n:r},u=lt.apply(void 0,o);return u.params=Object.assign(l,u.params),o=null===u.locale?[u.params]:[u.locale,u.params],this.fetchChoice((s=this)._t.apply(s,[n,e,t,i].concat(o)),r)},Ut.prototype.fetchChoice=function(n,e){if(!n&&"string"!=typeof n)return null;var t=n.split("|");return t[e=this.getChoiceIndex(e,t.length)]?t[e].trim():n},Ut.prototype.getChoiceIndex=function(n,e){var t,i;return this.locale in this.pluralizationRules?this.pluralizationRules[this.locale].apply(this,[n,e]):(t=n,i=e,t=Math.abs(t),2===i?t?t>1?1:0:1:t?Math.min(t,2):0)},Ut.prototype.tc=function(n,e){for(var t,i=[],r=arguments.length-2;r-- >0;)i[r]=arguments[r+2];return(t=this)._tc.apply(t,[n,this.locale,this._getMessages(),null,e].concat(i))},Ut.prototype._te=function(n,e,t){for(var i=[],r=arguments.length-3;r-- >0;)i[r]=arguments[r+3];var s=lt.apply(void 0,i).locale||e;return this._exist(t[s],n)},Ut.prototype.te=function(n,e){return this._te(n,this.locale,this._getMessages(),e)},Ut.prototype.getLocaleMessage=function(n){return ut(this._vm.messages[n]||{})},Ut.prototype.setLocaleMessage=function(n,e){("warn"!==this._warnHtmlInMessage&&"error"!==this._warnHtmlInMessage||(this._checkLocaleMessage(n,this._warnHtmlInMessage,e),"error"!==this._warnHtmlInMessage))&&this._vm.$set(this._vm.messages,n,e)},Ut.prototype.mergeLocaleMessage=function(n,e){("warn"!==this._warnHtmlInMessage&&"error"!==this._warnHtmlInMessage||(this._checkLocaleMessage(n,this._warnHtmlInMessage,e),"error"!==this._warnHtmlInMessage))&&this._vm.$set(this._vm.messages,n,mt({},this._vm.messages[n]||{},e))},Ut.prototype.getDateTimeFormat=function(n){return ut(this._vm.dateTimeFormats[n]||{})},Ut.prototype.setDateTimeFormat=function(n,e){this._vm.$set(this._vm.dateTimeFormats,n,e)},Ut.prototype.mergeDateTimeFormat=function(n,e){this._vm.$set(this._vm.dateTimeFormats,n,mt(this._vm.dateTimeFormats[n]||{},e))},Ut.prototype._localizeDateTime=function(n,e,t,i,r){var s=e,o=i[s];if((at(o)||at(o[r]))&&(o=i[s=t]),at(o)||at(o[r]))return null;var a=o[r],l=s+"__"+r,u=this._dateTimeFormatters[l];return u||(u=this._dateTimeFormatters[l]=new Intl.DateTimeFormat(s,a)),u.format(n)},Ut.prototype._d=function(n,e,t){if(!t)return new Intl.DateTimeFormat(e).format(n);var i=this._localizeDateTime(n,e,this.fallbackLocale,this._getDateTimeFormats(),t);if(this._isFallbackRoot(i)){if(!this._root)throw Error("unexpected error");return this._root.$i18n.d(n,t,e)}return i||""},Ut.prototype.d=function(n){for(var e=[],t=arguments.length-1;t-- >0;)e[t]=arguments[t+1];var i=this.locale,r=null;return 1===e.length?"string"==typeof e[0]?r=e[0]:rt(e[0])&&(e[0].locale&&(i=e[0].locale),e[0].key&&(r=e[0].key)):2===e.length&&("string"==typeof e[0]&&(r=e[0]),"string"==typeof e[1]&&(i=e[1])),this._d(n,i,r)},Ut.prototype.getNumberFormat=function(n){return ut(this._vm.numberFormats[n]||{})},Ut.prototype.setNumberFormat=function(n,e){this._vm.$set(this._vm.numberFormats,n,e)},Ut.prototype.mergeNumberFormat=function(n,e){this._vm.$set(this._vm.numberFormats,n,mt(this._vm.numberFormats[n]||{},e))},Ut.prototype._getNumberFormatter=function(n,e,t,i,r,s){var o=e,a=i[o];if((at(a)||at(a[r]))&&(a=i[o=t]),at(a)||at(a[r]))return null;var l,u=a[r];if(s)l=new Intl.NumberFormat(o,Object.assign({},u,s));else{var c=o+"__"+r;(l=this._numberFormatters[c])||(l=this._numberFormatters[c]=new Intl.NumberFormat(o,u))}return l},Ut.prototype._n=function(n,e,t,i){if(!Ut.availabilities.numberFormat)return"";if(!t)return(i?new Intl.NumberFormat(e,i):new Intl.NumberFormat(e)).format(n);var r=this._getNumberFormatter(n,e,this.fallbackLocale,this._getNumberFormats(),t,i),s=r&&r.format(n);if(this._isFallbackRoot(s)){if(!this._root)throw Error("unexpected error");return this._root.$i18n.n(n,Object.assign({},{key:t,locale:e},i))}return s||""},Ut.prototype.n=function(n){for(var e=[],t=arguments.length-1;t-- >0;)e[t]=arguments[t+1];var i=this.locale,r=null,s=null;return 1===e.length?"string"==typeof e[0]?r=e[0]:rt(e[0])&&(e[0].locale&&(i=e[0].locale),e[0].key&&(r=e[0].key),s=Object.keys(e[0]).reduce((function(n,t){var i;return tt.includes(t)?Object.assign({},n,((i={})[t]=e[0][t],i)):n}),null)):2===e.length&&("string"==typeof e[0]&&(r=e[0]),"string"==typeof e[1]&&(i=e[1])),this._n(n,i,r,s)},Ut.prototype._ntp=function(n,e,t,i){if(!Ut.availabilities.numberFormat)return[];if(!t)return(i?new Intl.NumberFormat(e,i):new Intl.NumberFormat(e)).formatToParts(n);var r=this._getNumberFormatter(n,e,this.fallbackLocale,this._getNumberFormats(),t,i),s=r&&r.formatToParts(n);if(this._isFallbackRoot(s)){if(!this._root)throw Error("unexpected error");return this._root.$i18n._ntp(n,e,t,i)}return s||[]},Object.defineProperties(Ut.prototype,Ht),Object.defineProperty(Ut,"availabilities",{get:function(){if(!qt){var n="undefined"!=typeof Intl;qt={dateTimeFormat:n&&void 0!==Intl.DateTimeFormat,numberFormat:n&&void 0!==Intl.NumberFormat}}return qt}}),Ut.install=Nt,Ut.version="8.15.3";var Vt=Ut;
/*!
 * vssue - A vue-powered issue-based comment plugin
 *
 * @version v1.4.2
 * @link https://vssue.js.org
 * @license MIT
 * @copyright 2018-2020 meteorlxy
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */function Wt(n,e,t,i){var r,s=arguments.length,o=s<3?e:null===i?i=Object.getOwnPropertyDescriptor(e,t):i;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)o=Reflect.decorate(n,e,t,i);else for(var a=n.length-1;a>=0;a--)(r=n[a])&&(o=(s<3?r(o):s>3?r(e,t,o):r(e,t))||o);return s>3&&o&&Object.defineProperty(e,t,o),o}var Kt=i.a.extend({name:"Iconfont"});function Qt(n,e,t,i,r,s,o,a,l,u){"boolean"!=typeof o&&(l=a,a=o,o=!1);const c="function"==typeof t?t.options:t;let d;if(n&&n.render&&(c.render=n.render,c.staticRenderFns=n.staticRenderFns,c._compiled=!0,r&&(c.functional=!0)),i&&(c._scopeId=i),s?(d=function(n){(n=n||this.$vnode&&this.$vnode.ssrContext||this.parent&&this.parent.$vnode&&this.parent.$vnode.ssrContext)||"undefined"==typeof __VUE_SSR_CONTEXT__||(n=__VUE_SSR_CONTEXT__),e&&e.call(this,l(n)),n&&n._registeredComponents&&n._registeredComponents.add(s)},c._ssrRegister=d):e&&(d=o?function(n){e.call(this,u(n,this.$root.$options.shadowRoot))}:function(n){e.call(this,a(n))}),d)if(c.functional){const n=c.render;c.render=function(e,t){return d.call(t),n(e,t)}}else{const n=c.beforeCreate;c.beforeCreate=n?[].concat(n,d):[d]}return t}"undefined"!=typeof navigator&&/msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());const Gt=Qt({render:function(n,e){var t=e._c;return t("svg",{directives:[{name:"show",rawName:"v-show",value:!1,expression:"false"}]},[t("symbol",{attrs:{id:"vssue-icon-bitbucket",viewBox:"0 0 1024 1024"}},[t("path",{attrs:{d:"M579.5522464 489.45249493q4.8371808 38.38537173-30.81752427 61.55702827t-67.95459093 3.66689493q-23.79580907-10.37653333-32.6119616-35.34262826t-0.31207573-50.01020907 31.67573333-35.34262827q21.92335253-11.00068587 44.1587808-7.33379093t39.00952427 21.61127573 16.77409493 41.1160384zM647.19476053 476.65737173q-8.50407573-65.22392427-68.8908192-99.9424t-120.07131413-7.9579424q-38.38537173 17.08617173-61.24495253 53.9111616t-21.0651424 78.95527574q2.41859093 55.4715424 47.20152426 94.48106666t100.87862827 34.1723424q55.4715424-4.8371808 92.60860907-51.18049493t30.50544746-102.43900907zM792.93434133 146.32472427q-12.17097173-16.4620192-34.1723424-27.15062827t-35.34262826-13.41927573-43.30057174-7.64586667q-177.33729493-28.63299093-345.00022826 1.24830507-26.2144 4.29104747-40.25782827 7.33379093t-33.54819093 13.41927573-30.50544747 26.2144q18.2564576 17.08617173 46.34331413 27.6967616t44.78293334 13.41927574 53.36502826 7.02171413q138.95192427 17.71032427 273.06666667 0.62415253 38.38537173-4.8371808 54.53531413-7.33379093t44.1587808-13.1072 45.7191616-28.32091413zM827.65281813 777.10872427q-4.8371808 15.83786667-9.44030506 46.65539093t-8.50407574 51.18049493-17.39824746 42.6764192-35.34262827 34.4064q-52.4288 29.2571424-115.46819093 43.61264747t-123.1140576 13.41927573-122.8019808-11.3127616q-28.0088384-4.8371808-49.69813334-11.00068586t-46.65539093-16.4620192-44.4708576-26.52647574-31.67573333-37.4491424q-15.21371413-58.51428587-34.71847574-177.96144746l3.66689494-9.7523808 11.00068586-5.46133334q135.9091808 90.1900192 308.72137174 90.1900192t309.34552426-90.1900192q12.79512427 3.66689493 14.5895616 14.04342827t-3.0427424 27.46270507-4.8371808 22.54750506zM937.97175147 191.41973333q-15.83786667 101.8148576-67.64251414 399.22346667-3.0427424 18.2564576-16.4620192 34.1723424t-26.52647573 24.3419424-33.23611413 18.88060907q-153.61950507 76.7707424-371.8387808 53.67710506-151.12289493-16.4620192-240.14262827-84.72868586-9.12822827-7.33379093-15.52579093-16.1499424t-10.37653334-21.2992-5.46133333-20.75306667-3.66689493-24.10788587-3.3548192-21.2992q-5.46133333-30.50544747-16.1499424-91.43832426t-17.08617174-98.4600384-14.35550506-89.8779424-13.41927574-96.27550507q1.7944384-15.83786667 10.68860907-29.5692192t19.19268587-22.8595808 27.46270506-18.2564576 28.0088384-13.73135253 29.2571424-11.3127616q76.22460907-28.0088384 190.75657174-39.00952427 231.0144-22.54750507 412.01859093 30.50544747 94.48106667 28.0088384 131.072 74.35215253 9.7523808 12.17097173 10.0644576 31.0515808t-3.3548192 32.9240384z"}})]),e._v(" "),t("symbol",{attrs:{id:"vssue-icon-gitea",viewBox:"0 0 1024 1024"}},[t("path",{attrs:{d:"M184.31868985 236.10860742C106.94832667 235.94086648 3.32655508 285.13080468 9.02973665 408.46209936c8.93218827 192.65010787 206.32096845 210.5144844 285.20099725 212.06608453 8.63864186 36.14810496 101.48307766 160.77938883 170.21479898 167.32127321h301.09442177c180.57278288-11.99345499 315.77172611-546.07960359 215.54670217-548.09249109-165.7696721 7.79993906-264.02374305 11.74184405-348.27147151 12.41280591v166.69224585l-26.25140843-11.61603761-0.16773997-154.99233728c-96.70246985-0.04193548-181.83083757-4.52899687-343.4069947-12.49667687-20.21274496-0.12580547-48.39316992-3.5644886-78.67035236-3.64835859z m10.94507577 68.14462849h9.22573371c10.98701124 98.75729283 28.85138778 156.50200291 64.99949274 244.73357185-92.25734394-10.90314029-170.75995634-37.69970509-185.18564974-137.75698809-7.46445813-51.78991757 17.69663558-105.84433456 110.96042329-107.01851827z m358.83913087 97.07988723c6.29027343 0.08386999 12.70635233 1.25805468 18.74501482 4.02577499l31.40943263 13.54505513-22.51917887 41.05451824a28.18042496 25.03528825 0 0 0-10.10637297 1.59353561 28.18042496 25.03528825 0 0 0-16.98373825 32.038459 28.18042496 25.03528825 0 0 0 4.69673781 7.29671718l-38.83195528 70.70267333a28.18042496 25.03528825 0 0 0-9.30960467 1.59353659 28.18042496 25.03528825 0 0 0-16.98373825 32.038459 28.18042496 25.03528825 0 0 0 36.06423497 15.09665623 28.18042496 25.03528825 0 0 0 16.94180276-32.08039449 28.18042496 25.03528825 0 0 0-6.62575434-9.22573468l37.82551056-68.85752581a28.18042496 25.03528825 0 0 0 12.28700044-1.25805469 28.18042496 25.03528825 0 0 0 8.93218826-4.69673783c14.59343435 6.12253248 26.54495386 11.11281671 35.14166122 15.34826717 12.91602778 6.37414341 17.48696012 10.60959485 18.87082027 15.30633169 1.38386015 4.61286685-0.12580547 13.50312062-7.42252263 29.10299872-5.45157063 11.61603859-14.46762889 28.09655497-25.11915823 47.51253164a28.18042496 25.03528825 0 0 0-10.52572486 1.59353659 28.18042496 25.03528825 0 0 0-16.98373826 32.038459 28.18042496 25.03528825 0 0 0 36.06423498 15.09665623 28.18042496 25.03528825 0 0 0 16.94180278-32.03845901 28.18042496 25.03528825 0 0 0-5.74511608-8.47090188c10.52572388-19.20630122 19.58371762-35.72875308 25.41270465-48.14155897 7.88380904-16.85793279 11.99345499-29.39654416 8.38703091-41.51580463-3.60642311-12.11926046-14.67730434-20.0030695-29.35460966-27.25785217-9.6450856-4.73867233-21.68047607-9.77089106-36.06423399-15.80955357a28.18042496 25.03528825 0 0 0-1.59353562-10.022502 28.18042496 25.03528825 0 0 0-6.08059796-8.7644483l22.14176246-40.38355541 122.61839638 52.96410227c22.14176247 9.6031511 31.2836262 33.12877372 20.54822685 52.8382968l-84.28966393 154.32137544c-10.77733482 19.66758857-37.23841869 27.80300855-59.38018118 18.24179293l-173.48574115-74.98005927c-22.14176247-9.5612156-31.32556167-33.12877372-20.54822687-52.83829679l84.28966395-154.27943995c7.38058716-13.54505513 22.22563246-21.59660511 37.951317-22.22563246h2.68384935z"}})]),e._v(" "),t("symbol",{attrs:{id:"vssue-icon-gitee",viewBox:"0 0 1024 1024"}},[t("path",{attrs:{d:"M978.404275 409.561604H455.061338c-25.117645 0-45.499734 20.382089-45.499734 45.499734l-0.031997 113.781333c0 25.117645 20.350092 45.499734 45.499734 45.531731h318.594132c25.117645 0 45.499734 20.382089 45.499734 45.499735v22.749867a136.5312 136.5312 0 0 1-136.5312 136.5312H250.248539a45.499734 45.499734 0 0 1-45.499734-45.499734V341.343999a136.5312 136.5312 0 0 1 136.5312-136.5312L978.308284 204.780802c25.117645 0 45.499734-20.350092 45.499734-45.467738L1023.904009 45.531731h0.031997A45.499734 45.499734 0 0 0 978.468269 0h-0.031997L341.343999 0.031997C152.84967 0.031997 0.031997 152.84967 0.031997 341.343999v637.092273c0 25.117645 20.382089 45.499734 45.499734 45.499734h671.233072a307.171203 307.171203 0 0 0 307.171203-307.171203v-261.671468c0-25.117645-20.382089-45.499734-45.499734-45.499734z"}})]),e._v(" "),t("symbol",{attrs:{id:"vssue-icon-github",viewBox:"0 0 1024 1024"}},[t("path",{attrs:{d:"M512 20.4425c-278.334 0-504 225.6345-504 504 0 222.6735 144.4275 411.6105 344.673 478.233 25.2 4.662 34.461-10.9305 34.461-24.255 0-12.0015-0.4725-51.723-0.693-93.8385-140.238 30.492-169.8165-59.472-169.8165-59.472-22.932-58.2435-55.944-73.7415-55.944-73.7415-45.738-31.2795 3.465-30.6495 3.465-30.6495 50.589 3.5595 77.238 51.9435 77.238 51.9435 44.9505 77.049 117.9045 54.7785 146.664 41.895 4.5045-32.571 17.577-54.81 32.004-67.41-111.951-12.726-229.635-55.9755-229.635-249.0705 0-55.0305 19.6875-99.981 51.9435-135.2925-5.229-12.6945-22.491-63.945 4.8825-133.371 0 0 42.336-13.545 138.6315 51.66 40.194-11.1825 83.3175-16.758 126.1575-16.9785 42.8085 0.189 85.9635 5.796 126.252 16.9785 96.201-65.205 138.4425-51.66 138.4425-51.66 27.4365 69.426 10.1745 120.6765 4.9455 133.371 32.319 35.28 51.8805 80.262 51.8805 135.2925 0 193.5675-117.9045 236.187-230.139 248.6925 18.081 15.6555 34.1775 46.305 34.1775 93.3345 0 67.4415-0.5985 121.716-0.5985 138.3165 0 13.419 9.072 29.1375 34.6185 24.192 200.151-66.717 344.3895-255.5595 344.3895-478.17 0-278.3655-225.666-504-504-504z"}})]),e._v(" "),t("symbol",{attrs:{id:"vssue-icon-gitlab",viewBox:"0 0 1024 1024"}},[t("path",{attrs:{d:"M66.61375986 405.11600042L512.11376028 976.03999972 23.84576 621.65599958a39.312 39.312 0 0 1-14.07600042-43.30799944l56.8080007-173.26800028z m259.88400014 0h371.26800014L512.14975986 976.03999972zM215.11376 60.88400042l111.384 344.232H66.61375986l111.384-344.232a19.72800014 19.72800014 0 0 1 37.11600014 0z m742.49999972 344.232l56.8080007 173.2679993a39.23999986 39.23999986 0 0 1-14.07600042 43.30800042l-488.26800028 354.38400014 445.50000042-570.92400028z m0 0h-259.88400014l111.384-344.232a19.72800014 19.72800014 0 0 1 37.11600014 0z"}})]),e._v(" "),t("symbol",{attrs:{id:"vssue-icon-loading",viewBox:"0 0 1024 1024"}},[t("path",{attrs:{d:"M843.307 742.24c0 3.217 2.607 5.824 5.824 5.824s5.824-2.607 5.824-5.824a5.823 5.823 0 0 0-5.824-5.824 5.823 5.823 0 0 0-5.824 5.824zM714.731 874.912c0 6.398 5.186 11.584 11.584 11.584s11.584-5.186 11.584-11.584-5.186-11.584-11.584-11.584-11.584 5.186-11.584 11.584zM541.419 943.2c0 9.614 7.794 17.408 17.408 17.408s17.408-7.794 17.408-17.408-7.794-17.408-17.408-17.408-17.408 7.794-17.408 17.408z m-186.56-9.152c0 12.795 10.373 23.168 23.168 23.168s23.168-10.373 23.168-23.168-10.373-23.168-23.168-23.168-23.168 10.373-23.168 23.168zM189.355 849.12c0 16.012 12.98 28.992 28.992 28.992s28.992-12.98 28.992-28.992-12.98-28.992-28.992-28.992-28.992 12.98-28.992 28.992zM74.731 704.736c0 19.228 15.588 34.816 34.816 34.816s34.816-15.588 34.816-34.816-15.588-34.816-34.816-34.816-34.816 15.588-34.816 34.816z m-43.008-177.28c0 22.41 18.166 40.576 40.576 40.576s40.576-18.166 40.576-40.576-18.166-40.576-40.576-40.576-40.576 18.166-40.576 40.576z m35.392-176.128c0 25.626 20.774 46.4 46.4 46.4s46.4-20.774 46.4-46.4c0-25.626-20.774-46.4-46.4-46.4-25.626 0-46.4 20.774-46.4 46.4z m106.176-142.016c0 28.843 23.381 52.224 52.224 52.224s52.224-23.381 52.224-52.224c0-28.843-23.381-52.224-52.224-52.224-28.843 0-52.224 23.381-52.224 52.224z m155.904-81.344c0 32.024 25.96 57.984 57.984 57.984s57.984-25.96 57.984-57.984-25.96-57.984-57.984-57.984-57.984 25.96-57.984 57.984z m175.104-5.056c0 35.24 28.568 63.808 63.808 63.808s63.808-28.568 63.808-63.808c0-35.24-28.568-63.808-63.808-63.808-35.24 0-63.808 28.568-63.808 63.808z m160.32 72.128c0 38.421 31.147 69.568 69.568 69.568s69.568-31.147 69.568-69.568-31.147-69.568-69.568-69.568-69.568 31.147-69.568 69.568z m113.92 135.488c0 41.638 33.754 75.392 75.392 75.392s75.392-33.754 75.392-75.392-33.754-75.392-75.392-75.392-75.392 33.754-75.392 75.392z m45.312 175.488c0 44.854 36.362 81.216 81.216 81.216s81.216-36.362 81.216-81.216c0-44.854-36.362-81.216-81.216-81.216-44.854 0-81.216 36.362-81.216 81.216z"}})]),e._v(" "),t("symbol",{attrs:{id:"vssue-icon-like",viewBox:"0 0 1024 1024"}},[t("path",{attrs:{d:"M885.9 533.7c16.8-22.2 26.1-49.4 26.1-77.7 0-44.9-25.1-87.4-65.5-111.1a67.67 67.67 0 0 0-34.3-9.3H572.4l6-122.9c1.4-29.7-9.1-57.9-29.5-79.4-20.5-21.5-48.1-33.4-77.9-33.4-52 0-98 35-111.8 85.1l-85.9 311H144c-17.7 0-32 14.3-32 32v364c0 17.7 14.3 32 32 32h601.3c9.2 0 18.2-1.8 26.5-5.4 47.6-20.3 78.3-66.8 78.3-118.4 0-12.6-1.8-25-5.4-37 16.8-22.2 26.1-49.4 26.1-77.7 0-12.6-1.8-25-5.4-37 16.8-22.2 26.1-49.4 26.1-77.7-0.2-12.6-2-25.1-5.6-37.1zM184 852V568h81v284h-81z m636.4-353l-21.9 19 13.9 25.4c4.6 8.4 6.9 17.6 6.9 27.3 0 16.5-7.2 32.2-19.6 43l-21.9 19 13.9 25.4c4.6 8.4 6.9 17.6 6.9 27.3 0 16.5-7.2 32.2-19.6 43l-21.9 19 13.9 25.4c4.6 8.4 6.9 17.6 6.9 27.3 0 22.4-13.2 42.6-33.6 51.8H329V564.8l99.5-360.5c5.2-18.9 22.5-32.2 42.2-32.3 7.6 0 15.1 2.2 21.1 6.7 9.9 7.4 15.2 18.6 14.6 30.5l-9.6 198.4h314.4C829 418.5 840 436.9 840 456c0 16.5-7.2 32.1-19.6 43z"}})]),e._v(" "),t("symbol",{attrs:{id:"vssue-icon-unlike",viewBox:"0 0 1024 1024"}},[t("path",{attrs:{d:"M885.9 490.3c3.6-12 5.4-24.4 5.4-37 0-28.3-9.3-55.5-26.1-77.7 3.6-12 5.4-24.4 5.4-37 0-28.3-9.3-55.5-26.1-77.7 3.6-12 5.4-24.4 5.4-37 0-51.6-30.7-98.1-78.3-118.4-8.3-3.6-17.2-5.4-26.5-5.4H144c-17.7 0-32 14.3-32 32v364c0 17.7 14.3 32 32 32h129.3l85.8 310.8C372.9 889 418.9 924 470.9 924c29.7 0 57.4-11.8 77.9-33.4 20.5-21.5 31-49.7 29.5-79.4l-6-122.9h239.9c12.1 0 23.9-3.2 34.3-9.3 40.4-23.5 65.5-66.1 65.5-111 0-28.3-9.3-55.5-26.1-77.7zM184 456V172h81v284h-81z m627.2 160.4H496.8l9.6 198.4c0.6 11.9-4.7 23.1-14.6 30.5-6.1 4.5-13.6 6.8-21.1 6.7-19.6-0.1-36.9-13.4-42.2-32.3L329 459.2V172h415.4c20.4 9.2 33.6 29.4 33.6 51.8 0 9.7-2.3 18.9-6.9 27.3l-13.9 25.4 21.9 19c12.5 10.8 19.6 26.5 19.6 43 0 9.7-2.3 18.9-6.9 27.3l-13.9 25.4 21.9 19c12.5 10.8 19.6 26.5 19.6 43 0 9.7-2.3 18.9-6.9 27.3l-14 25.5 21.9 19c12.5 10.8 19.6 26.5 19.6 43 0 19.1-11 37.5-28.8 48.4z"}})]),e._v(" "),t("symbol",{attrs:{id:"vssue-icon-heart",viewBox:"0 0 1024 1024"}},[t("path",{attrs:{d:"M923 283.6c-13.4-31.1-32.6-58.9-56.9-82.8-24.3-23.8-52.5-42.4-84-55.5-32.5-13.5-66.9-20.3-102.4-20.3-49.3 0-97.4 13.5-139.2 39-10 6.1-19.5 12.8-28.5 20.1-9-7.3-18.5-14-28.5-20.1-41.8-25.5-89.9-39-139.2-39-35.5 0-69.9 6.8-102.4 20.3-31.4 13-59.7 31.7-84 55.5-24.4 23.9-43.5 51.7-56.9 82.8-13.9 32.3-21 66.6-21 101.9 0 33.3 6.8 68 20.3 103.3 11.3 29.5 27.5 60.1 48.2 91 32.8 48.9 77.9 99.9 133.9 151.6 92.8 85.7 184.7 144.9 188.6 147.3l23.7 15.2c10.5 6.7 24 6.7 34.5 0l23.7-15.2c3.9-2.5 95.7-61.6 188.6-147.3 56-51.7 101.1-102.7 133.9-151.6 20.7-30.9 37-61.5 48.2-91 13.5-35.3 20.3-70 20.3-103.3 0.1-35.3-7-69.6-20.9-101.9zM512 814.8S156 586.7 156 385.5C156 283.6 240.3 201 344.3 201c73.1 0 136.5 40.8 167.7 100.4C543.2 241.8 606.6 201 679.7 201c104 0 188.3 82.6 188.3 184.5 0 201.2-356 429.3-356 429.3z"}})]),e._v(" "),t("symbol",{attrs:{id:"vssue-icon-edit",viewBox:"0 0 1024 1024"}},[t("path",{attrs:{d:"M723.2 917.76H286.72c-65.28 0-118.4-51.2-118.4-113.92V261.76C168.32 198.4 221.44 147.2 286.72 147.2h375.04c17.92 0 32 14.08 32 32s-14.08 32-32 32H286.72c-30.08 0-54.4 22.4-54.4 49.92v542.08c0 27.52 24.32 49.92 54.4 49.92H723.2c30.08 0 54.4-22.4 54.4-49.92V440.32c0-17.92 14.08-32 32-32s32 14.08 32 32v363.52c0 62.72-53.12 113.92-118.4 113.92z"}}),e._v(" "),t("path",{attrs:{d:"M499.84 602.24c-7.68 0-14.72-2.56-21.12-7.68-13.44-11.52-14.72-32-3.2-45.44L780.16 198.4c11.52-13.44 32-14.72 45.44-3.2s14.72 32 3.2 45.44L524.16 591.36c-6.4 7.04-15.36 10.88-24.32 10.88z"}})]),e._v(" "),t("symbol",{attrs:{id:"vssue-icon-delete",viewBox:"0 0 1024 1024"}},[t("path",{attrs:{d:"M677.647059 256l0-90.352941c0-37.436235-23.461647-60.235294-61.771294-60.235294L408.094118 105.411765c-38.249412 0-61.741176 22.799059-61.741176 60.235294l0 90.352941-180.705882 0 0 60.235294 60.235294 0 0 512c0 54.272 33.972706 90.352941 90.352941 90.352941l391.529412 0c55.085176 0 90.352941-33.490824 90.352941-90.352941l0-512 60.235294 0 0-60.235294L677.647059 256zM406.588235 165.647059l210.823529 0-1.264941 90.352941L406.588235 256 406.588235 165.647059zM737.882353 858.352941l-451.764706 0 0-542.117647 451.764706 0L737.882353 858.352941zM466.823529 376.470588l-58.729412 0-1.505882 391.529412 60.235294 0L466.823529 376.470588zM617.411765 376.470588l-60.235294 0 0 391.529412 60.235294 0L617.411765 376.470588z"}})]),e._v(" "),t("symbol",{attrs:{id:"vssue-icon-reply",viewBox:"0 0 1024 1024"}},[t("path",{attrs:{d:"M426.666667 384 426.666667 213.333333 128 512 426.666667 810.666667 426.666667 635.733333C640 635.733333 789.333333 704 896 853.333333 853.333333 640 725.333333 426.666667 426.666667 384Z"}})]),e._v(" "),t("symbol",{attrs:{id:"vssue-icon-error",viewBox:"0 0 1024 1024"}},[t("path",{attrs:{d:"M512 720m-48 0a48 48 0 1 0 96 0 48 48 0 1 0-96 0Z"}}),e._v(" "),t("path",{attrs:{d:"M480 416v184c0 4.4 3.6 8 8 8h48c4.4 0 8-3.6 8-8V416c0-4.4-3.6-8-8-8h-48c-4.4 0-8 3.6-8 8z"}}),e._v(" "),t("path",{attrs:{d:"M955.7 856l-416-720c-6.2-10.7-16.9-16-27.7-16s-21.6 5.3-27.7 16l-416 720C56 877.4 71.4 904 96 904h832c24.6 0 40-26.6 27.7-48z m-783.5-27.9L512 239.9l339.8 588.2H172.2z"}})])])},staticRenderFns:[]},void 0,Kt,void 0,!0,void 0,!1,void 0,void 0,void 0);const Zt=Qt({},void 0,i.a.extend({name:"TransitionFade",functional:!0,props:{group:{type:Boolean,required:!1,default:!1}},render:(n,{props:e,children:t})=>n(e.group?"TransitionGroup":"Transition",{props:{name:"fade",mode:"out-in",appear:!0}},t)}),void 0,void 0,void 0,!1,void 0,void 0,void 0);const Jt=Qt({},void 0,i.a.extend({name:"VssueIcon",functional:!0,props:{name:{type:String,required:!0},title:{type:String,required:!1,default:null}},render:(n,{props:e,data:t})=>n("svg",Object.assign(Object.assign({},t),{class:["vssue-icon",`vssue-icon-${e.name}`],attrs:{"aria-hidden":"true"}}),[n("title",e.title),n("use",{attrs:{"xlink:href":`#vssue-icon-${e.name}`}})])}),void 0,void 0,void 0,!1,void 0,void 0,void 0);let Xt=class extends i.a{constructor(){super(...arguments),this.editMode=!1,this.editContent=this.comment.contentRaw,this.creatingReactions=[],this.isPutingComment=!1,this.isDeletingComment=!1}get currentUser(){return this.vssue.user?this.vssue.user.username:null}get content(){return this.comment.content}get author(){return this.comment.author}get createdAt(){return et(this.comment.createdAt)}get updatedAt(){return et(this.comment.updatedAt)}get showReactions(){return Boolean(this.vssue.API&&this.vssue.API.platform.meta.reactable&&this.comment.reactions&&!this.editMode)}get reactionKeys(){return["heart","like","unlike"]}get editContentRows(){return this.editContent.split("\n").length-1}get editInputRows(){return this.editContentRows<3?5:this.editContentRows+2}async postReaction({reaction:n}){try{if(this.creatingReactions.includes(n))return;this.creatingReactions.push(n),await this.vssue.postCommentReaction({commentId:this.comment.id,reaction:n})||this.vssue.$emit("error",new Error(this.vssue.$t("reactionGiven",{reaction:this.vssue.$t(n)})));const e=await this.vssue.getCommentReactions({commentId:this.comment.id});e&&(this.comment.reactions=e)}finally{this.creatingReactions.splice(this.creatingReactions.findIndex(e=>e===n),1)}}enterEdit(){this.editMode=!0,this.$nextTick(()=>{this.$refs.input.focus()})}resetEdit(){this.editMode=!1,this.editContent=this.comment.contentRaw}async putComment(){try{if(this.vssue.isPending)return;if(this.editContent!==this.comment.contentRaw){this.isPutingComment=!0,this.vssue.isUpdatingComment=!0;const n=await this.vssue.putComment({commentId:this.comment.id,content:this.editContent});n&&this.vssue.comments.data.splice(this.vssue.comments.data.findIndex(n=>n.id===this.comment.id),1,n)}this.editMode=!1}finally{this.isPutingComment=!1,this.vssue.isUpdatingComment=!1}}async deleteComment(){try{if(this.vssue.isPending)return;if(!window.confirm(this.vssue.$t("deleteConfirm")))return;this.isDeletingComment=!0,this.vssue.isUpdatingComment=!0,await this.vssue.deleteComment({commentId:this.comment.id})?(this.vssue.comments.count-=1,this.vssue.comments.data.length>1&&this.vssue.comments.data.splice(this.vssue.comments.data.findIndex(n=>n.id===this.comment.id),1),this.vssue.query.page>1&&this.vssue.query.page>Math.ceil(this.vssue.comments.count/this.vssue.query.perPage)?this.vssue.query.page-=1:await this.vssue.getComments()):this.vssue.$emit("error",new Error(this.vssue.$t("deleteFailed")))}finally{this.isDeletingComment=!1,this.vssue.isUpdatingComment=!1}}};Wt([Ve({type:Object,required:!0})],Xt.prototype,"comment",void 0),Wt([$e()],Xt.prototype,"vssue",void 0),Xt=Wt([Re({components:{VssueIcon:Jt}})],Xt);const Yt=Qt({render:function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("div",{staticClass:"vssue-comment",class:{"vssue-comment-edit-mode":n.editMode,"vssue-comment-disabled":n.isDeletingComment||n.isPutingComment}},[t("div",{staticClass:"vssue-comment-avatar"},[t("a",{attrs:{href:n.author.homepage,title:n.author.username,target:"_blank"}},[t("img",{attrs:{src:n.author.avatar}})])]),n._v(" "),t("div",{staticClass:"vssue-comment-body"},[n._t("body",[t("div",{staticClass:"vssue-comment-header"},[t("span",{staticClass:"vssue-comment-author"},[t("a",{attrs:{href:n.author.homepage,title:n.author.username,target:"_blank"}},[n._v("\n            "+n._s(n.author.username)+"\n          ")])]),n._v(" "),t("span",{staticClass:"vssue-comment-created-at"},[n._v("\n          "+n._s(n.createdAt)+"\n        ")])]),n._v(" "),t("div",{staticClass:"vssue-comment-main"},[n.editMode?t("textarea",{directives:[{name:"model",rawName:"v-model",value:n.editContent,expression:"editContent"}],ref:"input",staticClass:"vssue-edit-comment-input",attrs:{rows:n.editInputRows},domProps:{value:n.editContent},on:{keyup:function(e){return!e.type.indexOf("key")&&n._k(e.keyCode,"enter",13,e.key,"Enter")?null:e.ctrlKey?n.putComment():null},input:function(e){e.target.composing||(n.editContent=e.target.value)}}}):t("article",{staticClass:"markdown-body",domProps:{innerHTML:n._s(n.content)}})]),n._v(" "),t("div",{staticClass:"vssue-comment-footer"},[n.editMode?t("span",{staticClass:"vssue-comment-hint"},[n._v("\n          "+n._s(n.vssue.$t("editMode"))+"\n        ")]):n._e(),n._v(" "),n.showReactions?t("span",{staticClass:"vssue-comment-reactions"},n._l(n.reactionKeys,(function(e){return t("span",{key:e,staticClass:"vssue-comment-reaction",attrs:{title:n.vssue.$t(n.creatingReactions.includes(e)?"loading":e)},on:{click:function(t){return n.postReaction({reaction:e})}}},[t("VssueIcon",{attrs:{name:n.creatingReactions.includes(e)?"loading":e,title:n.vssue.$t(n.creatingReactions.includes(e)?"loading":e)}}),n._v(" "),t("span",{staticClass:"vssue-comment-reaction-number"},[n._v("\n              "+n._s(n.comment.reactions[e])+"\n            ")])],1)})),0):n._e(),n._v(" "),t("span",{staticClass:"vssue-comment-operations"},[n.comment.author.username===n.currentUser&&n.editMode?t("span",{staticClass:"vssue-comment-operation",class:{"vssue-comment-operation-muted":n.isPutingComment},attrs:{title:n.vssue.$t(n.isPutingComment?"loading":"submit")},on:{click:function(e){return n.putComment()}}},[t("VssueIcon",{directives:[{name:"show",rawName:"v-show",value:n.isPutingComment,expression:"isPutingComment"}],attrs:{name:"loading",title:n.vssue.$t("loading")}}),n._v("\n\n            "+n._s(n.vssue.$t("submit"))+"\n          ")],1):n._e(),n._v(" "),n.comment.author.username===n.currentUser&&n.editMode?t("span",{staticClass:"vssue-comment-operation vssue-comment-operation-muted",attrs:{title:n.vssue.$t("cancel")},on:{click:function(e){return n.resetEdit()}}},[n._v("\n            "+n._s(n.vssue.$t("cancel"))+"\n          ")]):n._e(),n._v(" "),n.comment.author.username===n.currentUser?t("span",{directives:[{name:"show",rawName:"v-show",value:!n.editMode,expression:"!editMode"}],staticClass:"vssue-comment-operation",on:{click:function(e){return n.enterEdit()}}},[t("VssueIcon",{attrs:{name:"edit",title:n.vssue.$t("edit")}})],1):n._e(),n._v(" "),n.comment.author.username===n.currentUser||n.vssue.isAdmin?t("span",{directives:[{name:"show",rawName:"v-show",value:!n.editMode,expression:"!editMode"}],staticClass:"vssue-comment-operation",on:{click:function(e){return n.deleteComment()}}},[t("VssueIcon",{attrs:{name:n.isDeletingComment?"loading":"delete",title:n.vssue.$t(n.isDeletingComment?"loading":"delete")}})],1):n._e(),n._v(" "),t("span",{directives:[{name:"show",rawName:"v-show",value:!n.editMode,expression:"!editMode"}],staticClass:"vssue-comment-operation",on:{click:function(e){return n.vssue.$emit("reply-comment",n.comment)}}},[t("VssueIcon",{attrs:{name:"reply",title:n.vssue.$t("reply")}})],1)])])])],2)])},staticRenderFns:[]},void 0,Xt,void 0,!1,void 0,!1,void 0,void 0,void 0);let ni=class extends i.a{get disabled(){return this.vssue.isPending}get pageCount(){const n=Math.ceil(this.vssue.comments.count/this.vssue.comments.perPage);return n>1?n:1}get perPageOptions(){const n=[5,10,20,50];return!n.includes(this.vssue.options.perPage)&&this.vssue.options.perPage<100&&n.push(this.vssue.options.perPage),n.sort((n,e)=>n-e)}get page(){return this.vssue.query.page>this.pageCount?this.pageCount:this.vssue.query.page}set page(n){n>0&&n<=this.pageCount&&(this.vssue.query.page=n)}get perPage(){return this.vssue.query.perPage}set perPage(n){this.perPageOptions.includes(n)&&(this.vssue.query.perPage=n)}};Wt([$e()],ni.prototype,"vssue",void 0),ni=Wt([Re({components:{VssueIcon:Jt}})],ni);const ei=Qt({render:function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("div",{staticClass:"vssue-pagination"},[t("div",{staticClass:"vssue-pagination-per-page"},[t("select",{directives:[{name:"model",rawName:"v-model",value:n.perPage,expression:"perPage"}],staticClass:"vssue-pagination-select",attrs:{disabled:n.disabled},on:{change:function(e){var t=Array.prototype.filter.call(e.target.options,(function(n){return n.selected})).map((function(n){return"_value"in n?n._value:n.value}));n.perPage=e.target.multiple?t:t[0]}}},n._l(n.perPageOptions,(function(e){return t("option",{key:e,domProps:{value:e}},[n._v("\n        "+n._s(e)+"\n      ")])})),0),n._v(" "),t("span",[n._v("\n      "+n._s(n.vssue.$t("perPage"))+"\n    ")]),n._v(" "),n.vssue.API.platform.meta.sortable?t("span",{class:{"vssue-pagination-link":!0,disabled:n.disabled},attrs:{title:n.vssue.$t("sort")},on:{click:function(e){n.vssue.query.sort="asc"===n.vssue.query.sort?"desc":"asc"}}},[n._v("\n      "+n._s("asc"===n.vssue.query.sort?"↑":"↓")+"\n    ")]):n._e()]),n._v(" "),t("div",{staticClass:"vssue-pagination-page"},[t("span",{class:{"vssue-pagination-link":!0,disabled:1===n.page||n.disabled},attrs:{title:n.vssue.$t("prev")},domProps:{textContent:n._s("<")},on:{click:function(e){n.page-=1}}}),n._v(" "),t("span",[n._v("\n      "+n._s(n.vssue.$t("page"))+"\n    ")]),n._v(" "),t("select",{directives:[{name:"show",rawName:"v-show",value:n.pageCount>1,expression:"pageCount > 1"},{name:"model",rawName:"v-model",value:n.page,expression:"page"}],staticClass:"vssue-pagination-select",attrs:{disabled:n.disabled},on:{change:function(e){var t=Array.prototype.filter.call(e.target.options,(function(n){return n.selected})).map((function(n){return"_value"in n?n._value:n.value}));n.page=e.target.multiple?t:t[0]}}},n._l(n.pageCount,(function(e){return t("option",{key:e,domProps:{value:e}},[n._v("\n        "+n._s(e)+"\n      ")])})),0),n._v(" "),t("span",{directives:[{name:"show",rawName:"v-show",value:n.pageCount<2,expression:"pageCount < 2"}],domProps:{textContent:n._s(n.page)}}),n._v(" "),t("span",{domProps:{textContent:n._s(" / "+n.pageCount+" ")}}),n._v(" "),t("span",{class:{"vssue-pagination-link":!0,disabled:n.page===n.pageCount||n.disabled},attrs:{title:n.vssue.$t("next")},domProps:{textContent:n._s(">")},on:{click:function(e){n.page+=1}}})])])},staticRenderFns:[]},void 0,ni,void 0,!1,void 0,!1,void 0,void 0,void 0);let ti=class extends i.a{};Wt([$e()],ti.prototype,"vssue",void 0),ti=Wt([Re({components:{TransitionFade:Zt,VssueComment:Yt,VssuePagination:ei}})],ti);const ii=Qt({render:function(){var n=this.$createElement,e=this._self._c||n;return e("div",{staticClass:"vssue-comments"},[e("VssuePagination"),this._v(" "),e("TransitionFade",{attrs:{group:""}},this._l(this.vssue.comments.data,(function(n){return e("VssueComment",{key:n.id,attrs:{comment:n}})})),1),this._v(" "),e("VssuePagination",{directives:[{name:"show",rawName:"v-show",value:this.vssue.comments.data.length>5,expression:"vssue.comments.data.length > 5"}]})],1)},staticRenderFns:[]},void 0,ti,void 0,!1,void 0,!1,void 0,void 0,void 0);const ri=Qt({},void 0,i.a.extend({name:"VssueIcon",functional:!0,props:{type:{type:String,required:!1,default:"default"}},render:(n,{props:e,data:t,children:i})=>n("button",Object.assign(Object.assign({},t),{class:["vssue-button",`vssue-button-${e.type}`]}),i)}),void 0,void 0,void 0,!1,void 0,void 0,void 0);let si=class extends i.a{constructor(){super(...arguments),this.content=""}get user(){return this.vssue.user}get platform(){return this.vssue.API&&this.vssue.API.platform.name}get isInputDisabled(){return this.loading||null===this.user||null===this.vssue.issue}get isSubmitDisabled(){return""===this.content||this.vssue.isPending||null===this.vssue.issue}get loading(){return this.vssue.isCreatingComment}get contentRows(){return this.content.split("\n").length-1}get inputRows(){return this.contentRows<3?5:this.contentRows+2}created(){this.vssue.$on("reply-comment",n=>{const e=n.contentRaw.replace(/\n/g,"\n> "),t=`@${n.author.username}\n\n> ${e}\n\n`;this.content=this.content.concat(t),this.focus()})}beforeDestroy(){this.vssue.$off("reply-comment")}focus(){this.$refs.input.focus()}async submit(){this.isSubmitDisabled||(await this.vssue.postComment({content:this.content}),this.content="",await this.vssue.getComments())}};Wt([$e()],si.prototype,"vssue",void 0),si=Wt([Re({components:{VssueButton:ri,VssueIcon:Jt}})],si);const oi=Qt({render:function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("div",{staticClass:"vssue-new-comment"},[t("div",{staticClass:"vssue-comment-avatar"},[n.user?t("a",{attrs:{href:n.user.homepage,title:n.user.username,target:"_blank"}},[t("img",{attrs:{src:n.user.avatar}})]):t("VssueIcon",{attrs:{name:n.platform.toLowerCase(),title:n.vssue.$t("loginToComment",{platform:n.platform})},on:{click:function(e){return n.vssue.login()}}})],1),n._v(" "),t("div",{staticClass:"vssue-new-comment-body"},[t("textarea",{directives:[{name:"model",rawName:"v-model",value:n.content,expression:"content"}],ref:"input",staticClass:"vssue-new-comment-input",attrs:{rows:n.inputRows,disabled:n.isInputDisabled,placeholder:n.vssue.$t(n.user?"placeholder":"noLoginPlaceHolder"),spellcheck:!1},domProps:{value:n.content},on:{keyup:function(e){return!e.type.indexOf("key")&&n._k(e.keyCode,"enter",13,e.key,"Enter")?null:e.ctrlKey?n.submit():null},input:function(e){e.target.composing||(n.content=e.target.value)}}})]),n._v(" "),t("div",{staticClass:"vssue-new-comment-footer"},[n.user?t("span",{staticClass:"vssue-current-user"},[t("span",[n._v(n._s(n.vssue.$t("currentUser"))+" - "+n._s(n.user.username)+" - ")]),n._v(" "),t("a",{staticClass:"vssue-logout",on:{click:function(e){return n.vssue.logout()}}},[n._v("\n        "+n._s(n.vssue.$t("logout"))+"\n      ")])]):t("span",{staticClass:"vssue-current-user"},[n._v("\n      "+n._s(n.vssue.$t("loginToComment",{platform:n.platform}))+"\n    ")]),n._v(" "),t("div",{staticClass:"vssue-new-comment-operations"},[n.user?t("VssueButton",{staticClass:"vssue-button-submit-comment",attrs:{type:"primary",disabled:n.isSubmitDisabled},on:{click:function(e){return n.submit()}}},[t("VssueIcon",{directives:[{name:"show",rawName:"v-show",value:n.loading,expression:"loading"}],attrs:{name:"loading"}}),n._v("\n\n        "+n._s(n.vssue.$t(n.loading?"submitting":"submitComment"))+"\n      ")],1):t("VssueButton",{staticClass:"vssue-button-login",attrs:{type:"primary",title:n.vssue.$t("loginToComment",{platform:n.platform})},on:{click:function(e){return n.vssue.login()}}},[n._v("\n        "+n._s(n.vssue.$t("login",{platform:n.platform}))+"\n      ")])],1)])])},staticRenderFns:[]},void 0,si,void 0,!1,void 0,!1,void 0,void 0,void 0);let ai=class extends i.a{constructor(){super(...arguments),this.progress={show:!1,percent:0,timer:null,speed:200},this.alert={show:!1,message:null,timer:null}}onLoadingCommentsChange(n){this.vssue.comments&&(n?this.progressStart():this.progressDone())}created(){this.vssue.$on("error",n=>this.alertShow(n.message))}beforeDestroy(){this.vssue.$off("error"),null!==this.progress.timer&&window.clearTimeout(this.progress.timer),null!==this.alert.timer&&window.clearTimeout(this.alert.timer)}progressStart(){this.progress.show=!0,this.progress.percent=0,this.progress.timer=window.setInterval(()=>{this.progress.percent+=5,this.progress.percent>94&&null!==this.progress.timer&&window.clearInterval(this.progress.timer)},this.progress.speed)}progressDone(){this.progress.percent=100,null!==this.progress.timer&&window.clearTimeout(this.progress.timer),this.progress.timer=null,window.setTimeout(()=>{this.progress.show=!1},this.progress.speed)}alertShow(n){this.alert.show=!0,this.alert.message=n,null!==this.alert.timer&&window.clearTimeout(this.alert.timer),this.alert.timer=window.setTimeout(()=>{this.alertHide()},3e3)}alertHide(){this.alert.show=!1,null!==this.alert.timer&&window.clearTimeout(this.alert.timer),this.alert.timer=null}};Wt([$e()],ai.prototype,"vssue",void 0),Wt([We("vssue.isLoadingComments")],ai.prototype,"onLoadingCommentsChange",null),ai=Wt([Re({components:{TransitionFade:Zt}})],ai);const li=Qt({render:function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("div",{staticClass:"vssue-notice"},[t("div",{directives:[{name:"show",rawName:"v-show",value:n.progress.show,expression:"progress.show"}],staticClass:"vssue-progress",style:{width:n.progress.percent+"%",transition:"all "+n.progress.speed+"ms linear"}}),n._v(" "),t("TransitionFade",[t("div",{directives:[{name:"show",rawName:"v-show",value:n.alert.show,expression:"alert.show"}],staticClass:"vssue-alert",domProps:{textContent:n._s(n.alert.message)},on:{click:function(e){return n.alertHide()}}})])],1)},staticRenderFns:[]},void 0,ai,void 0,!1,void 0,!1,void 0,void 0,void 0);let ui=class extends i.a{get status(){return this.vssue.isFailed?"failed":this.vssue.isInitializing?"initializing":this.vssue.isIssueNotCreated&&!this.vssue.isCreatingIssue?this.vssue.isAdmin||!this.vssue.isLogined?"issueNotCreated":"failed":this.vssue.isLoginRequired?"loginRequired":!this.vssue.comments||this.vssue.isCreatingIssue?"loadingComments":0===this.vssue.comments.data.length?"noComments":null}handleClick(){"issueNotCreated"===this.status?this.vssue.postIssue():"loginRequired"===this.status&&this.vssue.login()}};Wt([$e()],ui.prototype,"vssue",void 0),ui=Wt([Re({components:{TransitionFade:Zt,VssueIcon:Jt}})],ui);const ci=Qt({render:function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("TransitionFade",[n.status?t("div",{key:n.status,staticClass:"vssue-status"},[["failed","loadingComments","initializing"].includes(n.status)?t("VssueIcon",{attrs:{name:"failed"===n.status?"error":"loading"}}):n._e(),n._v(" "),t("p",{staticClass:"vssue-status-info"},[t(["issueNotCreated","loginRequired"].includes(n.status)?"a":"span",{tag:"Component",on:{click:n.handleClick}},[n._v("\n        "+n._s(n.vssue.$t(n.status))+"\n      ")])],1)],1):n._e()])},staticRenderFns:[]},void 0,ui,void 0,!1,void 0,!1,void 0,void 0,void 0);let di=class extends i.a{};Wt([$e()],di.prototype,"vssue",void 0),di=Wt([Re({components:{TransitionFade:Zt,VssueIcon:Jt,VssueComments:ii,VssueNewComment:oi,VssueNotice:li,VssueStatus:ci}})],di);const mi=Qt({render:function(){var n=this.$createElement,e=this._self._c||n;return e("TransitionFade",[this.vssue.isInitializing?e("VssueStatus"):e("div",{staticClass:"vssue-body"},[this.vssue.API?e("VssueNewComment"):this._e(),this._v(" "),e("VssueNotice"),this._v(" "),e("TransitionFade",[this.vssue.comments&&this.vssue.comments.data.length>0?e("VssueComments"):e("VssueStatus")],1)],1)],1)},staticRenderFns:[]},void 0,di,void 0,!1,void 0,!1,void 0,void 0,void 0);let pi=class extends i.a{};Wt([$e()],pi.prototype,"vssue",void 0),pi=Wt([Re],pi);const hi=Qt({render:function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("div",{staticClass:"vssue-header"},[t("a",{staticClass:"vssue-header-comments-count",attrs:{href:n.vssue.issue?n.vssue.issue.link:null,target:"_blank"}},[t("span",[n._v("\n      "+n._s(n.vssue.comments?n.vssue.$tc("comments",n.vssue.comments.count,{count:n.vssue.comments.count}):n.vssue.$tc("comments",0))+"\n    ")])]),n._v(" "),t("span",{staticClass:"vssue-header-powered-by"},[t("span",[n._v("Powered by")]),n._v(" "),n.vssue.API?t("span",[t("a",{attrs:{href:n.vssue.API.platform.link,target:"_blank",title:n.vssue.API.platform.name+" API "+n.vssue.API.platform.version}},[n._v("\n        "+n._s(n.vssue.API.platform.name)+"\n      ")]),n._v(" "),t("span",[n._v("&")])]):n._e(),n._v(" "),t("a",{attrs:{href:"https://github.com/meteorlxy/vssue",target:"_blank",title:"Vssue v"+n.vssue.version}},[n._v("\n      Vssue\n    ")])])])},staticRenderFns:[]},void 0,pi,void 0,!1,void 0,!1,void 0,void 0,void 0),fi={login:"Login with {platform}",logout:"Logout",currentUser:"Current User",loading:"Loading",submit:"Submit",submitting:"Submitting",submitComment:"Submit Comment",cancel:"Cancel",edit:"Edit",editMode:"Edit Mode",delete:"Delete",reply:"Reply",heart:"Heart",like:"Like",unlike:"Unlike",perPage:"Comments per page",sort:"Click to change the sort direction",page:"Page",prev:"Previous Page",next:"Next Page",comments:"Comments | {count} Comment | {count} Comments",loginToComment:"Login with {platform} account to leave a comment",placeholder:"Leave a comment. Styling with Markdown is supported. Ctrl + Enter to submit.",noLoginPlaceHolder:"Login to leave a comment. Styling with Markdown is supported. ",failed:"Failed to load comments",initializing:"Initializing...",issueNotCreated:"Click to create issue",loadingComments:"Loading comments...",loginRequired:"Login to view comments",noComments:"No comments yet. Leave the first comment !",reactionGiven:"Already given '{reaction}' reaction",deleteConfirm:"Confirm to delete this comment ?",deleteFailed:"Failed to delete comment"},gi={login:"使用 {platform} 登录",logout:"退出登录",currentUser:"当前用户",loading:"加载中",submit:"提交",submitting:"发表中",submitComment:"发表评论",cancel:"取消",edit:"编辑",editMode:"编辑模式",delete:"删除",reply:"回复",heart:"喜欢",like:"赞",unlike:"踩",perPage:"每页评论数",sort:"点击改变排序方式",page:"页数",prev:"上一页",next:"下一页",comments:"评论 | {count} 条评论 | {count} 条评论",loginToComment:"使用 {platform} 帐号登录后发表评论",placeholder:"留下你的评论丨支持 Markdown 语法丨Ctrl + Enter 发表评论",noLoginPlaceHolder:"登录后才能发表评论丨支持 Markdown 语法",failed:"评论加载失败",initializing:"正在初始化...",issueNotCreated:"点击创建 Issue",loadingComments:"正在加载评论...",loginRequired:"登录后查看评论",noComments:"还没有评论，来发表第一条评论吧！",reactionGiven:"已经添加过 '{reaction}' 了",deleteConfirm:"确认要删除该评论吗？",deleteFailed:"评论删除失败"},vi={login:"Entrar com {platform}",logout:"Sair",currentUser:"Usuário Atual",loading:"Carregando",submit:"Enviar",submitting:"Enviando",submitComment:"Enviar Comentário",cancel:"Cancelar",edit:"Editar",editMode:"Modo de Edição",delete:"Apagar",reply:"Responder",heart:"Heart",like:"Like",unlike:"Unlike",perPage:"Comentários por página",sort:"Clique para alterar a ordenação",page:"Página",prev:"Página Anterior",next:"Próxima Página",comments:"Comentários | {count} Comentário | {count} Comentários",loginToComment:"Entre com uma conta {platform} para deixar um comentário",placeholder:"Deixe um comentário. Estilos com Markdown suportados. Ctrl + Enter para enviar.",noLoginPlaceHolder:"Entre para deixar um comentário. Estilos com Markdown suportados. ",failed:"Falha ao carregar comentários",initializing:"Inicializando...",issueNotCreated:"Click to create issue",loadingComments:"Carregando comentários...",loginRequired:"Entrar para visualizar comentários",noComments:"Nenhum comentário. Deixe o primeiro comentário!",reactionGiven:"Já reagiu com '{reaction}'",deleteConfirm:"Apagar este comentário?",deleteFailed:"Falha ao apagar comentário"},bi={login:"{platform} でログイン",logout:"ログアウト",currentUser:"現在のユーザー",loading:"読み込み中",submit:"送信",submitting:"送信中",submitComment:"コメントを送信",cancel:"キャンセル",edit:"編集",editMode:"編集モード",delete:"削除",reply:"返信",heart:"ハート",like:"高評価",unlike:"低評価",perPage:"コメント/ページ",sort:"並び順を変更するにはクリックしてください",page:"ページ",prev:"前のページ",next:"次のページ",comments:"コメント | {count} コメント | {count} コメント",loginToComment:"コメントを残すには {platform} アカウントでログインしてください。",placeholder:"コメントを残してください。Markdown 記法をサポートしています。 Ctrl + Enter で送信できます。",noLoginPlaceHolder:"コメントを残すにはログインしてください。マークダウン記法をサポートしています。",failed:"コメントの読み込みに失敗しました",initializing:"初期化中...",issueNotCreated:"Click to create issue",loadingComments:"コメントの読み込み中...",loginRequired:"コメントを見るにはログインしてください",noComments:"まだコメントがありません。最初のコメントを残しましょう！",reactionGiven:"既に '{reaction}' のリアクションをしています",deleteConfirm:"本当にコメントを削除してもいいですか？",deleteFailed:"コメントの削除に失敗しました"},xi={login:"התחברו עם {platform}",logout:"התנתקו",currentUser:"משתמש/ת נוכחי/ת",loading:"טוען",submit:"שליחה",submitting:"שולח",submitComment:"שליחת תגובה",cancel:"ביטל",edit:"עריכה",editMode:"מצב עריכה",delete:"מחיקה",reply:"תשובה",heart:"לב",like:"לייק",unlike:"אנלייק",perPage:"תגובות לדף",sort:"לחצו כדי לשנות את כיוון המיון",page:"דף",prev:"הדף הקודם",next:"הדף הבא",comments:"תגובות | {count} תגובה | {count} תגובות",loginToComment:"התחברו עם חשבון {platform} כדי להשאיר תגובה",placeholder:"השאירו תגובה. יש תמיכה בעיצוב בעזרת Markdown. Ctrl + Enter כדי לשלוח.",noLoginPlaceHolder:"התחברו כדי להשאיר תגובה. יש תמיכה בעיצוב בעזרת Markdown. ",failed:"כשלון בטעינת התגובות",initializing:"מאתחל...",issueNotCreated:"לחצו ליצירת issue",loadingComments:"טוען תגובות...",loginRequired:"התחברו כדי לצפות בתגובות",noComments:"עדיין אין תגובות. השאירו תגובה ראשונה !",reactionGiven:"כבר ניתן חיווי '{reaction}'",deleteConfirm:"בטוחים במחיקת התגובה ?",deleteFailed:"כשלון במחיקת התגובה"};Object.prototype.hasOwnProperty.call(i.a,"$i18n")||i.a.use(Vt);const wi=new Vt({locale:"en",fallbackLocale:"en",messages:{en:fi,"en-US":fi,zh:gi,"zh-CN":gi,pt:vi,"pt-BR":vi,ja:bi,"ja-JP":bi,he:xi,"he-IL":xi}});let Ei=class extends i.a{constructor(){super(...arguments),this.title=n=>`${n.prefix}${document.title}`,this.issueId=null,this.options=null,this.API=null,this.accessToken=null,this.user=null,this.issue=null,this.comments=null,this.query={page:1,perPage:10,sort:"desc"},this.isInitializing=!0,this.isIssueNotCreated=!1,this.isLoginRequired=!1,this.isFailed=!1,this.isCreatingIssue=!1,this.isLoadingComments=!1,this.isCreatingComment=!1,this.isUpdatingComment=!1}get version(){return"1.4.2"}get issueTitle(){return null===this.options?"":"function"==typeof this.title?this.title(this.options):`${this.options.prefix}${this.title}`}get isPending(){return this.isLoadingComments||this.isCreatingComment||this.isUpdatingComment}get isLogined(){return null!==this.accessToken&&null!==this.user}get isAdmin(){return null!==this.options&&null!==this.accessToken&&null!==this.user&&(this.user.username===this.options.owner||this.options.admins.includes(this.user.username))}get accessTokenKey(){return this.API?`Vssue.${this.API.platform.name.toLowerCase()}.access_token`:""}onQueryPerPageChange(){this.query.page=1,this.getComments()}onQueryChange(){this.getComments()}setOptions(n){this.options=Object.assign({labels:["Vssue"],state:"Vssue",prefix:"[Vssue]",admins:[],perPage:10,proxy:n=>`https://cors-anywhere.herokuapp.com/${n}`,issueContent:({url:n})=>n,autoCreateIssue:!1},n);const e=["api","owner","repo","clientId"];for(const n of e)this.options[n]||console.warn(`[Vssue] the option '${n}' is required`);if(this.options.locale)this.$i18n.locale=this.options.locale;else{const n=Object.keys(this.$i18n.messages),e=window.navigator.languages;this.$i18n.locale=e.filter(e=>n.includes(e)).shift()||"en"}}async init(){try{await this.initStore(),await this.initComments()}catch(n){n.response&&[401,403].includes(n.response.status)?this.isLoginRequired=!0:this.isFailed=!0,console.error(n)}}async initStore(){try{if(!this.options)throw new Error("Options are required to initialize Vssue");this.API=null,this.accessToken=null,this.user=null,this.issue=null,this.comments=null,this.query={page:1,perPage:this.options.perPage,sort:"desc"},this.isInitializing=!0,this.isIssueNotCreated=!1,this.isLoginRequired=!1,this.isFailed=!1,this.isCreatingIssue=!1,this.isLoadingComments=!1,this.isCreatingComment=!1,this.isUpdatingComment=!1;const n=this.options.api;this.API=new n({baseURL:this.options.baseURL,labels:this.options.labels,state:this.options.state,owner:this.options.owner,repo:this.options.repo,clientId:this.options.clientId,clientSecret:this.options.clientSecret,proxy:this.options.proxy}),await this.handleAuth()}finally{this.isInitializing=!1}}async initComments(){if(this.API&&this.options)if(this.issueId){const[n,e]=await Promise.all([this.API.getIssue({accessToken:this.accessToken,issueId:this.issueId}),this.API.getComments({accessToken:this.accessToken,issueId:this.issueId,query:this.query})]);this.issue=n,this.comments=e}else this.issue=await this.API.getIssue({accessToken:this.accessToken,issueTitle:this.issueTitle}),null===this.issue?(this.isIssueNotCreated=!0,this.options.autoCreateIssue&&await this.postIssue()):await this.getComments()}async postIssue(){if(this.API&&this.options&&!this.issue&&!this.issueId&&(this.isLogined||this.login(),this.isAdmin))try{this.isCreatingIssue=!0;const n=await this.API.postIssue({title:this.issueTitle,content:await this.options.issueContent({options:this.options,url:Xe(window.location.href)}),accessToken:this.accessToken});this.issue=n,this.isIssueNotCreated=!1,await this.getComments()}catch(n){this.isFailed=!0}finally{this.isCreatingIssue=!1}}async getComments(){try{if(!this.API||!this.issue||this.isLoadingComments)return;this.isLoadingComments=!0;const n=await this.API.getComments({accessToken:this.accessToken,issueId:this.issue.id,query:this.query});return this.comments=n,this.query.page!==n.page&&(this.query.page=n.page),this.query.perPage!==n.perPage&&(this.query.perPage=n.perPage),n}catch(n){if(!n.response||![401,403].includes(n.response.status)||this.isLogined)throw this.$emit("error",n),n;this.isLoginRequired=!0}finally{this.isLoadingComments=!1}}async postComment({content:n}){try{if(!this.API||!this.issue||this.isCreatingComment)return;return this.isCreatingComment=!0,await this.API.postComment({accessToken:this.accessToken,content:n,issueId:this.issue.id})}catch(n){throw this.$emit("error",n),n}finally{this.isCreatingComment=!1}}async putComment({commentId:n,content:e}){try{if(!this.API||!this.issue)return;return await this.API.putComment({accessToken:this.accessToken,issueId:this.issue.id,commentId:n,content:e})}catch(n){throw this.$emit("error",n),n}}async deleteComment({commentId:n}){try{if(!this.API||!this.issue)return;return await this.API.deleteComment({accessToken:this.accessToken,issueId:this.issue.id,commentId:n})}catch(n){throw this.$emit("error",n),n}}async getCommentReactions({commentId:n}){try{if(!this.API||!this.issue)return;return await this.API.getCommentReactions({accessToken:this.accessToken,issueId:this.issue.id,commentId:n})}catch(n){throw this.$emit("error",n),n}}async postCommentReaction({commentId:n,reaction:e}){try{if(!this.API||!this.issue)return!1;return await this.API.postCommentReaction({accessToken:this.accessToken,issueId:this.issue.id,commentId:n,reaction:e})}catch(n){throw this.$emit("error",n),n}}login(){this.API&&this.API.redirectAuth()}logout(){this.setAccessToken(null),this.user=null}async handleAuth(){if(!this.API)return;const n=await this.API.handleAuth();n?(this.setAccessToken(n),this.user=await this.API.getUser({accessToken:n})):this.getAccessToken()?this.user=await this.API.getUser({accessToken:this.accessToken}):(this.setAccessToken(null),this.user=null)}getAccessToken(){return this.accessToken=window.localStorage.getItem(this.accessTokenKey),this.accessToken}setAccessToken(n){null===n?window.localStorage.removeItem(this.accessTokenKey):window.localStorage.setItem(this.accessTokenKey,n),this.accessToken=n}};Wt([We("query.perPage")],Ei.prototype,"onQueryPerPageChange",null),Wt([We("query.page"),We("query.sort")],Ei.prototype,"onQueryChange",null),Ei=Wt([Re({i18n:wi})],Ei);var yi=Ei;let ki=class extends i.a{constructor(){super(...arguments),this.vssue=new yi}onOptionsChange(n){this.vssue.setOptions(n)}mounted(){null!==this.title&&(this.vssue.title=this.title),null!==this.issueId&&(this.vssue.issueId=this.issueId),this.vssue.setOptions(this.options),this.vssue.init()}};var Ai;Wt([Ve({type:[String,Function],required:!1,default:null})],ki.prototype,"title",void 0),Wt([Ve({type:[String,Number],required:!1,default:null})],ki.prototype,"issueId",void 0),Wt([Ve({type:Object,required:!1,default:()=>({})})],ki.prototype,"options",void 0),Wt([(Ai="vssue",Te((function(n,e){var t=n.provide;if("function"!=typeof t||!t.managed){var i=n.provide;(t=n.provide=function(){var n=Object.create(("function"==typeof i?i.call(this):i)||null);for(var e in t.managed)n[t.managed[e]]=this[e];return n}).managed={}}t.managed[e]=Ai||e})))],ki.prototype,"vssue",void 0),Wt([We("options",{deep:!0})],ki.prototype,"onOptionsChange",null),ki=Wt([Re({components:{Iconfont:Gt,VssueBody:mi,VssueHeader:hi}})],ki);const ji=Qt({render:function(){var n=this.$createElement,e=this._self._c||n;return e("div",{staticClass:"vssue"},[e("Iconfont"),this._v(" "),e("VssueHeader"),this._v(" "),e("VssueBody")],1)},staticRenderFns:[]},void 0,ki,void 0,!1,void 0,!1,void 0,void 0,void 0);var _i=t(5),Ni=t.n(_i);function Oi(n){return{username:n.login,avatar:n.avatar_url,homepage:n.html_url}}function Bi(n){return{id:n.number,title:n.title,content:n.body,link:n.html_url}}function Si(n){return{like:n["+1"],unlike:n[-1],heart:n.heart}}function Ii(n){return{id:n.id,content:n.body_html,contentRaw:n.body,author:Oi(n.user),createdAt:n.created_at,updatedAt:n.updated_at,reactions:Si(n.reactions)}}function Li(n){return"like"===n?"+1":"unlike"===n?"-1":n}class Ci{constructor({baseURL:n="https://github.com",owner:e,repo:t,labels:i,clientId:r,clientSecret:s,state:o,proxy:a}){if(void 0===s||void 0===a)throw new Error("clientSecret and proxy is required for GitHub V3");this.baseURL=n,this.owner=e,this.repo=t,this.labels=i,this.clientId=r,this.clientSecret=s,this.state=o,this.proxy=a,this.$http=Ni.a.create({baseURL:"https://github.com"===n?"https://api.github.com":Je(n,"api/v3"),headers:{Accept:"application/vnd.github.v3+json"}}),this.$http.interceptors.response.use(n=>n.data&&n.data.error?Promise.reject(new Error(n.data.error_description)):n)}get platform(){return{name:"GitHub",link:this.baseURL,version:"v3",meta:{reactable:!0,sortable:!1}}}redirectAuth(){window.location.href=Ze(Je(this.baseURL,"login/oauth/authorize"),{client_id:this.clientId,redirect_uri:window.location.href,scope:"public_repo",state:this.state})}async handleAuth(){const n=Ye(window.location.search);if(n.code){if(n.state!==this.state)return null;const e=n.code;delete n.code,delete n.state;const t=Ze(Xe(window.location.href),n)+window.location.hash;return window.history.replaceState(null,"",t),await this.getAccessToken({code:e})}return null}async getAccessToken({code:n}){const e=Je(this.baseURL,"login/oauth/access_token"),t="function"==typeof this.proxy?this.proxy(e):this.proxy,{data:i}=await this.$http.post(t,{client_id:this.clientId,client_secret:this.clientSecret,code:n},{headers:{Accept:"application/json"}});return i.access_token}async getUser({accessToken:n}){const{data:e}=await this.$http.get("user",{headers:{Authorization:`token ${n}`}});return Oi(e)}async getIssue({accessToken:n,issueId:e,issueTitle:t}){const i={};if(n&&(i.headers={Authorization:`token ${n}`}),!e){i.params={q:[`"${t}"`,"is:issue","in:title",`repo:${this.owner}/${this.repo}`,"is:public",...this.labels.map(n=>`label:${n}`)].join(" ")};const{data:n}=await this.$http.get("search/issues",i);return n.items.map(Bi).find(n=>n.title===t)||null}try{i.params={timestamp:Date.now()};const{data:n}=await this.$http.get(`repos/${this.owner}/${this.repo}/issues/${e}`,i);return Bi(n)}catch(n){if(n.response&&404===n.response.status)return null;throw n}}async postIssue({accessToken:n,title:e,content:t}){const{data:i}=await this.$http.post(`repos/${this.owner}/${this.repo}/issues`,{title:e,body:t,labels:this.labels},{headers:{Authorization:`token ${n}`}});return Bi(i)}async getComments({accessToken:n,issueId:e,query:{page:t=1,perPage:i=10}={}}){const r={params:{timestamp:Date.now()}},s={params:{page:t,per_page:i,timestamp:Date.now()},headers:{Accept:["application/vnd.github.v3.raw+json","application/vnd.github.v3.html+json","application/vnd.github.squirrel-girl-preview"]}};n&&(r.headers={Authorization:`token ${n}`},s.headers.Authorization=`token ${n}`);const[o,a]=await Promise.all([this.$http.get(`repos/${this.owner}/${this.repo}/issues/${e}`,r),this.$http.get(`repos/${this.owner}/${this.repo}/issues/${e}/comments`,s)]),l=a.headers.link||null,u=/rel="next"/.test(l)?Number(l.replace(/^.*[^_]page=(\d*).*rel="next".*$/,"$1"))-1:/rel="prev"/.test(l)?Number(l.replace(/^.*[^_]page=(\d*).*rel="prev".*$/,"$1"))+1:1,c=l?Number(l.replace(/^.*per_page=(\d*).*$/,"$1")):i;return{count:Number(o.data.comments),page:u,perPage:c,data:a.data.map(Ii)}}async postComment({accessToken:n,issueId:e,content:t}){const{data:i}=await this.$http.post(`repos/${this.owner}/${this.repo}/issues/${e}/comments`,{body:t},{headers:{Authorization:`token ${n}`,Accept:["application/vnd.github.v3.raw+json","application/vnd.github.v3.html+json","application/vnd.github.squirrel-girl-preview"]}});return Ii(i)}async putComment({accessToken:n,commentId:e,content:t}){const{data:i}=await this.$http.patch(`repos/${this.owner}/${this.repo}/issues/comments/${e}`,{body:t},{headers:{Authorization:`token ${n}`,Accept:["application/vnd.github.v3.raw+json","application/vnd.github.v3.html+json","application/vnd.github.squirrel-girl-preview"]}});return Ii(i)}async deleteComment({accessToken:n,commentId:e}){const{status:t}=await this.$http.delete(`repos/${this.owner}/${this.repo}/issues/comments/${e}`,{headers:{Authorization:`token ${n}`}});return 204===t}async getCommentReactions({accessToken:n,commentId:e}){const{data:t}=await this.$http.get(`repos/${this.owner}/${this.repo}/issues/comments/${e}`,{headers:{Authorization:`token ${n}`,Accept:"application/vnd.github.squirrel-girl-preview"}});return Si(t.reactions)}async postCommentReaction({accessToken:n,commentId:e,reaction:t}){const i=await this.$http.post(`repos/${this.owner}/${this.repo}/issues/comments/${e}/reactions`,{content:Li(t)},{headers:{Authorization:`token ${n}`,Accept:"application/vnd.github.squirrel-girl-preview"}});return 200===i.status?this.deleteCommentReaction({accessToken:n,reactionId:i.data.id}):201===i.status}async deleteCommentReaction({accessToken:n,reactionId:e}){return 204===(await this.$http.delete(`reactions/${e}`,{headers:{Authorization:`token ${n}`,Accept:"application/vnd.github.squirrel-girl-preview"}})).status}}function Ti(n){return null===n?{username:"ghost",avatar:"https://avatars3.githubusercontent.com/u/10137?v=4",homepage:"https://github.com/ghost"}:{username:n.login,avatar:n.avatarUrl,homepage:n.url}}function Di(n){return{id:n.number,title:n.title,content:n.body,link:n.url}}function qi(n){return{like:n.find(n=>"THUMBS_UP"===n.content).users.totalCount,unlike:n.find(n=>"THUMBS_DOWN"===n.content).users.totalCount,heart:n.find(n=>"HEART"===n.content).users.totalCount}}function Pi(n){return{id:n.id,content:n.bodyHTML,contentRaw:n.body,author:Ti(n.author),createdAt:n.createdAt,updatedAt:n.updatedAt,reactions:qi(n.reactionGroups)}}function Mi(n){return"like"===n?"THUMBS_UP":"unlike"===n?"THUMBS_DOWN":"heart"===n?"HEART":n}class Fi{constructor({baseURL:n="https://github.com",owner:e,repo:t,labels:i,clientId:r,clientSecret:s,state:o,proxy:a}){if(void 0===s||void 0===a)throw new Error("clientSecret and proxy is required for GitHub V4");this.baseURL=n,this.owner=e,this.repo=t,this.labels=i,this.clientId=r,this.clientSecret=s,this.state=o,this.proxy=a,this._pageInfo={page:1,startCursor:null,endCursor:null,sort:null,perPage:null},this._issueNodeId=null,this.$http=Ni.a.create({baseURL:"https://github.com"===n?"https://api.github.com":Je(n,"api"),headers:{Accept:"application/vnd.github.v3+json"}}),this.$http.interceptors.response.use(n=>n.data.error?Promise.reject(n.data.error_description):n.data.errors?Promise.reject(n.data.errors[0].message):n)}get platform(){return{name:"GitHub",link:this.baseURL,version:"v4",meta:{reactable:!0,sortable:!0}}}redirectAuth(){window.location.href=Ze(Je(this.baseURL,"login/oauth/authorize"),{client_id:this.clientId,redirect_uri:window.location.href,scope:"public_repo",state:this.state})}async handleAuth(){const n=Ye(window.location.search);if(n.code){if(n.state!==this.state)return null;const e=n.code;delete n.code,delete n.state;const t=Ze(Xe(window.location.href),n)+window.location.hash;return window.history.replaceState(null,"",t),await this.getAccessToken({code:e})}return null}async getAccessToken({code:n}){const e=Je(this.baseURL,"login/oauth/access_token"),t="function"==typeof this.proxy?this.proxy(e):this.proxy,{data:i}=await this.$http.post(t,{client_id:this.clientId,client_secret:this.clientSecret,code:n},{headers:{Accept:"application/json"}});return i.access_token}async getUser({accessToken:n}){const{data:e}=await this.$http.post("graphql",{query:"query getUser {\n  viewer {\n    login\n    avatarUrl\n    url\n  }\n}"},{headers:{Authorization:`token ${n}`}});return Ti(e.data.viewer)}async getIssue({accessToken:n,issueId:e,issueTitle:t}){const i={};if(n&&(i.headers={Authorization:`token ${n}`}),!e){const n=[`"${t}"`,"in:title",`repo:${this.owner}/${this.repo}`,"is:public",...this.labels.map(n=>`label:${n}`)].join(" "),{data:e}=await this.$http.post("graphql",{variables:{query:n},query:"query getIssueByTitle(\n  $query: String!\n) {\n  search(\n    query: $query\n    type: ISSUE\n    first: 20\n    ) {\n      nodes {\n      ... on Issue {\n        id\n        number\n        title\n        body\n        url\n      }\n    }\n  }\n}"},i),r=e.data.search.nodes.find(n=>n.title===t);return r?(this._issueNodeId=r.id,Di(r)):null}try{const{data:n}=await this.$http.post("graphql",{query:`query getIssueById {\n  repository(owner: "${this.owner}", name: "${this.repo}") {\n    issue (number: ${e}) {\n      id\n      number\n      title\n      body\n      url\n    }\n  }\n}`},i);return this._issueNodeId=n.data.repository.issue.id,Di(n.data.repository.issue)}catch(n){if(n.response&&404===n.response.status)return null;throw n}}async postIssue({accessToken:n,title:e,content:t}){const{data:i}=await this.$http.post(`repos/${this.owner}/${this.repo}/issues`,{title:e,body:t,labels:this.labels},{headers:{Authorization:`token ${n}`}});return i.url=i.html_url,this._issueNodeId=i.node_id,Di(i)}async getComments({accessToken:n,issueId:e,query:{page:t=1,perPage:i=10,sort:r="desc"}={}}){const s={};n&&(s.headers={Authorization:`token ${n}`}),null!==this._pageInfo.sort&&r!==this._pageInfo.sort&&(t=1);const{firstOrLast:o,afterOrBefore:a,cursor:l}=this._getQueryParams({page:t,sort:r}),{data:u}=await this.$http.post("graphql",{variables:{owner:this.owner,repo:this.repo,issueId:e,perPage:i},query:`query getComments(\n  $owner: String!\n  $repo: String!\n  $issueId: Int!\n  $perPage: Int!\n) {\n  repository(owner: $owner, name: $repo) {\n    issue(number: $issueId) {\n      comments(\n        ${o}: $perPage\n        ${null===a?"":`${a}: "${l}"`}\n      ) {\n        totalCount\n        pageInfo {\n          endCursor\n          startCursor\n        }\n        nodes {\n          id\n          body\n          bodyHTML\n          createdAt\n          updatedAt\n          author {\n            avatarUrl\n            login\n            url\n          }\n          reactionGroups {\n            users (first: 0) {\n              totalCount\n            }\n            content\n          }\n        }\n      }\n    }\n  }\n}`},s),c=u.data.repository.issue.comments;return"desc"===r&&c.nodes.reverse(),this._pageInfo={page:t,startCursor:c.pageInfo.startCursor,endCursor:c.pageInfo.endCursor,sort:r,perPage:i},{count:c.totalCount,page:t,perPage:i,data:c.nodes.map(Pi)}}async postComment({accessToken:n,content:e}){const{data:t}=await this.$http.post("graphql",{variables:{issueNodeId:this._issueNodeId,content:e},query:"mutation postComment(\n  $issueNodeId: ID!\n  $content: String!\n) {\n  addComment(\n    input: {\n      subjectId: $issueNodeId\n      body: $content\n    }\n  ) {\n    commentEdge {\n      node {\n        id\n        body\n        bodyHTML\n        createdAt\n        updatedAt\n        author {\n          avatarUrl\n          login\n          url\n        }\n        reactionGroups {\n          users (first: 0) {\n            totalCount\n          }\n          content\n        }\n      }\n    }\n  }\n}"},{headers:{Authorization:`token ${n}`}});return Pi(t.data.addComment.commentEdge.node)}async putComment({accessToken:n,commentId:e,content:t}){const{data:i}=await this.$http.post("graphql",{variables:{commentId:e,content:t},query:"mutation putComment(\n  $commentId: ID!,\n  $content: String!,\n) {\n  updateIssueComment(input: {\n    id: $commentId\n    body: $content\n  }) {\n    issueComment {\n      id\n      body\n      bodyHTML\n      createdAt\n      updatedAt\n      author {\n        avatarUrl\n        login\n        url\n      }\n      reactionGroups {\n        users (first: 0) {\n          totalCount\n        }\n        content\n      }\n    }\n  }\n}"},{headers:{Authorization:`token ${n}`}});return Pi(i.data.updateIssueComment.issueComment)}async deleteComment({accessToken:n,commentId:e}){return await this.$http.post("graphql",{variables:{commentId:e},query:"mutation deleteComment(\n  $commentId: ID!,\n) {\n  deleteIssueComment(input: {\n    id: $commentId\n  }) {\n    clientMutationId\n  }\n}"},{headers:{Authorization:`token ${n}`}}),!0}async getCommentReactions({accessToken:n,issueId:e,commentId:t}){const{firstOrLast:i,afterOrBefore:r,cursor:s}=this._getQueryParams(),{data:o}=await this.$http.post("graphql",{variables:{owner:this.owner,repo:this.repo,issueId:e,perPage:this._pageInfo.perPage},query:`query getComments(\n  $owner: String!\n  $repo: String!\n  $issueId: Int!\n  $perPage: Int!\n) {\n  repository(owner: $owner, name: $repo) {\n    issue(number: $issueId) {\n      comments(\n        ${i}: $perPage\n        ${null===r?"":`${r}: "${s}"`}\n      ) {\n        nodes {\n          id\n          reactionGroups {\n            users (first: 0) {\n              totalCount\n            }\n            content\n          }\n        }\n      }\n    }\n  }\n}`},{headers:{Authorization:`token ${n}`}});return qi(o.data.repository.issue.comments.nodes.find(n=>n.id===t).reactionGroups)}async postCommentReaction({accessToken:n,commentId:e,reaction:t}){return await this.$http.post("graphql",{variables:{commentId:e,content:Mi(t)},query:"mutation postCommentReaction(\n  $commentId: ID!,\n  $content: ReactionContent!,\n) {\n  addReaction(input: {\n    subjectId: $commentId\n    content: $content\n  }) {\n    reaction {\n      databaseId\n    }\n  }\n}"},{headers:{Authorization:`token ${n}`}}),!0}_getQueryParams({page:n=this._pageInfo.page,sort:e=this._pageInfo.sort}={}){let t,i,r;return 1===n?(t="asc"===e?"first":"last",i=null,r=null):"asc"===e?n>this._pageInfo.page?(t="first",i="after",r=this._pageInfo.endCursor):(t="last",i="before",r=this._pageInfo.startCursor):n>this._pageInfo.page?(t="last",i="before",r=this._pageInfo.startCursor):(t="first",i="after",r=this._pageInfo.endCursor),{firstOrLast:t,afterOrBefore:i,cursor:r}}}function zi(n){return{username:n.username,avatar:n.avatar_url,homepage:n.web_url}}function Ri(n){return{id:n.iid,title:n.title,content:n.description,link:n.web_url}}function $i(n){return{id:n.id,content:n.body_html||"",contentRaw:n.body,author:zi(n.author),createdAt:n.created_at,updatedAt:n.updated_at,reactions:n.reactions}}function Ui(n){return{like:n.filter(n=>"thumbsup"===n.name).length,unlike:n.filter(n=>"thumbsdown"===n.name).length,heart:n.filter(n=>"heart"===n.name).length}}function Hi(n){return"like"===n?"thumbsup":"unlike"===n?"thumbsdown":n}class Vi{constructor({baseURL:n="https://gitlab.com",owner:e,repo:t,labels:i,clientId:r,state:s}){this.baseURL=n,this.owner=e,this.repo=t,this.labels=i,this.clientId=r,this.state=s,this._encodedRepo=encodeURIComponent(`${this.owner}/${this.repo}`),this.$http=Ni.a.create({baseURL:Je(n,"api/v4"),headers:{Accept:"application/json"}})}get platform(){return{name:"GitLab",link:this.baseURL,version:"v4",meta:{reactable:!0,sortable:!0}}}redirectAuth(){window.location.href=Ze(Je(this.baseURL,"oauth/authorize"),{client_id:this.clientId,redirect_uri:window.location.href,response_type:"token",state:this.state})}async handleAuth(){const n=Ye(window.location.hash.slice(1));if(!n.access_token||n.state!==this.state)return null;const e=n.access_token;delete n.access_token,delete n.token_type,delete n.expires_in,delete n.state;const t=nt(n),i=t?`#${t}`:"",r=`${Xe(window.location.href)}${window.location.search}${i}`;return window.history.replaceState(null,"",r),e}async getUser({accessToken:n}){const{data:e}=await this.$http.get("user",{headers:{Authorization:`Bearer ${n}`}});return zi(e)}async getIssue({accessToken:n,issueId:e,issueTitle:t}){const i={};if(n&&(i.headers={Authorization:`Bearer ${n}`}),!e){i.params={labels:this.labels.join(","),order_by:"created_at",sort:"asc",search:t};const{data:n}=await this.$http.get(`projects/${this._encodedRepo}/issues`,i);return n.map(Ri).find(n=>n.title===t)||null}try{const{data:n}=await this.$http.get(`projects/${this._encodedRepo}/issues/${e}`,i);return Ri(n)}catch(n){if(n.response&&404===n.response.status)return null;throw n}}async postIssue({accessToken:n,title:e,content:t}){const{data:i}=await this.$http.post(`projects/${this._encodedRepo}/issues`,{title:e,description:t,labels:this.labels.join(",")},{headers:{Authorization:`Bearer ${n}`}});return Ri(i)}async getComments({accessToken:n,issueId:e,query:{page:t=1,perPage:i=10,sort:r="desc"}={}}){const s={params:{page:t,per_page:i,order_by:"created_at",sort:r}};n&&(s.headers={Authorization:`Bearer ${n}`});const o=await this.$http.get(`projects/${this._encodedRepo}/issues/${e}/notes`,s),a=o.data,l=[];for(const t of a)l.push((async()=>{t.body_html=await this.getMarkdownContent({accessToken:n,contentRaw:t.body})})()),l.push((async()=>{t.reactions=await this.getCommentReactions({accessToken:n,issueId:e,commentId:t.id})})());return await Promise.all(l),{count:Number(o.headers["x-total"]),page:Number(o.headers["x-page"]),perPage:Number(o.headers["x-per-page"]),data:a.map($i)}}async postComment({accessToken:n,issueId:e,content:t}){const{data:i}=await this.$http.post(`projects/${this._encodedRepo}/issues/${e}/notes`,{body:t},{headers:{Authorization:`Bearer ${n}`}});return $i(i)}async putComment({accessToken:n,issueId:e,commentId:t,content:i}){const{data:r}=await this.$http.put(`projects/${this._encodedRepo}/issues/${e}/notes/${t}`,{body:i},{headers:{Authorization:`Bearer ${n}`}}),[s,o]=await Promise.all([this.getMarkdownContent({accessToken:n,contentRaw:r.body}),this.getCommentReactions({accessToken:n,issueId:e,commentId:r.id})]);return r.body_html=s,r.reactions=o,$i(r)}async deleteComment({accessToken:n,issueId:e,commentId:t}){const{status:i}=await this.$http.delete(`projects/${this._encodedRepo}/issues/${e}/notes/${t}`,{headers:{Authorization:`Bearer ${n}`}});return 204===i}async getCommentReactions({accessToken:n,issueId:e,commentId:t}){const{data:i}=await this.$http.get(`projects/${this._encodedRepo}/issues/${e}/notes/${t}/award_emoji`,{headers:{Authorization:`Bearer ${n}`}});return Ui(i)}async postCommentReaction({issueId:n,commentId:e,reaction:t,accessToken:i}){try{return 201===(await this.$http.post(`projects/${this._encodedRepo}/issues/${n}/notes/${e}/award_emoji`,{name:Hi(t)},{headers:{Authorization:`Bearer ${i}`}})).status}catch(n){if(n.response&&404===n.response.status)return!1;throw n}}async getMarkdownContent({accessToken:n,contentRaw:e}){const t={};n&&(t.headers={Authorization:`Bearer ${n}`});const{data:i}=await this.$http.post("markdown",{text:e,gfm:!0},t);return i.html}}function Wi(n){return{username:n.nickname,avatar:n.links.avatar.href,homepage:n.links.html.href}}function Ki(n){return{id:n.id,title:n.title,content:n.content.raw,link:n.links.html.href}}function Qi(n){return{id:n.id,content:n.content.html,contentRaw:n.content.raw,author:Wi(n.user),createdAt:n.created_on,updatedAt:n.updated_on,reactions:null}}class Gi{constructor({baseURL:n="https://bitbucket.org",owner:e,repo:t,clientId:i,state:r}){this.baseURL=n,this.owner=e,this.repo=t,this.clientId=i,this.state=r,this.$http=Ni.a.create({baseURL:"https://api.bitbucket.org/2.0",headers:{Accept:"application/json"}})}get platform(){return{name:"Bitbucket",link:this.baseURL,version:"v2",meta:{reactable:!1,sortable:!0}}}redirectAuth(){window.location.href=Ze(Je(this.baseURL,"site/oauth2/authorize"),{client_id:this.clientId,redirect_uri:window.location.href,response_type:"token",state:this.state})}async handleAuth(){const n=Ye(window.location.hash.slice(1));if(!n.access_token||n.state!==this.state)return null;const e=n.access_token;delete n.access_token,delete n.token_type,delete n.expires_in,delete n.state,delete n.scopes;const t=nt(n),i=t?`#${t}`:"",r=`${Xe(window.location.href)}${window.location.search}${i}`;return window.history.replaceState(null,"",r),e}async getUser({accessToken:n}){const{data:e}=await this.$http.get("user",{headers:{Authorization:`Bearer ${n}`}});return Wi(e)}async getIssue({accessToken:n,issueId:e,issueTitle:t}){const i={};if(n&&(i.headers={Authorization:`Bearer ${n}`}),!e){i.params={sort:"created_on",q:`title="${t}"`,timestamp:Date.now()};const{data:n}=await this.$http.get(`repositories/${this.owner}/${this.repo}/issues`,i);return n.size>0?Ki(n.values[0]):null}try{i.params={timestamp:Date.now()};const{data:n}=await this.$http.get(`repositories/${this.owner}/${this.repo}/issues/${e}`,i);return Ki(n)}catch(n){if(n.response&&404===n.response.status)return null;throw n}}async postIssue({accessToken:n,title:e,content:t}){const{data:i}=await this.$http.post(`repositories/${this.owner}/${this.repo}/issues`,{title:e,content:{raw:t},priority:"trivial",kind:"task"},{headers:{Authorization:`Bearer ${n}`}});return i.links.html={href:Je(this.baseURL,`${this.owner}/${this.repo}/issues/${i.id}`)},Ki(i)}async getComments({accessToken:n,issueId:e,query:{page:t=1,perPage:i=10,sort:r="desc"}={}}){const s={params:{page:t,pagelen:i,sort:"desc"===r?"-created_on":"created_on",timestamp:Date.now()}};n&&(s.headers={Authorization:`Bearer ${n}`});const{data:o}=await this.$http.get(`repositories/${this.owner}/${this.repo}/issues/${e}/comments`,s);return{count:o.size,page:o.page,perPage:o.pagelen,data:o.values.filter(n=>null!==n.content.raw).map(Qi)}}async postComment({accessToken:n,issueId:e,content:t}){const{data:i}=await this.$http.post(`repositories/${this.owner}/${this.repo}/issues/${e}/comments`,{content:{raw:t}},{headers:{Authorization:`Bearer ${n}`}});return Qi(i)}async putComment({accessToken:n,issueId:e,commentId:t,content:i}){const{data:r}=await this.$http.put(`repositories/${this.owner}/${this.repo}/issues/${e}/comments/${t}`,{content:{raw:i}},{headers:{Authorization:`Bearer ${n}`}});return Qi(r)}async deleteComment({accessToken:n,issueId:e,commentId:t}){const{status:i}=await this.$http.delete(`repositories/${this.owner}/${this.repo}/issues/${e}/comments/${t}`,{headers:{Authorization:`Bearer ${n}`}});return 204===i}async getCommentReactions(n){throw new Error("501 Not Implemented")}async postCommentReaction(n){throw new Error("501 Not Implemented")}}function Zi(n){return{username:n.login,avatar:n.avatar_url,homepage:n.html_url}}function Ji(n){return{id:n.number,title:n.title,content:n.body,link:n.html_url}}function Xi(n){return{id:n.id,content:n.body_html||"",contentRaw:n.body,author:Zi(n.user),createdAt:n.created_at,updatedAt:n.updated_at||"",reactions:null}}class Yi{constructor({baseURL:n="https://gitee.com",owner:e,repo:t,labels:i,clientId:r,clientSecret:s,state:o,proxy:a}){if(void 0===s||void 0===a)throw new Error("clientSecret and proxy is required for Gitee V5");this.baseURL=n,this.owner=e,this.repo=t,this.labels=i,this.clientId=r,this.clientSecret=s,this.state=o,this.proxy=a,this.$http=Ni.a.create({baseURL:Je(n,"api/v5")}),this.$http.interceptors.response.use(n=>n,n=>(n.response.data&&n.response.data.message&&(n.message=n.response.data.message),Promise.reject(n)))}get platform(){return{name:"Gitee",link:this.baseURL,version:"v5",meta:{reactable:!1,sortable:!1}}}redirectAuth(){window.location.href=Ze(Je(this.baseURL,"oauth/authorize"),{client_id:this.clientId,redirect_uri:window.location.href,scope:"user_info issues notes",response_type:"code",state:this.state})}async handleAuth(){const n=Ye(window.location.search);if(n.code){if(n.state!==this.state)return null;const e=n.code;delete n.code,delete n.state;const t=Ze(Xe(window.location.href),n)+window.location.hash;return window.history.replaceState(null,"",t),await this.getAccessToken({code:e})}return null}async getAccessToken({code:n}){const e=Je(this.baseURL,"oauth/token"),t="function"==typeof this.proxy?this.proxy(e):this.proxy,{data:i}=await this.$http.post(t,{client_id:this.clientId,client_secret:this.clientSecret,code:n,grant_type:"authorization_code",redirect_uri:window.location.href});return i.access_token}async getUser({accessToken:n}){const{data:e}=await this.$http.get("user",{params:{access_token:n}});return Zi(e)}async getIssue({accessToken:n,issueId:e,issueTitle:t}){const i={params:{}};if(n&&(i.params.access_token=n),!e){Object.assign(i.params,{q:t,repo:`${this.owner}/${this.repo}`,per_page:1});const{data:n}=await this.$http.get("search/issues",i);return n.map(Ji).find(n=>n.title===t)||null}try{const{data:n}=await this.$http.get(`repos/${this.owner}/${this.repo}/issues/${e}`,i);return Ji(n)}catch(n){if(n.response&&404===n.response.status)return null;throw n}}async postIssue({accessToken:n,title:e,content:t}){const{data:i}=await this.$http.post(`repos/${this.owner}/issues`,{access_token:n,repo:this.repo,title:e,body:t,labels:this.labels.join(",")});return Ji(i)}async getComments({accessToken:n,issueId:e,query:{page:t=1,perPage:i=10}={}}){const r={params:{page:t,per_page:i},headers:{Accept:["application/vnd.gitee.html+json"]}};n&&(r.params.access_token=n);const s=await this.$http.get(`repos/${this.owner}/${this.repo}/issues/${e}/comments`,r);return{count:Number(s.headers.total_count),page:t,perPage:i,data:s.data.map(Xi)}}async postComment({accessToken:n,issueId:e,content:t}){const{data:i}=await this.$http.post(`repos/${this.owner}/${this.repo}/issues/${e}/comments`,{body:t,access_token:n},{headers:{Accept:["application/vnd.gitee.html+json"]}});return Xi(i)}async putComment({accessToken:n,commentId:e,content:t}){const{data:i}=await this.$http.patch(`repos/${this.owner}/${this.repo}/issues/comments/${e}`,{body:t,access_token:n},{headers:{Accept:["application/vnd.gitee.html+json"]}});return Xi(i)}async deleteComment({accessToken:n,commentId:e}){const{status:t}=await this.$http.delete(`repos/${this.owner}/${this.repo}/issues/comments/${e}`,{params:{access_token:n}});return 204===t}async getCommentReactions(n){throw new Error("501 Not Implemented")}async postCommentReaction(n){throw new Error("501 Not Implemented")}}t(171);function nr(n,e){var t=Object.keys(n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(n);e&&(i=i.filter((function(e){return Object.getOwnPropertyDescriptor(n,e).enumerable}))),t.push.apply(t,i)}return t}var er={name:"Vssue",components:{VssueComponent:ji},props:{options:{type:Object,default:function(){return{}}}},data:function(){return{key:"key",platformOptions:{github:Ci,"github-v4":Fi,gitlab:Vi,bitbucket:Gi,gitee:Yi}}},computed:{vssueOptions:function(){var n=this.platformOptions,e=this.options;return function(n){for(var e=1;e<arguments.length;e++){var t=null!=arguments[e]?arguments[e]:{};e%2?nr(Object(t),!0).forEach((function(e){Object(ke.a)(n,e,t[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(t)):nr(Object(t)).forEach((function(e){Object.defineProperty(n,e,Object.getOwnPropertyDescriptor(t,e))}))}return n}({},e,{api:n[e.platform]})}},watch:{$route:function(n,e){var t=this;n.path!==e.path&&setTimeout((function(){t.key="reco-".concat((new Date).getTime())}),300)}}},tr=(t(172),{components:{Valine:_e,Vssue:Object(de.a)(er,(function(){var n=this.$createElement;return(this._self._c||n)("VssueComponent",{key:this.key,staticClass:"vssue-wrapper",attrs:{options:this.vssueOptions}})}),[],!1,null,null,null).exports},props:{isShowComments:{type:Boolean,default:!0}},data:function(){return{commentsOptions:{}}},computed:{solution:function(){var n=this.commentsOptions.solution,e=this.$themeConfig,t=e.valineConfig,i=e.vssueConfig,r="";return void 0!==n?r=n:void 0!==t?r="valine":void 0!==i&&(r="vssue"),this.$themeConfig.commentsSolution=r,r},options:function(){var n=this.commentsOptions.options,e=this.$themeConfig,t=e.valineConfig,i=e.vssueConfig;return void 0!==n?n:void 0!==t?t:void 0!==i?i:null},componentName:function(){var n=this.solution;return"valine"===n?"Valine":"vssue"===n?"Vssue":""}}}),ir=Object(de.a)(tr,(function(){var n=this.$createElement,e=this._self._c||n;return e("div",{directives:[{name:"show",rawName:"v-show",value:this.isShowComments,expression:"isShowComments"}],staticClass:"comments-wrapper"},[e(this.componentName,{tag:"component",attrs:{options:this.options}})],1)}),[],!1,null,null,null).exports,rr={props:{idVal:String,numStyle:Object,flagTitle:{type:String,default:"Your Article Title"}},methods:{getIdVal:function(n){var e=this.$site.base;return e.slice(0,e.length-1)+n}}},sr=Object(de.a)(rr,(function(){var n=this.$createElement,e=this._self._c||n;return this.$themeConfig.valineConfig&&0!=this.$themeConfig.valineConfig.visitor?e("span",{staticClass:"leancloud-visitors",attrs:{id:this.getIdVal(this.idVal),"data-flag-title":this.flagTitle}},[e("a",{staticClass:"leancloud-visitors-count",style:this.numStyle})]):this._e()}),[],!1,null,null,null).exports,or=(t(173),{tags:{"链表<Linked List>":{key:"链表<Linked List>",scope:"tags",path:"/tags/链表<Linked List>/",pageKeys:["v-872b1f36","v-7541876e","v-2b081e4c","v-09fa2471","v-70fe855a","v-25ece19a","v-0aae0649","v-f3ca02fe","v-17a4fc23","v-896f1fde","v-1b66e8d5","v-f3fd332e","v-371682cc","v-638027b4","v-1f24f964"]},"数学<Math>":{key:"数学<Math>",scope:"tags",path:"/tags/数学<Math>/",pageKeys:["v-872b1f36","v-a45a98cc","v-39824ad2","v-4772a9c6","v-f20421d4","v-1146fde9","v-72c7019a","v-964e1e2e","v-31ede314","v-fa980d7a","v-58dab6f5","v-a44527a2","v-1b5e2caa","v-695ff01c","v-35ed2a6a","v-c89f9d26","v-9df561a4","v-2fc6e32b"]},"哈希表<Hash Table>":{key:"哈希表<Hash Table>",scope:"tags",path:"/tags/哈希表<Hash Table>/",pageKeys:["v-51a0a422","v-37e48825","v-4cbecd9d","v-a45ead70","v-2f5ba20c","v-4f4e8ede","v-9b996c72","v-0a7ef002","v-0cf96847","v-a44527a2","v-1b5e2caa","v-c12cd844","v-386f1cf4","v-3febb966","v-0e89010e","v-3f69c3c2","v-24aef886","v-33b19a42","v-57525a9a","v-0d795ffd","v-2d78303e","v-3f33cfdc","v-622c1825"]},"双指针<Two Pointers>":{key:"双指针<Two Pointers>",scope:"tags",path:"/tags/双指针<Two Pointers>/",pageKeys:["v-51a0a422","v-7541876e","v-4779f67f","v-29c9103a","v-92619eec","v-69c9e716","v-09fa2471","v-78dbd082","v-237c778e","v-78f01504","v-3caa00fc","v-22fe62f0","v-ccf835da","v-a3978ed0","v-1676ace0","v-896f1fde","v-2f53649e","v-72faf49f","v-f36f62ca","v-24aef886","v-33b19a42","v-5bdc57ee"]},"字符串<String>":{key:"字符串<String>",scope:"tags",path:"/tags/字符串<String>/",pageKeys:["v-51a0a422","v-082f848c","v-27f937b5","v-37e48825","v-3bb3d58a","v-7dcfc1d7","v-d999d50a","v-72c7019a","v-dd4bf7e4","v-22fe62f0","v-964e1e2e","v-eab508ce","v-a3978ed0","v-72faf49f","v-f36f62ca","v-57525a9a","v-4a51aa00","v-536bbb82"]},"Sliding Window":{key:"Sliding Window",scope:"tags",path:"/tags/Sliding Window/",pageKeys:["v-51a0a422"]},"回溯算法<Backtracking>":{key:"回溯算法<Backtracking>",scope:"tags",path:"/tags/回溯算法<Backtracking>/",pageKeys:["v-082f848c","v-40896626","v-1efc4839","v-4ed2f72c","v-46d8099a","v-27f937b5","v-7c92bd0a","v-4ec67454","v-67f0bc42","v-636b4c6e","v-7dcfc1d7","v-f54f2200","v-3e57534e","v-0677f7bb"]},"数组<Array>":{key:"数组<Array>",scope:"tags",path:"/tags/数组<Array>/",pageKeys:["v-4779f67f","v-69743892","v-40896626","v-29c9103a","v-1efc4839","v-662329a2","v-4b70cbd6","v-92619eec","v-0e1774ab","v-7c92bd0a","v-67f0bc42","v-69c9e716","v-636b4c6e","v-4aeac5ec","v-78dbd082","v-3e57534e","v-237c778e","v-0a7ef002","v-78f01504","v-7cecf4db","v-3caa00fc","v-86ef19d0","v-08aa0349","v-ccf835da","v-9c035a4c","v-3d43ded6","v-0bb21a4d","v-1676ace0","v-6f1770fa","v-683b2412","v-386f1cf4","v-3febb966","v-35ed2a6a","v-2f53649e","v-55c55936","v-25479726","v-3529fb88","v-54968448","v-78bc8af7","v-21d82b43","v-4f4bf9f6","v-6a8c0a12","v-75e2436c","v-6d5a9f28","v-493516c6","v-2bbe7c80","v-71aae79a","v-a8e7c0ea","v-0aece9fa","v-c077fb86","v-3f33cfdc","v-622c1825"]},"二分查找<Binary Search>":{key:"二分查找<Binary Search>",scope:"tags",path:"/tags/二分查找<Binary Search>/",pageKeys:["v-69743892","v-a45a98cc","v-78dbd082","v-239b7bef","v-49ca1f81","v-4f2683df","v-9b996c72","v-7cecf4db","v-31ede314","v-1676ace0","v-b9ae42f8","v-24aef886","v-33b19a42","v-9549f80c","v-c89f9d26","v-22e5cd39","v-0b39ac5e"]},"递归<Recursion>":{key:"递归<Recursion>",scope:"tags",path:"/tags/递归<Recursion>/",pageKeys:["v-2b081e4c","v-559cfd35","v-64944eae"]},"动态规划<Dynamic Programming>":{key:"动态规划<Dynamic Programming>",scope:"tags",path:"/tags/动态规划<Dynamic Programming>/",pageKeys:["v-662329a2","v-4b70cbd6","v-0e1774ab","v-3bb3d58a","v-4aeac5ec","v-7d3d3b3c","v-39824ad2","v-4f2683df","v-59e03967","v-36ec1cda","v-4772a9c6","v-fedf490e","v-b2977cb0","v-86ef19d0","v-49990e49","v-3d43ded6","v-0d83ecdc","v-b8b51226","v-4f4bf9f6"]},"排序<Sort>":{key:"排序<Sort>",scope:"tags",path:"/tags/排序<Sort>/",pageKeys:["v-92619eec","v-0c1dc4cd","v-0e89010e","v-24aef886","v-33b19a42"]},"位运算<Bit Manipulation>":{key:"位运算<Bit Manipulation>",scope:"tags",path:"/tags/位运算<Bit Manipulation>/",pageKeys:["v-7c92bd0a","v-0cf96847","v-6f1770fa","v-35ed2a6a","v-487d573a"]},"栈<Stack>":{key:"栈<Stack>",scope:"tags",path:"/tags/栈<Stack>/",pageKeys:["v-4cbecd9d","v-b7e2d1be","v-6fab22e5","v-172d1308","v-b27509c4","v-dd4bf7e4","v-35262026","v-c9f395f0","v-e1b467a8","v-5bdc57ee","v-0e65eec4"]},"树<Tree>":{key:"树<Tree>",scope:"tags",path:"/tags/树<Tree>/",pageKeys:["v-4cbecd9d","v-78c30bf4","v-08021f6f","v-4fb1a763","v-b7e2d1be","v-94273df0","v-172d1308","v-239b7bef","v-0d191fb0","v-64e21c1e","v-b27509c4","v-0e59c80c","v-cb8dcbd0","v-1f930831","v-8f131bfc","v-9e31a4c2","v-41f9c21d","v-7727e773","v-c37cfd5c","v-6a1a8aca","v-eacea4c0","v-812258f8","v-861ad970","v-fa0e71a0","v-17bb9e2d","v-6384368a"]},"深度优先搜索<Depth-first Search>":{key:"深度优先搜索<Depth-first Search>",scope:"tags",path:"/tags/深度优先搜索<Depth-first Search>/",pageKeys:["v-78c30bf4","v-4fb1a763","v-94273df0","v-6ba46688","v-f54f2200","v-0d191fb0","v-0e59c80c","v-cb8dcbd0","v-8f131bfc","v-9e31a4c2","v-41f9c21d","v-7727e773","v-c37cfd5c","v-812258f8"]},"广度优先搜索<Breadth-first Search>":{key:"广度优先搜索<Breadth-first Search>",scope:"tags",path:"/tags/广度优先搜索<Breadth-first Search>/",pageKeys:["v-08021f6f","v-b7e2d1be","v-6ba46688","v-39824ad2","v-cb8dcbd0","v-1f930831","v-c37cfd5c"]},"并查集<Union Find>":{key:"并查集<Union Find>",scope:"tags",path:"/tags/并查集<Union Find>/",pageKeys:["v-6ba46688"]},"设计<Design>":{key:"设计<Design>",scope:"tags",path:"/tags/设计<Design>/",pageKeys:["v-2a6bb239","v-f54f2200","v-35262026","v-0e65eec4"]},"字典树<Trie>":{key:"字典树<Trie>",scope:"tags",path:"/tags/字典树<Trie>/",pageKeys:["v-2a6bb239","v-f54f2200"]},"堆<Heap>":{key:"堆<Heap>",scope:"tags",path:"/tags/堆<Heap>/",pageKeys:["v-5cfb85d7","v-a45ead70","v-4f4e8ede","v-25ece19a"]},"分治算法<Divide and Conquer>":{key:"分治算法<Divide and Conquer>",scope:"tags",path:"/tags/分治算法<Divide and Conquer>/",pageKeys:["v-5cfb85d7","v-49ca1f81","v-25ece19a","v-7016069a","v-86ef19d0","v-6f1770fa"]},"Ordered Map":{key:"Ordered Map",scope:"tags",path:"/tags/Ordered Map/",pageKeys:["v-0c1dc4cd"]},"树状数组<Binary Indexed Tree>":{key:"树状数组<Binary Indexed Tree>",scope:"tags",path:"/tags/树状数组<Binary Indexed Tree>/",pageKeys:["v-a8cd2084"]},"线段树<Segment Tree>":{key:"线段树<Segment Tree>",scope:"tags",path:"/tags/线段树<Segment Tree>/",pageKeys:["v-a8cd2084"]},"贪心算法<Greedy>":{key:"贪心算法<Greedy>",scope:"tags",path:"/tags/贪心算法<Greedy>/",pageKeys:["v-4b6669ef","v-16b46357"]},"脑筋急转弯<Brainteaser>":{key:"脑筋急转弯<Brainteaser>",scope:"tags",path:"/tags/脑筋急转弯<Brainteaser>/",pageKeys:["v-d3e8a800"]},"几何<Geometry>":{key:"几何<Geometry>",scope:"tags",path:"/tags/几何<Geometry>/",pageKeys:["v-493516c6"]}},categories:{"中等":{key:"中等",scope:"categories",path:"/categories/中等/",pageKeys:["v-872b1f36","v-51a0a422","v-7541876e","v-082f848c","v-4779f67f","v-69743892","v-40896626","v-2b081e4c","v-29c9103a","v-1efc4839","v-4ed2f72c","v-46d8099a","v-27f937b5","v-662329a2","v-37e48825","v-4b70cbd6","v-92619eec","v-0e1774ab","v-7c92bd0a","v-4ec67454","v-67f0bc42","v-69c9e716","v-09fa2471","v-a45a98cc","v-636b4c6e","v-4cbecd9d","v-3bb3d58a","v-70fe855a","v-7dcfc1d7","v-78c30bf4","v-08021f6f","v-4fb1a763","v-b7e2d1be","v-4aeac5ec","v-94273df0","v-6fab22e5","v-6ba46688","v-2a6bb239","v-78dbd082","v-172d1308","v-f54f2200","v-7d3d3b3c","v-5cfb85d7","v-3e57534e","v-0c1dc4cd","v-239b7bef","v-a8cd2084","v-39824ad2","v-49ca1f81","v-4f2683df","v-59e03967","v-36ec1cda","v-0d191fb0","v-4772a9c6","v-a45ead70","v-fedf490e","v-b2977cb0","v-4b6669ef","v-64e21c1e","v-2f5ba20c","v-4f4e8ede","v-9b996c72","v-237c778e"]},"困难":{key:"困难",scope:"categories",path:"/categories/困难/",pageKeys:["v-25ece19a","v-0677f7bb","v-b27509c4","v-7016069a"]},"简单":{key:"简单",scope:"categories",path:"/categories/简单/",pageKeys:["v-0a7ef002","v-f20421d4","v-1146fde9","v-d999d50a","v-72c7019a","v-0aae0649","v-78f01504","v-7cecf4db","v-dd4bf7e4","v-3caa00fc","v-22fe62f0","v-964e1e2e","v-eab508ce","v-86ef19d0","v-08aa0349","v-f3ca02fe","v-31ede314","v-49990e49","v-0e59c80c","v-ccf835da","v-cb8dcbd0","v-1f930831","v-8f131bfc","v-9e31a4c2","v-41f9c21d","v-7727e773","v-9c035a4c","v-c37cfd5c","v-3d43ded6","v-a3978ed0","v-0bb21a4d","v-0cf96847","v-1676ace0","v-fa980d7a","v-35262026","v-17a4fc23","v-6f1770fa","v-58dab6f5","v-896f1fde","v-683b2412","v-0d83ecdc","v-a44527a2","v-1b66e8d5","v-1b5e2caa","v-f3fd332e","v-c12cd844","v-695ff01c","v-386f1cf4","v-6a1a8aca","v-3febb966","v-eacea4c0","v-0e89010e","v-371682cc","v-812258f8","v-35ed2a6a","v-b9ae42f8","v-2f53649e","v-3f69c3c2","v-b8b51226","v-72faf49f","v-f36f62ca","v-24aef886","v-33b19a42","v-57525a9a","v-861ad970","v-9549f80c","v-c89f9d26","v-4a51aa00","v-0d795ffd","v-16b46357","v-fa0e71a0","v-487d573a","v-55c55936","v-25479726","v-3529fb88","v-17bb9e2d","v-9df561a4","v-54968448","v-78bc8af7","v-6384368a","v-21d82b43","v-2fc6e32b","v-22e5cd39","v-4f4bf9f6","v-c9f395f0","v-6a8c0a12","v-2d78303e","v-e1b467a8","v-0b39ac5e","v-536bbb82","v-75e2436c","v-6d5a9f28","v-638027b4","v-d3e8a800","v-5bdc57ee","v-493516c6","v-2bbe7c80","v-71aae79a","v-a8e7c0ea","v-0aece9fa","v-c077fb86","v-3f33cfdc","v-622c1825","v-1bff81f9","v-1f24f964","v-0e65eec4","v-559cfd35","v-64944eae"]}},timeline:{}});class ar{constructor(n,e){this._metaMap=Object.assign({},n),Object.keys(this._metaMap).forEach(n=>{const{pageKeys:t}=this._metaMap[n];this._metaMap[n].pages=t.map(n=>Object(Rn.b)(e,n))})}get length(){return Object.keys(this._metaMap).length}get map(){return this._metaMap}get pages(){return this.list}get list(){return this.toArray()}toArray(){const n=[];return Object.keys(this._metaMap).forEach(e=>{const{pages:t,path:i}=this._metaMap[e];n.push({name:e,pages:t,path:i})}),n}getItemByName(n){return this._metaMap[n]}}var lr={tags:(n,e)=>new Date(n.frontmatter.date).getTime()-new Date(e.frontmatter.date).getTime()>0?-1:1,categories:(n,e)=>new Date(n.frontmatter.date).getTime()-new Date(e.frontmatter.date).getTime()>0?-1:1},ur={tags:function(n,e,t){const i=e;return["tags"].some(e=>{const t=n.frontmatter[e];return Array.isArray(t)?t.some(n=>n===i):t===i})},categories:function(n,e,t){const i=e;return["categories"].some(e=>{const t=n.frontmatter[e];return Array.isArray(t)?t.some(n=>n===i):t===i})}},cr=[{pid:"tags",id:"链表<Linked List>",filter:ur.tags,sorter:lr.tags,pages:[{path:"/tags/链表<Linked List>/",interval:[0,9]},{path:"/tags/链表<Linked List>/page/2/",interval:[10,15]}]},{pid:"tags",id:"数学<Math>",filter:ur.tags,sorter:lr.tags,pages:[{path:"/tags/数学<Math>/",interval:[0,9]},{path:"/tags/数学<Math>/page/2/",interval:[10,18]}]},{pid:"tags",id:"哈希表<Hash Table>",filter:ur.tags,sorter:lr.tags,pages:[{path:"/tags/哈希表<Hash Table>/",interval:[0,9]},{path:"/tags/哈希表<Hash Table>/page/2/",interval:[10,19]},{path:"/tags/哈希表<Hash Table>/page/3/",interval:[20,23]}]},{pid:"tags",id:"双指针<Two Pointers>",filter:ur.tags,sorter:lr.tags,pages:[{path:"/tags/双指针<Two Pointers>/",interval:[0,9]},{path:"/tags/双指针<Two Pointers>/page/2/",interval:[10,19]},{path:"/tags/双指针<Two Pointers>/page/3/",interval:[20,22]}]},{pid:"tags",id:"字符串<String>",filter:ur.tags,sorter:lr.tags,pages:[{path:"/tags/字符串<String>/",interval:[0,9]},{path:"/tags/字符串<String>/page/2/",interval:[10,18]}]},{pid:"tags",id:"Sliding Window",filter:ur.tags,sorter:lr.tags,pages:[{path:"/tags/Sliding Window/",interval:[0,1]}]},{pid:"tags",id:"回溯算法<Backtracking>",filter:ur.tags,sorter:lr.tags,pages:[{path:"/tags/回溯算法<Backtracking>/",interval:[0,9]},{path:"/tags/回溯算法<Backtracking>/page/2/",interval:[10,14]}]},{pid:"tags",id:"数组<Array>",filter:ur.tags,sorter:lr.tags,pages:[{path:"/tags/数组<Array>/",interval:[0,9]},{path:"/tags/数组<Array>/page/2/",interval:[10,19]},{path:"/tags/数组<Array>/page/3/",interval:[20,29]},{path:"/tags/数组<Array>/page/4/",interval:[30,39]},{path:"/tags/数组<Array>/page/5/",interval:[40,49]},{path:"/tags/数组<Array>/page/6/",interval:[50,52]}]},{pid:"tags",id:"二分查找<Binary Search>",filter:ur.tags,sorter:lr.tags,pages:[{path:"/tags/二分查找<Binary Search>/",interval:[0,9]},{path:"/tags/二分查找<Binary Search>/page/2/",interval:[10,17]}]},{pid:"tags",id:"递归<Recursion>",filter:ur.tags,sorter:lr.tags,pages:[{path:"/tags/递归<Recursion>/",interval:[0,3]}]},{pid:"tags",id:"动态规划<Dynamic Programming>",filter:ur.tags,sorter:lr.tags,pages:[{path:"/tags/动态规划<Dynamic Programming>/",interval:[0,9]},{path:"/tags/动态规划<Dynamic Programming>/page/2/",interval:[10,19]}]},{pid:"tags",id:"排序<Sort>",filter:ur.tags,sorter:lr.tags,pages:[{path:"/tags/排序<Sort>/",interval:[0,5]}]},{pid:"tags",id:"位运算<Bit Manipulation>",filter:ur.tags,sorter:lr.tags,pages:[{path:"/tags/位运算<Bit Manipulation>/",interval:[0,5]}]},{pid:"tags",id:"栈<Stack>",filter:ur.tags,sorter:lr.tags,pages:[{path:"/tags/栈<Stack>/",interval:[0,9]},{path:"/tags/栈<Stack>/page/2/",interval:[10,11]}]},{pid:"tags",id:"树<Tree>",filter:ur.tags,sorter:lr.tags,pages:[{path:"/tags/树<Tree>/",interval:[0,9]},{path:"/tags/树<Tree>/page/2/",interval:[10,19]},{path:"/tags/树<Tree>/page/3/",interval:[20,26]}]},{pid:"tags",id:"深度优先搜索<Depth-first Search>",filter:ur.tags,sorter:lr.tags,pages:[{path:"/tags/深度优先搜索<Depth-first Search>/",interval:[0,9]},{path:"/tags/深度优先搜索<Depth-first Search>/page/2/",interval:[10,14]}]},{pid:"tags",id:"广度优先搜索<Breadth-first Search>",filter:ur.tags,sorter:lr.tags,pages:[{path:"/tags/广度优先搜索<Breadth-first Search>/",interval:[0,7]}]},{pid:"tags",id:"并查集<Union Find>",filter:ur.tags,sorter:lr.tags,pages:[{path:"/tags/并查集<Union Find>/",interval:[0,1]}]},{pid:"tags",id:"设计<Design>",filter:ur.tags,sorter:lr.tags,pages:[{path:"/tags/设计<Design>/",interval:[0,4]}]},{pid:"tags",id:"字典树<Trie>",filter:ur.tags,sorter:lr.tags,pages:[{path:"/tags/字典树<Trie>/",interval:[0,2]}]},{pid:"tags",id:"堆<Heap>",filter:ur.tags,sorter:lr.tags,pages:[{path:"/tags/堆<Heap>/",interval:[0,4]}]},{pid:"tags",id:"分治算法<Divide and Conquer>",filter:ur.tags,sorter:lr.tags,pages:[{path:"/tags/分治算法<Divide and Conquer>/",interval:[0,6]}]},{pid:"tags",id:"Ordered Map",filter:ur.tags,sorter:lr.tags,pages:[{path:"/tags/Ordered Map/",interval:[0,1]}]},{pid:"tags",id:"树状数组<Binary Indexed Tree>",filter:ur.tags,sorter:lr.tags,pages:[{path:"/tags/树状数组<Binary Indexed Tree>/",interval:[0,1]}]},{pid:"tags",id:"线段树<Segment Tree>",filter:ur.tags,sorter:lr.tags,pages:[{path:"/tags/线段树<Segment Tree>/",interval:[0,1]}]},{pid:"tags",id:"贪心算法<Greedy>",filter:ur.tags,sorter:lr.tags,pages:[{path:"/tags/贪心算法<Greedy>/",interval:[0,2]}]},{pid:"tags",id:"脑筋急转弯<Brainteaser>",filter:ur.tags,sorter:lr.tags,pages:[{path:"/tags/脑筋急转弯<Brainteaser>/",interval:[0,1]}]},{pid:"tags",id:"几何<Geometry>",filter:ur.tags,sorter:lr.tags,pages:[{path:"/tags/几何<Geometry>/",interval:[0,1]}]},{pid:"categories",id:"中等",filter:ur.categories,sorter:lr.categories,pages:[{path:"/categories/中等/",interval:[0,9]},{path:"/categories/中等/page/2/",interval:[10,19]},{path:"/categories/中等/page/3/",interval:[20,29]},{path:"/categories/中等/page/4/",interval:[30,39]},{path:"/categories/中等/page/5/",interval:[40,49]},{path:"/categories/中等/page/6/",interval:[50,59]},{path:"/categories/中等/page/7/",interval:[60,63]}]},{pid:"categories",id:"困难",filter:ur.categories,sorter:lr.categories,pages:[{path:"/categories/困难/",interval:[0,4]}]},{pid:"categories",id:"简单",filter:ur.categories,sorter:lr.categories,pages:[{path:"/categories/简单/",interval:[0,9]},{path:"/categories/简单/page/2/",interval:[10,19]},{path:"/categories/简单/page/3/",interval:[20,29]},{path:"/categories/简单/page/4/",interval:[30,39]},{path:"/categories/简单/page/5/",interval:[40,49]},{path:"/categories/简单/page/6/",interval:[50,59]},{path:"/categories/简单/page/7/",interval:[60,69]},{path:"/categories/简单/page/8/",interval:[70,79]},{path:"/categories/简单/page/9/",interval:[80,89]},{path:"/categories/简单/page/10/",interval:[90,99]},{path:"/categories/简单/page/11/",interval:[100,108]}]}],dr=t(87);const mr=t.n(dr)()("plugin-blog:pagination");class pr{constructor(n,e,t){mr(n);const{pages:i}=n,{path:r}=t;for(let n=0,e=i.length;n<e;n++){if(i[n].path===r){this.paginationIndex=n;break}}this.paginationIndex||(this.paginationIndex=0),this._paginationPages=i,this._currentPage=i[this.paginationIndex],this._matchedPages=e.filter(e=>n.filter(e,n.id,n.pid)).sort(n.sorter)}setIndexPage(n){this._indexPage=n}get length(){return this._paginationPages.length}get pages(){const[n,e]=this._currentPage.interval;return this._matchedPages.slice(n,e+1)}get hasPrev(){return 0!==this.paginationIndex}get prevLink(){return this.hasPrev?this.paginationIndex-1==0&&this._indexPage?this._indexPage:this._paginationPages[this.paginationIndex-1].path:null}get hasNext(){return this.paginationIndex!==this.length-1}get nextLink(){return this.hasNext?this._paginationPages[this.paginationIndex+1].path:null}getSpecificPageLink(n){return this._paginationPages[n].path}}const hr=new class{constructor(n){this.paginations=n}get pages(){return i.a.$vuepress.$get("siteData").pages}getPagination(n,e,t){mr("id",e),mr("this.paginations",this.paginations);const i=this.paginations.filter(t=>t.id===e&&t.pid===n)[0];return new pr(i,this.pages,t)}}(cr);t(176),t(177),t(91),t(88);var fr={name:"Demo",props:{collapse:{type:Boolean,default:!1}},data:function(){return{showCode:!1,copied:!1,codeNavIndex:0,codeNavConfigs:[]}},created:function(){this.showCode=this.collapse,this.makeCodeNavConfigs()},methods:{toggleCode:function(){this.showCode=!this.showCode},copyCode:function(){var n=this,e=this.$el.querySelectorAll("pre")[this.codeNavIndex];e.setAttribute("contenteditable","true"),e.focus(),document.execCommand("selectAll",!1,null),this.copied=document.execCommand("copy"),e.removeAttribute("contenteditable"),setTimeout((function(){n.copied=!1}),1e3)},codeNavBtnHandler:function(n){this.codeNavIndex=n},makeCodeNavConfigs:function(){console.log(this.$slots);var n,e=this.$slots,t=[];for(var i in e)console.log(i.indexOf("code-")),0==i.indexOf("code-")&&(n=i.replace("code-","").replace(/^\S/,(function(n){return n.toUpperCase()})),t.push({title:n,slotName:i}));this.codeNavConfigs=t}}},gr=(t(181),Object(de.a)(fr,(function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("div",{staticClass:"demo-wrap"},[t("div",{staticClass:"demo-nav"},[t("i",{staticClass:"demo-nav-btn",on:{click:n.toggleCode}},[t("svg",{staticClass:"icon",attrs:{t:"1572515960134",viewBox:"0 0 1024 1024",version:"1.1",xmlns:"http://www.w3.org/2000/svg","p-id":"1097",width:"20",height:"20"}},[t("path",{attrs:{d:"M888 64H136q-30.016 0-51.008 20.992T64 136v752.992q0 28.992 20.992 50.496t51.008 21.504h752.992q28.992 0 50.496-21.504t21.504-50.496V136q0-30.016-21.504-51.008T888 64zM228.992 548.992q-15.008 0-25.504-10.496t-10.496-25.504 10.016-26.016l115.008-115.008-115.008-116.992q-10.016-11.008-10.016-25.504t10.496-24.992 25.504-10.496 24.992 10.016l140.992 142.016q10.016 11.008 10.016 26.016t-11.008 24.992l-140 140.992q-10.016 11.008-24.992 11.008z m389.024 0l-199.008-0.992q-15.008 0-25.504-10.496T383.008 512t10.496-25.504 25.504-10.496l199.008 0.992q15.008 0 25.504 10.496t10.496 25.504-11.008 25.504-24.992 10.496z","p-id":"1098"}})])]),n._v(" "),t("i",{class:n.showCode?"demo-icon-arrow active":"demo-icon-arrow"},[t("svg",{staticClass:"icon",attrs:{t:"1572587847226",viewBox:"0 0 1024 1024",version:"1.1",xmlns:"http://www.w3.org/2000/svg","p-id":"3297",width:"16",height:"16"}},[t("path",{attrs:{d:"M830.687738 603.071182c0 9.614985-3.933589 17.949814-11.799744 25.007557-7.867178 7.05672-17.222243 10.56052-28.065196 10.512425L232.716714 638.591163c-10.789741 0-20.144806-3.5038-28.064172-10.512425-7.919367-7.009647-11.852956-15.344476-11.799744-25.007557 0.053212-9.660011 3.986801-17.996886 11.799744-25.00551l279.05253-248.641917c7.867178-7.009647 17.22122-10.513448 28.065196-10.513448 10.842952 0 20.196994 3.504824 28.064172 10.513448l279.05253 248.641917C826.754149 585.074296 830.687738 593.411171 830.687738 603.071182z","p-id":"3298"}})])])]),n._v(" "),t("transition",{attrs:{name:"code-fade"}},[t("div",{directives:[{name:"show",rawName:"v-show",value:n.showCode,expression:"showCode"}],staticClass:"demo-code"},[t("div",{staticClass:"demo-code-nav"},n._l(n.codeNavConfigs,(function(e,i){return t("button",{key:i,class:["demo-code-btn",n.codeNavIndex===i?"active":""],on:{click:function(e){return n.codeNavBtnHandler(i)}}},[n._v(n._s(e.title))])})),0),n._v(" "),t("div",{staticClass:"demo-code-content"},[n._l(n.codeNavConfigs,(function(e,i){return t("div",{directives:[{name:"show",rawName:"v-show",value:n.codeNavIndex===i,expression:"codeNavIndex === index"}],key:i,staticClass:"demo-code-item"},[n._t(e.slotName)],2)})),n._v(" "),t("i",{staticClass:"demo-code-content-copy",on:{click:n.copyCode}},[t("svg",{staticClass:"icon",staticStyle:{fill:"#fff"},attrs:{t:"1572585974849",viewBox:"0 0 1024 1024",version:"1.1",xmlns:"http://www.w3.org/2000/svg","p-id":"1695",width:"20",height:"20"}},[t("path",{attrs:{d:"M866.461538 39.384615H354.461538c-43.323077 0-78.769231 35.446154-78.76923 78.769231v39.384616h472.615384c43.323077 0 78.769231 35.446154 78.769231 78.76923v551.384616h39.384615c43.323077 0 78.769231-35.446154 78.769231-78.769231V118.153846c0-43.323077-35.446154-78.769231-78.769231-78.769231z m-118.153846 275.692308c0-43.323077-35.446154-78.769231-78.76923-78.769231H157.538462c-43.323077 0-78.769231 35.446154-78.769231 78.769231v590.769231c0 43.323077 35.446154 78.769231 78.769231 78.769231h512c43.323077 0 78.769231-35.446154 78.76923-78.769231V315.076923z m-354.461538 137.846154c0 11.815385-7.876923 19.692308-19.692308 19.692308h-157.538461c-11.815385 0-19.692308-7.876923-19.692308-19.692308v-39.384615c0-11.815385 7.876923-19.692308 19.692308-19.692308h157.538461c11.815385 0 19.692308 7.876923 19.692308 19.692308v39.384615z m157.538461 315.076923c0 11.815385-7.876923 19.692308-19.692307 19.692308H216.615385c-11.815385 0-19.692308-7.876923-19.692308-19.692308v-39.384615c0-11.815385 7.876923-19.692308 19.692308-19.692308h315.076923c11.815385 0 19.692308 7.876923 19.692307 19.692308v39.384615z m78.769231-157.538462c0 11.815385-7.876923 19.692308-19.692308 19.692308H216.615385c-11.815385 0-19.692308-7.876923-19.692308-19.692308v-39.384615c0-11.815385 7.876923-19.692308 19.692308-19.692308h393.846153c11.815385 0 19.692308 7.876923 19.692308 19.692308v39.384615z","p-id":"1696"}})])]),n._v(" "),t("transition",{attrs:{name:"slide-fade"}},[n.copied?t("span",{staticClass:"demo-code-content-copied"},[n._v("Copied")]):n._e()])],2)])]),n._v(" "),t("div",{staticClass:"demo-main"},[n.$slots.demo?t("div",{staticClass:"demo-component-wrap"},[n._t("demo")],2):n._e()])],1)}),[],!1,null,null,null).exports);function vr(n,e){void 0===e&&(e={});var t=e.registrationOptions;void 0===t&&(t={}),delete e.registrationOptions;var i=function(n){for(var t=[],i=arguments.length-1;i-- >0;)t[i]=arguments[i+1];e&&e[n]&&e[n].apply(e,t)};"serviceWorker"in navigator&&window.addEventListener("load",(function(){Boolean("localhost"===window.location.hostname||"[::1]"===window.location.hostname||window.location.hostname.match(/^127(?:\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/))?(!function(n,e,t){fetch(n).then((function(i){404===i.status?(e("error",new Error("Service worker not found at "+n)),xr()):-1===i.headers.get("content-type").indexOf("javascript")?(e("error",new Error("Expected "+n+" to have javascript content-type, but received "+i.headers.get("content-type"))),xr()):br(n,e,t)})).catch((function(n){navigator.onLine?e("error",n):e("offline")}))}(n,i,t),navigator.serviceWorker.ready.then((function(n){i("ready",n)}))):br(n,i,t)}))}function br(n,e,t){navigator.serviceWorker.register(n,t).then((function(n){e("registered",n),n.waiting?e("updated",n):n.onupdatefound=function(){e("updatefound",n);var t=n.installing;t.onstatechange=function(){"installed"===t.state&&(navigator.serviceWorker.controller?e("updated",n):e("cached",n))}}})).catch((function(n){e("error",n)}))}function xr(){"serviceWorker"in navigator&&navigator.serviceWorker.ready.then((function(n){n.unregister()}))}class wr{constructor(n){Object.defineProperty(this,"registration",{value:n,configurable:!0,writable:!0})}update(){return this.registration.update()}skipWaiting(){const n=this.registration.waiting;return n?(console.log("[vuepress:sw] Doing worker.skipWaiting()."),new Promise((e,t)=>{const i=new MessageChannel;i.port1.onmessage=n=>{console.log("[vuepress:sw] Done worker.skipWaiting()."),n.data.error?t(n.data.error):e(n.data)},n.postMessage({type:"skip-waiting"},[i.port2])})):Promise.resolve()}}var Er=t(16);i.a.component("SWUpdatePopup",()=>Promise.all([t.e(0),t.e(78)]).then(t.bind(null,1222)));var yr=[({Vue:n})=>{n.mixin(ge)},{},({Vue:n})=>{n.mixin({computed:{$dataBlock(){return this.$options.__data__block__}}})},{},({Vue:n})=>{n.component("BackToTop",xe)},({Vue:n})=>{n.component("LoadingPage",we)},({Vue:n})=>{n.component("Pagation",ye)},({Vue:n})=>{n.component("Comments",ir),n.component("AccessNumber",sr)},{},({Vue:n})=>{const e=Object.keys(or).map(n=>{const e=or[n],t=`$${n}`;return{[t](){const{pages:n}=this.$site;return new ar(e,n)},[`$current${n.charAt(0).toUpperCase()+n.slice(1)}`](){const n=this.$route.meta.id;return this[t].getItemByName(n)}}}).reduce((n,e)=>(Object.assign(n,e),n),{});e.$frontmatterKey=function(){const n=this[`$${this.$route.meta.id}`];return n||null},n.mixin({computed:e})},({Vue:n})=>{n.mixin({methods:{$getPagination(n,e){return e=e||n,hr.getPagination(n,e,this.$route)}},computed:{$pagination(){return this.$route.meta.pid&&this.$route.meta.id?this.$getPagination(this.$route.meta.pid,this.$route.meta.id):null}}})},{},({Vue:n})=>{n.component("RecoDemo",gr)},({router:n,isServer:e})=>{n.onReady(()=>{e||vr("/service-worker.js",{registrationOptions:{},ready(){console.log("[vuepress:sw] Service worker is active."),Er.a.$emit("sw-ready")},cached(n){console.log("[vuepress:sw] Content has been cached for offline use."),Er.a.$emit("sw-cached",new wr(n))},updated(n){console.log("[vuepress:sw] Content updated."),Er.a.$emit("sw-updated",new wr(n))},offline(){console.log("[vuepress:sw] No internet connection found. App is running in offline mode."),Er.a.$emit("sw-offline")},error(n){console.error("[vuepress:sw] Error during service worker registration:",n),Er.a.$emit("sw-error",n)}})})},({router:n})=>{0}],kr=["BackToTop","SWUpdatePopup"];class Ar extends class{constructor(){this.store=new i.a({data:{state:{}}})}$get(n){return this.store.state[n]}$set(n,e){i.a.set(this.store.state,n,e)}$emit(...n){this.store.$emit(...n)}$on(...n){this.store.$on(...n)}}{}Object.assign(Ar.prototype,{getPageAsyncComponent:Rn.e,getLayoutAsyncComponent:Rn.d,getAsyncComponent:Rn.c,getVueComponent:Rn.f});var jr={install(n){const e=new Ar;n.$vuepress=e,n.prototype.$vuepress=e}};function _r(n,e){return n.options.routes.filter(n=>n.path.toLowerCase()===e.toLowerCase()).length>0}var Nr={props:{pageKey:String,slotKey:{type:String,default:"default"}},render(n){const e=this.pageKey||this.$parent.$page.key;return Object(Rn.i)("pageKey",e),i.a.component(e)||i.a.component(e,Object(Rn.e)(e)),i.a.component(e)?n(e):n("")}},Or={functional:!0,props:{slotKey:String,required:!0},render:(n,{props:e,slots:t})=>n("div",{class:[`content__${e.slotKey}`]},t()[e.slotKey])},Br=(t(182),Object(de.a)({},(function(n,e){var t=e._c;return t("svg",{staticClass:"icon outbound",attrs:{xmlns:"http://www.w3.org/2000/svg","aria-hidden":"true",x:"0px",y:"0px",viewBox:"0 0 100 100",width:"15",height:"15"}},[t("path",{attrs:{fill:"currentColor",d:"M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"}}),e._v(" "),t("polygon",{attrs:{fill:"currentColor",points:"45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"}})])}),[],!0,null,null,null).exports),Sr={functional:!0,render(n,{parent:e,children:t}){if(e._isMounted)return t;e.$once("hook:mounted",()=>{e.$forceUpdate()})}};i.a.config.productionTip=!1,i.a.use(zn),i.a.use(jr),i.a.mixin(function(n,e,t=i.a){!function(n){n.locales&&Object.keys(n.locales).forEach(e=>{n.locales[e].path=e});Object.freeze(n)}(e),t.$vuepress.$set("siteData",e);const r=new(n(t.$vuepress.$get("siteData"))),s=Object.getOwnPropertyDescriptors(Object.getPrototypeOf(r)),o={};return Object.keys(s).reduce((n,e)=>(e.startsWith("$")&&(n[e]=s[e].get),n),o),{computed:o}}(n=>class{setPage(n){this.__page=n}get $site(){return n}get $themeConfig(){return this.$site.themeConfig}get $frontmatter(){return this.$page.frontmatter}get $localeConfig(){const{locales:n={}}=this.$site;let e,t;for(const i in n)"/"===i?t=n[i]:0===this.$page.path.indexOf(i)&&(e=n[i]);return e||t||{}}get $siteTitle(){return this.$localeConfig.title||this.$site.title||""}get $title(){const n=this.$page,{metaTitle:e}=this.$page.frontmatter;if("string"==typeof e)return e;const t=this.$siteTitle,i=n.frontmatter.home?null:n.frontmatter.title||n.title;return t?i?i+" | "+t:t:i||"VuePress"}get $description(){const n=function(n){if(n){const e=n.filter(n=>"description"===n.name)[0];if(e)return e.content}}(this.$page.frontmatter.meta);return n||(this.$page.frontmatter.description||this.$localeConfig.description||this.$site.description||"")}get $lang(){return this.$page.frontmatter.lang||this.$localeConfig.lang||"en-US"}get $localePath(){return this.$localeConfig.path||"/"}get $themeLocaleConfig(){return(this.$site.themeConfig.locales||{})[this.$localePath]||{}}get $page(){return this.__page?this.__page:function(n,e){for(let t=0;t<n.length;t++){const i=n[t];if(i.path.toLowerCase()===e.toLowerCase())return i}return{path:"",frontmatter:{}}}(this.$site.pages,this.$route.path)}},he)),i.a.component("Content",Nr),i.a.component("ContentSlotsDistributor",Or),i.a.component("OutboundLink",Br),i.a.component("ClientOnly",Sr),i.a.component("Layout",Object(Rn.d)("Layout")),i.a.component("NotFound",Object(Rn.d)("NotFound")),i.a.prototype.$withBase=function(n){const e=this.$site.base;return"/"===n.charAt(0)?e+n.slice(1):n};const{app:Ir,router:Lr}=function(n){const e="undefined"!=typeof window&&window.__VUEPRESS_ROUTER_BASE__?window.__VUEPRESS_ROUTER_BASE__:he.routerBase||he.base,t=new zn({base:e,mode:"history",fallback:!1,routes:pe,scrollBehavior:(n,e,t)=>t||(n.hash?!i.a.$vuepress.$get("disableScrollBehavior")&&{selector:n.hash}:{x:0,y:0})});!function(n){n.beforeEach((e,t,i)=>{if(_r(n,e.path))i();else if(/(\/|\.html)$/.test(e.path))if(/\/$/.test(e.path)){const t=e.path.replace(/\/$/,"")+".html";_r(n,t)?i(t):i()}else i();else{const t=e.path+"/",r=e.path+".html";_r(n,r)?i(r):_r(n,t)?i(t):i()}})}(t);const r={};try{yr.forEach(e=>{"function"==typeof e&&e({Vue:i.a,options:r,router:t,siteData:he,isServer:n})})}catch(n){console.error(n)}return{app:new i.a(Object.assign(r,{router:t,render:n=>n("div",{attrs:{id:"app"}},[n("router-view",{ref:"layout"}),n("div",{class:"global-ui"},kr.map(e=>n(e)))])})),router:t}}(!1);window.__VUEPRESS__={version:"1.2.0",hash:"b77dae54"},Lr.onReady(()=>{Ir.$mount("#app")})}]);